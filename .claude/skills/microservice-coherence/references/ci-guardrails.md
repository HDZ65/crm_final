# CI Guardrails

Prevent coherence drift by running automated checks in CI pipelines. This document describes how to generate and integrate CI-ready coherence validators.

## Overview

After applying Fix Packs, generate a CI guardrail to:
1. Detect new inconsistencies before merge
2. Block PRs that introduce coherence violations
3. Produce readable reports for reviewers

## Output Artifacts

The skill can generate:

| Artifact | Description |
|----------|-------------|
| `coherence-check.sh` | Shell script for any CI |
| `coherence-check.js` | Node.js script with richer output |
| `coherence-check.py` | Python script alternative |
| `.github/workflows/coherence.yml` | GitHub Actions workflow |
| `.gitlab-ci.coherence.yml` | GitLab CI job template |
| `coherence-report.md` | Human-readable summary |

## Exit Codes

All scripts follow this convention:

| Code | Meaning |
|------|---------|
| 0 | No issues found |
| 1 | Warnings only (non-blocking by default) |
| 2 | Critical issues found (blocking) |

## Shell Script Template

```bash
#!/usr/bin/env bash
# coherence-check.sh
# Generated by microservice-coherence skill
# Run: ./coherence-check.sh [--strict] [--report]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="${SCRIPT_DIR}"
STRICT_MODE=false
GENERATE_REPORT=false
REPORT_FILE="coherence-report.md"

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --strict) STRICT_MODE=true; shift ;;
    --report) GENERATE_REPORT=true; shift ;;
    --report-file) REPORT_FILE="$2"; shift 2 ;;
    *) echo "Unknown option: $1"; exit 1 ;;
  esac
done

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

CRITICAL_COUNT=0
WARNING_COUNT=0
INFO_COUNT=0

log_critical() { echo -e "${RED}[CRITICAL]${NC} $1"; ((CRITICAL_COUNT++)); }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; ((WARNING_COUNT++)); }
log_info() { echo -e "${GREEN}[INFO]${NC} $1"; ((INFO_COUNT++)); }

# ============================================
# CONFIGURABLE: Service Discovery
# ============================================
# Modify this function to match your repo structure

discover_services() {
  # Default: look for directories with package.json, go.mod, etc.
  find "${REPO_ROOT}" -maxdepth 3 -type f \( \
    -name "package.json" -o \
    -name "go.mod" -o \
    -name "Cargo.toml" -o \
    -name "pyproject.toml" -o \
    -name "pom.xml" \
  \) | xargs -I {} dirname {} | sort -u
}

SERVICES=$(discover_services)
SERVICE_COUNT=$(echo "$SERVICES" | wc -l)

echo "=========================================="
echo "Coherence Check"
echo "Services found: ${SERVICE_COUNT}"
echo "=========================================="

# ============================================
# RULE CHECKS
# ============================================

# MIN-001: Dockerfile required
check_dockerfile() {
  for service in $SERVICES; do
    if [[ ! -f "${service}/Dockerfile" ]]; then
      log_critical "Missing Dockerfile: ${service}"
    fi
  done
}

# MIN-002: Healthcheck required
check_healthcheck() {
  for service in $SERVICES; do
    # Simple heuristic: search for health endpoint patterns
    if ! grep -rq -E "(\/health|\/healthz|\/ready)" "${service}/src" 2>/dev/null; then
      if ! grep -rq -E "(\/health|\/healthz|\/ready)" "${service}" 2>/dev/null; then
        log_critical "No healthcheck endpoint found: ${service}"
      fi
    fi
  done
}

# MIN-003: Test script required
check_test_script() {
  for service in $SERVICES; do
    if [[ -f "${service}/package.json" ]]; then
      if ! grep -q '"test"' "${service}/package.json"; then
        log_warning "No test script in package.json: ${service}"
      fi
    elif [[ -f "${service}/Makefile" ]]; then
      if ! grep -q '^test:' "${service}/Makefile"; then
        log_warning "No test target in Makefile: ${service}"
      fi
    fi
  done
}

# TS-001: tsconfig.json required for TypeScript
check_tsconfig() {
  for service in $SERVICES; do
    if [[ -f "${service}/package.json" ]]; then
      if grep -q '"typescript"' "${service}/package.json"; then
        if [[ ! -f "${service}/tsconfig.json" ]]; then
          log_critical "TypeScript detected but no tsconfig.json: ${service}"
        fi
      fi
    fi
  done
}

# TS-002: Lockfile required
check_lockfile() {
  for service in $SERVICES; do
    if [[ -f "${service}/package.json" ]]; then
      if [[ ! -f "${service}/package-lock.json" ]] && \
         [[ ! -f "${service}/yarn.lock" ]] && \
         [[ ! -f "${service}/pnpm-lock.yaml" ]]; then
        log_critical "No lockfile found: ${service}"
      fi
    fi
  done
}

# Run all checks
echo ""
echo "Running checks..."
echo ""

check_dockerfile
check_healthcheck
check_test_script
check_tsconfig
check_lockfile

# ============================================
# SUMMARY
# ============================================

echo ""
echo "=========================================="
echo "Summary"
echo "=========================================="
echo "Critical: ${CRITICAL_COUNT}"
echo "Warnings: ${WARNING_COUNT}"
echo "Info: ${INFO_COUNT}"

# Generate report if requested
if [[ "$GENERATE_REPORT" == true ]]; then
  cat > "${REPORT_FILE}" << EOF
# Coherence Report

**Generated:** $(date -u +"%Y-%m-%dT%H:%M:%SZ")
**Services scanned:** ${SERVICE_COUNT}

## Summary

| Severity | Count |
|----------|-------|
| Critical | ${CRITICAL_COUNT} |
| Warning | ${WARNING_COUNT} |
| Info | ${INFO_COUNT} |

## Status

$(if [[ $CRITICAL_COUNT -gt 0 ]]; then echo "❌ **FAILED** - Critical issues found"; elif [[ $WARNING_COUNT -gt 0 ]]; then echo "⚠️ **PASSED WITH WARNINGS**"; else echo "✅ **PASSED**"; fi)
EOF
  echo "Report written to: ${REPORT_FILE}"
fi

# Exit code
if [[ $CRITICAL_COUNT -gt 0 ]]; then
  exit 2
elif [[ $WARNING_COUNT -gt 0 ]] && [[ "$STRICT_MODE" == true ]]; then
  exit 1
else
  exit 0
fi
```

## Node.js Script Template

```javascript
#!/usr/bin/env node
// coherence-check.js
// Generated by microservice-coherence skill

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const args = process.argv.slice(2);
const STRICT_MODE = args.includes('--strict');
const GENERATE_REPORT = args.includes('--report');
const REPO_ROOT = process.cwd();

const issues = {
  critical: [],
  warning: [],
  info: []
};

// ============================================
// Service Discovery
// ============================================

function discoverServices() {
  const indicators = ['package.json', 'go.mod', 'Cargo.toml', 'pyproject.toml', 'pom.xml'];
  const services = new Set();

  function walkDir(dir, depth = 0) {
    if (depth > 3) return;
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.name.startsWith('.') || entry.name === 'node_modules') continue;

        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          walkDir(fullPath, depth + 1);
        } else if (indicators.includes(entry.name)) {
          services.add(path.dirname(fullPath));
        }
      }
    } catch (e) {
      // Ignore permission errors
    }
  }

  walkDir(REPO_ROOT);
  return Array.from(services);
}

// ============================================
// Rule Checks
// ============================================

function checkDockerfile(services) {
  for (const service of services) {
    if (!fs.existsSync(path.join(service, 'Dockerfile'))) {
      issues.critical.push({
        rule: 'MIN-001',
        service: path.relative(REPO_ROOT, service),
        message: 'Missing Dockerfile'
      });
    }
  }
}

function checkHealthcheck(services) {
  const patterns = ['/health', '/healthz', '/ready', 'HealthCheck', 'healthCheck'];

  for (const service of services) {
    let found = false;
    try {
      const result = execSync(
        `grep -r -l -E "${patterns.join('|')}" "${service}" 2>/dev/null || true`,
        { encoding: 'utf-8' }
      );
      found = result.trim().length > 0;
    } catch (e) {
      // grep failed, no matches
    }

    if (!found) {
      issues.critical.push({
        rule: 'MIN-002',
        service: path.relative(REPO_ROOT, service),
        message: 'No healthcheck endpoint detected'
      });
    }
  }
}

function checkTestScript(services) {
  for (const service of services) {
    const pkgPath = path.join(service, 'package.json');
    if (fs.existsSync(pkgPath)) {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
      if (!pkg.scripts?.test || pkg.scripts.test.includes('no test')) {
        issues.warning.push({
          rule: 'MIN-003',
          service: path.relative(REPO_ROOT, service),
          message: 'No test script defined'
        });
      }
    }
  }
}

function checkLockfile(services) {
  const lockfiles = ['package-lock.json', 'yarn.lock', 'pnpm-lock.yaml'];

  for (const service of services) {
    if (fs.existsSync(path.join(service, 'package.json'))) {
      const hasLockfile = lockfiles.some(lf =>
        fs.existsSync(path.join(service, lf))
      );
      if (!hasLockfile) {
        issues.critical.push({
          rule: 'TS-002',
          service: path.relative(REPO_ROOT, service),
          message: 'No lockfile found'
        });
      }
    }
  }
}

// ============================================
// Main
// ============================================

console.log('==========================================');
console.log('Coherence Check (Node.js)');
console.log('==========================================\n');

const services = discoverServices();
console.log(`Services found: ${services.length}\n`);

// Run checks
checkDockerfile(services);
checkHealthcheck(services);
checkTestScript(services);
checkLockfile(services);

// Print issues
for (const severity of ['critical', 'warning', 'info']) {
  for (const issue of issues[severity]) {
    const prefix = {
      critical: '\x1b[31m[CRITICAL]\x1b[0m',
      warning: '\x1b[33m[WARNING]\x1b[0m',
      info: '\x1b[32m[INFO]\x1b[0m'
    }[severity];
    console.log(`${prefix} ${issue.rule}: ${issue.message} (${issue.service})`);
  }
}

// Summary
console.log('\n==========================================');
console.log('Summary');
console.log('==========================================');
console.log(`Critical: ${issues.critical.length}`);
console.log(`Warning: ${issues.warning.length}`);
console.log(`Info: ${issues.info.length}`);

// Generate report
if (GENERATE_REPORT) {
  const report = `# Coherence Report

**Generated:** ${new Date().toISOString()}
**Services scanned:** ${services.length}

## Summary

| Severity | Count |
|----------|-------|
| Critical | ${issues.critical.length} |
| Warning | ${issues.warning.length} |
| Info | ${issues.info.length} |

## Issues

${['critical', 'warning', 'info'].map(sev =>
  issues[sev].length > 0 ?
    `### ${sev.charAt(0).toUpperCase() + sev.slice(1)}\n\n` +
    issues[sev].map(i => `- **${i.rule}**: ${i.message} (\`${i.service}\`)`).join('\n')
  : ''
).filter(Boolean).join('\n\n')}
`;
  fs.writeFileSync('coherence-report.md', report);
  console.log('\nReport written to: coherence-report.md');
}

// Exit code
if (issues.critical.length > 0) {
  process.exit(2);
} else if (issues.warning.length > 0 && STRICT_MODE) {
  process.exit(1);
} else {
  process.exit(0);
}
```

## GitHub Actions Workflow

```yaml
# .github/workflows/coherence.yml
name: Coherence Check

on:
  pull_request:
    branches: [main, master, develop]
  push:
    branches: [main, master]

jobs:
  coherence:
    name: Check Microservice Coherence
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Coherence Check
        id: coherence
        run: |
          chmod +x ./coherence-check.sh
          ./coherence-check.sh --report || echo "exit_code=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Upload Report
        uses: actions/upload-artifact@v4
        with:
          name: coherence-report
          path: coherence-report.md
        if: always()

      - name: Comment on PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('coherence-report.md', 'utf8');

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('# Coherence Report')
            );

            const body = `## Coherence Check Results\n\n${report}`;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Fail on Critical Issues
        if: steps.coherence.outputs.exit_code == '2'
        run: exit 1
```

## GitLab CI Template

```yaml
# .gitlab-ci.coherence.yml
# Include in your .gitlab-ci.yml with:
# include:
#   - local: '.gitlab-ci.coherence.yml'

coherence-check:
  stage: test
  image: node:20-alpine
  script:
    - chmod +x ./coherence-check.sh
    - ./coherence-check.sh --report
  artifacts:
    paths:
      - coherence-report.md
    reports:
      dotenv: coherence.env
    when: always
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure:
    exit_codes:
      - 1  # Allow warnings, fail on critical (exit 2)
```

## Integration Options

### Blocking vs Non-Blocking

Configure based on team maturity:

| Stage | Approach |
|-------|----------|
| Adoption | Non-blocking, report only |
| Stabilization | Block on critical, warn on others |
| Mature | Block on critical + warnings (strict mode) |

### Incremental Rollout

1. **Week 1-2**: Run in report-only mode, collect baseline
2. **Week 3-4**: Enable blocking for critical issues
3. **Week 5+**: Gradually enable strict mode

### Customization Points

Modify the scripts to:

1. **Add custom rules**: Edit the check functions
2. **Change service discovery**: Modify `discover_services()` / `discoverServices()`
3. **Adjust severity thresholds**: Change exit codes
4. **Add custom report sections**: Extend report generation

## Maintenance

When coherence rules change:

1. Update rule checks in the script
2. Bump script version comment
3. Re-run on all services to establish new baseline
4. Communicate changes to team
