// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: agenda/agenda.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";

export const protobufPackage = "agenda";

export enum OAuthProvider {
  OAUTH_PROVIDER_UNSPECIFIED = 0,
  OAUTH_PROVIDER_ZOOM = 1,
  OAUTH_PROVIDER_GOOGLE = 2,
  OAUTH_PROVIDER_MICROSOFT = 3,
  UNRECOGNIZED = -1,
}

export function oAuthProviderFromJSON(object: any): OAuthProvider {
  switch (object) {
    case 0:
    case "OAUTH_PROVIDER_UNSPECIFIED":
      return OAuthProvider.OAUTH_PROVIDER_UNSPECIFIED;
    case 1:
    case "OAUTH_PROVIDER_ZOOM":
      return OAuthProvider.OAUTH_PROVIDER_ZOOM;
    case 2:
    case "OAUTH_PROVIDER_GOOGLE":
      return OAuthProvider.OAUTH_PROVIDER_GOOGLE;
    case 3:
    case "OAUTH_PROVIDER_MICROSOFT":
      return OAuthProvider.OAUTH_PROVIDER_MICROSOFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OAuthProvider.UNRECOGNIZED;
  }
}

export function oAuthProviderToJSON(object: OAuthProvider): string {
  switch (object) {
    case OAuthProvider.OAUTH_PROVIDER_UNSPECIFIED:
      return "OAUTH_PROVIDER_UNSPECIFIED";
    case OAuthProvider.OAUTH_PROVIDER_ZOOM:
      return "OAUTH_PROVIDER_ZOOM";
    case OAuthProvider.OAUTH_PROVIDER_GOOGLE:
      return "OAUTH_PROVIDER_GOOGLE";
    case OAuthProvider.OAUTH_PROVIDER_MICROSOFT:
      return "OAUTH_PROVIDER_MICROSOFT";
    case OAuthProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MeetingSummaryStatus {
  MEETING_SUMMARY_STATUS_UNSPECIFIED = 0,
  MEETING_SUMMARY_STATUS_PENDING = 1,
  MEETING_SUMMARY_STATUS_PROCESSING = 2,
  MEETING_SUMMARY_STATUS_COMPLETED = 3,
  MEETING_SUMMARY_STATUS_FAILED = 4,
  MEETING_SUMMARY_STATUS_NO_TRANSCRIPT = 5,
  UNRECOGNIZED = -1,
}

export function meetingSummaryStatusFromJSON(object: any): MeetingSummaryStatus {
  switch (object) {
    case 0:
    case "MEETING_SUMMARY_STATUS_UNSPECIFIED":
      return MeetingSummaryStatus.MEETING_SUMMARY_STATUS_UNSPECIFIED;
    case 1:
    case "MEETING_SUMMARY_STATUS_PENDING":
      return MeetingSummaryStatus.MEETING_SUMMARY_STATUS_PENDING;
    case 2:
    case "MEETING_SUMMARY_STATUS_PROCESSING":
      return MeetingSummaryStatus.MEETING_SUMMARY_STATUS_PROCESSING;
    case 3:
    case "MEETING_SUMMARY_STATUS_COMPLETED":
      return MeetingSummaryStatus.MEETING_SUMMARY_STATUS_COMPLETED;
    case 4:
    case "MEETING_SUMMARY_STATUS_FAILED":
      return MeetingSummaryStatus.MEETING_SUMMARY_STATUS_FAILED;
    case 5:
    case "MEETING_SUMMARY_STATUS_NO_TRANSCRIPT":
      return MeetingSummaryStatus.MEETING_SUMMARY_STATUS_NO_TRANSCRIPT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MeetingSummaryStatus.UNRECOGNIZED;
  }
}

export function meetingSummaryStatusToJSON(object: MeetingSummaryStatus): string {
  switch (object) {
    case MeetingSummaryStatus.MEETING_SUMMARY_STATUS_UNSPECIFIED:
      return "MEETING_SUMMARY_STATUS_UNSPECIFIED";
    case MeetingSummaryStatus.MEETING_SUMMARY_STATUS_PENDING:
      return "MEETING_SUMMARY_STATUS_PENDING";
    case MeetingSummaryStatus.MEETING_SUMMARY_STATUS_PROCESSING:
      return "MEETING_SUMMARY_STATUS_PROCESSING";
    case MeetingSummaryStatus.MEETING_SUMMARY_STATUS_COMPLETED:
      return "MEETING_SUMMARY_STATUS_COMPLETED";
    case MeetingSummaryStatus.MEETING_SUMMARY_STATUS_FAILED:
      return "MEETING_SUMMARY_STATUS_FAILED";
    case MeetingSummaryStatus.MEETING_SUMMARY_STATUS_NO_TRANSCRIPT:
      return "MEETING_SUMMARY_STATUS_NO_TRANSCRIPT";
    case MeetingSummaryStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ParticipantMatchType {
  PARTICIPANT_MATCH_TYPE_UNSPECIFIED = 0,
  PARTICIPANT_MATCH_TYPE_EMAIL_EXACT = 1,
  PARTICIPANT_MATCH_TYPE_MANUAL = 2,
  PARTICIPANT_MATCH_TYPE_UNMATCHED = 3,
  UNRECOGNIZED = -1,
}

export function participantMatchTypeFromJSON(object: any): ParticipantMatchType {
  switch (object) {
    case 0:
    case "PARTICIPANT_MATCH_TYPE_UNSPECIFIED":
      return ParticipantMatchType.PARTICIPANT_MATCH_TYPE_UNSPECIFIED;
    case 1:
    case "PARTICIPANT_MATCH_TYPE_EMAIL_EXACT":
      return ParticipantMatchType.PARTICIPANT_MATCH_TYPE_EMAIL_EXACT;
    case 2:
    case "PARTICIPANT_MATCH_TYPE_MANUAL":
      return ParticipantMatchType.PARTICIPANT_MATCH_TYPE_MANUAL;
    case 3:
    case "PARTICIPANT_MATCH_TYPE_UNMATCHED":
      return ParticipantMatchType.PARTICIPANT_MATCH_TYPE_UNMATCHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParticipantMatchType.UNRECOGNIZED;
  }
}

export function participantMatchTypeToJSON(object: ParticipantMatchType): string {
  switch (object) {
    case ParticipantMatchType.PARTICIPANT_MATCH_TYPE_UNSPECIFIED:
      return "PARTICIPANT_MATCH_TYPE_UNSPECIFIED";
    case ParticipantMatchType.PARTICIPANT_MATCH_TYPE_EMAIL_EXACT:
      return "PARTICIPANT_MATCH_TYPE_EMAIL_EXACT";
    case ParticipantMatchType.PARTICIPANT_MATCH_TYPE_MANUAL:
      return "PARTICIPANT_MATCH_TYPE_MANUAL";
    case ParticipantMatchType.PARTICIPANT_MATCH_TYPE_UNMATCHED:
      return "PARTICIPANT_MATCH_TYPE_UNMATCHED";
    case ParticipantMatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CalendarEventSource {
  CALENDAR_EVENT_SOURCE_UNSPECIFIED = 0,
  CALENDAR_EVENT_SOURCE_CRM = 1,
  CALENDAR_EVENT_SOURCE_GOOGLE_CALENDAR = 2,
  CALENDAR_EVENT_SOURCE_OUTLOOK = 3,
  CALENDAR_EVENT_SOURCE_ZOOM = 4,
  CALENDAR_EVENT_SOURCE_GOOGLE_MEET = 5,
  UNRECOGNIZED = -1,
}

export function calendarEventSourceFromJSON(object: any): CalendarEventSource {
  switch (object) {
    case 0:
    case "CALENDAR_EVENT_SOURCE_UNSPECIFIED":
      return CalendarEventSource.CALENDAR_EVENT_SOURCE_UNSPECIFIED;
    case 1:
    case "CALENDAR_EVENT_SOURCE_CRM":
      return CalendarEventSource.CALENDAR_EVENT_SOURCE_CRM;
    case 2:
    case "CALENDAR_EVENT_SOURCE_GOOGLE_CALENDAR":
      return CalendarEventSource.CALENDAR_EVENT_SOURCE_GOOGLE_CALENDAR;
    case 3:
    case "CALENDAR_EVENT_SOURCE_OUTLOOK":
      return CalendarEventSource.CALENDAR_EVENT_SOURCE_OUTLOOK;
    case 4:
    case "CALENDAR_EVENT_SOURCE_ZOOM":
      return CalendarEventSource.CALENDAR_EVENT_SOURCE_ZOOM;
    case 5:
    case "CALENDAR_EVENT_SOURCE_GOOGLE_MEET":
      return CalendarEventSource.CALENDAR_EVENT_SOURCE_GOOGLE_MEET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CalendarEventSource.UNRECOGNIZED;
  }
}

export function calendarEventSourceToJSON(object: CalendarEventSource): string {
  switch (object) {
    case CalendarEventSource.CALENDAR_EVENT_SOURCE_UNSPECIFIED:
      return "CALENDAR_EVENT_SOURCE_UNSPECIFIED";
    case CalendarEventSource.CALENDAR_EVENT_SOURCE_CRM:
      return "CALENDAR_EVENT_SOURCE_CRM";
    case CalendarEventSource.CALENDAR_EVENT_SOURCE_GOOGLE_CALENDAR:
      return "CALENDAR_EVENT_SOURCE_GOOGLE_CALENDAR";
    case CalendarEventSource.CALENDAR_EVENT_SOURCE_OUTLOOK:
      return "CALENDAR_EVENT_SOURCE_OUTLOOK";
    case CalendarEventSource.CALENDAR_EVENT_SOURCE_ZOOM:
      return "CALENDAR_EVENT_SOURCE_ZOOM";
    case CalendarEventSource.CALENDAR_EVENT_SOURCE_GOOGLE_MEET:
      return "CALENDAR_EVENT_SOURCE_GOOGLE_MEET";
    case CalendarEventSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OAuthConnectionStatus {
  OAUTH_CONNECTION_STATUS_UNSPECIFIED = 0,
  OAUTH_CONNECTION_STATUS_ACTIVE = 1,
  OAUTH_CONNECTION_STATUS_EXPIRED = 2,
  OAUTH_CONNECTION_STATUS_REVOKED = 3,
  OAUTH_CONNECTION_STATUS_ERROR = 4,
  UNRECOGNIZED = -1,
}

export function oAuthConnectionStatusFromJSON(object: any): OAuthConnectionStatus {
  switch (object) {
    case 0:
    case "OAUTH_CONNECTION_STATUS_UNSPECIFIED":
      return OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_UNSPECIFIED;
    case 1:
    case "OAUTH_CONNECTION_STATUS_ACTIVE":
      return OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_ACTIVE;
    case 2:
    case "OAUTH_CONNECTION_STATUS_EXPIRED":
      return OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_EXPIRED;
    case 3:
    case "OAUTH_CONNECTION_STATUS_REVOKED":
      return OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_REVOKED;
    case 4:
    case "OAUTH_CONNECTION_STATUS_ERROR":
      return OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OAuthConnectionStatus.UNRECOGNIZED;
  }
}

export function oAuthConnectionStatusToJSON(object: OAuthConnectionStatus): string {
  switch (object) {
    case OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_UNSPECIFIED:
      return "OAUTH_CONNECTION_STATUS_UNSPECIFIED";
    case OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_ACTIVE:
      return "OAUTH_CONNECTION_STATUS_ACTIVE";
    case OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_EXPIRED:
      return "OAUTH_CONNECTION_STATUS_EXPIRED";
    case OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_REVOKED:
      return "OAUTH_CONNECTION_STATUS_REVOKED";
    case OAuthConnectionStatus.OAUTH_CONNECTION_STATUS_ERROR:
      return "OAUTH_CONNECTION_STATUS_ERROR";
    case OAuthConnectionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OAuthConnection {
  id: string;
  userId: string;
  organisationId: string;
  provider: OAuthProvider;
  scopes: string;
  status: OAuthConnectionStatus;
  connectedAt: string;
  tokenExpiresAt: string;
  syncToken: string;
  channelId: string;
  channelExpiration: string;
  createdAt: string;
  updatedAt: string;
}

export interface ConnectProviderRequest {
  userId: string;
  organisationId: string;
  provider: OAuthProvider;
  accessToken: string;
  refreshToken: string;
  scopes: string;
  tokenExpiresAt: string;
}

export interface DisconnectProviderRequest {
  id: string;
}

export interface GetAuthUrlRequest {
  userId: string;
  organisationId: string;
  provider: OAuthProvider;
  redirectUri: string;
  scopes: string[];
}

export interface GetAuthUrlResponse {
  authUrl: string;
  state: string;
}

export interface HandleCallbackRequest {
  code: string;
  state: string;
  provider: OAuthProvider;
  redirectUri: string;
}

export interface ListConnectionsRequest {
  userId: string;
  organisationId: string;
  pagination: Pagination | undefined;
}

export interface ListConnectionsResponse {
  connections: OAuthConnection[];
  pagination: PaginationResult | undefined;
}

export interface RefreshTokenRequest {
  id: string;
}

export interface CalendarEvent {
  id: string;
  userId: string;
  organisationId: string;
  provider: OAuthProvider;
  externalId: string;
  title: string;
  description: string;
  startTime: string;
  endTime: string;
  location: string;
  attendees: string;
  isAllDay: boolean;
  source: CalendarEventSource;
  sourceUrl: string;
  meetingId: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateCalendarEventRequest {
  userId: string;
  organisationId: string;
  provider: OAuthProvider;
  externalId: string;
  title: string;
  description: string;
  startTime: string;
  endTime: string;
  location: string;
  attendees: string;
  isAllDay: boolean;
  source: CalendarEventSource;
  sourceUrl: string;
  meetingId: string;
}

export interface GetCalendarEventRequest {
  id: string;
}

export interface UpdateCalendarEventRequest {
  id: string;
  title: string;
  description: string;
  startTime: string;
  endTime: string;
  location: string;
  attendees: string;
  isAllDay: boolean;
  sourceUrl: string;
  meetingId: string;
}

export interface DeleteCalendarEventRequest {
  id: string;
}

export interface ListCalendarEventsByDateRangeRequest {
  userId: string;
  organisationId: string;
  startDate: string;
  endDate: string;
  pagination: Pagination | undefined;
}

export interface ListCalendarEventsByClientRequest {
  clientId: string;
  organisationId: string;
  pagination: Pagination | undefined;
}

export interface ListCalendarEventsResponse {
  events: CalendarEvent[];
  pagination: PaginationResult | undefined;
}

export interface SyncFromProviderRequest {
  oauthConnectionId: string;
  syncFromDate: string;
}

export interface SyncFromProviderResponse {
  syncedCount: number;
  createdCount: number;
  updatedCount: number;
  deletedCount: number;
}

export interface Meeting {
  id: string;
  userId: string;
  organisationId: string;
  provider: OAuthProvider;
  externalMeetingId: string;
  title: string;
  startTime: string;
  endTime: string;
  durationMinutes: number;
  participants: string;
  recordingUrl: string;
  transcriptUrl: string;
  summaryStatus: MeetingSummaryStatus;
  calendarEventId: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateMeetingRequest {
  userId: string;
  organisationId: string;
  provider: OAuthProvider;
  externalMeetingId: string;
  title: string;
  startTime: string;
  endTime: string;
  durationMinutes: number;
  participants: string;
  recordingUrl: string;
  transcriptUrl: string;
  calendarEventId: string;
}

export interface GetMeetingRequest {
  id: string;
}

export interface ListMeetingsByDateRangeRequest {
  userId: string;
  organisationId: string;
  startDate: string;
  endDate: string;
  pagination: Pagination | undefined;
}

export interface ListMeetingsResponse {
  meetings: Meeting[];
  pagination: PaginationResult | undefined;
}

export interface MeetingParticipant {
  email: string;
  displayName: string;
  matchType: ParticipantMatchType;
  matchedClientId: string;
}

export interface MatchParticipantsRequest {
  meetingId: string;
}

export interface MatchParticipantsResponse {
  participants: MeetingParticipant[];
  matchedCount: number;
  unmatchedCount: number;
}

export interface UpdateClientMatchRequest {
  meetingId: string;
  participantEmail: string;
  clientId: string;
  matchType: ParticipantMatchType;
}

export interface CallSummary {
  id: string;
  meetingId: string;
  executiveSummary: string;
  keyPoints: string;
  decisions: string;
  actionItems: string;
  generatedAt: string;
  aiModel: string;
  rawAiResponse: string;
  createdAt: string;
  updatedAt: string;
}

export interface GetCallSummaryRequest {
  id: string;
}

export interface GetCallSummaryByMeetingRequest {
  meetingId: string;
}

export interface RegenerateCallSummaryRequest {
  meetingId: string;
  aiModel: string;
}

/** ========== COMMON MESSAGES ========== */
export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
}

function createBaseOAuthConnection(): OAuthConnection {
  return {
    id: "",
    userId: "",
    organisationId: "",
    provider: 0,
    scopes: "",
    status: 0,
    connectedAt: "",
    tokenExpiresAt: "",
    syncToken: "",
    channelId: "",
    channelExpiration: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const OAuthConnection: MessageFns<OAuthConnection> = {
  encode(message: OAuthConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    if (message.provider !== 0) {
      writer.uint32(32).int32(message.provider);
    }
    if (message.scopes !== "") {
      writer.uint32(42).string(message.scopes);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.connectedAt !== "") {
      writer.uint32(58).string(message.connectedAt);
    }
    if (message.tokenExpiresAt !== "") {
      writer.uint32(66).string(message.tokenExpiresAt);
    }
    if (message.syncToken !== "") {
      writer.uint32(74).string(message.syncToken);
    }
    if (message.channelId !== "") {
      writer.uint32(82).string(message.channelId);
    }
    if (message.channelExpiration !== "") {
      writer.uint32(90).string(message.channelExpiration);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scopes = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.connectedAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tokenExpiresAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.syncToken = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.channelExpiration = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthConnection {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      scopes: isSet(object.scopes) ? globalThis.String(object.scopes) : "",
      status: isSet(object.status) ? oAuthConnectionStatusFromJSON(object.status) : 0,
      connectedAt: isSet(object.connectedAt)
        ? globalThis.String(object.connectedAt)
        : isSet(object.connected_at)
        ? globalThis.String(object.connected_at)
        : "",
      tokenExpiresAt: isSet(object.tokenExpiresAt)
        ? globalThis.String(object.tokenExpiresAt)
        : isSet(object.token_expires_at)
        ? globalThis.String(object.token_expires_at)
        : "",
      syncToken: isSet(object.syncToken)
        ? globalThis.String(object.syncToken)
        : isSet(object.sync_token)
        ? globalThis.String(object.sync_token)
        : "",
      channelId: isSet(object.channelId)
        ? globalThis.String(object.channelId)
        : isSet(object.channel_id)
        ? globalThis.String(object.channel_id)
        : "",
      channelExpiration: isSet(object.channelExpiration)
        ? globalThis.String(object.channelExpiration)
        : isSet(object.channel_expiration)
        ? globalThis.String(object.channel_expiration)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: OAuthConnection): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.scopes !== "") {
      obj.scopes = message.scopes;
    }
    if (message.status !== 0) {
      obj.status = oAuthConnectionStatusToJSON(message.status);
    }
    if (message.connectedAt !== "") {
      obj.connectedAt = message.connectedAt;
    }
    if (message.tokenExpiresAt !== "") {
      obj.tokenExpiresAt = message.tokenExpiresAt;
    }
    if (message.syncToken !== "") {
      obj.syncToken = message.syncToken;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.channelExpiration !== "") {
      obj.channelExpiration = message.channelExpiration;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthConnection>, I>>(base?: I): OAuthConnection {
    return OAuthConnection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthConnection>, I>>(object: I): OAuthConnection {
    const message = createBaseOAuthConnection();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.provider = object.provider ?? 0;
    message.scopes = object.scopes ?? "";
    message.status = object.status ?? 0;
    message.connectedAt = object.connectedAt ?? "";
    message.tokenExpiresAt = object.tokenExpiresAt ?? "";
    message.syncToken = object.syncToken ?? "";
    message.channelId = object.channelId ?? "";
    message.channelExpiration = object.channelExpiration ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseConnectProviderRequest(): ConnectProviderRequest {
  return {
    userId: "",
    organisationId: "",
    provider: 0,
    accessToken: "",
    refreshToken: "",
    scopes: "",
    tokenExpiresAt: "",
  };
}

export const ConnectProviderRequest: MessageFns<ConnectProviderRequest> = {
  encode(message: ConnectProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.provider !== 0) {
      writer.uint32(24).int32(message.provider);
    }
    if (message.accessToken !== "") {
      writer.uint32(34).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(42).string(message.refreshToken);
    }
    if (message.scopes !== "") {
      writer.uint32(50).string(message.scopes);
    }
    if (message.tokenExpiresAt !== "") {
      writer.uint32(58).string(message.tokenExpiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scopes = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenExpiresAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectProviderRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : "",
      scopes: isSet(object.scopes) ? globalThis.String(object.scopes) : "",
      tokenExpiresAt: isSet(object.tokenExpiresAt)
        ? globalThis.String(object.tokenExpiresAt)
        : isSet(object.token_expires_at)
        ? globalThis.String(object.token_expires_at)
        : "",
    };
  },

  toJSON(message: ConnectProviderRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.scopes !== "") {
      obj.scopes = message.scopes;
    }
    if (message.tokenExpiresAt !== "") {
      obj.tokenExpiresAt = message.tokenExpiresAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectProviderRequest>, I>>(base?: I): ConnectProviderRequest {
    return ConnectProviderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectProviderRequest>, I>>(object: I): ConnectProviderRequest {
    const message = createBaseConnectProviderRequest();
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.provider = object.provider ?? 0;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.scopes = object.scopes ?? "";
    message.tokenExpiresAt = object.tokenExpiresAt ?? "";
    return message;
  },
};

function createBaseDisconnectProviderRequest(): DisconnectProviderRequest {
  return { id: "" };
}

export const DisconnectProviderRequest: MessageFns<DisconnectProviderRequest> = {
  encode(message: DisconnectProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisconnectProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisconnectProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisconnectProviderRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DisconnectProviderRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisconnectProviderRequest>, I>>(base?: I): DisconnectProviderRequest {
    return DisconnectProviderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisconnectProviderRequest>, I>>(object: I): DisconnectProviderRequest {
    const message = createBaseDisconnectProviderRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetAuthUrlRequest(): GetAuthUrlRequest {
  return { userId: "", organisationId: "", provider: 0, redirectUri: "", scopes: [] };
}

export const GetAuthUrlRequest: MessageFns<GetAuthUrlRequest> = {
  encode(message: GetAuthUrlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.provider !== 0) {
      writer.uint32(24).int32(message.provider);
    }
    if (message.redirectUri !== "") {
      writer.uint32(34).string(message.redirectUri);
    }
    for (const v of message.scopes) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuthUrlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthUrlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuthUrlRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      redirectUri: isSet(object.redirectUri)
        ? globalThis.String(object.redirectUri)
        : isSet(object.redirect_uri)
        ? globalThis.String(object.redirect_uri)
        : "",
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetAuthUrlRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuthUrlRequest>, I>>(base?: I): GetAuthUrlRequest {
    return GetAuthUrlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuthUrlRequest>, I>>(object: I): GetAuthUrlRequest {
    const message = createBaseGetAuthUrlRequest();
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.provider = object.provider ?? 0;
    message.redirectUri = object.redirectUri ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAuthUrlResponse(): GetAuthUrlResponse {
  return { authUrl: "", state: "" };
}

export const GetAuthUrlResponse: MessageFns<GetAuthUrlResponse> = {
  encode(message: GetAuthUrlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authUrl !== "") {
      writer.uint32(10).string(message.authUrl);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuthUrlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthUrlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuthUrlResponse {
    return {
      authUrl: isSet(object.authUrl)
        ? globalThis.String(object.authUrl)
        : isSet(object.auth_url)
        ? globalThis.String(object.auth_url)
        : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
    };
  },

  toJSON(message: GetAuthUrlResponse): unknown {
    const obj: any = {};
    if (message.authUrl !== "") {
      obj.authUrl = message.authUrl;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuthUrlResponse>, I>>(base?: I): GetAuthUrlResponse {
    return GetAuthUrlResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuthUrlResponse>, I>>(object: I): GetAuthUrlResponse {
    const message = createBaseGetAuthUrlResponse();
    message.authUrl = object.authUrl ?? "";
    message.state = object.state ?? "";
    return message;
  },
};

function createBaseHandleCallbackRequest(): HandleCallbackRequest {
  return { code: "", state: "", provider: 0, redirectUri: "" };
}

export const HandleCallbackRequest: MessageFns<HandleCallbackRequest> = {
  encode(message: HandleCallbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    if (message.provider !== 0) {
      writer.uint32(24).int32(message.provider);
    }
    if (message.redirectUri !== "") {
      writer.uint32(34).string(message.redirectUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandleCallbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandleCallbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandleCallbackRequest {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      redirectUri: isSet(object.redirectUri)
        ? globalThis.String(object.redirectUri)
        : isSet(object.redirect_uri)
        ? globalThis.String(object.redirect_uri)
        : "",
    };
  },

  toJSON(message: HandleCallbackRequest): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandleCallbackRequest>, I>>(base?: I): HandleCallbackRequest {
    return HandleCallbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandleCallbackRequest>, I>>(object: I): HandleCallbackRequest {
    const message = createBaseHandleCallbackRequest();
    message.code = object.code ?? "";
    message.state = object.state ?? "";
    message.provider = object.provider ?? 0;
    message.redirectUri = object.redirectUri ?? "";
    return message;
  },
};

function createBaseListConnectionsRequest(): ListConnectionsRequest {
  return { userId: "", organisationId: "", pagination: undefined };
}

export const ListConnectionsRequest: MessageFns<ListConnectionsRequest> = {
  encode(message: ListConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListConnectionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConnectionsRequest>, I>>(base?: I): ListConnectionsRequest {
    return ListConnectionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConnectionsRequest>, I>>(object: I): ListConnectionsRequest {
    const message = createBaseListConnectionsRequest();
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { connections: [], pagination: undefined };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      OAuthConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connections.push(OAuthConnection.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => OAuthConnection.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => OAuthConnection.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConnectionsResponse>, I>>(base?: I): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConnectionsResponse>, I>>(object: I): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.connections = object.connections?.map((e) => OAuthConnection.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { id: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCalendarEvent(): CalendarEvent {
  return {
    id: "",
    userId: "",
    organisationId: "",
    provider: 0,
    externalId: "",
    title: "",
    description: "",
    startTime: "",
    endTime: "",
    location: "",
    attendees: "",
    isAllDay: false,
    source: 0,
    sourceUrl: "",
    meetingId: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const CalendarEvent: MessageFns<CalendarEvent> = {
  encode(message: CalendarEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    if (message.provider !== 0) {
      writer.uint32(32).int32(message.provider);
    }
    if (message.externalId !== "") {
      writer.uint32(42).string(message.externalId);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.startTime !== "") {
      writer.uint32(66).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(74).string(message.endTime);
    }
    if (message.location !== "") {
      writer.uint32(82).string(message.location);
    }
    if (message.attendees !== "") {
      writer.uint32(90).string(message.attendees);
    }
    if (message.isAllDay !== false) {
      writer.uint32(96).bool(message.isAllDay);
    }
    if (message.source !== 0) {
      writer.uint32(104).int32(message.source);
    }
    if (message.sourceUrl !== "") {
      writer.uint32(114).string(message.sourceUrl);
    }
    if (message.meetingId !== "") {
      writer.uint32(122).string(message.meetingId);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(138).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalendarEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalendarEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.attendees = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isAllDay = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.sourceUrl = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalendarEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      externalId: isSet(object.externalId)
        ? globalThis.String(object.externalId)
        : isSet(object.external_id)
        ? globalThis.String(object.external_id)
        : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : isSet(object.start_time)
        ? globalThis.String(object.start_time)
        : "",
      endTime: isSet(object.endTime)
        ? globalThis.String(object.endTime)
        : isSet(object.end_time)
        ? globalThis.String(object.end_time)
        : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      attendees: isSet(object.attendees) ? globalThis.String(object.attendees) : "",
      isAllDay: isSet(object.isAllDay)
        ? globalThis.Boolean(object.isAllDay)
        : isSet(object.is_all_day)
        ? globalThis.Boolean(object.is_all_day)
        : false,
      source: isSet(object.source) ? calendarEventSourceFromJSON(object.source) : 0,
      sourceUrl: isSet(object.sourceUrl)
        ? globalThis.String(object.sourceUrl)
        : isSet(object.source_url)
        ? globalThis.String(object.source_url)
        : "",
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: CalendarEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.attendees !== "") {
      obj.attendees = message.attendees;
    }
    if (message.isAllDay !== false) {
      obj.isAllDay = message.isAllDay;
    }
    if (message.source !== 0) {
      obj.source = calendarEventSourceToJSON(message.source);
    }
    if (message.sourceUrl !== "") {
      obj.sourceUrl = message.sourceUrl;
    }
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalendarEvent>, I>>(base?: I): CalendarEvent {
    return CalendarEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalendarEvent>, I>>(object: I): CalendarEvent {
    const message = createBaseCalendarEvent();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.provider = object.provider ?? 0;
    message.externalId = object.externalId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.location = object.location ?? "";
    message.attendees = object.attendees ?? "";
    message.isAllDay = object.isAllDay ?? false;
    message.source = object.source ?? 0;
    message.sourceUrl = object.sourceUrl ?? "";
    message.meetingId = object.meetingId ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateCalendarEventRequest(): CreateCalendarEventRequest {
  return {
    userId: "",
    organisationId: "",
    provider: 0,
    externalId: "",
    title: "",
    description: "",
    startTime: "",
    endTime: "",
    location: "",
    attendees: "",
    isAllDay: false,
    source: 0,
    sourceUrl: "",
    meetingId: "",
  };
}

export const CreateCalendarEventRequest: MessageFns<CreateCalendarEventRequest> = {
  encode(message: CreateCalendarEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.provider !== 0) {
      writer.uint32(24).int32(message.provider);
    }
    if (message.externalId !== "") {
      writer.uint32(34).string(message.externalId);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.startTime !== "") {
      writer.uint32(58).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(66).string(message.endTime);
    }
    if (message.location !== "") {
      writer.uint32(74).string(message.location);
    }
    if (message.attendees !== "") {
      writer.uint32(82).string(message.attendees);
    }
    if (message.isAllDay !== false) {
      writer.uint32(88).bool(message.isAllDay);
    }
    if (message.source !== 0) {
      writer.uint32(96).int32(message.source);
    }
    if (message.sourceUrl !== "") {
      writer.uint32(106).string(message.sourceUrl);
    }
    if (message.meetingId !== "") {
      writer.uint32(114).string(message.meetingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCalendarEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCalendarEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attendees = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isAllDay = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sourceUrl = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCalendarEventRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      externalId: isSet(object.externalId)
        ? globalThis.String(object.externalId)
        : isSet(object.external_id)
        ? globalThis.String(object.external_id)
        : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : isSet(object.start_time)
        ? globalThis.String(object.start_time)
        : "",
      endTime: isSet(object.endTime)
        ? globalThis.String(object.endTime)
        : isSet(object.end_time)
        ? globalThis.String(object.end_time)
        : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      attendees: isSet(object.attendees) ? globalThis.String(object.attendees) : "",
      isAllDay: isSet(object.isAllDay)
        ? globalThis.Boolean(object.isAllDay)
        : isSet(object.is_all_day)
        ? globalThis.Boolean(object.is_all_day)
        : false,
      source: isSet(object.source) ? calendarEventSourceFromJSON(object.source) : 0,
      sourceUrl: isSet(object.sourceUrl)
        ? globalThis.String(object.sourceUrl)
        : isSet(object.source_url)
        ? globalThis.String(object.source_url)
        : "",
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
    };
  },

  toJSON(message: CreateCalendarEventRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.attendees !== "") {
      obj.attendees = message.attendees;
    }
    if (message.isAllDay !== false) {
      obj.isAllDay = message.isAllDay;
    }
    if (message.source !== 0) {
      obj.source = calendarEventSourceToJSON(message.source);
    }
    if (message.sourceUrl !== "") {
      obj.sourceUrl = message.sourceUrl;
    }
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCalendarEventRequest>, I>>(base?: I): CreateCalendarEventRequest {
    return CreateCalendarEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCalendarEventRequest>, I>>(object: I): CreateCalendarEventRequest {
    const message = createBaseCreateCalendarEventRequest();
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.provider = object.provider ?? 0;
    message.externalId = object.externalId ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.location = object.location ?? "";
    message.attendees = object.attendees ?? "";
    message.isAllDay = object.isAllDay ?? false;
    message.source = object.source ?? 0;
    message.sourceUrl = object.sourceUrl ?? "";
    message.meetingId = object.meetingId ?? "";
    return message;
  },
};

function createBaseGetCalendarEventRequest(): GetCalendarEventRequest {
  return { id: "" };
}

export const GetCalendarEventRequest: MessageFns<GetCalendarEventRequest> = {
  encode(message: GetCalendarEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCalendarEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCalendarEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCalendarEventRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetCalendarEventRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCalendarEventRequest>, I>>(base?: I): GetCalendarEventRequest {
    return GetCalendarEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCalendarEventRequest>, I>>(object: I): GetCalendarEventRequest {
    const message = createBaseGetCalendarEventRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateCalendarEventRequest(): UpdateCalendarEventRequest {
  return {
    id: "",
    title: "",
    description: "",
    startTime: "",
    endTime: "",
    location: "",
    attendees: "",
    isAllDay: false,
    sourceUrl: "",
    meetingId: "",
  };
}

export const UpdateCalendarEventRequest: MessageFns<UpdateCalendarEventRequest> = {
  encode(message: UpdateCalendarEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.startTime !== "") {
      writer.uint32(34).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(42).string(message.endTime);
    }
    if (message.location !== "") {
      writer.uint32(50).string(message.location);
    }
    if (message.attendees !== "") {
      writer.uint32(58).string(message.attendees);
    }
    if (message.isAllDay !== false) {
      writer.uint32(64).bool(message.isAllDay);
    }
    if (message.sourceUrl !== "") {
      writer.uint32(74).string(message.sourceUrl);
    }
    if (message.meetingId !== "") {
      writer.uint32(82).string(message.meetingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCalendarEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCalendarEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attendees = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isAllDay = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.sourceUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCalendarEventRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : isSet(object.start_time)
        ? globalThis.String(object.start_time)
        : "",
      endTime: isSet(object.endTime)
        ? globalThis.String(object.endTime)
        : isSet(object.end_time)
        ? globalThis.String(object.end_time)
        : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      attendees: isSet(object.attendees) ? globalThis.String(object.attendees) : "",
      isAllDay: isSet(object.isAllDay)
        ? globalThis.Boolean(object.isAllDay)
        : isSet(object.is_all_day)
        ? globalThis.Boolean(object.is_all_day)
        : false,
      sourceUrl: isSet(object.sourceUrl)
        ? globalThis.String(object.sourceUrl)
        : isSet(object.source_url)
        ? globalThis.String(object.source_url)
        : "",
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
    };
  },

  toJSON(message: UpdateCalendarEventRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.attendees !== "") {
      obj.attendees = message.attendees;
    }
    if (message.isAllDay !== false) {
      obj.isAllDay = message.isAllDay;
    }
    if (message.sourceUrl !== "") {
      obj.sourceUrl = message.sourceUrl;
    }
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCalendarEventRequest>, I>>(base?: I): UpdateCalendarEventRequest {
    return UpdateCalendarEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCalendarEventRequest>, I>>(object: I): UpdateCalendarEventRequest {
    const message = createBaseUpdateCalendarEventRequest();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.location = object.location ?? "";
    message.attendees = object.attendees ?? "";
    message.isAllDay = object.isAllDay ?? false;
    message.sourceUrl = object.sourceUrl ?? "";
    message.meetingId = object.meetingId ?? "";
    return message;
  },
};

function createBaseDeleteCalendarEventRequest(): DeleteCalendarEventRequest {
  return { id: "" };
}

export const DeleteCalendarEventRequest: MessageFns<DeleteCalendarEventRequest> = {
  encode(message: DeleteCalendarEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCalendarEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCalendarEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCalendarEventRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteCalendarEventRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCalendarEventRequest>, I>>(base?: I): DeleteCalendarEventRequest {
    return DeleteCalendarEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCalendarEventRequest>, I>>(object: I): DeleteCalendarEventRequest {
    const message = createBaseDeleteCalendarEventRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListCalendarEventsByDateRangeRequest(): ListCalendarEventsByDateRangeRequest {
  return { userId: "", organisationId: "", startDate: "", endDate: "", pagination: undefined };
}

export const ListCalendarEventsByDateRangeRequest: MessageFns<ListCalendarEventsByDateRangeRequest> = {
  encode(message: ListCalendarEventsByDateRangeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.startDate !== "") {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(34).string(message.endDate);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCalendarEventsByDateRangeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCalendarEventsByDateRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCalendarEventsByDateRangeRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListCalendarEventsByDateRangeRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCalendarEventsByDateRangeRequest>, I>>(
    base?: I,
  ): ListCalendarEventsByDateRangeRequest {
    return ListCalendarEventsByDateRangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCalendarEventsByDateRangeRequest>, I>>(
    object: I,
  ): ListCalendarEventsByDateRangeRequest {
    const message = createBaseListCalendarEventsByDateRangeRequest();
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListCalendarEventsByClientRequest(): ListCalendarEventsByClientRequest {
  return { clientId: "", organisationId: "", pagination: undefined };
}

export const ListCalendarEventsByClientRequest: MessageFns<ListCalendarEventsByClientRequest> = {
  encode(message: ListCalendarEventsByClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCalendarEventsByClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCalendarEventsByClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCalendarEventsByClientRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListCalendarEventsByClientRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCalendarEventsByClientRequest>, I>>(
    base?: I,
  ): ListCalendarEventsByClientRequest {
    return ListCalendarEventsByClientRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCalendarEventsByClientRequest>, I>>(
    object: I,
  ): ListCalendarEventsByClientRequest {
    const message = createBaseListCalendarEventsByClientRequest();
    message.clientId = object.clientId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListCalendarEventsResponse(): ListCalendarEventsResponse {
  return { events: [], pagination: undefined };
}

export const ListCalendarEventsResponse: MessageFns<ListCalendarEventsResponse> = {
  encode(message: ListCalendarEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      CalendarEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCalendarEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCalendarEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(CalendarEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCalendarEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => CalendarEvent.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListCalendarEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => CalendarEvent.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCalendarEventsResponse>, I>>(base?: I): ListCalendarEventsResponse {
    return ListCalendarEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCalendarEventsResponse>, I>>(object: I): ListCalendarEventsResponse {
    const message = createBaseListCalendarEventsResponse();
    message.events = object.events?.map((e) => CalendarEvent.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSyncFromProviderRequest(): SyncFromProviderRequest {
  return { oauthConnectionId: "", syncFromDate: "" };
}

export const SyncFromProviderRequest: MessageFns<SyncFromProviderRequest> = {
  encode(message: SyncFromProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oauthConnectionId !== "") {
      writer.uint32(10).string(message.oauthConnectionId);
    }
    if (message.syncFromDate !== "") {
      writer.uint32(18).string(message.syncFromDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncFromProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncFromProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oauthConnectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.syncFromDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncFromProviderRequest {
    return {
      oauthConnectionId: isSet(object.oauthConnectionId)
        ? globalThis.String(object.oauthConnectionId)
        : isSet(object.oauth_connection_id)
        ? globalThis.String(object.oauth_connection_id)
        : "",
      syncFromDate: isSet(object.syncFromDate)
        ? globalThis.String(object.syncFromDate)
        : isSet(object.sync_from_date)
        ? globalThis.String(object.sync_from_date)
        : "",
    };
  },

  toJSON(message: SyncFromProviderRequest): unknown {
    const obj: any = {};
    if (message.oauthConnectionId !== "") {
      obj.oauthConnectionId = message.oauthConnectionId;
    }
    if (message.syncFromDate !== "") {
      obj.syncFromDate = message.syncFromDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncFromProviderRequest>, I>>(base?: I): SyncFromProviderRequest {
    return SyncFromProviderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncFromProviderRequest>, I>>(object: I): SyncFromProviderRequest {
    const message = createBaseSyncFromProviderRequest();
    message.oauthConnectionId = object.oauthConnectionId ?? "";
    message.syncFromDate = object.syncFromDate ?? "";
    return message;
  },
};

function createBaseSyncFromProviderResponse(): SyncFromProviderResponse {
  return { syncedCount: 0, createdCount: 0, updatedCount: 0, deletedCount: 0 };
}

export const SyncFromProviderResponse: MessageFns<SyncFromProviderResponse> = {
  encode(message: SyncFromProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syncedCount !== 0) {
      writer.uint32(8).int32(message.syncedCount);
    }
    if (message.createdCount !== 0) {
      writer.uint32(16).int32(message.createdCount);
    }
    if (message.updatedCount !== 0) {
      writer.uint32(24).int32(message.updatedCount);
    }
    if (message.deletedCount !== 0) {
      writer.uint32(32).int32(message.deletedCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncFromProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncFromProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.syncedCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.createdCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.updatedCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deletedCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncFromProviderResponse {
    return {
      syncedCount: isSet(object.syncedCount)
        ? globalThis.Number(object.syncedCount)
        : isSet(object.synced_count)
        ? globalThis.Number(object.synced_count)
        : 0,
      createdCount: isSet(object.createdCount)
        ? globalThis.Number(object.createdCount)
        : isSet(object.created_count)
        ? globalThis.Number(object.created_count)
        : 0,
      updatedCount: isSet(object.updatedCount)
        ? globalThis.Number(object.updatedCount)
        : isSet(object.updated_count)
        ? globalThis.Number(object.updated_count)
        : 0,
      deletedCount: isSet(object.deletedCount)
        ? globalThis.Number(object.deletedCount)
        : isSet(object.deleted_count)
        ? globalThis.Number(object.deleted_count)
        : 0,
    };
  },

  toJSON(message: SyncFromProviderResponse): unknown {
    const obj: any = {};
    if (message.syncedCount !== 0) {
      obj.syncedCount = Math.round(message.syncedCount);
    }
    if (message.createdCount !== 0) {
      obj.createdCount = Math.round(message.createdCount);
    }
    if (message.updatedCount !== 0) {
      obj.updatedCount = Math.round(message.updatedCount);
    }
    if (message.deletedCount !== 0) {
      obj.deletedCount = Math.round(message.deletedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncFromProviderResponse>, I>>(base?: I): SyncFromProviderResponse {
    return SyncFromProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncFromProviderResponse>, I>>(object: I): SyncFromProviderResponse {
    const message = createBaseSyncFromProviderResponse();
    message.syncedCount = object.syncedCount ?? 0;
    message.createdCount = object.createdCount ?? 0;
    message.updatedCount = object.updatedCount ?? 0;
    message.deletedCount = object.deletedCount ?? 0;
    return message;
  },
};

function createBaseMeeting(): Meeting {
  return {
    id: "",
    userId: "",
    organisationId: "",
    provider: 0,
    externalMeetingId: "",
    title: "",
    startTime: "",
    endTime: "",
    durationMinutes: 0,
    participants: "",
    recordingUrl: "",
    transcriptUrl: "",
    summaryStatus: 0,
    calendarEventId: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Meeting: MessageFns<Meeting> = {
  encode(message: Meeting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    if (message.provider !== 0) {
      writer.uint32(32).int32(message.provider);
    }
    if (message.externalMeetingId !== "") {
      writer.uint32(42).string(message.externalMeetingId);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    if (message.startTime !== "") {
      writer.uint32(58).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(66).string(message.endTime);
    }
    if (message.durationMinutes !== 0) {
      writer.uint32(72).int32(message.durationMinutes);
    }
    if (message.participants !== "") {
      writer.uint32(82).string(message.participants);
    }
    if (message.recordingUrl !== "") {
      writer.uint32(90).string(message.recordingUrl);
    }
    if (message.transcriptUrl !== "") {
      writer.uint32(98).string(message.transcriptUrl);
    }
    if (message.summaryStatus !== 0) {
      writer.uint32(104).int32(message.summaryStatus);
    }
    if (message.calendarEventId !== "") {
      writer.uint32(114).string(message.calendarEventId);
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Meeting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeeting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalMeetingId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.durationMinutes = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.participants = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recordingUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.transcriptUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.summaryStatus = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.calendarEventId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Meeting {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      externalMeetingId: isSet(object.externalMeetingId)
        ? globalThis.String(object.externalMeetingId)
        : isSet(object.external_meeting_id)
        ? globalThis.String(object.external_meeting_id)
        : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : isSet(object.start_time)
        ? globalThis.String(object.start_time)
        : "",
      endTime: isSet(object.endTime)
        ? globalThis.String(object.endTime)
        : isSet(object.end_time)
        ? globalThis.String(object.end_time)
        : "",
      durationMinutes: isSet(object.durationMinutes)
        ? globalThis.Number(object.durationMinutes)
        : isSet(object.duration_minutes)
        ? globalThis.Number(object.duration_minutes)
        : 0,
      participants: isSet(object.participants) ? globalThis.String(object.participants) : "",
      recordingUrl: isSet(object.recordingUrl)
        ? globalThis.String(object.recordingUrl)
        : isSet(object.recording_url)
        ? globalThis.String(object.recording_url)
        : "",
      transcriptUrl: isSet(object.transcriptUrl)
        ? globalThis.String(object.transcriptUrl)
        : isSet(object.transcript_url)
        ? globalThis.String(object.transcript_url)
        : "",
      summaryStatus: isSet(object.summaryStatus)
        ? meetingSummaryStatusFromJSON(object.summaryStatus)
        : isSet(object.summary_status)
        ? meetingSummaryStatusFromJSON(object.summary_status)
        : 0,
      calendarEventId: isSet(object.calendarEventId)
        ? globalThis.String(object.calendarEventId)
        : isSet(object.calendar_event_id)
        ? globalThis.String(object.calendar_event_id)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: Meeting): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.externalMeetingId !== "") {
      obj.externalMeetingId = message.externalMeetingId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.durationMinutes !== 0) {
      obj.durationMinutes = Math.round(message.durationMinutes);
    }
    if (message.participants !== "") {
      obj.participants = message.participants;
    }
    if (message.recordingUrl !== "") {
      obj.recordingUrl = message.recordingUrl;
    }
    if (message.transcriptUrl !== "") {
      obj.transcriptUrl = message.transcriptUrl;
    }
    if (message.summaryStatus !== 0) {
      obj.summaryStatus = meetingSummaryStatusToJSON(message.summaryStatus);
    }
    if (message.calendarEventId !== "") {
      obj.calendarEventId = message.calendarEventId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Meeting>, I>>(base?: I): Meeting {
    return Meeting.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Meeting>, I>>(object: I): Meeting {
    const message = createBaseMeeting();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.provider = object.provider ?? 0;
    message.externalMeetingId = object.externalMeetingId ?? "";
    message.title = object.title ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.durationMinutes = object.durationMinutes ?? 0;
    message.participants = object.participants ?? "";
    message.recordingUrl = object.recordingUrl ?? "";
    message.transcriptUrl = object.transcriptUrl ?? "";
    message.summaryStatus = object.summaryStatus ?? 0;
    message.calendarEventId = object.calendarEventId ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateMeetingRequest(): CreateMeetingRequest {
  return {
    userId: "",
    organisationId: "",
    provider: 0,
    externalMeetingId: "",
    title: "",
    startTime: "",
    endTime: "",
    durationMinutes: 0,
    participants: "",
    recordingUrl: "",
    transcriptUrl: "",
    calendarEventId: "",
  };
}

export const CreateMeetingRequest: MessageFns<CreateMeetingRequest> = {
  encode(message: CreateMeetingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.provider !== 0) {
      writer.uint32(24).int32(message.provider);
    }
    if (message.externalMeetingId !== "") {
      writer.uint32(34).string(message.externalMeetingId);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.startTime !== "") {
      writer.uint32(50).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(58).string(message.endTime);
    }
    if (message.durationMinutes !== 0) {
      writer.uint32(64).int32(message.durationMinutes);
    }
    if (message.participants !== "") {
      writer.uint32(74).string(message.participants);
    }
    if (message.recordingUrl !== "") {
      writer.uint32(82).string(message.recordingUrl);
    }
    if (message.transcriptUrl !== "") {
      writer.uint32(90).string(message.transcriptUrl);
    }
    if (message.calendarEventId !== "") {
      writer.uint32(98).string(message.calendarEventId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMeetingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMeetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalMeetingId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.durationMinutes = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.participants = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.recordingUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.transcriptUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.calendarEventId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMeetingRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      provider: isSet(object.provider) ? oAuthProviderFromJSON(object.provider) : 0,
      externalMeetingId: isSet(object.externalMeetingId)
        ? globalThis.String(object.externalMeetingId)
        : isSet(object.external_meeting_id)
        ? globalThis.String(object.external_meeting_id)
        : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : isSet(object.start_time)
        ? globalThis.String(object.start_time)
        : "",
      endTime: isSet(object.endTime)
        ? globalThis.String(object.endTime)
        : isSet(object.end_time)
        ? globalThis.String(object.end_time)
        : "",
      durationMinutes: isSet(object.durationMinutes)
        ? globalThis.Number(object.durationMinutes)
        : isSet(object.duration_minutes)
        ? globalThis.Number(object.duration_minutes)
        : 0,
      participants: isSet(object.participants) ? globalThis.String(object.participants) : "",
      recordingUrl: isSet(object.recordingUrl)
        ? globalThis.String(object.recordingUrl)
        : isSet(object.recording_url)
        ? globalThis.String(object.recording_url)
        : "",
      transcriptUrl: isSet(object.transcriptUrl)
        ? globalThis.String(object.transcriptUrl)
        : isSet(object.transcript_url)
        ? globalThis.String(object.transcript_url)
        : "",
      calendarEventId: isSet(object.calendarEventId)
        ? globalThis.String(object.calendarEventId)
        : isSet(object.calendar_event_id)
        ? globalThis.String(object.calendar_event_id)
        : "",
    };
  },

  toJSON(message: CreateMeetingRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.provider !== 0) {
      obj.provider = oAuthProviderToJSON(message.provider);
    }
    if (message.externalMeetingId !== "") {
      obj.externalMeetingId = message.externalMeetingId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.durationMinutes !== 0) {
      obj.durationMinutes = Math.round(message.durationMinutes);
    }
    if (message.participants !== "") {
      obj.participants = message.participants;
    }
    if (message.recordingUrl !== "") {
      obj.recordingUrl = message.recordingUrl;
    }
    if (message.transcriptUrl !== "") {
      obj.transcriptUrl = message.transcriptUrl;
    }
    if (message.calendarEventId !== "") {
      obj.calendarEventId = message.calendarEventId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMeetingRequest>, I>>(base?: I): CreateMeetingRequest {
    return CreateMeetingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMeetingRequest>, I>>(object: I): CreateMeetingRequest {
    const message = createBaseCreateMeetingRequest();
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.provider = object.provider ?? 0;
    message.externalMeetingId = object.externalMeetingId ?? "";
    message.title = object.title ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.durationMinutes = object.durationMinutes ?? 0;
    message.participants = object.participants ?? "";
    message.recordingUrl = object.recordingUrl ?? "";
    message.transcriptUrl = object.transcriptUrl ?? "";
    message.calendarEventId = object.calendarEventId ?? "";
    return message;
  },
};

function createBaseGetMeetingRequest(): GetMeetingRequest {
  return { id: "" };
}

export const GetMeetingRequest: MessageFns<GetMeetingRequest> = {
  encode(message: GetMeetingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMeetingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMeetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMeetingRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetMeetingRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMeetingRequest>, I>>(base?: I): GetMeetingRequest {
    return GetMeetingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMeetingRequest>, I>>(object: I): GetMeetingRequest {
    const message = createBaseGetMeetingRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListMeetingsByDateRangeRequest(): ListMeetingsByDateRangeRequest {
  return { userId: "", organisationId: "", startDate: "", endDate: "", pagination: undefined };
}

export const ListMeetingsByDateRangeRequest: MessageFns<ListMeetingsByDateRangeRequest> = {
  encode(message: ListMeetingsByDateRangeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.startDate !== "") {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(34).string(message.endDate);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMeetingsByDateRangeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMeetingsByDateRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMeetingsByDateRangeRequest {
    return {
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListMeetingsByDateRangeRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListMeetingsByDateRangeRequest>, I>>(base?: I): ListMeetingsByDateRangeRequest {
    return ListMeetingsByDateRangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListMeetingsByDateRangeRequest>, I>>(
    object: I,
  ): ListMeetingsByDateRangeRequest {
    const message = createBaseListMeetingsByDateRangeRequest();
    message.userId = object.userId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListMeetingsResponse(): ListMeetingsResponse {
  return { meetings: [], pagination: undefined };
}

export const ListMeetingsResponse: MessageFns<ListMeetingsResponse> = {
  encode(message: ListMeetingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.meetings) {
      Meeting.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMeetingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMeetingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meetings.push(Meeting.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMeetingsResponse {
    return {
      meetings: globalThis.Array.isArray(object?.meetings) ? object.meetings.map((e: any) => Meeting.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListMeetingsResponse): unknown {
    const obj: any = {};
    if (message.meetings?.length) {
      obj.meetings = message.meetings.map((e) => Meeting.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListMeetingsResponse>, I>>(base?: I): ListMeetingsResponse {
    return ListMeetingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListMeetingsResponse>, I>>(object: I): ListMeetingsResponse {
    const message = createBaseListMeetingsResponse();
    message.meetings = object.meetings?.map((e) => Meeting.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseMeetingParticipant(): MeetingParticipant {
  return { email: "", displayName: "", matchType: 0, matchedClientId: "" };
}

export const MeetingParticipant: MessageFns<MeetingParticipant> = {
  encode(message: MeetingParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.matchType !== 0) {
      writer.uint32(24).int32(message.matchType);
    }
    if (message.matchedClientId !== "") {
      writer.uint32(34).string(message.matchedClientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeetingParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeetingParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.matchedClientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeetingParticipant {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      displayName: isSet(object.displayName)
        ? globalThis.String(object.displayName)
        : isSet(object.display_name)
        ? globalThis.String(object.display_name)
        : "",
      matchType: isSet(object.matchType)
        ? participantMatchTypeFromJSON(object.matchType)
        : isSet(object.match_type)
        ? participantMatchTypeFromJSON(object.match_type)
        : 0,
      matchedClientId: isSet(object.matchedClientId)
        ? globalThis.String(object.matchedClientId)
        : isSet(object.matched_client_id)
        ? globalThis.String(object.matched_client_id)
        : "",
    };
  },

  toJSON(message: MeetingParticipant): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.matchType !== 0) {
      obj.matchType = participantMatchTypeToJSON(message.matchType);
    }
    if (message.matchedClientId !== "") {
      obj.matchedClientId = message.matchedClientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MeetingParticipant>, I>>(base?: I): MeetingParticipant {
    return MeetingParticipant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeetingParticipant>, I>>(object: I): MeetingParticipant {
    const message = createBaseMeetingParticipant();
    message.email = object.email ?? "";
    message.displayName = object.displayName ?? "";
    message.matchType = object.matchType ?? 0;
    message.matchedClientId = object.matchedClientId ?? "";
    return message;
  },
};

function createBaseMatchParticipantsRequest(): MatchParticipantsRequest {
  return { meetingId: "" };
}

export const MatchParticipantsRequest: MessageFns<MatchParticipantsRequest> = {
  encode(message: MatchParticipantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meetingId !== "") {
      writer.uint32(10).string(message.meetingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchParticipantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchParticipantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchParticipantsRequest {
    return {
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
    };
  },

  toJSON(message: MatchParticipantsRequest): unknown {
    const obj: any = {};
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchParticipantsRequest>, I>>(base?: I): MatchParticipantsRequest {
    return MatchParticipantsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchParticipantsRequest>, I>>(object: I): MatchParticipantsRequest {
    const message = createBaseMatchParticipantsRequest();
    message.meetingId = object.meetingId ?? "";
    return message;
  },
};

function createBaseMatchParticipantsResponse(): MatchParticipantsResponse {
  return { participants: [], matchedCount: 0, unmatchedCount: 0 };
}

export const MatchParticipantsResponse: MessageFns<MatchParticipantsResponse> = {
  encode(message: MatchParticipantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      MeetingParticipant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.matchedCount !== 0) {
      writer.uint32(16).int32(message.matchedCount);
    }
    if (message.unmatchedCount !== 0) {
      writer.uint32(24).int32(message.unmatchedCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchParticipantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchParticipantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participants.push(MeetingParticipant.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.matchedCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.unmatchedCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchParticipantsResponse {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => MeetingParticipant.fromJSON(e))
        : [],
      matchedCount: isSet(object.matchedCount)
        ? globalThis.Number(object.matchedCount)
        : isSet(object.matched_count)
        ? globalThis.Number(object.matched_count)
        : 0,
      unmatchedCount: isSet(object.unmatchedCount)
        ? globalThis.Number(object.unmatchedCount)
        : isSet(object.unmatched_count)
        ? globalThis.Number(object.unmatched_count)
        : 0,
    };
  },

  toJSON(message: MatchParticipantsResponse): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => MeetingParticipant.toJSON(e));
    }
    if (message.matchedCount !== 0) {
      obj.matchedCount = Math.round(message.matchedCount);
    }
    if (message.unmatchedCount !== 0) {
      obj.unmatchedCount = Math.round(message.unmatchedCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MatchParticipantsResponse>, I>>(base?: I): MatchParticipantsResponse {
    return MatchParticipantsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MatchParticipantsResponse>, I>>(object: I): MatchParticipantsResponse {
    const message = createBaseMatchParticipantsResponse();
    message.participants = object.participants?.map((e) => MeetingParticipant.fromPartial(e)) || [];
    message.matchedCount = object.matchedCount ?? 0;
    message.unmatchedCount = object.unmatchedCount ?? 0;
    return message;
  },
};

function createBaseUpdateClientMatchRequest(): UpdateClientMatchRequest {
  return { meetingId: "", participantEmail: "", clientId: "", matchType: 0 };
}

export const UpdateClientMatchRequest: MessageFns<UpdateClientMatchRequest> = {
  encode(message: UpdateClientMatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meetingId !== "") {
      writer.uint32(10).string(message.meetingId);
    }
    if (message.participantEmail !== "") {
      writer.uint32(18).string(message.participantEmail);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.matchType !== 0) {
      writer.uint32(32).int32(message.matchType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClientMatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClientMatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participantEmail = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClientMatchRequest {
    return {
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
      participantEmail: isSet(object.participantEmail)
        ? globalThis.String(object.participantEmail)
        : isSet(object.participant_email)
        ? globalThis.String(object.participant_email)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      matchType: isSet(object.matchType)
        ? participantMatchTypeFromJSON(object.matchType)
        : isSet(object.match_type)
        ? participantMatchTypeFromJSON(object.match_type)
        : 0,
    };
  },

  toJSON(message: UpdateClientMatchRequest): unknown {
    const obj: any = {};
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    if (message.participantEmail !== "") {
      obj.participantEmail = message.participantEmail;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.matchType !== 0) {
      obj.matchType = participantMatchTypeToJSON(message.matchType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClientMatchRequest>, I>>(base?: I): UpdateClientMatchRequest {
    return UpdateClientMatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClientMatchRequest>, I>>(object: I): UpdateClientMatchRequest {
    const message = createBaseUpdateClientMatchRequest();
    message.meetingId = object.meetingId ?? "";
    message.participantEmail = object.participantEmail ?? "";
    message.clientId = object.clientId ?? "";
    message.matchType = object.matchType ?? 0;
    return message;
  },
};

function createBaseCallSummary(): CallSummary {
  return {
    id: "",
    meetingId: "",
    executiveSummary: "",
    keyPoints: "",
    decisions: "",
    actionItems: "",
    generatedAt: "",
    aiModel: "",
    rawAiResponse: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const CallSummary: MessageFns<CallSummary> = {
  encode(message: CallSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.meetingId !== "") {
      writer.uint32(18).string(message.meetingId);
    }
    if (message.executiveSummary !== "") {
      writer.uint32(26).string(message.executiveSummary);
    }
    if (message.keyPoints !== "") {
      writer.uint32(34).string(message.keyPoints);
    }
    if (message.decisions !== "") {
      writer.uint32(42).string(message.decisions);
    }
    if (message.actionItems !== "") {
      writer.uint32(50).string(message.actionItems);
    }
    if (message.generatedAt !== "") {
      writer.uint32(58).string(message.generatedAt);
    }
    if (message.aiModel !== "") {
      writer.uint32(66).string(message.aiModel);
    }
    if (message.rawAiResponse !== "") {
      writer.uint32(74).string(message.rawAiResponse);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.executiveSummary = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keyPoints = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.decisions = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actionItems = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.generatedAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.aiModel = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rawAiResponse = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallSummary {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
      executiveSummary: isSet(object.executiveSummary)
        ? globalThis.String(object.executiveSummary)
        : isSet(object.executive_summary)
        ? globalThis.String(object.executive_summary)
        : "",
      keyPoints: isSet(object.keyPoints)
        ? globalThis.String(object.keyPoints)
        : isSet(object.key_points)
        ? globalThis.String(object.key_points)
        : "",
      decisions: isSet(object.decisions) ? globalThis.String(object.decisions) : "",
      actionItems: isSet(object.actionItems)
        ? globalThis.String(object.actionItems)
        : isSet(object.action_items)
        ? globalThis.String(object.action_items)
        : "",
      generatedAt: isSet(object.generatedAt)
        ? globalThis.String(object.generatedAt)
        : isSet(object.generated_at)
        ? globalThis.String(object.generated_at)
        : "",
      aiModel: isSet(object.aiModel)
        ? globalThis.String(object.aiModel)
        : isSet(object.ai_model)
        ? globalThis.String(object.ai_model)
        : "",
      rawAiResponse: isSet(object.rawAiResponse)
        ? globalThis.String(object.rawAiResponse)
        : isSet(object.raw_ai_response)
        ? globalThis.String(object.raw_ai_response)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: CallSummary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    if (message.executiveSummary !== "") {
      obj.executiveSummary = message.executiveSummary;
    }
    if (message.keyPoints !== "") {
      obj.keyPoints = message.keyPoints;
    }
    if (message.decisions !== "") {
      obj.decisions = message.decisions;
    }
    if (message.actionItems !== "") {
      obj.actionItems = message.actionItems;
    }
    if (message.generatedAt !== "") {
      obj.generatedAt = message.generatedAt;
    }
    if (message.aiModel !== "") {
      obj.aiModel = message.aiModel;
    }
    if (message.rawAiResponse !== "") {
      obj.rawAiResponse = message.rawAiResponse;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallSummary>, I>>(base?: I): CallSummary {
    return CallSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallSummary>, I>>(object: I): CallSummary {
    const message = createBaseCallSummary();
    message.id = object.id ?? "";
    message.meetingId = object.meetingId ?? "";
    message.executiveSummary = object.executiveSummary ?? "";
    message.keyPoints = object.keyPoints ?? "";
    message.decisions = object.decisions ?? "";
    message.actionItems = object.actionItems ?? "";
    message.generatedAt = object.generatedAt ?? "";
    message.aiModel = object.aiModel ?? "";
    message.rawAiResponse = object.rawAiResponse ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseGetCallSummaryRequest(): GetCallSummaryRequest {
  return { id: "" };
}

export const GetCallSummaryRequest: MessageFns<GetCallSummaryRequest> = {
  encode(message: GetCallSummaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCallSummaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCallSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCallSummaryRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetCallSummaryRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCallSummaryRequest>, I>>(base?: I): GetCallSummaryRequest {
    return GetCallSummaryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCallSummaryRequest>, I>>(object: I): GetCallSummaryRequest {
    const message = createBaseGetCallSummaryRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetCallSummaryByMeetingRequest(): GetCallSummaryByMeetingRequest {
  return { meetingId: "" };
}

export const GetCallSummaryByMeetingRequest: MessageFns<GetCallSummaryByMeetingRequest> = {
  encode(message: GetCallSummaryByMeetingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meetingId !== "") {
      writer.uint32(10).string(message.meetingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCallSummaryByMeetingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCallSummaryByMeetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCallSummaryByMeetingRequest {
    return {
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
    };
  },

  toJSON(message: GetCallSummaryByMeetingRequest): unknown {
    const obj: any = {};
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCallSummaryByMeetingRequest>, I>>(base?: I): GetCallSummaryByMeetingRequest {
    return GetCallSummaryByMeetingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCallSummaryByMeetingRequest>, I>>(
    object: I,
  ): GetCallSummaryByMeetingRequest {
    const message = createBaseGetCallSummaryByMeetingRequest();
    message.meetingId = object.meetingId ?? "";
    return message;
  },
};

function createBaseRegenerateCallSummaryRequest(): RegenerateCallSummaryRequest {
  return { meetingId: "", aiModel: "" };
}

export const RegenerateCallSummaryRequest: MessageFns<RegenerateCallSummaryRequest> = {
  encode(message: RegenerateCallSummaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meetingId !== "") {
      writer.uint32(10).string(message.meetingId);
    }
    if (message.aiModel !== "") {
      writer.uint32(18).string(message.aiModel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegenerateCallSummaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegenerateCallSummaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.meetingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aiModel = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegenerateCallSummaryRequest {
    return {
      meetingId: isSet(object.meetingId)
        ? globalThis.String(object.meetingId)
        : isSet(object.meeting_id)
        ? globalThis.String(object.meeting_id)
        : "",
      aiModel: isSet(object.aiModel)
        ? globalThis.String(object.aiModel)
        : isSet(object.ai_model)
        ? globalThis.String(object.ai_model)
        : "",
    };
  },

  toJSON(message: RegenerateCallSummaryRequest): unknown {
    const obj: any = {};
    if (message.meetingId !== "") {
      obj.meetingId = message.meetingId;
    }
    if (message.aiModel !== "") {
      obj.aiModel = message.aiModel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegenerateCallSummaryRequest>, I>>(base?: I): RegenerateCallSummaryRequest {
    return RegenerateCallSummaryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegenerateCallSummaryRequest>, I>>(object: I): RegenerateCallSummaryRequest {
    const message = createBaseRegenerateCallSummaryRequest();
    message.meetingId = object.meetingId ?? "";
    message.aiModel = object.aiModel ?? "";
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pagination {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      sortBy: isSet(object.sortBy)
        ? globalThis.String(object.sortBy)
        : isSet(object.sort_by)
        ? globalThis.String(object.sort_by)
        : "",
      sortOrder: isSet(object.sortOrder)
        ? globalThis.String(object.sortOrder)
        : isSet(object.sort_order)
        ? globalThis.String(object.sort_order)
        : "",
    };
  },

  toJSON(message: Pagination): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pagination>, I>>(base?: I): Pagination {
    return Pagination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pagination>, I>>(object: I): Pagination {
    const message = createBasePagination();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResult {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: PaginationResult): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResult>, I>>(base?: I): PaginationResult {
    return PaginationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResult>, I>>(object: I): PaginationResult {
    const message = createBasePaginationResult();
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    return message;
  },
};

/** ========== OAUTH CONNECTION SERVICE ========== */
export type OAuthConnectionServiceService = typeof OAuthConnectionServiceService;
export const OAuthConnectionServiceService = {
  connectProvider: {
    path: "/agenda.OAuthConnectionService/ConnectProvider",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConnectProviderRequest): Buffer =>
      Buffer.from(ConnectProviderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ConnectProviderRequest => ConnectProviderRequest.decode(value),
    responseSerialize: (value: OAuthConnection): Buffer => Buffer.from(OAuthConnection.encode(value).finish()),
    responseDeserialize: (value: Buffer): OAuthConnection => OAuthConnection.decode(value),
  },
  disconnectProvider: {
    path: "/agenda.OAuthConnectionService/DisconnectProvider",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DisconnectProviderRequest): Buffer =>
      Buffer.from(DisconnectProviderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DisconnectProviderRequest => DisconnectProviderRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getAuthUrl: {
    path: "/agenda.OAuthConnectionService/GetAuthUrl",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuthUrlRequest): Buffer => Buffer.from(GetAuthUrlRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuthUrlRequest => GetAuthUrlRequest.decode(value),
    responseSerialize: (value: GetAuthUrlResponse): Buffer => Buffer.from(GetAuthUrlResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAuthUrlResponse => GetAuthUrlResponse.decode(value),
  },
  handleCallback: {
    path: "/agenda.OAuthConnectionService/HandleCallback",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HandleCallbackRequest): Buffer =>
      Buffer.from(HandleCallbackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HandleCallbackRequest => HandleCallbackRequest.decode(value),
    responseSerialize: (value: OAuthConnection): Buffer => Buffer.from(OAuthConnection.encode(value).finish()),
    responseDeserialize: (value: Buffer): OAuthConnection => OAuthConnection.decode(value),
  },
  listConnections: {
    path: "/agenda.OAuthConnectionService/ListConnections",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListConnectionsRequest): Buffer =>
      Buffer.from(ListConnectionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListConnectionsRequest => ListConnectionsRequest.decode(value),
    responseSerialize: (value: ListConnectionsResponse): Buffer =>
      Buffer.from(ListConnectionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListConnectionsResponse => ListConnectionsResponse.decode(value),
  },
  refreshToken: {
    path: "/agenda.OAuthConnectionService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: OAuthConnection): Buffer => Buffer.from(OAuthConnection.encode(value).finish()),
    responseDeserialize: (value: Buffer): OAuthConnection => OAuthConnection.decode(value),
  },
} as const;

export interface OAuthConnectionServiceServer extends UntypedServiceImplementation {
  connectProvider: handleUnaryCall<ConnectProviderRequest, OAuthConnection>;
  disconnectProvider: handleUnaryCall<DisconnectProviderRequest, DeleteResponse>;
  getAuthUrl: handleUnaryCall<GetAuthUrlRequest, GetAuthUrlResponse>;
  handleCallback: handleUnaryCall<HandleCallbackRequest, OAuthConnection>;
  listConnections: handleUnaryCall<ListConnectionsRequest, ListConnectionsResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, OAuthConnection>;
}

/** ========== CALENDAR EVENT SERVICE ========== */
export type CalendarEventServiceService = typeof CalendarEventServiceService;
export const CalendarEventServiceService = {
  create: {
    path: "/agenda.CalendarEventService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCalendarEventRequest): Buffer =>
      Buffer.from(CreateCalendarEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCalendarEventRequest => CreateCalendarEventRequest.decode(value),
    responseSerialize: (value: CalendarEvent): Buffer => Buffer.from(CalendarEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalendarEvent => CalendarEvent.decode(value),
  },
  get: {
    path: "/agenda.CalendarEventService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCalendarEventRequest): Buffer =>
      Buffer.from(GetCalendarEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCalendarEventRequest => GetCalendarEventRequest.decode(value),
    responseSerialize: (value: CalendarEvent): Buffer => Buffer.from(CalendarEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalendarEvent => CalendarEvent.decode(value),
  },
  update: {
    path: "/agenda.CalendarEventService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCalendarEventRequest): Buffer =>
      Buffer.from(UpdateCalendarEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateCalendarEventRequest => UpdateCalendarEventRequest.decode(value),
    responseSerialize: (value: CalendarEvent): Buffer => Buffer.from(CalendarEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalendarEvent => CalendarEvent.decode(value),
  },
  delete: {
    path: "/agenda.CalendarEventService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCalendarEventRequest): Buffer =>
      Buffer.from(DeleteCalendarEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCalendarEventRequest => DeleteCalendarEventRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  listByDateRange: {
    path: "/agenda.CalendarEventService/ListByDateRange",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCalendarEventsByDateRangeRequest): Buffer =>
      Buffer.from(ListCalendarEventsByDateRangeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCalendarEventsByDateRangeRequest =>
      ListCalendarEventsByDateRangeRequest.decode(value),
    responseSerialize: (value: ListCalendarEventsResponse): Buffer =>
      Buffer.from(ListCalendarEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCalendarEventsResponse => ListCalendarEventsResponse.decode(value),
  },
  listByClient: {
    path: "/agenda.CalendarEventService/ListByClient",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCalendarEventsByClientRequest): Buffer =>
      Buffer.from(ListCalendarEventsByClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCalendarEventsByClientRequest =>
      ListCalendarEventsByClientRequest.decode(value),
    responseSerialize: (value: ListCalendarEventsResponse): Buffer =>
      Buffer.from(ListCalendarEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCalendarEventsResponse => ListCalendarEventsResponse.decode(value),
  },
  syncFromProvider: {
    path: "/agenda.CalendarEventService/SyncFromProvider",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SyncFromProviderRequest): Buffer =>
      Buffer.from(SyncFromProviderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SyncFromProviderRequest => SyncFromProviderRequest.decode(value),
    responseSerialize: (value: SyncFromProviderResponse): Buffer =>
      Buffer.from(SyncFromProviderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SyncFromProviderResponse => SyncFromProviderResponse.decode(value),
  },
} as const;

export interface CalendarEventServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateCalendarEventRequest, CalendarEvent>;
  get: handleUnaryCall<GetCalendarEventRequest, CalendarEvent>;
  update: handleUnaryCall<UpdateCalendarEventRequest, CalendarEvent>;
  delete: handleUnaryCall<DeleteCalendarEventRequest, DeleteResponse>;
  listByDateRange: handleUnaryCall<ListCalendarEventsByDateRangeRequest, ListCalendarEventsResponse>;
  listByClient: handleUnaryCall<ListCalendarEventsByClientRequest, ListCalendarEventsResponse>;
  syncFromProvider: handleUnaryCall<SyncFromProviderRequest, SyncFromProviderResponse>;
}

/** ========== MEETING SERVICE ========== */
export type MeetingServiceService = typeof MeetingServiceService;
export const MeetingServiceService = {
  create: {
    path: "/agenda.MeetingService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateMeetingRequest): Buffer => Buffer.from(CreateMeetingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateMeetingRequest => CreateMeetingRequest.decode(value),
    responseSerialize: (value: Meeting): Buffer => Buffer.from(Meeting.encode(value).finish()),
    responseDeserialize: (value: Buffer): Meeting => Meeting.decode(value),
  },
  get: {
    path: "/agenda.MeetingService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMeetingRequest): Buffer => Buffer.from(GetMeetingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMeetingRequest => GetMeetingRequest.decode(value),
    responseSerialize: (value: Meeting): Buffer => Buffer.from(Meeting.encode(value).finish()),
    responseDeserialize: (value: Buffer): Meeting => Meeting.decode(value),
  },
  listByDateRange: {
    path: "/agenda.MeetingService/ListByDateRange",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListMeetingsByDateRangeRequest): Buffer =>
      Buffer.from(ListMeetingsByDateRangeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListMeetingsByDateRangeRequest => ListMeetingsByDateRangeRequest.decode(value),
    responseSerialize: (value: ListMeetingsResponse): Buffer =>
      Buffer.from(ListMeetingsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListMeetingsResponse => ListMeetingsResponse.decode(value),
  },
  matchParticipants: {
    path: "/agenda.MeetingService/MatchParticipants",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MatchParticipantsRequest): Buffer =>
      Buffer.from(MatchParticipantsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MatchParticipantsRequest => MatchParticipantsRequest.decode(value),
    responseSerialize: (value: MatchParticipantsResponse): Buffer =>
      Buffer.from(MatchParticipantsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MatchParticipantsResponse => MatchParticipantsResponse.decode(value),
  },
  updateClientMatch: {
    path: "/agenda.MeetingService/UpdateClientMatch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateClientMatchRequest): Buffer =>
      Buffer.from(UpdateClientMatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateClientMatchRequest => UpdateClientMatchRequest.decode(value),
    responseSerialize: (value: Meeting): Buffer => Buffer.from(Meeting.encode(value).finish()),
    responseDeserialize: (value: Buffer): Meeting => Meeting.decode(value),
  },
} as const;

export interface MeetingServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateMeetingRequest, Meeting>;
  get: handleUnaryCall<GetMeetingRequest, Meeting>;
  listByDateRange: handleUnaryCall<ListMeetingsByDateRangeRequest, ListMeetingsResponse>;
  matchParticipants: handleUnaryCall<MatchParticipantsRequest, MatchParticipantsResponse>;
  updateClientMatch: handleUnaryCall<UpdateClientMatchRequest, Meeting>;
}

/** ========== CALL SUMMARY SERVICE ========== */
export type CallSummaryServiceService = typeof CallSummaryServiceService;
export const CallSummaryServiceService = {
  get: {
    path: "/agenda.CallSummaryService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCallSummaryRequest): Buffer =>
      Buffer.from(GetCallSummaryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCallSummaryRequest => GetCallSummaryRequest.decode(value),
    responseSerialize: (value: CallSummary): Buffer => Buffer.from(CallSummary.encode(value).finish()),
    responseDeserialize: (value: Buffer): CallSummary => CallSummary.decode(value),
  },
  getByMeeting: {
    path: "/agenda.CallSummaryService/GetByMeeting",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCallSummaryByMeetingRequest): Buffer =>
      Buffer.from(GetCallSummaryByMeetingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCallSummaryByMeetingRequest => GetCallSummaryByMeetingRequest.decode(value),
    responseSerialize: (value: CallSummary): Buffer => Buffer.from(CallSummary.encode(value).finish()),
    responseDeserialize: (value: Buffer): CallSummary => CallSummary.decode(value),
  },
  regenerate: {
    path: "/agenda.CallSummaryService/Regenerate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegenerateCallSummaryRequest): Buffer =>
      Buffer.from(RegenerateCallSummaryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RegenerateCallSummaryRequest => RegenerateCallSummaryRequest.decode(value),
    responseSerialize: (value: CallSummary): Buffer => Buffer.from(CallSummary.encode(value).finish()),
    responseDeserialize: (value: Buffer): CallSummary => CallSummary.decode(value),
  },
} as const;

export interface CallSummaryServiceServer extends UntypedServiceImplementation {
  get: handleUnaryCall<GetCallSummaryRequest, CallSummary>;
  getByMeeting: handleUnaryCall<GetCallSummaryByMeetingRequest, CallSummary>;
  regenerate: handleUnaryCall<RegenerateCallSummaryRequest, CallSummary>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
