// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: calendar/calendar.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";

export const protobufPackage = "calendar";

/**
 * Définition des lots de prélèvement (fenêtres d'émission)
 * L1 = Semaine 1 du mois (jours 1-7)
 * L2 = Semaine 2 du mois (jours 8-14)
 * L3 = Semaine 3 du mois (jours 15-21)
 * L4 = Semaine 4 du mois (jours 22-fin)
 */
export enum DebitBatch {
  DEBIT_BATCH_UNSPECIFIED = 0,
  /** DEBIT_BATCH_L1 - Semaine 1: jours 1-7 */
  DEBIT_BATCH_L1 = 1,
  /** DEBIT_BATCH_L2 - Semaine 2: jours 8-14 */
  DEBIT_BATCH_L2 = 2,
  /** DEBIT_BATCH_L3 - Semaine 3: jours 15-21 */
  DEBIT_BATCH_L3 = 3,
  /** DEBIT_BATCH_L4 - Semaine 4: jours 22-fin du mois */
  DEBIT_BATCH_L4 = 4,
  UNRECOGNIZED = -1,
}

export function debitBatchFromJSON(object: any): DebitBatch {
  switch (object) {
    case 0:
    case "DEBIT_BATCH_UNSPECIFIED":
      return DebitBatch.DEBIT_BATCH_UNSPECIFIED;
    case 1:
    case "DEBIT_BATCH_L1":
      return DebitBatch.DEBIT_BATCH_L1;
    case 2:
    case "DEBIT_BATCH_L2":
      return DebitBatch.DEBIT_BATCH_L2;
    case 3:
    case "DEBIT_BATCH_L3":
      return DebitBatch.DEBIT_BATCH_L3;
    case 4:
    case "DEBIT_BATCH_L4":
      return DebitBatch.DEBIT_BATCH_L4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DebitBatch.UNRECOGNIZED;
  }
}

export function debitBatchToJSON(object: DebitBatch): string {
  switch (object) {
    case DebitBatch.DEBIT_BATCH_UNSPECIFIED:
      return "DEBIT_BATCH_UNSPECIFIED";
    case DebitBatch.DEBIT_BATCH_L1:
      return "DEBIT_BATCH_L1";
    case DebitBatch.DEBIT_BATCH_L2:
      return "DEBIT_BATCH_L2";
    case DebitBatch.DEBIT_BATCH_L3:
      return "DEBIT_BATCH_L3";
    case DebitBatch.DEBIT_BATCH_L4:
      return "DEBIT_BATCH_L4";
    case DebitBatch.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Mode de calcul de la date de prélèvement */
export enum DebitDateMode {
  DEBIT_DATE_MODE_UNSPECIFIED = 0,
  /** DEBIT_DATE_MODE_BATCH - Utilise le lot L1-L4 (premier jour ouvré du lot) */
  DEBIT_DATE_MODE_BATCH = 1,
  /** DEBIT_DATE_MODE_FIXED_DAY - Utilise un jour fixe du mois (ex: le 5) */
  DEBIT_DATE_MODE_FIXED_DAY = 2,
  UNRECOGNIZED = -1,
}

export function debitDateModeFromJSON(object: any): DebitDateMode {
  switch (object) {
    case 0:
    case "DEBIT_DATE_MODE_UNSPECIFIED":
      return DebitDateMode.DEBIT_DATE_MODE_UNSPECIFIED;
    case 1:
    case "DEBIT_DATE_MODE_BATCH":
      return DebitDateMode.DEBIT_DATE_MODE_BATCH;
    case 2:
    case "DEBIT_DATE_MODE_FIXED_DAY":
      return DebitDateMode.DEBIT_DATE_MODE_FIXED_DAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DebitDateMode.UNRECOGNIZED;
  }
}

export function debitDateModeToJSON(object: DebitDateMode): string {
  switch (object) {
    case DebitDateMode.DEBIT_DATE_MODE_UNSPECIFIED:
      return "DEBIT_DATE_MODE_UNSPECIFIED";
    case DebitDateMode.DEBIT_DATE_MODE_BATCH:
      return "DEBIT_DATE_MODE_BATCH";
    case DebitDateMode.DEBIT_DATE_MODE_FIXED_DAY:
      return "DEBIT_DATE_MODE_FIXED_DAY";
    case DebitDateMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Stratégie de report si date non éligible (weekend/férié) */
export enum DateShiftStrategy {
  DATE_SHIFT_STRATEGY_UNSPECIFIED = 0,
  /** DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY - Reporter au prochain jour ouvré */
  DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY = 1,
  /** DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY - Anticiper au jour ouvré précédent */
  DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY = 2,
  /** DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY - Reporter à la semaine suivante, même jour */
  DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY = 3,
  UNRECOGNIZED = -1,
}

export function dateShiftStrategyFromJSON(object: any): DateShiftStrategy {
  switch (object) {
    case 0:
    case "DATE_SHIFT_STRATEGY_UNSPECIFIED":
      return DateShiftStrategy.DATE_SHIFT_STRATEGY_UNSPECIFIED;
    case 1:
    case "DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY":
      return DateShiftStrategy.DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY;
    case 2:
    case "DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY":
      return DateShiftStrategy.DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY;
    case 3:
    case "DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY":
      return DateShiftStrategy.DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DateShiftStrategy.UNRECOGNIZED;
  }
}

export function dateShiftStrategyToJSON(object: DateShiftStrategy): string {
  switch (object) {
    case DateShiftStrategy.DATE_SHIFT_STRATEGY_UNSPECIFIED:
      return "DATE_SHIFT_STRATEGY_UNSPECIFIED";
    case DateShiftStrategy.DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY:
      return "DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY";
    case DateShiftStrategy.DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY:
      return "DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY";
    case DateShiftStrategy.DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY:
      return "DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY";
    case DateShiftStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Niveau de configuration (pour la priorité) */
export enum ConfigurationLevel {
  CONFIGURATION_LEVEL_UNSPECIFIED = 0,
  /** CONFIGURATION_LEVEL_SYSTEM_DEFAULT - Priorité la plus basse */
  CONFIGURATION_LEVEL_SYSTEM_DEFAULT = 1,
  /** CONFIGURATION_LEVEL_COMPANY - Niveau société */
  CONFIGURATION_LEVEL_COMPANY = 2,
  /** CONFIGURATION_LEVEL_CLIENT - Niveau client */
  CONFIGURATION_LEVEL_CLIENT = 3,
  /** CONFIGURATION_LEVEL_CONTRACT - Priorité la plus haute */
  CONFIGURATION_LEVEL_CONTRACT = 4,
  UNRECOGNIZED = -1,
}

export function configurationLevelFromJSON(object: any): ConfigurationLevel {
  switch (object) {
    case 0:
    case "CONFIGURATION_LEVEL_UNSPECIFIED":
      return ConfigurationLevel.CONFIGURATION_LEVEL_UNSPECIFIED;
    case 1:
    case "CONFIGURATION_LEVEL_SYSTEM_DEFAULT":
      return ConfigurationLevel.CONFIGURATION_LEVEL_SYSTEM_DEFAULT;
    case 2:
    case "CONFIGURATION_LEVEL_COMPANY":
      return ConfigurationLevel.CONFIGURATION_LEVEL_COMPANY;
    case 3:
    case "CONFIGURATION_LEVEL_CLIENT":
      return ConfigurationLevel.CONFIGURATION_LEVEL_CLIENT;
    case 4:
    case "CONFIGURATION_LEVEL_CONTRACT":
      return ConfigurationLevel.CONFIGURATION_LEVEL_CONTRACT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConfigurationLevel.UNRECOGNIZED;
  }
}

export function configurationLevelToJSON(object: ConfigurationLevel): string {
  switch (object) {
    case ConfigurationLevel.CONFIGURATION_LEVEL_UNSPECIFIED:
      return "CONFIGURATION_LEVEL_UNSPECIFIED";
    case ConfigurationLevel.CONFIGURATION_LEVEL_SYSTEM_DEFAULT:
      return "CONFIGURATION_LEVEL_SYSTEM_DEFAULT";
    case ConfigurationLevel.CONFIGURATION_LEVEL_COMPANY:
      return "CONFIGURATION_LEVEL_COMPANY";
    case ConfigurationLevel.CONFIGURATION_LEVEL_CLIENT:
      return "CONFIGURATION_LEVEL_CLIENT";
    case ConfigurationLevel.CONFIGURATION_LEVEL_CONTRACT:
      return "CONFIGURATION_LEVEL_CONTRACT";
    case ConfigurationLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Statut d'une date planifiée */
export enum PlannedDateStatus {
  PLANNED_DATE_STATUS_UNSPECIFIED = 0,
  /** PLANNED_DATE_STATUS_PLANNED - Date calculée, en attente */
  PLANNED_DATE_STATUS_PLANNED = 1,
  /** PLANNED_DATE_STATUS_CONFIRMED - Date confirmée pour émission */
  PLANNED_DATE_STATUS_CONFIRMED = 2,
  /** PLANNED_DATE_STATUS_PROCESSING - En cours de traitement */
  PLANNED_DATE_STATUS_PROCESSING = 3,
  /** PLANNED_DATE_STATUS_EXECUTED - Prélèvement exécuté */
  PLANNED_DATE_STATUS_EXECUTED = 4,
  /** PLANNED_DATE_STATUS_FAILED - Échec du prélèvement */
  PLANNED_DATE_STATUS_FAILED = 5,
  /** PLANNED_DATE_STATUS_CANCELLED - Annulé */
  PLANNED_DATE_STATUS_CANCELLED = 6,
  UNRECOGNIZED = -1,
}

export function plannedDateStatusFromJSON(object: any): PlannedDateStatus {
  switch (object) {
    case 0:
    case "PLANNED_DATE_STATUS_UNSPECIFIED":
      return PlannedDateStatus.PLANNED_DATE_STATUS_UNSPECIFIED;
    case 1:
    case "PLANNED_DATE_STATUS_PLANNED":
      return PlannedDateStatus.PLANNED_DATE_STATUS_PLANNED;
    case 2:
    case "PLANNED_DATE_STATUS_CONFIRMED":
      return PlannedDateStatus.PLANNED_DATE_STATUS_CONFIRMED;
    case 3:
    case "PLANNED_DATE_STATUS_PROCESSING":
      return PlannedDateStatus.PLANNED_DATE_STATUS_PROCESSING;
    case 4:
    case "PLANNED_DATE_STATUS_EXECUTED":
      return PlannedDateStatus.PLANNED_DATE_STATUS_EXECUTED;
    case 5:
    case "PLANNED_DATE_STATUS_FAILED":
      return PlannedDateStatus.PLANNED_DATE_STATUS_FAILED;
    case 6:
    case "PLANNED_DATE_STATUS_CANCELLED":
      return PlannedDateStatus.PLANNED_DATE_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PlannedDateStatus.UNRECOGNIZED;
  }
}

export function plannedDateStatusToJSON(object: PlannedDateStatus): string {
  switch (object) {
    case PlannedDateStatus.PLANNED_DATE_STATUS_UNSPECIFIED:
      return "PLANNED_DATE_STATUS_UNSPECIFIED";
    case PlannedDateStatus.PLANNED_DATE_STATUS_PLANNED:
      return "PLANNED_DATE_STATUS_PLANNED";
    case PlannedDateStatus.PLANNED_DATE_STATUS_CONFIRMED:
      return "PLANNED_DATE_STATUS_CONFIRMED";
    case PlannedDateStatus.PLANNED_DATE_STATUS_PROCESSING:
      return "PLANNED_DATE_STATUS_PROCESSING";
    case PlannedDateStatus.PLANNED_DATE_STATUS_EXECUTED:
      return "PLANNED_DATE_STATUS_EXECUTED";
    case PlannedDateStatus.PLANNED_DATE_STATUS_FAILED:
      return "PLANNED_DATE_STATUS_FAILED";
    case PlannedDateStatus.PLANNED_DATE_STATUS_CANCELLED:
      return "PLANNED_DATE_STATUS_CANCELLED";
    case PlannedDateStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type de jour férié */
export enum HolidayType {
  HOLIDAY_TYPE_UNSPECIFIED = 0,
  /** HOLIDAY_TYPE_PUBLIC - Jour férié légal */
  HOLIDAY_TYPE_PUBLIC = 1,
  /** HOLIDAY_TYPE_BANK - Jour de fermeture bancaire */
  HOLIDAY_TYPE_BANK = 2,
  /** HOLIDAY_TYPE_REGIONAL - Jour férié régional */
  HOLIDAY_TYPE_REGIONAL = 3,
  /** HOLIDAY_TYPE_COMPANY - Jour de fermeture société */
  HOLIDAY_TYPE_COMPANY = 4,
  UNRECOGNIZED = -1,
}

export function holidayTypeFromJSON(object: any): HolidayType {
  switch (object) {
    case 0:
    case "HOLIDAY_TYPE_UNSPECIFIED":
      return HolidayType.HOLIDAY_TYPE_UNSPECIFIED;
    case 1:
    case "HOLIDAY_TYPE_PUBLIC":
      return HolidayType.HOLIDAY_TYPE_PUBLIC;
    case 2:
    case "HOLIDAY_TYPE_BANK":
      return HolidayType.HOLIDAY_TYPE_BANK;
    case 3:
    case "HOLIDAY_TYPE_REGIONAL":
      return HolidayType.HOLIDAY_TYPE_REGIONAL;
    case 4:
    case "HOLIDAY_TYPE_COMPANY":
      return HolidayType.HOLIDAY_TYPE_COMPANY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HolidayType.UNRECOGNIZED;
  }
}

export function holidayTypeToJSON(object: HolidayType): string {
  switch (object) {
    case HolidayType.HOLIDAY_TYPE_UNSPECIFIED:
      return "HOLIDAY_TYPE_UNSPECIFIED";
    case HolidayType.HOLIDAY_TYPE_PUBLIC:
      return "HOLIDAY_TYPE_PUBLIC";
    case HolidayType.HOLIDAY_TYPE_BANK:
      return "HOLIDAY_TYPE_BANK";
    case HolidayType.HOLIDAY_TYPE_REGIONAL:
      return "HOLIDAY_TYPE_REGIONAL";
    case HolidayType.HOLIDAY_TYPE_COMPANY:
      return "HOLIDAY_TYPE_COMPANY";
    case HolidayType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Source de modification pour audit */
export enum AuditSource {
  AUDIT_SOURCE_UNSPECIFIED = 0,
  /** AUDIT_SOURCE_UI - Interface admin */
  AUDIT_SOURCE_UI = 1,
  /** AUDIT_SOURCE_CSV_IMPORT - Import CSV */
  AUDIT_SOURCE_CSV_IMPORT = 2,
  /** AUDIT_SOURCE_API - Appel API */
  AUDIT_SOURCE_API = 3,
  /** AUDIT_SOURCE_SYSTEM - Calcul automatique système */
  AUDIT_SOURCE_SYSTEM = 4,
  UNRECOGNIZED = -1,
}

export function auditSourceFromJSON(object: any): AuditSource {
  switch (object) {
    case 0:
    case "AUDIT_SOURCE_UNSPECIFIED":
      return AuditSource.AUDIT_SOURCE_UNSPECIFIED;
    case 1:
    case "AUDIT_SOURCE_UI":
      return AuditSource.AUDIT_SOURCE_UI;
    case 2:
    case "AUDIT_SOURCE_CSV_IMPORT":
      return AuditSource.AUDIT_SOURCE_CSV_IMPORT;
    case 3:
    case "AUDIT_SOURCE_API":
      return AuditSource.AUDIT_SOURCE_API;
    case 4:
    case "AUDIT_SOURCE_SYSTEM":
      return AuditSource.AUDIT_SOURCE_SYSTEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuditSource.UNRECOGNIZED;
  }
}

export function auditSourceToJSON(object: AuditSource): string {
  switch (object) {
    case AuditSource.AUDIT_SOURCE_UNSPECIFIED:
      return "AUDIT_SOURCE_UNSPECIFIED";
    case AuditSource.AUDIT_SOURCE_UI:
      return "AUDIT_SOURCE_UI";
    case AuditSource.AUDIT_SOURCE_CSV_IMPORT:
      return "AUDIT_SOURCE_CSV_IMPORT";
    case AuditSource.AUDIT_SOURCE_API:
      return "AUDIT_SOURCE_API";
    case AuditSource.AUDIT_SOURCE_SYSTEM:
      return "AUDIT_SOURCE_SYSTEM";
    case AuditSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration des jours fériés par zone/pays */
export interface HolidayZone {
  id: string;
  organisationId: string;
  /** Ex: "FR", "FR-ALS" (Alsace), "DE", "BE" */
  code: string;
  /** Ex: "France", "Alsace-Moselle" */
  name: string;
  /** ISO 3166-1 alpha-2: "FR", "DE", "BE" */
  countryCode: string;
  /** Code région optionnel (ex: "ALS", "IDF") */
  regionCode: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Jour férié individuel */
export interface Holiday {
  id: string;
  holidayZoneId: string;
  /** Format ISO: "2026-01-01" */
  date: string;
  /** Ex: "Jour de l'An", "Lundi de Pâques" */
  name: string;
  holidayType: HolidayType;
  /** True si récurrent chaque année (même jour/mois) */
  isRecurring: boolean;
  /** 1-12 si récurrent */
  recurringMonth: number;
  /** 1-31 si récurrent */
  recurringDay: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration du cutoff horaire */
export interface CutoffConfiguration {
  id: string;
  organisationId: string;
  /** Ex: "Cutoff SEPA Standard" */
  name: string;
  /** Format HH:mm en timezone locale, ex: "14:00" */
  cutoffTime: string;
  /** Ex: "Europe/Paris" */
  timezone: string;
  /** J-X avant la date de valeur (ex: 2 pour SEPA) */
  daysBeforeValueDate: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot par défaut système */
export interface SystemDebitConfiguration {
  id: string;
  organisationId: string;
  defaultMode: DebitDateMode;
  /** Si mode = BATCH */
  defaultBatch: DebitBatch;
  /** Si mode = FIXED_DAY (1-28) */
  defaultFixedDay: number;
  shiftStrategy: DateShiftStrategy;
  /** Zone de jours fériés par défaut */
  holidayZoneId: string;
  /** Configuration cutoff par défaut */
  cutoffConfigId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau société */
export interface CompanyDebitConfiguration {
  id: string;
  organisationId: string;
  societeId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau client */
export interface ClientDebitConfiguration {
  id: string;
  organisationId: string;
  clientId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau contrat (priorité maximale) */
export interface ContractDebitConfiguration {
  id: string;
  organisationId: string;
  contratId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration résolue (après application de la priorité) */
export interface ResolvedDebitConfiguration {
  /** Niveau qui a été appliqué */
  appliedLevel: ConfigurationLevel;
  /** ID de la config appliquée */
  appliedConfigId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

/** Entrée pour le calcul de date de prélèvement */
export interface CalculatePlannedDateRequest {
  organisationId: string;
  /** Optionnel - si fourni, utilise config contrat */
  contratId: string;
  /** Optionnel - si fourni, utilise config client */
  clientId: string;
  /** Optionnel - si fourni, utilise config société */
  societeId: string;
  /** Date de référence pour le calcul (ISO format) */
  referenceDate: string;
  /** Mois cible (1-12) */
  targetMonth: number;
  /** Année cible */
  targetYear: number;
  /** Inclure le détail de la résolution */
  includeResolutionTrace: boolean;
}

/** Résultat du calcul de date de prélèvement */
export interface CalculatePlannedDateResponse {
  /** Date calculée (ISO format) */
  plannedDebitDate: string;
  /** Date cible avant ajustement */
  originalTargetDate: string;
  /** True si la date a été décalée */
  wasShifted: boolean;
  /** Raison du décalage (weekend, férié, etc.) */
  shiftReason: string;
  resolvedConfig:
    | ResolvedDebitConfiguration
    | undefined;
  /** Trace de résolution si demandée */
  resolutionTrace: DateResolutionStep[];
}

/** Étape de résolution de date (pour debug/audit) */
export interface DateResolutionStep {
  stepOrder: number;
  description: string;
  inputDate: string;
  outputDate: string;
  appliedRule: string;
}

/** Calcul en lot pour plusieurs entités */
export interface CalculatePlannedDatesBatchRequest {
  organisationId: string;
  inputs: PlannedDateCalculationInput[];
  targetMonth: number;
  targetYear: number;
}

export interface PlannedDateCalculationInput {
  contratId: string;
  clientId: string;
  societeId: string;
  /** Montant en centimes */
  amountCents: number;
  currency: string;
}

export interface CalculatePlannedDatesBatchResponse {
  results: PlannedDateCalculationResult[];
  totalCount: number;
  successCount: number;
  errorCount: number;
}

export interface PlannedDateCalculationResult {
  contratId: string;
  success: boolean;
  plannedDebitDate: string;
  errorCode: string;
  errorMessage: string;
  resolvedConfig: ResolvedDebitConfiguration | undefined;
}

/** Vérification d'éligibilité d'une date */
export interface CheckDateEligibilityRequest {
  organisationId: string;
  /** Date à vérifier (ISO format) */
  date: string;
  /** Zone de jours fériés */
  holidayZoneId: string;
}

export interface CheckDateEligibilityResponse {
  isEligible: boolean;
  isWeekend: boolean;
  isHoliday: boolean;
  /** Nom du jour férié si applicable */
  holidayName: string;
  /** Prochaine date éligible */
  nextEligibleDate: string;
  /** Date éligible précédente */
  previousEligibleDate: string;
}

/** Prélèvement planifié */
export interface PlannedDebit {
  id: string;
  organisationId: string;
  societeId: string;
  clientId: string;
  contratId: string;
  /** Référence vers payment.Schedule */
  scheduleId: string;
  /** Référence vers facture si applicable */
  factureId: string;
  /** Date de prélèvement planifiée */
  plannedDebitDate: string;
  /** Date cible avant ajustement */
  originalTargetDate: string;
  status: PlannedDateStatus;
  /** Lot assigné */
  batch: DebitBatch;
  /** Montant en centimes */
  amountCents: number;
  currency: string;
  resolvedConfig: ResolvedDebitConfiguration | undefined;
  createdAt: string;
  updatedAt: string;
}

/** Volume agrégé par date/lot */
export interface DebitVolumeAggregate {
  /** Date (ISO format) */
  date: string;
  batch: DebitBatch;
  /** Optionnel, si agrégation par société */
  societeId: string;
  transactionCount: number;
  totalAmountCents: number;
  currency: string;
}

/** Prévision de volume (pour la heatmap) */
export interface VolumeForecast {
  id: string;
  organisationId: string;
  societeId: string;
  year: number;
  month: number;
  day: number;
  batch: DebitBatch;
  expectedTransactionCount: number;
  expectedAmountCents: number;
  currency: string;
  /** Rempli après exécution */
  actualTransactionCount: number;
  actualAmountCents: number;
  createdAt: string;
  updatedAt: string;
}

/** Seuil d'alerte pour les volumes */
export interface VolumeThreshold {
  id: string;
  organisationId: string;
  /** Optionnel */
  societeId: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Requête d'import CSV (dry-run obligatoire) */
export interface ImportCsvRequest {
  organisationId: string;
  /** Contenu du fichier CSV */
  csvContent: Uint8Array;
  /** "DEBIT_CONFIG", "HOLIDAYS", "VOLUME_FORECAST" */
  importType: string;
  /** OBLIGATOIRE: true pour prévisualisation */
  dryRun: boolean;
  uploadedByUserId: string;
}

export interface ImportCsvResponse {
  importId: string;
  success: boolean;
  isDryRun: boolean;
  totalRows: number;
  validRows: number;
  errorRows: number;
  errors: CsvValidationError[];
  /** Aperçu des changements */
  preview: CsvImportPreview[];
}

export interface CsvValidationError {
  rowNumber: number;
  columnName: string;
  value: string;
  errorCode: string;
  errorMessage: string;
}

export interface CsvImportPreview {
  rowNumber: number;
  /** "CREATE", "UPDATE", "SKIP" */
  action: string;
  entityType: string;
  /** Existant si UPDATE */
  entityId: string;
  /** Données à importer */
  data: { [key: string]: string };
  /** Résumé des changements */
  changeSummary: string;
}

export interface CsvImportPreview_DataEntry {
  key: string;
  value: string;
}

/** Confirmation d'import (après dry-run) */
export interface ConfirmCsvImportRequest {
  importId: string;
  organisationId: string;
  confirmedByUserId: string;
}

export interface ConfirmCsvImportResponse {
  success: boolean;
  createdCount: number;
  updatedCount: number;
  skippedCount: number;
  auditLogId: string;
}

/** Entrée de log d'audit */
export interface CalendarAuditLog {
  id: string;
  organisationId: string;
  /** Type d'entité modifiée */
  entityType: string;
  /** ID de l'entité modifiée */
  entityId: string;
  /** "CREATE", "UPDATE", "DELETE" */
  action: string;
  /** Utilisateur ayant effectué l'action */
  actorUserId: string;
  /** Source de la modification */
  source: AuditSource;
  /** État avant (JSON) */
  beforeState: string;
  /** État après (JSON) */
  afterState: string;
  /** Résumé lisible des changements */
  changeSummary: string;
  ipAddress: string;
  userAgent: string;
  createdAt: string;
}

/** Requête de calendrier avec filtres */
export interface GetCalendarViewRequest {
  organisationId: string;
  /** Date début (ISO format) */
  startDate: string;
  /** Date fin (ISO format) */
  endDate: string;
  /** Filtrer par sociétés */
  societeIds: string[];
  /** Filtrer par lots */
  batches: DebitBatch[];
  /** Filtrer par statut */
  statuses: PlannedDateStatus[];
  /** Inclure les volumes agrégés */
  includeVolumes: boolean;
}

export interface GetCalendarViewResponse {
  days: CalendarDay[];
  volumes: DebitVolumeAggregate[];
}

export interface CalendarDay {
  date: string;
  isWeekend: boolean;
  isHoliday: boolean;
  holidayName: string;
  isEligible: boolean;
  debits: PlannedDebitSummary[];
}

export interface PlannedDebitSummary {
  id: string;
  contratId: string;
  clientName: string;
  amountCents: number;
  currency: string;
  status: PlannedDateStatus;
  batch: DebitBatch;
}

/** Requête drill-down (détail d'une date) */
export interface GetDateDetailsRequest {
  organisationId: string;
  date: string;
  societeId: string;
  batch: DebitBatch;
  pagination: Pagination | undefined;
}

export interface GetDateDetailsResponse {
  debits: PlannedDebit[];
  pagination: PaginationResult | undefined;
  aggregate: DebitVolumeAggregate | undefined;
}

/** Requête heatmap */
export interface GetVolumeHeatmapRequest {
  organisationId: string;
  year: number;
  /** Optionnel, si non fourni: année entière */
  month: number;
  societeIds: string[];
  batches: DebitBatch[];
  includeForecast: boolean;
}

export interface GetVolumeHeatmapResponse {
  cells: HeatmapCell[];
  exceededThresholds: VolumeThreshold[];
}

export interface HeatmapCell {
  date: string;
  /** 0=Lundi, 6=Dimanche */
  dayOfWeek: number;
  weekOfMonth: number;
  transactionCount: number;
  totalAmountCents: number;
  currency: string;
  /** "LOW", "MEDIUM", "HIGH", "CRITICAL" */
  intensityLevel: string;
  exceedsThreshold: boolean;
  /** Prévision si demandée */
  forecast: VolumeForecast | undefined;
}

/** Export CSV */
export interface ExportCalendarCsvRequest {
  organisationId: string;
  startDate: string;
  endDate: string;
  societeIds: string[];
  batches: DebitBatch[];
  /** "PLANNED_DEBITS", "VOLUMES", "HEATMAP" */
  exportType: string;
}

export interface ExportCalendarCsvResponse {
  csvContent: Uint8Array;
  filename: string;
  rowCount: number;
}

export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

/** System Config */
export interface GetSystemConfigRequest {
  organisationId: string;
}

export interface UpdateSystemConfigRequest {
  organisationId: string;
  defaultMode: DebitDateMode;
  defaultBatch: DebitBatch;
  defaultFixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

/** Company Config */
export interface CreateCompanyConfigRequest {
  organisationId: string;
  societeId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

export interface UpdateCompanyConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
  isActive: boolean;
}

export interface GetCompanyConfigRequest {
  id: string;
}

export interface ListCompanyConfigsRequest {
  organisationId: string;
  societeId: string;
  pagination: Pagination | undefined;
}

export interface ListCompanyConfigsResponse {
  configs: CompanyDebitConfiguration[];
  pagination: PaginationResult | undefined;
}

export interface DeleteCompanyConfigRequest {
  id: string;
}

/** Client Config */
export interface CreateClientConfigRequest {
  organisationId: string;
  clientId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
}

export interface UpdateClientConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
}

export interface GetClientConfigRequest {
  id: string;
}

export interface ListClientConfigsRequest {
  organisationId: string;
  clientId: string;
  pagination: Pagination | undefined;
}

export interface ListClientConfigsResponse {
  configs: ClientDebitConfiguration[];
  pagination: PaginationResult | undefined;
}

export interface DeleteClientConfigRequest {
  id: string;
}

/** Contract Config */
export interface CreateContractConfigRequest {
  organisationId: string;
  contratId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
}

export interface UpdateContractConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
}

export interface GetContractConfigRequest {
  id: string;
}

export interface ListContractConfigsRequest {
  organisationId: string;
  contratId: string;
  pagination: Pagination | undefined;
}

export interface ListContractConfigsResponse {
  configs: ContractDebitConfiguration[];
  pagination: PaginationResult | undefined;
}

export interface DeleteContractConfigRequest {
  id: string;
}

/** Resolve Configuration */
export interface ResolveConfigurationRequest {
  organisationId: string;
  contratId: string;
  clientId: string;
  societeId: string;
}

/** Holiday Zone CRUD */
export interface CreateHolidayZoneRequest {
  organisationId: string;
  code: string;
  name: string;
  countryCode: string;
  regionCode: string;
}

export interface UpdateHolidayZoneRequest {
  id: string;
  code: string;
  name: string;
  countryCode: string;
  regionCode: string;
  isActive: boolean;
}

export interface GetHolidayZoneRequest {
  id: string;
}

export interface ListHolidayZonesRequest {
  organisationId: string;
  countryCode: string;
  pagination: Pagination | undefined;
}

export interface ListHolidayZonesResponse {
  zones: HolidayZone[];
  pagination: PaginationResult | undefined;
}

export interface DeleteHolidayZoneRequest {
  id: string;
}

/** Holiday CRUD */
export interface CreateHolidayRequest {
  holidayZoneId: string;
  date: string;
  name: string;
  holidayType: HolidayType;
  isRecurring: boolean;
  recurringMonth: number;
  recurringDay: number;
}

export interface UpdateHolidayRequest {
  id: string;
  date: string;
  name: string;
  holidayType: HolidayType;
  isRecurring: boolean;
  recurringMonth: number;
  recurringDay: number;
  isActive: boolean;
}

export interface GetHolidayRequest {
  id: string;
}

export interface ListHolidaysRequest {
  holidayZoneId: string;
  year: number;
  pagination: Pagination | undefined;
}

export interface ListHolidaysResponse {
  holidays: Holiday[];
  pagination: PaginationResult | undefined;
}

export interface DeleteHolidayRequest {
  id: string;
}

export interface ImportHolidaysByCountryRequest {
  organisationId: string;
  countryCode: string;
  year: number;
  includeRegional: boolean;
}

export interface ImportHolidaysByCountryResponse {
  success: boolean;
  importedCount: number;
  holidayZoneId: string;
}

/** Volume Threshold CRUD */
export interface CreateVolumeThresholdRequest {
  organisationId: string;
  societeId: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
}

export interface UpdateVolumeThresholdRequest {
  id: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
  isActive: boolean;
}

export interface GetVolumeThresholdRequest {
  id: string;
}

export interface ListVolumeThresholdsRequest {
  organisationId: string;
  societeId: string;
  pagination: Pagination | undefined;
}

export interface ListVolumeThresholdsResponse {
  thresholds: VolumeThreshold[];
  pagination: PaginationResult | undefined;
}

export interface DeleteVolumeThresholdRequest {
  id: string;
}

/** Audit */
export interface GetAuditLogsRequest {
  organisationId: string;
  entityType: string;
  entityId: string;
  actorUserId: string;
  source: AuditSource;
  startDate: string;
  endDate: string;
  pagination: Pagination | undefined;
}

export interface GetAuditLogsResponse {
  logs: CalendarAuditLog[];
  pagination: PaginationResult | undefined;
}

function createBaseHolidayZone(): HolidayZone {
  return {
    id: "",
    organisationId: "",
    code: "",
    name: "",
    countryCode: "",
    regionCode: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const HolidayZone: MessageFns<HolidayZone> = {
  encode(message: HolidayZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(42).string(message.countryCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(50).string(message.regionCode);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HolidayZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHolidayZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HolidayZone {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      countryCode: isSet(object.countryCode)
        ? globalThis.String(object.countryCode)
        : isSet(object.country_code)
        ? globalThis.String(object.country_code)
        : "",
      regionCode: isSet(object.regionCode)
        ? globalThis.String(object.regionCode)
        : isSet(object.region_code)
        ? globalThis.String(object.region_code)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: HolidayZone): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HolidayZone>, I>>(base?: I): HolidayZone {
    return HolidayZone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HolidayZone>, I>>(object: I): HolidayZone {
    const message = createBaseHolidayZone();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    message.countryCode = object.countryCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseHoliday(): Holiday {
  return {
    id: "",
    holidayZoneId: "",
    date: "",
    name: "",
    holidayType: 0,
    isRecurring: false,
    recurringMonth: 0,
    recurringDay: 0,
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Holiday: MessageFns<Holiday> = {
  encode(message: Holiday, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(18).string(message.holidayZoneId);
    }
    if (message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.holidayType !== 0) {
      writer.uint32(40).int32(message.holidayType);
    }
    if (message.isRecurring !== false) {
      writer.uint32(48).bool(message.isRecurring);
    }
    if (message.recurringMonth !== 0) {
      writer.uint32(56).int32(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      writer.uint32(64).int32(message.recurringDay);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Holiday {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHoliday();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.holidayType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isRecurring = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recurringMonth = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.recurringDay = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Holiday {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      holidayType: isSet(object.holidayType)
        ? holidayTypeFromJSON(object.holidayType)
        : isSet(object.holiday_type)
        ? holidayTypeFromJSON(object.holiday_type)
        : 0,
      isRecurring: isSet(object.isRecurring)
        ? globalThis.Boolean(object.isRecurring)
        : isSet(object.is_recurring)
        ? globalThis.Boolean(object.is_recurring)
        : false,
      recurringMonth: isSet(object.recurringMonth)
        ? globalThis.Number(object.recurringMonth)
        : isSet(object.recurring_month)
        ? globalThis.Number(object.recurring_month)
        : 0,
      recurringDay: isSet(object.recurringDay)
        ? globalThis.Number(object.recurringDay)
        : isSet(object.recurring_day)
        ? globalThis.Number(object.recurring_day)
        : 0,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: Holiday): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.holidayType !== 0) {
      obj.holidayType = holidayTypeToJSON(message.holidayType);
    }
    if (message.isRecurring !== false) {
      obj.isRecurring = message.isRecurring;
    }
    if (message.recurringMonth !== 0) {
      obj.recurringMonth = Math.round(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      obj.recurringDay = Math.round(message.recurringDay);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Holiday>, I>>(base?: I): Holiday {
    return Holiday.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Holiday>, I>>(object: I): Holiday {
    const message = createBaseHoliday();
    message.id = object.id ?? "";
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.date = object.date ?? "";
    message.name = object.name ?? "";
    message.holidayType = object.holidayType ?? 0;
    message.isRecurring = object.isRecurring ?? false;
    message.recurringMonth = object.recurringMonth ?? 0;
    message.recurringDay = object.recurringDay ?? 0;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCutoffConfiguration(): CutoffConfiguration {
  return {
    id: "",
    organisationId: "",
    name: "",
    cutoffTime: "",
    timezone: "",
    daysBeforeValueDate: 0,
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const CutoffConfiguration: MessageFns<CutoffConfiguration> = {
  encode(message: CutoffConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(34).string(message.cutoffTime);
    }
    if (message.timezone !== "") {
      writer.uint32(42).string(message.timezone);
    }
    if (message.daysBeforeValueDate !== 0) {
      writer.uint32(48).int32(message.daysBeforeValueDate);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CutoffConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCutoffConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.daysBeforeValueDate = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CutoffConfiguration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cutoffTime: isSet(object.cutoffTime)
        ? globalThis.String(object.cutoffTime)
        : isSet(object.cutoff_time)
        ? globalThis.String(object.cutoff_time)
        : "",
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
      daysBeforeValueDate: isSet(object.daysBeforeValueDate)
        ? globalThis.Number(object.daysBeforeValueDate)
        : isSet(object.days_before_value_date)
        ? globalThis.Number(object.days_before_value_date)
        : 0,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: CutoffConfiguration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cutoffTime !== "") {
      obj.cutoffTime = message.cutoffTime;
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    if (message.daysBeforeValueDate !== 0) {
      obj.daysBeforeValueDate = Math.round(message.daysBeforeValueDate);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CutoffConfiguration>, I>>(base?: I): CutoffConfiguration {
    return CutoffConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CutoffConfiguration>, I>>(object: I): CutoffConfiguration {
    const message = createBaseCutoffConfiguration();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.name = object.name ?? "";
    message.cutoffTime = object.cutoffTime ?? "";
    message.timezone = object.timezone ?? "";
    message.daysBeforeValueDate = object.daysBeforeValueDate ?? 0;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSystemDebitConfiguration(): SystemDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    defaultMode: 0,
    defaultBatch: 0,
    defaultFixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const SystemDebitConfiguration: MessageFns<SystemDebitConfiguration> = {
  encode(message: SystemDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.defaultMode !== 0) {
      writer.uint32(24).int32(message.defaultMode);
    }
    if (message.defaultBatch !== 0) {
      writer.uint32(32).int32(message.defaultBatch);
    }
    if (message.defaultFixedDay !== 0) {
      writer.uint32(40).int32(message.defaultFixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(66).string(message.cutoffConfigId);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.defaultMode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.defaultBatch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.defaultFixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemDebitConfiguration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      defaultMode: isSet(object.defaultMode)
        ? debitDateModeFromJSON(object.defaultMode)
        : isSet(object.default_mode)
        ? debitDateModeFromJSON(object.default_mode)
        : 0,
      defaultBatch: isSet(object.defaultBatch)
        ? debitBatchFromJSON(object.defaultBatch)
        : isSet(object.default_batch)
        ? debitBatchFromJSON(object.default_batch)
        : 0,
      defaultFixedDay: isSet(object.defaultFixedDay)
        ? globalThis.Number(object.defaultFixedDay)
        : isSet(object.default_fixed_day)
        ? globalThis.Number(object.default_fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      cutoffConfigId: isSet(object.cutoffConfigId)
        ? globalThis.String(object.cutoffConfigId)
        : isSet(object.cutoff_config_id)
        ? globalThis.String(object.cutoff_config_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: SystemDebitConfiguration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.defaultMode !== 0) {
      obj.defaultMode = debitDateModeToJSON(message.defaultMode);
    }
    if (message.defaultBatch !== 0) {
      obj.defaultBatch = debitBatchToJSON(message.defaultBatch);
    }
    if (message.defaultFixedDay !== 0) {
      obj.defaultFixedDay = Math.round(message.defaultFixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.cutoffConfigId !== "") {
      obj.cutoffConfigId = message.cutoffConfigId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemDebitConfiguration>, I>>(base?: I): SystemDebitConfiguration {
    return SystemDebitConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemDebitConfiguration>, I>>(object: I): SystemDebitConfiguration {
    const message = createBaseSystemDebitConfiguration();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.defaultMode = object.defaultMode ?? 0;
    message.defaultBatch = object.defaultBatch ?? 0;
    message.defaultFixedDay = object.defaultFixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.cutoffConfigId = object.cutoffConfigId ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCompanyDebitConfiguration(): CompanyDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const CompanyDebitConfiguration: MessageFns<CompanyDebitConfiguration> = {
  encode(message: CompanyDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(40).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(48).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(56).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(66).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(74).string(message.cutoffConfigId);
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(90).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(98).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyDebitConfiguration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      cutoffConfigId: isSet(object.cutoffConfigId)
        ? globalThis.String(object.cutoffConfigId)
        : isSet(object.cutoff_config_id)
        ? globalThis.String(object.cutoff_config_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: CompanyDebitConfiguration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.cutoffConfigId !== "") {
      obj.cutoffConfigId = message.cutoffConfigId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompanyDebitConfiguration>, I>>(base?: I): CompanyDebitConfiguration {
    return CompanyDebitConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompanyDebitConfiguration>, I>>(object: I): CompanyDebitConfiguration {
    const message = createBaseCompanyDebitConfiguration();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.cutoffConfigId = object.cutoffConfigId ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseClientDebitConfiguration(): ClientDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    clientId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const ClientDebitConfiguration: MessageFns<ClientDebitConfiguration> = {
  encode(message: ClientDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(40).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(48).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(56).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(66).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientDebitConfiguration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: ClientDebitConfiguration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientDebitConfiguration>, I>>(base?: I): ClientDebitConfiguration {
    return ClientDebitConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientDebitConfiguration>, I>>(object: I): ClientDebitConfiguration {
    const message = createBaseClientDebitConfiguration();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseContractDebitConfiguration(): ContractDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    contratId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const ContractDebitConfiguration: MessageFns<ContractDebitConfiguration> = {
  encode(message: ContractDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(26).string(message.contratId);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(40).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(48).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(56).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(66).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractDebitConfiguration {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: ContractDebitConfiguration): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContractDebitConfiguration>, I>>(base?: I): ContractDebitConfiguration {
    return ContractDebitConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContractDebitConfiguration>, I>>(object: I): ContractDebitConfiguration {
    const message = createBaseContractDebitConfiguration();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.contratId = object.contratId ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseResolvedDebitConfiguration(): ResolvedDebitConfiguration {
  return {
    appliedLevel: 0,
    appliedConfigId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
  };
}

export const ResolvedDebitConfiguration: MessageFns<ResolvedDebitConfiguration> = {
  encode(message: ResolvedDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appliedLevel !== 0) {
      writer.uint32(8).int32(message.appliedLevel);
    }
    if (message.appliedConfigId !== "") {
      writer.uint32(18).string(message.appliedConfigId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(66).string(message.cutoffConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolvedDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolvedDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appliedLevel = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appliedConfigId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolvedDebitConfiguration {
    return {
      appliedLevel: isSet(object.appliedLevel)
        ? configurationLevelFromJSON(object.appliedLevel)
        : isSet(object.applied_level)
        ? configurationLevelFromJSON(object.applied_level)
        : 0,
      appliedConfigId: isSet(object.appliedConfigId)
        ? globalThis.String(object.appliedConfigId)
        : isSet(object.applied_config_id)
        ? globalThis.String(object.applied_config_id)
        : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      cutoffConfigId: isSet(object.cutoffConfigId)
        ? globalThis.String(object.cutoffConfigId)
        : isSet(object.cutoff_config_id)
        ? globalThis.String(object.cutoff_config_id)
        : "",
    };
  },

  toJSON(message: ResolvedDebitConfiguration): unknown {
    const obj: any = {};
    if (message.appliedLevel !== 0) {
      obj.appliedLevel = configurationLevelToJSON(message.appliedLevel);
    }
    if (message.appliedConfigId !== "") {
      obj.appliedConfigId = message.appliedConfigId;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.cutoffConfigId !== "") {
      obj.cutoffConfigId = message.cutoffConfigId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResolvedDebitConfiguration>, I>>(base?: I): ResolvedDebitConfiguration {
    return ResolvedDebitConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResolvedDebitConfiguration>, I>>(object: I): ResolvedDebitConfiguration {
    const message = createBaseResolvedDebitConfiguration();
    message.appliedLevel = object.appliedLevel ?? 0;
    message.appliedConfigId = object.appliedConfigId ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.cutoffConfigId = object.cutoffConfigId ?? "";
    return message;
  },
};

function createBaseCalculatePlannedDateRequest(): CalculatePlannedDateRequest {
  return {
    organisationId: "",
    contratId: "",
    clientId: "",
    societeId: "",
    referenceDate: "",
    targetMonth: 0,
    targetYear: 0,
    includeResolutionTrace: false,
  };
}

export const CalculatePlannedDateRequest: MessageFns<CalculatePlannedDateRequest> = {
  encode(message: CalculatePlannedDateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(34).string(message.societeId);
    }
    if (message.referenceDate !== "") {
      writer.uint32(42).string(message.referenceDate);
    }
    if (message.targetMonth !== 0) {
      writer.uint32(48).int32(message.targetMonth);
    }
    if (message.targetYear !== 0) {
      writer.uint32(56).int32(message.targetYear);
    }
    if (message.includeResolutionTrace !== false) {
      writer.uint32(64).bool(message.includeResolutionTrace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referenceDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.targetMonth = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.targetYear = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.includeResolutionTrace = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculatePlannedDateRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      referenceDate: isSet(object.referenceDate)
        ? globalThis.String(object.referenceDate)
        : isSet(object.reference_date)
        ? globalThis.String(object.reference_date)
        : "",
      targetMonth: isSet(object.targetMonth)
        ? globalThis.Number(object.targetMonth)
        : isSet(object.target_month)
        ? globalThis.Number(object.target_month)
        : 0,
      targetYear: isSet(object.targetYear)
        ? globalThis.Number(object.targetYear)
        : isSet(object.target_year)
        ? globalThis.Number(object.target_year)
        : 0,
      includeResolutionTrace: isSet(object.includeResolutionTrace)
        ? globalThis.Boolean(object.includeResolutionTrace)
        : isSet(object.include_resolution_trace)
        ? globalThis.Boolean(object.include_resolution_trace)
        : false,
    };
  },

  toJSON(message: CalculatePlannedDateRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.referenceDate !== "") {
      obj.referenceDate = message.referenceDate;
    }
    if (message.targetMonth !== 0) {
      obj.targetMonth = Math.round(message.targetMonth);
    }
    if (message.targetYear !== 0) {
      obj.targetYear = Math.round(message.targetYear);
    }
    if (message.includeResolutionTrace !== false) {
      obj.includeResolutionTrace = message.includeResolutionTrace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalculatePlannedDateRequest>, I>>(base?: I): CalculatePlannedDateRequest {
    return CalculatePlannedDateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalculatePlannedDateRequest>, I>>(object: I): CalculatePlannedDateRequest {
    const message = createBaseCalculatePlannedDateRequest();
    message.organisationId = object.organisationId ?? "";
    message.contratId = object.contratId ?? "";
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.referenceDate = object.referenceDate ?? "";
    message.targetMonth = object.targetMonth ?? 0;
    message.targetYear = object.targetYear ?? 0;
    message.includeResolutionTrace = object.includeResolutionTrace ?? false;
    return message;
  },
};

function createBaseCalculatePlannedDateResponse(): CalculatePlannedDateResponse {
  return {
    plannedDebitDate: "",
    originalTargetDate: "",
    wasShifted: false,
    shiftReason: "",
    resolvedConfig: undefined,
    resolutionTrace: [],
  };
}

export const CalculatePlannedDateResponse: MessageFns<CalculatePlannedDateResponse> = {
  encode(message: CalculatePlannedDateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannedDebitDate !== "") {
      writer.uint32(10).string(message.plannedDebitDate);
    }
    if (message.originalTargetDate !== "") {
      writer.uint32(18).string(message.originalTargetDate);
    }
    if (message.wasShifted !== false) {
      writer.uint32(24).bool(message.wasShifted);
    }
    if (message.shiftReason !== "") {
      writer.uint32(34).string(message.shiftReason);
    }
    if (message.resolvedConfig !== undefined) {
      ResolvedDebitConfiguration.encode(message.resolvedConfig, writer.uint32(42).fork()).join();
    }
    for (const v of message.resolutionTrace) {
      DateResolutionStep.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plannedDebitDate = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originalTargetDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.wasShifted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shiftReason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resolvedConfig = ResolvedDebitConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resolutionTrace.push(DateResolutionStep.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculatePlannedDateResponse {
    return {
      plannedDebitDate: isSet(object.plannedDebitDate)
        ? globalThis.String(object.plannedDebitDate)
        : isSet(object.planned_debit_date)
        ? globalThis.String(object.planned_debit_date)
        : "",
      originalTargetDate: isSet(object.originalTargetDate)
        ? globalThis.String(object.originalTargetDate)
        : isSet(object.original_target_date)
        ? globalThis.String(object.original_target_date)
        : "",
      wasShifted: isSet(object.wasShifted)
        ? globalThis.Boolean(object.wasShifted)
        : isSet(object.was_shifted)
        ? globalThis.Boolean(object.was_shifted)
        : false,
      shiftReason: isSet(object.shiftReason)
        ? globalThis.String(object.shiftReason)
        : isSet(object.shift_reason)
        ? globalThis.String(object.shift_reason)
        : "",
      resolvedConfig: isSet(object.resolvedConfig)
        ? ResolvedDebitConfiguration.fromJSON(object.resolvedConfig)
        : isSet(object.resolved_config)
        ? ResolvedDebitConfiguration.fromJSON(object.resolved_config)
        : undefined,
      resolutionTrace: globalThis.Array.isArray(object?.resolutionTrace)
        ? object.resolutionTrace.map((e: any) => DateResolutionStep.fromJSON(e))
        : globalThis.Array.isArray(object?.resolution_trace)
        ? object.resolution_trace.map((e: any) => DateResolutionStep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CalculatePlannedDateResponse): unknown {
    const obj: any = {};
    if (message.plannedDebitDate !== "") {
      obj.plannedDebitDate = message.plannedDebitDate;
    }
    if (message.originalTargetDate !== "") {
      obj.originalTargetDate = message.originalTargetDate;
    }
    if (message.wasShifted !== false) {
      obj.wasShifted = message.wasShifted;
    }
    if (message.shiftReason !== "") {
      obj.shiftReason = message.shiftReason;
    }
    if (message.resolvedConfig !== undefined) {
      obj.resolvedConfig = ResolvedDebitConfiguration.toJSON(message.resolvedConfig);
    }
    if (message.resolutionTrace?.length) {
      obj.resolutionTrace = message.resolutionTrace.map((e) => DateResolutionStep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalculatePlannedDateResponse>, I>>(base?: I): CalculatePlannedDateResponse {
    return CalculatePlannedDateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalculatePlannedDateResponse>, I>>(object: I): CalculatePlannedDateResponse {
    const message = createBaseCalculatePlannedDateResponse();
    message.plannedDebitDate = object.plannedDebitDate ?? "";
    message.originalTargetDate = object.originalTargetDate ?? "";
    message.wasShifted = object.wasShifted ?? false;
    message.shiftReason = object.shiftReason ?? "";
    message.resolvedConfig = (object.resolvedConfig !== undefined && object.resolvedConfig !== null)
      ? ResolvedDebitConfiguration.fromPartial(object.resolvedConfig)
      : undefined;
    message.resolutionTrace = object.resolutionTrace?.map((e) => DateResolutionStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDateResolutionStep(): DateResolutionStep {
  return { stepOrder: 0, description: "", inputDate: "", outputDate: "", appliedRule: "" };
}

export const DateResolutionStep: MessageFns<DateResolutionStep> = {
  encode(message: DateResolutionStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepOrder !== 0) {
      writer.uint32(8).int32(message.stepOrder);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.inputDate !== "") {
      writer.uint32(26).string(message.inputDate);
    }
    if (message.outputDate !== "") {
      writer.uint32(34).string(message.outputDate);
    }
    if (message.appliedRule !== "") {
      writer.uint32(42).string(message.appliedRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateResolutionStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateResolutionStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stepOrder = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appliedRule = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateResolutionStep {
    return {
      stepOrder: isSet(object.stepOrder)
        ? globalThis.Number(object.stepOrder)
        : isSet(object.step_order)
        ? globalThis.Number(object.step_order)
        : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      inputDate: isSet(object.inputDate)
        ? globalThis.String(object.inputDate)
        : isSet(object.input_date)
        ? globalThis.String(object.input_date)
        : "",
      outputDate: isSet(object.outputDate)
        ? globalThis.String(object.outputDate)
        : isSet(object.output_date)
        ? globalThis.String(object.output_date)
        : "",
      appliedRule: isSet(object.appliedRule)
        ? globalThis.String(object.appliedRule)
        : isSet(object.applied_rule)
        ? globalThis.String(object.applied_rule)
        : "",
    };
  },

  toJSON(message: DateResolutionStep): unknown {
    const obj: any = {};
    if (message.stepOrder !== 0) {
      obj.stepOrder = Math.round(message.stepOrder);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.inputDate !== "") {
      obj.inputDate = message.inputDate;
    }
    if (message.outputDate !== "") {
      obj.outputDate = message.outputDate;
    }
    if (message.appliedRule !== "") {
      obj.appliedRule = message.appliedRule;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DateResolutionStep>, I>>(base?: I): DateResolutionStep {
    return DateResolutionStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DateResolutionStep>, I>>(object: I): DateResolutionStep {
    const message = createBaseDateResolutionStep();
    message.stepOrder = object.stepOrder ?? 0;
    message.description = object.description ?? "";
    message.inputDate = object.inputDate ?? "";
    message.outputDate = object.outputDate ?? "";
    message.appliedRule = object.appliedRule ?? "";
    return message;
  },
};

function createBaseCalculatePlannedDatesBatchRequest(): CalculatePlannedDatesBatchRequest {
  return { organisationId: "", inputs: [], targetMonth: 0, targetYear: 0 };
}

export const CalculatePlannedDatesBatchRequest: MessageFns<CalculatePlannedDatesBatchRequest> = {
  encode(message: CalculatePlannedDatesBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    for (const v of message.inputs) {
      PlannedDateCalculationInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.targetMonth !== 0) {
      writer.uint32(24).int32(message.targetMonth);
    }
    if (message.targetYear !== 0) {
      writer.uint32(32).int32(message.targetYear);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDatesBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDatesBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(PlannedDateCalculationInput.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetMonth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.targetYear = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculatePlannedDatesBatchRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => PlannedDateCalculationInput.fromJSON(e))
        : [],
      targetMonth: isSet(object.targetMonth)
        ? globalThis.Number(object.targetMonth)
        : isSet(object.target_month)
        ? globalThis.Number(object.target_month)
        : 0,
      targetYear: isSet(object.targetYear)
        ? globalThis.Number(object.targetYear)
        : isSet(object.target_year)
        ? globalThis.Number(object.target_year)
        : 0,
    };
  },

  toJSON(message: CalculatePlannedDatesBatchRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => PlannedDateCalculationInput.toJSON(e));
    }
    if (message.targetMonth !== 0) {
      obj.targetMonth = Math.round(message.targetMonth);
    }
    if (message.targetYear !== 0) {
      obj.targetYear = Math.round(message.targetYear);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalculatePlannedDatesBatchRequest>, I>>(
    base?: I,
  ): CalculatePlannedDatesBatchRequest {
    return CalculatePlannedDatesBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalculatePlannedDatesBatchRequest>, I>>(
    object: I,
  ): CalculatePlannedDatesBatchRequest {
    const message = createBaseCalculatePlannedDatesBatchRequest();
    message.organisationId = object.organisationId ?? "";
    message.inputs = object.inputs?.map((e) => PlannedDateCalculationInput.fromPartial(e)) || [];
    message.targetMonth = object.targetMonth ?? 0;
    message.targetYear = object.targetYear ?? 0;
    return message;
  },
};

function createBasePlannedDateCalculationInput(): PlannedDateCalculationInput {
  return { contratId: "", clientId: "", societeId: "", amountCents: 0, currency: "" };
}

export const PlannedDateCalculationInput: MessageFns<PlannedDateCalculationInput> = {
  encode(message: PlannedDateCalculationInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDateCalculationInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDateCalculationInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedDateCalculationInput {
    return {
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: PlannedDateCalculationInput): unknown {
    const obj: any = {};
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlannedDateCalculationInput>, I>>(base?: I): PlannedDateCalculationInput {
    return PlannedDateCalculationInput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlannedDateCalculationInput>, I>>(object: I): PlannedDateCalculationInput {
    const message = createBasePlannedDateCalculationInput();
    message.contratId = object.contratId ?? "";
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseCalculatePlannedDatesBatchResponse(): CalculatePlannedDatesBatchResponse {
  return { results: [], totalCount: 0, successCount: 0, errorCount: 0 };
}

export const CalculatePlannedDatesBatchResponse: MessageFns<CalculatePlannedDatesBatchResponse> = {
  encode(message: CalculatePlannedDatesBatchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      PlannedDateCalculationResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.successCount !== 0) {
      writer.uint32(24).int32(message.successCount);
    }
    if (message.errorCount !== 0) {
      writer.uint32(32).int32(message.errorCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDatesBatchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDatesBatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(PlannedDateCalculationResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalculatePlannedDatesBatchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => PlannedDateCalculationResult.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount)
        ? globalThis.Number(object.totalCount)
        : isSet(object.total_count)
        ? globalThis.Number(object.total_count)
        : 0,
      successCount: isSet(object.successCount)
        ? globalThis.Number(object.successCount)
        : isSet(object.success_count)
        ? globalThis.Number(object.success_count)
        : 0,
      errorCount: isSet(object.errorCount)
        ? globalThis.Number(object.errorCount)
        : isSet(object.error_count)
        ? globalThis.Number(object.error_count)
        : 0,
    };
  },

  toJSON(message: CalculatePlannedDatesBatchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => PlannedDateCalculationResult.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.errorCount !== 0) {
      obj.errorCount = Math.round(message.errorCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalculatePlannedDatesBatchResponse>, I>>(
    base?: I,
  ): CalculatePlannedDatesBatchResponse {
    return CalculatePlannedDatesBatchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalculatePlannedDatesBatchResponse>, I>>(
    object: I,
  ): CalculatePlannedDatesBatchResponse {
    const message = createBaseCalculatePlannedDatesBatchResponse();
    message.results = object.results?.map((e) => PlannedDateCalculationResult.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.successCount = object.successCount ?? 0;
    message.errorCount = object.errorCount ?? 0;
    return message;
  },
};

function createBasePlannedDateCalculationResult(): PlannedDateCalculationResult {
  return {
    contratId: "",
    success: false,
    plannedDebitDate: "",
    errorCode: "",
    errorMessage: "",
    resolvedConfig: undefined,
  };
}

export const PlannedDateCalculationResult: MessageFns<PlannedDateCalculationResult> = {
  encode(message: PlannedDateCalculationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.plannedDebitDate !== "") {
      writer.uint32(26).string(message.plannedDebitDate);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    if (message.resolvedConfig !== undefined) {
      ResolvedDebitConfiguration.encode(message.resolvedConfig, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDateCalculationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDateCalculationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.plannedDebitDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resolvedConfig = ResolvedDebitConfiguration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedDateCalculationResult {
    return {
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      plannedDebitDate: isSet(object.plannedDebitDate)
        ? globalThis.String(object.plannedDebitDate)
        : isSet(object.planned_debit_date)
        ? globalThis.String(object.planned_debit_date)
        : "",
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : "",
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
      resolvedConfig: isSet(object.resolvedConfig)
        ? ResolvedDebitConfiguration.fromJSON(object.resolvedConfig)
        : isSet(object.resolved_config)
        ? ResolvedDebitConfiguration.fromJSON(object.resolved_config)
        : undefined,
    };
  },

  toJSON(message: PlannedDateCalculationResult): unknown {
    const obj: any = {};
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.plannedDebitDate !== "") {
      obj.plannedDebitDate = message.plannedDebitDate;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.resolvedConfig !== undefined) {
      obj.resolvedConfig = ResolvedDebitConfiguration.toJSON(message.resolvedConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlannedDateCalculationResult>, I>>(base?: I): PlannedDateCalculationResult {
    return PlannedDateCalculationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlannedDateCalculationResult>, I>>(object: I): PlannedDateCalculationResult {
    const message = createBasePlannedDateCalculationResult();
    message.contratId = object.contratId ?? "";
    message.success = object.success ?? false;
    message.plannedDebitDate = object.plannedDebitDate ?? "";
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.resolvedConfig = (object.resolvedConfig !== undefined && object.resolvedConfig !== null)
      ? ResolvedDebitConfiguration.fromPartial(object.resolvedConfig)
      : undefined;
    return message;
  },
};

function createBaseCheckDateEligibilityRequest(): CheckDateEligibilityRequest {
  return { organisationId: "", date: "", holidayZoneId: "" };
}

export const CheckDateEligibilityRequest: MessageFns<CheckDateEligibilityRequest> = {
  encode(message: CheckDateEligibilityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(26).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckDateEligibilityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckDateEligibilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckDateEligibilityRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
    };
  },

  toJSON(message: CheckDateEligibilityRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckDateEligibilityRequest>, I>>(base?: I): CheckDateEligibilityRequest {
    return CheckDateEligibilityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckDateEligibilityRequest>, I>>(object: I): CheckDateEligibilityRequest {
    const message = createBaseCheckDateEligibilityRequest();
    message.organisationId = object.organisationId ?? "";
    message.date = object.date ?? "";
    message.holidayZoneId = object.holidayZoneId ?? "";
    return message;
  },
};

function createBaseCheckDateEligibilityResponse(): CheckDateEligibilityResponse {
  return {
    isEligible: false,
    isWeekend: false,
    isHoliday: false,
    holidayName: "",
    nextEligibleDate: "",
    previousEligibleDate: "",
  };
}

export const CheckDateEligibilityResponse: MessageFns<CheckDateEligibilityResponse> = {
  encode(message: CheckDateEligibilityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isEligible !== false) {
      writer.uint32(8).bool(message.isEligible);
    }
    if (message.isWeekend !== false) {
      writer.uint32(16).bool(message.isWeekend);
    }
    if (message.isHoliday !== false) {
      writer.uint32(24).bool(message.isHoliday);
    }
    if (message.holidayName !== "") {
      writer.uint32(34).string(message.holidayName);
    }
    if (message.nextEligibleDate !== "") {
      writer.uint32(42).string(message.nextEligibleDate);
    }
    if (message.previousEligibleDate !== "") {
      writer.uint32(50).string(message.previousEligibleDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckDateEligibilityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckDateEligibilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isEligible = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isWeekend = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isHoliday = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.holidayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextEligibleDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.previousEligibleDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckDateEligibilityResponse {
    return {
      isEligible: isSet(object.isEligible)
        ? globalThis.Boolean(object.isEligible)
        : isSet(object.is_eligible)
        ? globalThis.Boolean(object.is_eligible)
        : false,
      isWeekend: isSet(object.isWeekend)
        ? globalThis.Boolean(object.isWeekend)
        : isSet(object.is_weekend)
        ? globalThis.Boolean(object.is_weekend)
        : false,
      isHoliday: isSet(object.isHoliday)
        ? globalThis.Boolean(object.isHoliday)
        : isSet(object.is_holiday)
        ? globalThis.Boolean(object.is_holiday)
        : false,
      holidayName: isSet(object.holidayName)
        ? globalThis.String(object.holidayName)
        : isSet(object.holiday_name)
        ? globalThis.String(object.holiday_name)
        : "",
      nextEligibleDate: isSet(object.nextEligibleDate)
        ? globalThis.String(object.nextEligibleDate)
        : isSet(object.next_eligible_date)
        ? globalThis.String(object.next_eligible_date)
        : "",
      previousEligibleDate: isSet(object.previousEligibleDate)
        ? globalThis.String(object.previousEligibleDate)
        : isSet(object.previous_eligible_date)
        ? globalThis.String(object.previous_eligible_date)
        : "",
    };
  },

  toJSON(message: CheckDateEligibilityResponse): unknown {
    const obj: any = {};
    if (message.isEligible !== false) {
      obj.isEligible = message.isEligible;
    }
    if (message.isWeekend !== false) {
      obj.isWeekend = message.isWeekend;
    }
    if (message.isHoliday !== false) {
      obj.isHoliday = message.isHoliday;
    }
    if (message.holidayName !== "") {
      obj.holidayName = message.holidayName;
    }
    if (message.nextEligibleDate !== "") {
      obj.nextEligibleDate = message.nextEligibleDate;
    }
    if (message.previousEligibleDate !== "") {
      obj.previousEligibleDate = message.previousEligibleDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckDateEligibilityResponse>, I>>(base?: I): CheckDateEligibilityResponse {
    return CheckDateEligibilityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckDateEligibilityResponse>, I>>(object: I): CheckDateEligibilityResponse {
    const message = createBaseCheckDateEligibilityResponse();
    message.isEligible = object.isEligible ?? false;
    message.isWeekend = object.isWeekend ?? false;
    message.isHoliday = object.isHoliday ?? false;
    message.holidayName = object.holidayName ?? "";
    message.nextEligibleDate = object.nextEligibleDate ?? "";
    message.previousEligibleDate = object.previousEligibleDate ?? "";
    return message;
  },
};

function createBasePlannedDebit(): PlannedDebit {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    clientId: "",
    contratId: "",
    scheduleId: "",
    factureId: "",
    plannedDebitDate: "",
    originalTargetDate: "",
    status: 0,
    batch: 0,
    amountCents: 0,
    currency: "",
    resolvedConfig: undefined,
    createdAt: "",
    updatedAt: "",
  };
}

export const PlannedDebit: MessageFns<PlannedDebit> = {
  encode(message: PlannedDebit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.clientId !== "") {
      writer.uint32(34).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(42).string(message.contratId);
    }
    if (message.scheduleId !== "") {
      writer.uint32(50).string(message.scheduleId);
    }
    if (message.factureId !== "") {
      writer.uint32(58).string(message.factureId);
    }
    if (message.plannedDebitDate !== "") {
      writer.uint32(66).string(message.plannedDebitDate);
    }
    if (message.originalTargetDate !== "") {
      writer.uint32(74).string(message.originalTargetDate);
    }
    if (message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    if (message.batch !== 0) {
      writer.uint32(88).int32(message.batch);
    }
    if (message.amountCents !== 0) {
      writer.uint32(96).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(106).string(message.currency);
    }
    if (message.resolvedConfig !== undefined) {
      ResolvedDebitConfiguration.encode(message.resolvedConfig, writer.uint32(114).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDebit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDebit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.plannedDebitDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.originalTargetDate = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.resolvedConfig = ResolvedDebitConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedDebit {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      scheduleId: isSet(object.scheduleId)
        ? globalThis.String(object.scheduleId)
        : isSet(object.schedule_id)
        ? globalThis.String(object.schedule_id)
        : "",
      factureId: isSet(object.factureId)
        ? globalThis.String(object.factureId)
        : isSet(object.facture_id)
        ? globalThis.String(object.facture_id)
        : "",
      plannedDebitDate: isSet(object.plannedDebitDate)
        ? globalThis.String(object.plannedDebitDate)
        : isSet(object.planned_debit_date)
        ? globalThis.String(object.planned_debit_date)
        : "",
      originalTargetDate: isSet(object.originalTargetDate)
        ? globalThis.String(object.originalTargetDate)
        : isSet(object.original_target_date)
        ? globalThis.String(object.original_target_date)
        : "",
      status: isSet(object.status) ? plannedDateStatusFromJSON(object.status) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      resolvedConfig: isSet(object.resolvedConfig)
        ? ResolvedDebitConfiguration.fromJSON(object.resolvedConfig)
        : isSet(object.resolved_config)
        ? ResolvedDebitConfiguration.fromJSON(object.resolved_config)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: PlannedDebit): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.scheduleId !== "") {
      obj.scheduleId = message.scheduleId;
    }
    if (message.factureId !== "") {
      obj.factureId = message.factureId;
    }
    if (message.plannedDebitDate !== "") {
      obj.plannedDebitDate = message.plannedDebitDate;
    }
    if (message.originalTargetDate !== "") {
      obj.originalTargetDate = message.originalTargetDate;
    }
    if (message.status !== 0) {
      obj.status = plannedDateStatusToJSON(message.status);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.resolvedConfig !== undefined) {
      obj.resolvedConfig = ResolvedDebitConfiguration.toJSON(message.resolvedConfig);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlannedDebit>, I>>(base?: I): PlannedDebit {
    return PlannedDebit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlannedDebit>, I>>(object: I): PlannedDebit {
    const message = createBasePlannedDebit();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.clientId = object.clientId ?? "";
    message.contratId = object.contratId ?? "";
    message.scheduleId = object.scheduleId ?? "";
    message.factureId = object.factureId ?? "";
    message.plannedDebitDate = object.plannedDebitDate ?? "";
    message.originalTargetDate = object.originalTargetDate ?? "";
    message.status = object.status ?? 0;
    message.batch = object.batch ?? 0;
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.resolvedConfig = (object.resolvedConfig !== undefined && object.resolvedConfig !== null)
      ? ResolvedDebitConfiguration.fromPartial(object.resolvedConfig)
      : undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseDebitVolumeAggregate(): DebitVolumeAggregate {
  return { date: "", batch: 0, societeId: "", transactionCount: 0, totalAmountCents: 0, currency: "" };
}

export const DebitVolumeAggregate: MessageFns<DebitVolumeAggregate> = {
  encode(message: DebitVolumeAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.batch !== 0) {
      writer.uint32(16).int32(message.batch);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.transactionCount !== 0) {
      writer.uint32(32).int32(message.transactionCount);
    }
    if (message.totalAmountCents !== 0) {
      writer.uint32(40).int64(message.totalAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebitVolumeAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebitVolumeAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.transactionCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebitVolumeAggregate {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      transactionCount: isSet(object.transactionCount)
        ? globalThis.Number(object.transactionCount)
        : isSet(object.transaction_count)
        ? globalThis.Number(object.transaction_count)
        : 0,
      totalAmountCents: isSet(object.totalAmountCents)
        ? globalThis.Number(object.totalAmountCents)
        : isSet(object.total_amount_cents)
        ? globalThis.Number(object.total_amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: DebitVolumeAggregate): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.transactionCount !== 0) {
      obj.transactionCount = Math.round(message.transactionCount);
    }
    if (message.totalAmountCents !== 0) {
      obj.totalAmountCents = Math.round(message.totalAmountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebitVolumeAggregate>, I>>(base?: I): DebitVolumeAggregate {
    return DebitVolumeAggregate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebitVolumeAggregate>, I>>(object: I): DebitVolumeAggregate {
    const message = createBaseDebitVolumeAggregate();
    message.date = object.date ?? "";
    message.batch = object.batch ?? 0;
    message.societeId = object.societeId ?? "";
    message.transactionCount = object.transactionCount ?? 0;
    message.totalAmountCents = object.totalAmountCents ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseVolumeForecast(): VolumeForecast {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    year: 0,
    month: 0,
    day: 0,
    batch: 0,
    expectedTransactionCount: 0,
    expectedAmountCents: 0,
    currency: "",
    actualTransactionCount: 0,
    actualAmountCents: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const VolumeForecast: MessageFns<VolumeForecast> = {
  encode(message: VolumeForecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.year !== 0) {
      writer.uint32(32).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(40).int32(message.month);
    }
    if (message.day !== 0) {
      writer.uint32(48).int32(message.day);
    }
    if (message.batch !== 0) {
      writer.uint32(56).int32(message.batch);
    }
    if (message.expectedTransactionCount !== 0) {
      writer.uint32(64).int32(message.expectedTransactionCount);
    }
    if (message.expectedAmountCents !== 0) {
      writer.uint32(72).int64(message.expectedAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(82).string(message.currency);
    }
    if (message.actualTransactionCount !== 0) {
      writer.uint32(88).int32(message.actualTransactionCount);
    }
    if (message.actualAmountCents !== 0) {
      writer.uint32(96).int64(message.actualAmountCents);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeForecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.month = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.day = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.expectedTransactionCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expectedAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.actualTransactionCount = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.actualAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VolumeForecast {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
      day: isSet(object.day) ? globalThis.Number(object.day) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      expectedTransactionCount: isSet(object.expectedTransactionCount)
        ? globalThis.Number(object.expectedTransactionCount)
        : isSet(object.expected_transaction_count)
        ? globalThis.Number(object.expected_transaction_count)
        : 0,
      expectedAmountCents: isSet(object.expectedAmountCents)
        ? globalThis.Number(object.expectedAmountCents)
        : isSet(object.expected_amount_cents)
        ? globalThis.Number(object.expected_amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      actualTransactionCount: isSet(object.actualTransactionCount)
        ? globalThis.Number(object.actualTransactionCount)
        : isSet(object.actual_transaction_count)
        ? globalThis.Number(object.actual_transaction_count)
        : 0,
      actualAmountCents: isSet(object.actualAmountCents)
        ? globalThis.Number(object.actualAmountCents)
        : isSet(object.actual_amount_cents)
        ? globalThis.Number(object.actual_amount_cents)
        : 0,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: VolumeForecast): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.day !== 0) {
      obj.day = Math.round(message.day);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.expectedTransactionCount !== 0) {
      obj.expectedTransactionCount = Math.round(message.expectedTransactionCount);
    }
    if (message.expectedAmountCents !== 0) {
      obj.expectedAmountCents = Math.round(message.expectedAmountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.actualTransactionCount !== 0) {
      obj.actualTransactionCount = Math.round(message.actualTransactionCount);
    }
    if (message.actualAmountCents !== 0) {
      obj.actualAmountCents = Math.round(message.actualAmountCents);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VolumeForecast>, I>>(base?: I): VolumeForecast {
    return VolumeForecast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VolumeForecast>, I>>(object: I): VolumeForecast {
    const message = createBaseVolumeForecast();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.day = object.day ?? 0;
    message.batch = object.batch ?? 0;
    message.expectedTransactionCount = object.expectedTransactionCount ?? 0;
    message.expectedAmountCents = object.expectedAmountCents ?? 0;
    message.currency = object.currency ?? "";
    message.actualTransactionCount = object.actualTransactionCount ?? 0;
    message.actualAmountCents = object.actualAmountCents ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseVolumeThreshold(): VolumeThreshold {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    maxTransactionCount: 0,
    maxAmountCents: 0,
    currency: "",
    alertOnExceed: false,
    alertEmail: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const VolumeThreshold: MessageFns<VolumeThreshold> = {
  encode(message: VolumeThreshold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.maxTransactionCount !== 0) {
      writer.uint32(32).int32(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      writer.uint32(40).int64(message.maxAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.alertOnExceed !== false) {
      writer.uint32(56).bool(message.alertOnExceed);
    }
    if (message.alertEmail !== "") {
      writer.uint32(66).string(message.alertEmail);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeThreshold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxTransactionCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.alertOnExceed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.alertEmail = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VolumeThreshold {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      maxTransactionCount: isSet(object.maxTransactionCount)
        ? globalThis.Number(object.maxTransactionCount)
        : isSet(object.max_transaction_count)
        ? globalThis.Number(object.max_transaction_count)
        : 0,
      maxAmountCents: isSet(object.maxAmountCents)
        ? globalThis.Number(object.maxAmountCents)
        : isSet(object.max_amount_cents)
        ? globalThis.Number(object.max_amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      alertOnExceed: isSet(object.alertOnExceed)
        ? globalThis.Boolean(object.alertOnExceed)
        : isSet(object.alert_on_exceed)
        ? globalThis.Boolean(object.alert_on_exceed)
        : false,
      alertEmail: isSet(object.alertEmail)
        ? globalThis.String(object.alertEmail)
        : isSet(object.alert_email)
        ? globalThis.String(object.alert_email)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: VolumeThreshold): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.maxTransactionCount !== 0) {
      obj.maxTransactionCount = Math.round(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      obj.maxAmountCents = Math.round(message.maxAmountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.alertOnExceed !== false) {
      obj.alertOnExceed = message.alertOnExceed;
    }
    if (message.alertEmail !== "") {
      obj.alertEmail = message.alertEmail;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VolumeThreshold>, I>>(base?: I): VolumeThreshold {
    return VolumeThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VolumeThreshold>, I>>(object: I): VolumeThreshold {
    const message = createBaseVolumeThreshold();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.maxTransactionCount = object.maxTransactionCount ?? 0;
    message.maxAmountCents = object.maxAmountCents ?? 0;
    message.currency = object.currency ?? "";
    message.alertOnExceed = object.alertOnExceed ?? false;
    message.alertEmail = object.alertEmail ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseImportCsvRequest(): ImportCsvRequest {
  return { organisationId: "", csvContent: new Uint8Array(0), importType: "", dryRun: false, uploadedByUserId: "" };
}

export const ImportCsvRequest: MessageFns<ImportCsvRequest> = {
  encode(message: ImportCsvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.csvContent.length !== 0) {
      writer.uint32(18).bytes(message.csvContent);
    }
    if (message.importType !== "") {
      writer.uint32(26).string(message.importType);
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    if (message.uploadedByUserId !== "") {
      writer.uint32(42).string(message.uploadedByUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportCsvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportCsvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.csvContent = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.importType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.uploadedByUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportCsvRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      csvContent: isSet(object.csvContent)
        ? bytesFromBase64(object.csvContent)
        : isSet(object.csv_content)
        ? bytesFromBase64(object.csv_content)
        : new Uint8Array(0),
      importType: isSet(object.importType)
        ? globalThis.String(object.importType)
        : isSet(object.import_type)
        ? globalThis.String(object.import_type)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
      uploadedByUserId: isSet(object.uploadedByUserId)
        ? globalThis.String(object.uploadedByUserId)
        : isSet(object.uploaded_by_user_id)
        ? globalThis.String(object.uploaded_by_user_id)
        : "",
    };
  },

  toJSON(message: ImportCsvRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.csvContent.length !== 0) {
      obj.csvContent = base64FromBytes(message.csvContent);
    }
    if (message.importType !== "") {
      obj.importType = message.importType;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    if (message.uploadedByUserId !== "") {
      obj.uploadedByUserId = message.uploadedByUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportCsvRequest>, I>>(base?: I): ImportCsvRequest {
    return ImportCsvRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportCsvRequest>, I>>(object: I): ImportCsvRequest {
    const message = createBaseImportCsvRequest();
    message.organisationId = object.organisationId ?? "";
    message.csvContent = object.csvContent ?? new Uint8Array(0);
    message.importType = object.importType ?? "";
    message.dryRun = object.dryRun ?? false;
    message.uploadedByUserId = object.uploadedByUserId ?? "";
    return message;
  },
};

function createBaseImportCsvResponse(): ImportCsvResponse {
  return {
    importId: "",
    success: false,
    isDryRun: false,
    totalRows: 0,
    validRows: 0,
    errorRows: 0,
    errors: [],
    preview: [],
  };
}

export const ImportCsvResponse: MessageFns<ImportCsvResponse> = {
  encode(message: ImportCsvResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importId !== "") {
      writer.uint32(10).string(message.importId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.isDryRun !== false) {
      writer.uint32(24).bool(message.isDryRun);
    }
    if (message.totalRows !== 0) {
      writer.uint32(32).int32(message.totalRows);
    }
    if (message.validRows !== 0) {
      writer.uint32(40).int32(message.validRows);
    }
    if (message.errorRows !== 0) {
      writer.uint32(48).int32(message.errorRows);
    }
    for (const v of message.errors) {
      CsvValidationError.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.preview) {
      CsvImportPreview.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportCsvResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportCsvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isDryRun = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalRows = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validRows = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.errorRows = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.errors.push(CsvValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.preview.push(CsvImportPreview.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportCsvResponse {
    return {
      importId: isSet(object.importId)
        ? globalThis.String(object.importId)
        : isSet(object.import_id)
        ? globalThis.String(object.import_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      isDryRun: isSet(object.isDryRun)
        ? globalThis.Boolean(object.isDryRun)
        : isSet(object.is_dry_run)
        ? globalThis.Boolean(object.is_dry_run)
        : false,
      totalRows: isSet(object.totalRows)
        ? globalThis.Number(object.totalRows)
        : isSet(object.total_rows)
        ? globalThis.Number(object.total_rows)
        : 0,
      validRows: isSet(object.validRows)
        ? globalThis.Number(object.validRows)
        : isSet(object.valid_rows)
        ? globalThis.Number(object.valid_rows)
        : 0,
      errorRows: isSet(object.errorRows)
        ? globalThis.Number(object.errorRows)
        : isSet(object.error_rows)
        ? globalThis.Number(object.error_rows)
        : 0,
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => CsvValidationError.fromJSON(e))
        : [],
      preview: globalThis.Array.isArray(object?.preview)
        ? object.preview.map((e: any) => CsvImportPreview.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ImportCsvResponse): unknown {
    const obj: any = {};
    if (message.importId !== "") {
      obj.importId = message.importId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.isDryRun !== false) {
      obj.isDryRun = message.isDryRun;
    }
    if (message.totalRows !== 0) {
      obj.totalRows = Math.round(message.totalRows);
    }
    if (message.validRows !== 0) {
      obj.validRows = Math.round(message.validRows);
    }
    if (message.errorRows !== 0) {
      obj.errorRows = Math.round(message.errorRows);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => CsvValidationError.toJSON(e));
    }
    if (message.preview?.length) {
      obj.preview = message.preview.map((e) => CsvImportPreview.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportCsvResponse>, I>>(base?: I): ImportCsvResponse {
    return ImportCsvResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportCsvResponse>, I>>(object: I): ImportCsvResponse {
    const message = createBaseImportCsvResponse();
    message.importId = object.importId ?? "";
    message.success = object.success ?? false;
    message.isDryRun = object.isDryRun ?? false;
    message.totalRows = object.totalRows ?? 0;
    message.validRows = object.validRows ?? 0;
    message.errorRows = object.errorRows ?? 0;
    message.errors = object.errors?.map((e) => CsvValidationError.fromPartial(e)) || [];
    message.preview = object.preview?.map((e) => CsvImportPreview.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCsvValidationError(): CsvValidationError {
  return { rowNumber: 0, columnName: "", value: "", errorCode: "", errorMessage: "" };
}

export const CsvValidationError: MessageFns<CsvValidationError> = {
  encode(message: CsvValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rowNumber !== 0) {
      writer.uint32(8).int32(message.rowNumber);
    }
    if (message.columnName !== "") {
      writer.uint32(18).string(message.columnName);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CsvValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsvValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columnName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CsvValidationError {
    return {
      rowNumber: isSet(object.rowNumber)
        ? globalThis.Number(object.rowNumber)
        : isSet(object.row_number)
        ? globalThis.Number(object.row_number)
        : 0,
      columnName: isSet(object.columnName)
        ? globalThis.String(object.columnName)
        : isSet(object.column_name)
        ? globalThis.String(object.column_name)
        : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : "",
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: CsvValidationError): unknown {
    const obj: any = {};
    if (message.rowNumber !== 0) {
      obj.rowNumber = Math.round(message.rowNumber);
    }
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CsvValidationError>, I>>(base?: I): CsvValidationError {
    return CsvValidationError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CsvValidationError>, I>>(object: I): CsvValidationError {
    const message = createBaseCsvValidationError();
    message.rowNumber = object.rowNumber ?? 0;
    message.columnName = object.columnName ?? "";
    message.value = object.value ?? "";
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseCsvImportPreview(): CsvImportPreview {
  return { rowNumber: 0, action: "", entityType: "", entityId: "", data: {}, changeSummary: "" };
}

export const CsvImportPreview: MessageFns<CsvImportPreview> = {
  encode(message: CsvImportPreview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rowNumber !== 0) {
      writer.uint32(8).int32(message.rowNumber);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    globalThis.Object.entries(message.data).forEach(([key, value]: [string, string]) => {
      CsvImportPreview_DataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.changeSummary !== "") {
      writer.uint32(50).string(message.changeSummary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CsvImportPreview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsvImportPreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = CsvImportPreview_DataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.data[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.changeSummary = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CsvImportPreview {
    return {
      rowNumber: isSet(object.rowNumber)
        ? globalThis.Number(object.rowNumber)
        : isSet(object.row_number)
        ? globalThis.Number(object.row_number)
        : 0,
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      entityType: isSet(object.entityType)
        ? globalThis.String(object.entityType)
        : isSet(object.entity_type)
        ? globalThis.String(object.entity_type)
        : "",
      entityId: isSet(object.entityId)
        ? globalThis.String(object.entityId)
        : isSet(object.entity_id)
        ? globalThis.String(object.entity_id)
        : "",
      data: isObject(object.data)
        ? (globalThis.Object.entries(object.data) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      changeSummary: isSet(object.changeSummary)
        ? globalThis.String(object.changeSummary)
        : isSet(object.change_summary)
        ? globalThis.String(object.change_summary)
        : "",
    };
  },

  toJSON(message: CsvImportPreview): unknown {
    const obj: any = {};
    if (message.rowNumber !== 0) {
      obj.rowNumber = Math.round(message.rowNumber);
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.data) {
      const entries = globalThis.Object.entries(message.data) as [string, string][];
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    if (message.changeSummary !== "") {
      obj.changeSummary = message.changeSummary;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CsvImportPreview>, I>>(base?: I): CsvImportPreview {
    return CsvImportPreview.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CsvImportPreview>, I>>(object: I): CsvImportPreview {
    const message = createBaseCsvImportPreview();
    message.rowNumber = object.rowNumber ?? 0;
    message.action = object.action ?? "";
    message.entityType = object.entityType ?? "";
    message.entityId = object.entityId ?? "";
    message.data = (globalThis.Object.entries(object.data ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.changeSummary = object.changeSummary ?? "";
    return message;
  },
};

function createBaseCsvImportPreview_DataEntry(): CsvImportPreview_DataEntry {
  return { key: "", value: "" };
}

export const CsvImportPreview_DataEntry: MessageFns<CsvImportPreview_DataEntry> = {
  encode(message: CsvImportPreview_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CsvImportPreview_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsvImportPreview_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CsvImportPreview_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CsvImportPreview_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CsvImportPreview_DataEntry>, I>>(base?: I): CsvImportPreview_DataEntry {
    return CsvImportPreview_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CsvImportPreview_DataEntry>, I>>(object: I): CsvImportPreview_DataEntry {
    const message = createBaseCsvImportPreview_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConfirmCsvImportRequest(): ConfirmCsvImportRequest {
  return { importId: "", organisationId: "", confirmedByUserId: "" };
}

export const ConfirmCsvImportRequest: MessageFns<ConfirmCsvImportRequest> = {
  encode(message: ConfirmCsvImportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importId !== "") {
      writer.uint32(10).string(message.importId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.confirmedByUserId !== "") {
      writer.uint32(26).string(message.confirmedByUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfirmCsvImportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmCsvImportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.confirmedByUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmCsvImportRequest {
    return {
      importId: isSet(object.importId)
        ? globalThis.String(object.importId)
        : isSet(object.import_id)
        ? globalThis.String(object.import_id)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      confirmedByUserId: isSet(object.confirmedByUserId)
        ? globalThis.String(object.confirmedByUserId)
        : isSet(object.confirmed_by_user_id)
        ? globalThis.String(object.confirmed_by_user_id)
        : "",
    };
  },

  toJSON(message: ConfirmCsvImportRequest): unknown {
    const obj: any = {};
    if (message.importId !== "") {
      obj.importId = message.importId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.confirmedByUserId !== "") {
      obj.confirmedByUserId = message.confirmedByUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmCsvImportRequest>, I>>(base?: I): ConfirmCsvImportRequest {
    return ConfirmCsvImportRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmCsvImportRequest>, I>>(object: I): ConfirmCsvImportRequest {
    const message = createBaseConfirmCsvImportRequest();
    message.importId = object.importId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.confirmedByUserId = object.confirmedByUserId ?? "";
    return message;
  },
};

function createBaseConfirmCsvImportResponse(): ConfirmCsvImportResponse {
  return { success: false, createdCount: 0, updatedCount: 0, skippedCount: 0, auditLogId: "" };
}

export const ConfirmCsvImportResponse: MessageFns<ConfirmCsvImportResponse> = {
  encode(message: ConfirmCsvImportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.createdCount !== 0) {
      writer.uint32(16).int32(message.createdCount);
    }
    if (message.updatedCount !== 0) {
      writer.uint32(24).int32(message.updatedCount);
    }
    if (message.skippedCount !== 0) {
      writer.uint32(32).int32(message.skippedCount);
    }
    if (message.auditLogId !== "") {
      writer.uint32(42).string(message.auditLogId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfirmCsvImportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmCsvImportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.createdCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.updatedCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skippedCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.auditLogId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmCsvImportResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      createdCount: isSet(object.createdCount)
        ? globalThis.Number(object.createdCount)
        : isSet(object.created_count)
        ? globalThis.Number(object.created_count)
        : 0,
      updatedCount: isSet(object.updatedCount)
        ? globalThis.Number(object.updatedCount)
        : isSet(object.updated_count)
        ? globalThis.Number(object.updated_count)
        : 0,
      skippedCount: isSet(object.skippedCount)
        ? globalThis.Number(object.skippedCount)
        : isSet(object.skipped_count)
        ? globalThis.Number(object.skipped_count)
        : 0,
      auditLogId: isSet(object.auditLogId)
        ? globalThis.String(object.auditLogId)
        : isSet(object.audit_log_id)
        ? globalThis.String(object.audit_log_id)
        : "",
    };
  },

  toJSON(message: ConfirmCsvImportResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.createdCount !== 0) {
      obj.createdCount = Math.round(message.createdCount);
    }
    if (message.updatedCount !== 0) {
      obj.updatedCount = Math.round(message.updatedCount);
    }
    if (message.skippedCount !== 0) {
      obj.skippedCount = Math.round(message.skippedCount);
    }
    if (message.auditLogId !== "") {
      obj.auditLogId = message.auditLogId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmCsvImportResponse>, I>>(base?: I): ConfirmCsvImportResponse {
    return ConfirmCsvImportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmCsvImportResponse>, I>>(object: I): ConfirmCsvImportResponse {
    const message = createBaseConfirmCsvImportResponse();
    message.success = object.success ?? false;
    message.createdCount = object.createdCount ?? 0;
    message.updatedCount = object.updatedCount ?? 0;
    message.skippedCount = object.skippedCount ?? 0;
    message.auditLogId = object.auditLogId ?? "";
    return message;
  },
};

function createBaseCalendarAuditLog(): CalendarAuditLog {
  return {
    id: "",
    organisationId: "",
    entityType: "",
    entityId: "",
    action: "",
    actorUserId: "",
    source: 0,
    beforeState: "",
    afterState: "",
    changeSummary: "",
    ipAddress: "",
    userAgent: "",
    createdAt: "",
  };
}

export const CalendarAuditLog: MessageFns<CalendarAuditLog> = {
  encode(message: CalendarAuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.actorUserId !== "") {
      writer.uint32(50).string(message.actorUserId);
    }
    if (message.source !== 0) {
      writer.uint32(56).int32(message.source);
    }
    if (message.beforeState !== "") {
      writer.uint32(66).string(message.beforeState);
    }
    if (message.afterState !== "") {
      writer.uint32(74).string(message.afterState);
    }
    if (message.changeSummary !== "") {
      writer.uint32(82).string(message.changeSummary);
    }
    if (message.ipAddress !== "") {
      writer.uint32(90).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(98).string(message.userAgent);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalendarAuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalendarAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actorUserId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.beforeState = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.afterState = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.changeSummary = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalendarAuditLog {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      entityType: isSet(object.entityType)
        ? globalThis.String(object.entityType)
        : isSet(object.entity_type)
        ? globalThis.String(object.entity_type)
        : "",
      entityId: isSet(object.entityId)
        ? globalThis.String(object.entityId)
        : isSet(object.entity_id)
        ? globalThis.String(object.entity_id)
        : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      actorUserId: isSet(object.actorUserId)
        ? globalThis.String(object.actorUserId)
        : isSet(object.actor_user_id)
        ? globalThis.String(object.actor_user_id)
        : "",
      source: isSet(object.source) ? auditSourceFromJSON(object.source) : 0,
      beforeState: isSet(object.beforeState)
        ? globalThis.String(object.beforeState)
        : isSet(object.before_state)
        ? globalThis.String(object.before_state)
        : "",
      afterState: isSet(object.afterState)
        ? globalThis.String(object.afterState)
        : isSet(object.after_state)
        ? globalThis.String(object.after_state)
        : "",
      changeSummary: isSet(object.changeSummary)
        ? globalThis.String(object.changeSummary)
        : isSet(object.change_summary)
        ? globalThis.String(object.change_summary)
        : "",
      ipAddress: isSet(object.ipAddress)
        ? globalThis.String(object.ipAddress)
        : isSet(object.ip_address)
        ? globalThis.String(object.ip_address)
        : "",
      userAgent: isSet(object.userAgent)
        ? globalThis.String(object.userAgent)
        : isSet(object.user_agent)
        ? globalThis.String(object.user_agent)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
    };
  },

  toJSON(message: CalendarAuditLog): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.actorUserId !== "") {
      obj.actorUserId = message.actorUserId;
    }
    if (message.source !== 0) {
      obj.source = auditSourceToJSON(message.source);
    }
    if (message.beforeState !== "") {
      obj.beforeState = message.beforeState;
    }
    if (message.afterState !== "") {
      obj.afterState = message.afterState;
    }
    if (message.changeSummary !== "") {
      obj.changeSummary = message.changeSummary;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalendarAuditLog>, I>>(base?: I): CalendarAuditLog {
    return CalendarAuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalendarAuditLog>, I>>(object: I): CalendarAuditLog {
    const message = createBaseCalendarAuditLog();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.entityType = object.entityType ?? "";
    message.entityId = object.entityId ?? "";
    message.action = object.action ?? "";
    message.actorUserId = object.actorUserId ?? "";
    message.source = object.source ?? 0;
    message.beforeState = object.beforeState ?? "";
    message.afterState = object.afterState ?? "";
    message.changeSummary = object.changeSummary ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseGetCalendarViewRequest(): GetCalendarViewRequest {
  return {
    organisationId: "",
    startDate: "",
    endDate: "",
    societeIds: [],
    batches: [],
    statuses: [],
    includeVolumes: false,
  };
}

export const GetCalendarViewRequest: MessageFns<GetCalendarViewRequest> = {
  encode(message: GetCalendarViewRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.startDate !== "") {
      writer.uint32(18).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(26).string(message.endDate);
    }
    for (const v of message.societeIds) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.batches) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeVolumes !== false) {
      writer.uint32(56).bool(message.includeVolumes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCalendarViewRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCalendarViewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.batches.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.batches.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag === 48) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.includeVolumes = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCalendarViewRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : "",
      societeIds: globalThis.Array.isArray(object?.societeIds)
        ? object.societeIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.societe_ids)
        ? object.societe_ids.map((e: any) => globalThis.String(e))
        : [],
      batches: globalThis.Array.isArray(object?.batches)
        ? object.batches.map((e: any) => debitBatchFromJSON(e))
        : [],
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => plannedDateStatusFromJSON(e))
        : [],
      includeVolumes: isSet(object.includeVolumes)
        ? globalThis.Boolean(object.includeVolumes)
        : isSet(object.include_volumes)
        ? globalThis.Boolean(object.include_volumes)
        : false,
    };
  },

  toJSON(message: GetCalendarViewRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.societeIds?.length) {
      obj.societeIds = message.societeIds;
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => debitBatchToJSON(e));
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => plannedDateStatusToJSON(e));
    }
    if (message.includeVolumes !== false) {
      obj.includeVolumes = message.includeVolumes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCalendarViewRequest>, I>>(base?: I): GetCalendarViewRequest {
    return GetCalendarViewRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCalendarViewRequest>, I>>(object: I): GetCalendarViewRequest {
    const message = createBaseGetCalendarViewRequest();
    message.organisationId = object.organisationId ?? "";
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.societeIds = object.societeIds?.map((e) => e) || [];
    message.batches = object.batches?.map((e) => e) || [];
    message.statuses = object.statuses?.map((e) => e) || [];
    message.includeVolumes = object.includeVolumes ?? false;
    return message;
  },
};

function createBaseGetCalendarViewResponse(): GetCalendarViewResponse {
  return { days: [], volumes: [] };
}

export const GetCalendarViewResponse: MessageFns<GetCalendarViewResponse> = {
  encode(message: GetCalendarViewResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.days) {
      CalendarDay.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.volumes) {
      DebitVolumeAggregate.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCalendarViewResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCalendarViewResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.days.push(CalendarDay.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.volumes.push(DebitVolumeAggregate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCalendarViewResponse {
    return {
      days: globalThis.Array.isArray(object?.days) ? object.days.map((e: any) => CalendarDay.fromJSON(e)) : [],
      volumes: globalThis.Array.isArray(object?.volumes)
        ? object.volumes.map((e: any) => DebitVolumeAggregate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetCalendarViewResponse): unknown {
    const obj: any = {};
    if (message.days?.length) {
      obj.days = message.days.map((e) => CalendarDay.toJSON(e));
    }
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => DebitVolumeAggregate.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCalendarViewResponse>, I>>(base?: I): GetCalendarViewResponse {
    return GetCalendarViewResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCalendarViewResponse>, I>>(object: I): GetCalendarViewResponse {
    const message = createBaseGetCalendarViewResponse();
    message.days = object.days?.map((e) => CalendarDay.fromPartial(e)) || [];
    message.volumes = object.volumes?.map((e) => DebitVolumeAggregate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCalendarDay(): CalendarDay {
  return { date: "", isWeekend: false, isHoliday: false, holidayName: "", isEligible: false, debits: [] };
}

export const CalendarDay: MessageFns<CalendarDay> = {
  encode(message: CalendarDay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.isWeekend !== false) {
      writer.uint32(16).bool(message.isWeekend);
    }
    if (message.isHoliday !== false) {
      writer.uint32(24).bool(message.isHoliday);
    }
    if (message.holidayName !== "") {
      writer.uint32(34).string(message.holidayName);
    }
    if (message.isEligible !== false) {
      writer.uint32(40).bool(message.isEligible);
    }
    for (const v of message.debits) {
      PlannedDebitSummary.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalendarDay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalendarDay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isWeekend = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isHoliday = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.holidayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isEligible = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.debits.push(PlannedDebitSummary.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CalendarDay {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      isWeekend: isSet(object.isWeekend)
        ? globalThis.Boolean(object.isWeekend)
        : isSet(object.is_weekend)
        ? globalThis.Boolean(object.is_weekend)
        : false,
      isHoliday: isSet(object.isHoliday)
        ? globalThis.Boolean(object.isHoliday)
        : isSet(object.is_holiday)
        ? globalThis.Boolean(object.is_holiday)
        : false,
      holidayName: isSet(object.holidayName)
        ? globalThis.String(object.holidayName)
        : isSet(object.holiday_name)
        ? globalThis.String(object.holiday_name)
        : "",
      isEligible: isSet(object.isEligible)
        ? globalThis.Boolean(object.isEligible)
        : isSet(object.is_eligible)
        ? globalThis.Boolean(object.is_eligible)
        : false,
      debits: globalThis.Array.isArray(object?.debits)
        ? object.debits.map((e: any) => PlannedDebitSummary.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CalendarDay): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.isWeekend !== false) {
      obj.isWeekend = message.isWeekend;
    }
    if (message.isHoliday !== false) {
      obj.isHoliday = message.isHoliday;
    }
    if (message.holidayName !== "") {
      obj.holidayName = message.holidayName;
    }
    if (message.isEligible !== false) {
      obj.isEligible = message.isEligible;
    }
    if (message.debits?.length) {
      obj.debits = message.debits.map((e) => PlannedDebitSummary.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CalendarDay>, I>>(base?: I): CalendarDay {
    return CalendarDay.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CalendarDay>, I>>(object: I): CalendarDay {
    const message = createBaseCalendarDay();
    message.date = object.date ?? "";
    message.isWeekend = object.isWeekend ?? false;
    message.isHoliday = object.isHoliday ?? false;
    message.holidayName = object.holidayName ?? "";
    message.isEligible = object.isEligible ?? false;
    message.debits = object.debits?.map((e) => PlannedDebitSummary.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlannedDebitSummary(): PlannedDebitSummary {
  return { id: "", contratId: "", clientName: "", amountCents: 0, currency: "", status: 0, batch: 0 };
}

export const PlannedDebitSummary: MessageFns<PlannedDebitSummary> = {
  encode(message: PlannedDebitSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.clientName !== "") {
      writer.uint32(26).string(message.clientName);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.batch !== 0) {
      writer.uint32(56).int32(message.batch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDebitSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDebitSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlannedDebitSummary {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      clientName: isSet(object.clientName)
        ? globalThis.String(object.clientName)
        : isSet(object.client_name)
        ? globalThis.String(object.client_name)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? plannedDateStatusFromJSON(object.status) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
    };
  },

  toJSON(message: PlannedDebitSummary): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.clientName !== "") {
      obj.clientName = message.clientName;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = plannedDateStatusToJSON(message.status);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlannedDebitSummary>, I>>(base?: I): PlannedDebitSummary {
    return PlannedDebitSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlannedDebitSummary>, I>>(object: I): PlannedDebitSummary {
    const message = createBasePlannedDebitSummary();
    message.id = object.id ?? "";
    message.contratId = object.contratId ?? "";
    message.clientName = object.clientName ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.batch = object.batch ?? 0;
    return message;
  },
};

function createBaseGetDateDetailsRequest(): GetDateDetailsRequest {
  return { organisationId: "", date: "", societeId: "", batch: 0, pagination: undefined };
}

export const GetDateDetailsRequest: MessageFns<GetDateDetailsRequest> = {
  encode(message: GetDateDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDateDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDateDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDateDetailsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetDateDetailsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDateDetailsRequest>, I>>(base?: I): GetDateDetailsRequest {
    return GetDateDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDateDetailsRequest>, I>>(object: I): GetDateDetailsRequest {
    const message = createBaseGetDateDetailsRequest();
    message.organisationId = object.organisationId ?? "";
    message.date = object.date ?? "";
    message.societeId = object.societeId ?? "";
    message.batch = object.batch ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetDateDetailsResponse(): GetDateDetailsResponse {
  return { debits: [], pagination: undefined, aggregate: undefined };
}

export const GetDateDetailsResponse: MessageFns<GetDateDetailsResponse> = {
  encode(message: GetDateDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.debits) {
      PlannedDebit.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.aggregate !== undefined) {
      DebitVolumeAggregate.encode(message.aggregate, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDateDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDateDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.debits.push(PlannedDebit.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aggregate = DebitVolumeAggregate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDateDetailsResponse {
    return {
      debits: globalThis.Array.isArray(object?.debits) ? object.debits.map((e: any) => PlannedDebit.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
      aggregate: isSet(object.aggregate) ? DebitVolumeAggregate.fromJSON(object.aggregate) : undefined,
    };
  },

  toJSON(message: GetDateDetailsResponse): unknown {
    const obj: any = {};
    if (message.debits?.length) {
      obj.debits = message.debits.map((e) => PlannedDebit.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    if (message.aggregate !== undefined) {
      obj.aggregate = DebitVolumeAggregate.toJSON(message.aggregate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDateDetailsResponse>, I>>(base?: I): GetDateDetailsResponse {
    return GetDateDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDateDetailsResponse>, I>>(object: I): GetDateDetailsResponse {
    const message = createBaseGetDateDetailsResponse();
    message.debits = object.debits?.map((e) => PlannedDebit.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    message.aggregate = (object.aggregate !== undefined && object.aggregate !== null)
      ? DebitVolumeAggregate.fromPartial(object.aggregate)
      : undefined;
    return message;
  },
};

function createBaseGetVolumeHeatmapRequest(): GetVolumeHeatmapRequest {
  return { organisationId: "", year: 0, month: 0, societeIds: [], batches: [], includeForecast: false };
}

export const GetVolumeHeatmapRequest: MessageFns<GetVolumeHeatmapRequest> = {
  encode(message: GetVolumeHeatmapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(24).int32(message.month);
    }
    for (const v of message.societeIds) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.batches) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeForecast !== false) {
      writer.uint32(48).bool(message.includeForecast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeHeatmapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeHeatmapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.month = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.batches.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.batches.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.includeForecast = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVolumeHeatmapRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      month: isSet(object.month) ? globalThis.Number(object.month) : 0,
      societeIds: globalThis.Array.isArray(object?.societeIds)
        ? object.societeIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.societe_ids)
        ? object.societe_ids.map((e: any) => globalThis.String(e))
        : [],
      batches: globalThis.Array.isArray(object?.batches) ? object.batches.map((e: any) => debitBatchFromJSON(e)) : [],
      includeForecast: isSet(object.includeForecast)
        ? globalThis.Boolean(object.includeForecast)
        : isSet(object.include_forecast)
        ? globalThis.Boolean(object.include_forecast)
        : false,
    };
  },

  toJSON(message: GetVolumeHeatmapRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.month !== 0) {
      obj.month = Math.round(message.month);
    }
    if (message.societeIds?.length) {
      obj.societeIds = message.societeIds;
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => debitBatchToJSON(e));
    }
    if (message.includeForecast !== false) {
      obj.includeForecast = message.includeForecast;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVolumeHeatmapRequest>, I>>(base?: I): GetVolumeHeatmapRequest {
    return GetVolumeHeatmapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVolumeHeatmapRequest>, I>>(object: I): GetVolumeHeatmapRequest {
    const message = createBaseGetVolumeHeatmapRequest();
    message.organisationId = object.organisationId ?? "";
    message.year = object.year ?? 0;
    message.month = object.month ?? 0;
    message.societeIds = object.societeIds?.map((e) => e) || [];
    message.batches = object.batches?.map((e) => e) || [];
    message.includeForecast = object.includeForecast ?? false;
    return message;
  },
};

function createBaseGetVolumeHeatmapResponse(): GetVolumeHeatmapResponse {
  return { cells: [], exceededThresholds: [] };
}

export const GetVolumeHeatmapResponse: MessageFns<GetVolumeHeatmapResponse> = {
  encode(message: GetVolumeHeatmapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      HeatmapCell.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.exceededThresholds) {
      VolumeThreshold.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeHeatmapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeHeatmapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cells.push(HeatmapCell.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exceededThresholds.push(VolumeThreshold.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVolumeHeatmapResponse {
    return {
      cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => HeatmapCell.fromJSON(e)) : [],
      exceededThresholds: globalThis.Array.isArray(object?.exceededThresholds)
        ? object.exceededThresholds.map((e: any) => VolumeThreshold.fromJSON(e))
        : globalThis.Array.isArray(object?.exceeded_thresholds)
        ? object.exceeded_thresholds.map((e: any) => VolumeThreshold.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetVolumeHeatmapResponse): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => HeatmapCell.toJSON(e));
    }
    if (message.exceededThresholds?.length) {
      obj.exceededThresholds = message.exceededThresholds.map((e) => VolumeThreshold.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVolumeHeatmapResponse>, I>>(base?: I): GetVolumeHeatmapResponse {
    return GetVolumeHeatmapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVolumeHeatmapResponse>, I>>(object: I): GetVolumeHeatmapResponse {
    const message = createBaseGetVolumeHeatmapResponse();
    message.cells = object.cells?.map((e) => HeatmapCell.fromPartial(e)) || [];
    message.exceededThresholds = object.exceededThresholds?.map((e) => VolumeThreshold.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHeatmapCell(): HeatmapCell {
  return {
    date: "",
    dayOfWeek: 0,
    weekOfMonth: 0,
    transactionCount: 0,
    totalAmountCents: 0,
    currency: "",
    intensityLevel: "",
    exceedsThreshold: false,
    forecast: undefined,
  };
}

export const HeatmapCell: MessageFns<HeatmapCell> = {
  encode(message: HeatmapCell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(16).int32(message.dayOfWeek);
    }
    if (message.weekOfMonth !== 0) {
      writer.uint32(24).int32(message.weekOfMonth);
    }
    if (message.transactionCount !== 0) {
      writer.uint32(32).int32(message.transactionCount);
    }
    if (message.totalAmountCents !== 0) {
      writer.uint32(40).int64(message.totalAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.intensityLevel !== "") {
      writer.uint32(58).string(message.intensityLevel);
    }
    if (message.exceedsThreshold !== false) {
      writer.uint32(64).bool(message.exceedsThreshold);
    }
    if (message.forecast !== undefined) {
      VolumeForecast.encode(message.forecast, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeatmapCell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeatmapCell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dayOfWeek = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.weekOfMonth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.transactionCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.intensityLevel = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.exceedsThreshold = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.forecast = VolumeForecast.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeatmapCell {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      dayOfWeek: isSet(object.dayOfWeek)
        ? globalThis.Number(object.dayOfWeek)
        : isSet(object.day_of_week)
        ? globalThis.Number(object.day_of_week)
        : 0,
      weekOfMonth: isSet(object.weekOfMonth)
        ? globalThis.Number(object.weekOfMonth)
        : isSet(object.week_of_month)
        ? globalThis.Number(object.week_of_month)
        : 0,
      transactionCount: isSet(object.transactionCount)
        ? globalThis.Number(object.transactionCount)
        : isSet(object.transaction_count)
        ? globalThis.Number(object.transaction_count)
        : 0,
      totalAmountCents: isSet(object.totalAmountCents)
        ? globalThis.Number(object.totalAmountCents)
        : isSet(object.total_amount_cents)
        ? globalThis.Number(object.total_amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      intensityLevel: isSet(object.intensityLevel)
        ? globalThis.String(object.intensityLevel)
        : isSet(object.intensity_level)
        ? globalThis.String(object.intensity_level)
        : "",
      exceedsThreshold: isSet(object.exceedsThreshold)
        ? globalThis.Boolean(object.exceedsThreshold)
        : isSet(object.exceeds_threshold)
        ? globalThis.Boolean(object.exceeds_threshold)
        : false,
      forecast: isSet(object.forecast) ? VolumeForecast.fromJSON(object.forecast) : undefined,
    };
  },

  toJSON(message: HeatmapCell): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = Math.round(message.dayOfWeek);
    }
    if (message.weekOfMonth !== 0) {
      obj.weekOfMonth = Math.round(message.weekOfMonth);
    }
    if (message.transactionCount !== 0) {
      obj.transactionCount = Math.round(message.transactionCount);
    }
    if (message.totalAmountCents !== 0) {
      obj.totalAmountCents = Math.round(message.totalAmountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.intensityLevel !== "") {
      obj.intensityLevel = message.intensityLevel;
    }
    if (message.exceedsThreshold !== false) {
      obj.exceedsThreshold = message.exceedsThreshold;
    }
    if (message.forecast !== undefined) {
      obj.forecast = VolumeForecast.toJSON(message.forecast);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeatmapCell>, I>>(base?: I): HeatmapCell {
    return HeatmapCell.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeatmapCell>, I>>(object: I): HeatmapCell {
    const message = createBaseHeatmapCell();
    message.date = object.date ?? "";
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.weekOfMonth = object.weekOfMonth ?? 0;
    message.transactionCount = object.transactionCount ?? 0;
    message.totalAmountCents = object.totalAmountCents ?? 0;
    message.currency = object.currency ?? "";
    message.intensityLevel = object.intensityLevel ?? "";
    message.exceedsThreshold = object.exceedsThreshold ?? false;
    message.forecast = (object.forecast !== undefined && object.forecast !== null)
      ? VolumeForecast.fromPartial(object.forecast)
      : undefined;
    return message;
  },
};

function createBaseExportCalendarCsvRequest(): ExportCalendarCsvRequest {
  return { organisationId: "", startDate: "", endDate: "", societeIds: [], batches: [], exportType: "" };
}

export const ExportCalendarCsvRequest: MessageFns<ExportCalendarCsvRequest> = {
  encode(message: ExportCalendarCsvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.startDate !== "") {
      writer.uint32(18).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(26).string(message.endDate);
    }
    for (const v of message.societeIds) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.batches) {
      writer.int32(v);
    }
    writer.join();
    if (message.exportType !== "") {
      writer.uint32(50).string(message.exportType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportCalendarCsvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportCalendarCsvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.batches.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.batches.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.exportType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportCalendarCsvRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : "",
      societeIds: globalThis.Array.isArray(object?.societeIds)
        ? object.societeIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.societe_ids)
        ? object.societe_ids.map((e: any) => globalThis.String(e))
        : [],
      batches: globalThis.Array.isArray(object?.batches)
        ? object.batches.map((e: any) => debitBatchFromJSON(e))
        : [],
      exportType: isSet(object.exportType)
        ? globalThis.String(object.exportType)
        : isSet(object.export_type)
        ? globalThis.String(object.export_type)
        : "",
    };
  },

  toJSON(message: ExportCalendarCsvRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.societeIds?.length) {
      obj.societeIds = message.societeIds;
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => debitBatchToJSON(e));
    }
    if (message.exportType !== "") {
      obj.exportType = message.exportType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportCalendarCsvRequest>, I>>(base?: I): ExportCalendarCsvRequest {
    return ExportCalendarCsvRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportCalendarCsvRequest>, I>>(object: I): ExportCalendarCsvRequest {
    const message = createBaseExportCalendarCsvRequest();
    message.organisationId = object.organisationId ?? "";
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.societeIds = object.societeIds?.map((e) => e) || [];
    message.batches = object.batches?.map((e) => e) || [];
    message.exportType = object.exportType ?? "";
    return message;
  },
};

function createBaseExportCalendarCsvResponse(): ExportCalendarCsvResponse {
  return { csvContent: new Uint8Array(0), filename: "", rowCount: 0 };
}

export const ExportCalendarCsvResponse: MessageFns<ExportCalendarCsvResponse> = {
  encode(message: ExportCalendarCsvResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.csvContent.length !== 0) {
      writer.uint32(10).bytes(message.csvContent);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.rowCount !== 0) {
      writer.uint32(24).int32(message.rowCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportCalendarCsvResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportCalendarCsvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.csvContent = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportCalendarCsvResponse {
    return {
      csvContent: isSet(object.csvContent)
        ? bytesFromBase64(object.csvContent)
        : isSet(object.csv_content)
        ? bytesFromBase64(object.csv_content)
        : new Uint8Array(0),
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      rowCount: isSet(object.rowCount)
        ? globalThis.Number(object.rowCount)
        : isSet(object.row_count)
        ? globalThis.Number(object.row_count)
        : 0,
    };
  },

  toJSON(message: ExportCalendarCsvResponse): unknown {
    const obj: any = {};
    if (message.csvContent.length !== 0) {
      obj.csvContent = base64FromBytes(message.csvContent);
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.rowCount !== 0) {
      obj.rowCount = Math.round(message.rowCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportCalendarCsvResponse>, I>>(base?: I): ExportCalendarCsvResponse {
    return ExportCalendarCsvResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportCalendarCsvResponse>, I>>(object: I): ExportCalendarCsvResponse {
    const message = createBaseExportCalendarCsvResponse();
    message.csvContent = object.csvContent ?? new Uint8Array(0);
    message.filename = object.filename ?? "";
    message.rowCount = object.rowCount ?? 0;
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pagination {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      sortBy: isSet(object.sortBy)
        ? globalThis.String(object.sortBy)
        : isSet(object.sort_by)
        ? globalThis.String(object.sort_by)
        : "",
      sortOrder: isSet(object.sortOrder)
        ? globalThis.String(object.sortOrder)
        : isSet(object.sort_order)
        ? globalThis.String(object.sort_order)
        : "",
    };
  },

  toJSON(message: Pagination): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pagination>, I>>(base?: I): Pagination {
    return Pagination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pagination>, I>>(object: I): Pagination {
    const message = createBasePagination();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResult {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: PaginationResult): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResult>, I>>(base?: I): PaginationResult {
    return PaginationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResult>, I>>(object: I): PaginationResult {
    const message = createBasePaginationResult();
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetSystemConfigRequest(): GetSystemConfigRequest {
  return { organisationId: "" };
}

export const GetSystemConfigRequest: MessageFns<GetSystemConfigRequest> = {
  encode(message: GetSystemConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSystemConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSystemConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSystemConfigRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
    };
  },

  toJSON(message: GetSystemConfigRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSystemConfigRequest>, I>>(base?: I): GetSystemConfigRequest {
    return GetSystemConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSystemConfigRequest>, I>>(object: I): GetSystemConfigRequest {
    const message = createBaseGetSystemConfigRequest();
    message.organisationId = object.organisationId ?? "";
    return message;
  },
};

function createBaseUpdateSystemConfigRequest(): UpdateSystemConfigRequest {
  return {
    organisationId: "",
    defaultMode: 0,
    defaultBatch: 0,
    defaultFixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
  };
}

export const UpdateSystemConfigRequest: MessageFns<UpdateSystemConfigRequest> = {
  encode(message: UpdateSystemConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.defaultMode !== 0) {
      writer.uint32(16).int32(message.defaultMode);
    }
    if (message.defaultBatch !== 0) {
      writer.uint32(24).int32(message.defaultBatch);
    }
    if (message.defaultFixedDay !== 0) {
      writer.uint32(32).int32(message.defaultFixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(58).string(message.cutoffConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSystemConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSystemConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.defaultMode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.defaultBatch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.defaultFixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSystemConfigRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      defaultMode: isSet(object.defaultMode)
        ? debitDateModeFromJSON(object.defaultMode)
        : isSet(object.default_mode)
        ? debitDateModeFromJSON(object.default_mode)
        : 0,
      defaultBatch: isSet(object.defaultBatch)
        ? debitBatchFromJSON(object.defaultBatch)
        : isSet(object.default_batch)
        ? debitBatchFromJSON(object.default_batch)
        : 0,
      defaultFixedDay: isSet(object.defaultFixedDay)
        ? globalThis.Number(object.defaultFixedDay)
        : isSet(object.default_fixed_day)
        ? globalThis.Number(object.default_fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      cutoffConfigId: isSet(object.cutoffConfigId)
        ? globalThis.String(object.cutoffConfigId)
        : isSet(object.cutoff_config_id)
        ? globalThis.String(object.cutoff_config_id)
        : "",
    };
  },

  toJSON(message: UpdateSystemConfigRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.defaultMode !== 0) {
      obj.defaultMode = debitDateModeToJSON(message.defaultMode);
    }
    if (message.defaultBatch !== 0) {
      obj.defaultBatch = debitBatchToJSON(message.defaultBatch);
    }
    if (message.defaultFixedDay !== 0) {
      obj.defaultFixedDay = Math.round(message.defaultFixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.cutoffConfigId !== "") {
      obj.cutoffConfigId = message.cutoffConfigId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSystemConfigRequest>, I>>(base?: I): UpdateSystemConfigRequest {
    return UpdateSystemConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSystemConfigRequest>, I>>(object: I): UpdateSystemConfigRequest {
    const message = createBaseUpdateSystemConfigRequest();
    message.organisationId = object.organisationId ?? "";
    message.defaultMode = object.defaultMode ?? 0;
    message.defaultBatch = object.defaultBatch ?? 0;
    message.defaultFixedDay = object.defaultFixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.cutoffConfigId = object.cutoffConfigId ?? "";
    return message;
  },
};

function createBaseCreateCompanyConfigRequest(): CreateCompanyConfigRequest {
  return {
    organisationId: "",
    societeId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
  };
}

export const CreateCompanyConfigRequest: MessageFns<CreateCompanyConfigRequest> = {
  encode(message: CreateCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(66).string(message.cutoffConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCompanyConfigRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      cutoffConfigId: isSet(object.cutoffConfigId)
        ? globalThis.String(object.cutoffConfigId)
        : isSet(object.cutoff_config_id)
        ? globalThis.String(object.cutoff_config_id)
        : "",
    };
  },

  toJSON(message: CreateCompanyConfigRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.cutoffConfigId !== "") {
      obj.cutoffConfigId = message.cutoffConfigId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCompanyConfigRequest>, I>>(base?: I): CreateCompanyConfigRequest {
    return CreateCompanyConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCompanyConfigRequest>, I>>(object: I): CreateCompanyConfigRequest {
    const message = createBaseCreateCompanyConfigRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.cutoffConfigId = object.cutoffConfigId ?? "";
    return message;
  },
};

function createBaseUpdateCompanyConfigRequest(): UpdateCompanyConfigRequest {
  return {
    id: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
    isActive: false,
  };
}

export const UpdateCompanyConfigRequest: MessageFns<UpdateCompanyConfigRequest> = {
  encode(message: UpdateCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(24).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(32).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(58).string(message.cutoffConfigId);
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCompanyConfigRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      cutoffConfigId: isSet(object.cutoffConfigId)
        ? globalThis.String(object.cutoffConfigId)
        : isSet(object.cutoff_config_id)
        ? globalThis.String(object.cutoff_config_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: UpdateCompanyConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.cutoffConfigId !== "") {
      obj.cutoffConfigId = message.cutoffConfigId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCompanyConfigRequest>, I>>(base?: I): UpdateCompanyConfigRequest {
    return UpdateCompanyConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCompanyConfigRequest>, I>>(object: I): UpdateCompanyConfigRequest {
    const message = createBaseUpdateCompanyConfigRequest();
    message.id = object.id ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.cutoffConfigId = object.cutoffConfigId ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetCompanyConfigRequest(): GetCompanyConfigRequest {
  return { id: "" };
}

export const GetCompanyConfigRequest: MessageFns<GetCompanyConfigRequest> = {
  encode(message: GetCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCompanyConfigRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetCompanyConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCompanyConfigRequest>, I>>(base?: I): GetCompanyConfigRequest {
    return GetCompanyConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCompanyConfigRequest>, I>>(object: I): GetCompanyConfigRequest {
    const message = createBaseGetCompanyConfigRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListCompanyConfigsRequest(): ListCompanyConfigsRequest {
  return { organisationId: "", societeId: "", pagination: undefined };
}

export const ListCompanyConfigsRequest: MessageFns<ListCompanyConfigsRequest> = {
  encode(message: ListCompanyConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCompanyConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCompanyConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCompanyConfigsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListCompanyConfigsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCompanyConfigsRequest>, I>>(base?: I): ListCompanyConfigsRequest {
    return ListCompanyConfigsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCompanyConfigsRequest>, I>>(object: I): ListCompanyConfigsRequest {
    const message = createBaseListCompanyConfigsRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListCompanyConfigsResponse(): ListCompanyConfigsResponse {
  return { configs: [], pagination: undefined };
}

export const ListCompanyConfigsResponse: MessageFns<ListCompanyConfigsResponse> = {
  encode(message: ListCompanyConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      CompanyDebitConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCompanyConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCompanyConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(CompanyDebitConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCompanyConfigsResponse {
    return {
      configs: globalThis.Array.isArray(object?.configs)
        ? object.configs.map((e: any) => CompanyDebitConfiguration.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListCompanyConfigsResponse): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => CompanyDebitConfiguration.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCompanyConfigsResponse>, I>>(base?: I): ListCompanyConfigsResponse {
    return ListCompanyConfigsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCompanyConfigsResponse>, I>>(object: I): ListCompanyConfigsResponse {
    const message = createBaseListCompanyConfigsResponse();
    message.configs = object.configs?.map((e) => CompanyDebitConfiguration.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteCompanyConfigRequest(): DeleteCompanyConfigRequest {
  return { id: "" };
}

export const DeleteCompanyConfigRequest: MessageFns<DeleteCompanyConfigRequest> = {
  encode(message: DeleteCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCompanyConfigRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteCompanyConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCompanyConfigRequest>, I>>(base?: I): DeleteCompanyConfigRequest {
    return DeleteCompanyConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCompanyConfigRequest>, I>>(object: I): DeleteCompanyConfigRequest {
    const message = createBaseDeleteCompanyConfigRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateClientConfigRequest(): CreateClientConfigRequest {
  return { organisationId: "", clientId: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "" };
}

export const CreateClientConfigRequest: MessageFns<CreateClientConfigRequest> = {
  encode(message: CreateClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClientConfigRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
    };
  },

  toJSON(message: CreateClientConfigRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateClientConfigRequest>, I>>(base?: I): CreateClientConfigRequest {
    return CreateClientConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateClientConfigRequest>, I>>(object: I): CreateClientConfigRequest {
    const message = createBaseCreateClientConfigRequest();
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    return message;
  },
};

function createBaseUpdateClientConfigRequest(): UpdateClientConfigRequest {
  return { id: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "", isActive: false };
}

export const UpdateClientConfigRequest: MessageFns<UpdateClientConfigRequest> = {
  encode(message: UpdateClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(24).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(32).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClientConfigRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: UpdateClientConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClientConfigRequest>, I>>(base?: I): UpdateClientConfigRequest {
    return UpdateClientConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClientConfigRequest>, I>>(object: I): UpdateClientConfigRequest {
    const message = createBaseUpdateClientConfigRequest();
    message.id = object.id ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetClientConfigRequest(): GetClientConfigRequest {
  return { id: "" };
}

export const GetClientConfigRequest: MessageFns<GetClientConfigRequest> = {
  encode(message: GetClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClientConfigRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetClientConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClientConfigRequest>, I>>(base?: I): GetClientConfigRequest {
    return GetClientConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClientConfigRequest>, I>>(object: I): GetClientConfigRequest {
    const message = createBaseGetClientConfigRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListClientConfigsRequest(): ListClientConfigsRequest {
  return { organisationId: "", clientId: "", pagination: undefined };
}

export const ListClientConfigsRequest: MessageFns<ListClientConfigsRequest> = {
  encode(message: ListClientConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClientConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClientConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClientConfigsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListClientConfigsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListClientConfigsRequest>, I>>(base?: I): ListClientConfigsRequest {
    return ListClientConfigsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListClientConfigsRequest>, I>>(object: I): ListClientConfigsRequest {
    const message = createBaseListClientConfigsRequest();
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListClientConfigsResponse(): ListClientConfigsResponse {
  return { configs: [], pagination: undefined };
}

export const ListClientConfigsResponse: MessageFns<ListClientConfigsResponse> = {
  encode(message: ListClientConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      ClientDebitConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClientConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClientConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(ClientDebitConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClientConfigsResponse {
    return {
      configs: globalThis.Array.isArray(object?.configs)
        ? object.configs.map((e: any) => ClientDebitConfiguration.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListClientConfigsResponse): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => ClientDebitConfiguration.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListClientConfigsResponse>, I>>(base?: I): ListClientConfigsResponse {
    return ListClientConfigsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListClientConfigsResponse>, I>>(object: I): ListClientConfigsResponse {
    const message = createBaseListClientConfigsResponse();
    message.configs = object.configs?.map((e) => ClientDebitConfiguration.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteClientConfigRequest(): DeleteClientConfigRequest {
  return { id: "" };
}

export const DeleteClientConfigRequest: MessageFns<DeleteClientConfigRequest> = {
  encode(message: DeleteClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClientConfigRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteClientConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteClientConfigRequest>, I>>(base?: I): DeleteClientConfigRequest {
    return DeleteClientConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteClientConfigRequest>, I>>(object: I): DeleteClientConfigRequest {
    const message = createBaseDeleteClientConfigRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateContractConfigRequest(): CreateContractConfigRequest {
  return { organisationId: "", contratId: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "" };
}

export const CreateContractConfigRequest: MessageFns<CreateContractConfigRequest> = {
  encode(message: CreateContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateContractConfigRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
    };
  },

  toJSON(message: CreateContractConfigRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateContractConfigRequest>, I>>(base?: I): CreateContractConfigRequest {
    return CreateContractConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateContractConfigRequest>, I>>(object: I): CreateContractConfigRequest {
    const message = createBaseCreateContractConfigRequest();
    message.organisationId = object.organisationId ?? "";
    message.contratId = object.contratId ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    return message;
  },
};

function createBaseUpdateContractConfigRequest(): UpdateContractConfigRequest {
  return { id: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "", isActive: false };
}

export const UpdateContractConfigRequest: MessageFns<UpdateContractConfigRequest> = {
  encode(message: UpdateContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(24).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(32).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateContractConfigRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      mode: isSet(object.mode) ? debitDateModeFromJSON(object.mode) : 0,
      batch: isSet(object.batch) ? debitBatchFromJSON(object.batch) : 0,
      fixedDay: isSet(object.fixedDay)
        ? globalThis.Number(object.fixedDay)
        : isSet(object.fixed_day)
        ? globalThis.Number(object.fixed_day)
        : 0,
      shiftStrategy: isSet(object.shiftStrategy)
        ? dateShiftStrategyFromJSON(object.shiftStrategy)
        : isSet(object.shift_strategy)
        ? dateShiftStrategyFromJSON(object.shift_strategy)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: UpdateContractConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.mode !== 0) {
      obj.mode = debitDateModeToJSON(message.mode);
    }
    if (message.batch !== 0) {
      obj.batch = debitBatchToJSON(message.batch);
    }
    if (message.fixedDay !== 0) {
      obj.fixedDay = Math.round(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      obj.shiftStrategy = dateShiftStrategyToJSON(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateContractConfigRequest>, I>>(base?: I): UpdateContractConfigRequest {
    return UpdateContractConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateContractConfigRequest>, I>>(object: I): UpdateContractConfigRequest {
    const message = createBaseUpdateContractConfigRequest();
    message.id = object.id ?? "";
    message.mode = object.mode ?? 0;
    message.batch = object.batch ?? 0;
    message.fixedDay = object.fixedDay ?? 0;
    message.shiftStrategy = object.shiftStrategy ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetContractConfigRequest(): GetContractConfigRequest {
  return { id: "" };
}

export const GetContractConfigRequest: MessageFns<GetContractConfigRequest> = {
  encode(message: GetContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContractConfigRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetContractConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContractConfigRequest>, I>>(base?: I): GetContractConfigRequest {
    return GetContractConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContractConfigRequest>, I>>(object: I): GetContractConfigRequest {
    const message = createBaseGetContractConfigRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListContractConfigsRequest(): ListContractConfigsRequest {
  return { organisationId: "", contratId: "", pagination: undefined };
}

export const ListContractConfigsRequest: MessageFns<ListContractConfigsRequest> = {
  encode(message: ListContractConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContractConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContractConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContractConfigsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListContractConfigsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListContractConfigsRequest>, I>>(base?: I): ListContractConfigsRequest {
    return ListContractConfigsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListContractConfigsRequest>, I>>(object: I): ListContractConfigsRequest {
    const message = createBaseListContractConfigsRequest();
    message.organisationId = object.organisationId ?? "";
    message.contratId = object.contratId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListContractConfigsResponse(): ListContractConfigsResponse {
  return { configs: [], pagination: undefined };
}

export const ListContractConfigsResponse: MessageFns<ListContractConfigsResponse> = {
  encode(message: ListContractConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      ContractDebitConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContractConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContractConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(ContractDebitConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContractConfigsResponse {
    return {
      configs: globalThis.Array.isArray(object?.configs)
        ? object.configs.map((e: any) => ContractDebitConfiguration.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListContractConfigsResponse): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs.map((e) => ContractDebitConfiguration.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListContractConfigsResponse>, I>>(base?: I): ListContractConfigsResponse {
    return ListContractConfigsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListContractConfigsResponse>, I>>(object: I): ListContractConfigsResponse {
    const message = createBaseListContractConfigsResponse();
    message.configs = object.configs?.map((e) => ContractDebitConfiguration.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteContractConfigRequest(): DeleteContractConfigRequest {
  return { id: "" };
}

export const DeleteContractConfigRequest: MessageFns<DeleteContractConfigRequest> = {
  encode(message: DeleteContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteContractConfigRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteContractConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteContractConfigRequest>, I>>(base?: I): DeleteContractConfigRequest {
    return DeleteContractConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteContractConfigRequest>, I>>(object: I): DeleteContractConfigRequest {
    const message = createBaseDeleteContractConfigRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseResolveConfigurationRequest(): ResolveConfigurationRequest {
  return { organisationId: "", contratId: "", clientId: "", societeId: "" };
}

export const ResolveConfigurationRequest: MessageFns<ResolveConfigurationRequest> = {
  encode(message: ResolveConfigurationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(34).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveConfigurationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResolveConfigurationRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: ResolveConfigurationRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResolveConfigurationRequest>, I>>(base?: I): ResolveConfigurationRequest {
    return ResolveConfigurationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResolveConfigurationRequest>, I>>(object: I): ResolveConfigurationRequest {
    const message = createBaseResolveConfigurationRequest();
    message.organisationId = object.organisationId ?? "";
    message.contratId = object.contratId ?? "";
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateHolidayZoneRequest(): CreateHolidayZoneRequest {
  return { organisationId: "", code: "", name: "", countryCode: "", regionCode: "" };
}

export const CreateHolidayZoneRequest: MessageFns<CreateHolidayZoneRequest> = {
  encode(message: CreateHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(34).string(message.countryCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(42).string(message.regionCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateHolidayZoneRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      countryCode: isSet(object.countryCode)
        ? globalThis.String(object.countryCode)
        : isSet(object.country_code)
        ? globalThis.String(object.country_code)
        : "",
      regionCode: isSet(object.regionCode)
        ? globalThis.String(object.regionCode)
        : isSet(object.region_code)
        ? globalThis.String(object.region_code)
        : "",
    };
  },

  toJSON(message: CreateHolidayZoneRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateHolidayZoneRequest>, I>>(base?: I): CreateHolidayZoneRequest {
    return CreateHolidayZoneRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateHolidayZoneRequest>, I>>(object: I): CreateHolidayZoneRequest {
    const message = createBaseCreateHolidayZoneRequest();
    message.organisationId = object.organisationId ?? "";
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    message.countryCode = object.countryCode ?? "";
    message.regionCode = object.regionCode ?? "";
    return message;
  },
};

function createBaseUpdateHolidayZoneRequest(): UpdateHolidayZoneRequest {
  return { id: "", code: "", name: "", countryCode: "", regionCode: "", isActive: false };
}

export const UpdateHolidayZoneRequest: MessageFns<UpdateHolidayZoneRequest> = {
  encode(message: UpdateHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(34).string(message.countryCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(42).string(message.regionCode);
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateHolidayZoneRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      countryCode: isSet(object.countryCode)
        ? globalThis.String(object.countryCode)
        : isSet(object.country_code)
        ? globalThis.String(object.country_code)
        : "",
      regionCode: isSet(object.regionCode)
        ? globalThis.String(object.regionCode)
        : isSet(object.region_code)
        ? globalThis.String(object.region_code)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: UpdateHolidayZoneRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateHolidayZoneRequest>, I>>(base?: I): UpdateHolidayZoneRequest {
    return UpdateHolidayZoneRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateHolidayZoneRequest>, I>>(object: I): UpdateHolidayZoneRequest {
    const message = createBaseUpdateHolidayZoneRequest();
    message.id = object.id ?? "";
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    message.countryCode = object.countryCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetHolidayZoneRequest(): GetHolidayZoneRequest {
  return { id: "" };
}

export const GetHolidayZoneRequest: MessageFns<GetHolidayZoneRequest> = {
  encode(message: GetHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHolidayZoneRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetHolidayZoneRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHolidayZoneRequest>, I>>(base?: I): GetHolidayZoneRequest {
    return GetHolidayZoneRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHolidayZoneRequest>, I>>(object: I): GetHolidayZoneRequest {
    const message = createBaseGetHolidayZoneRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListHolidayZonesRequest(): ListHolidayZonesRequest {
  return { organisationId: "", countryCode: "", pagination: undefined };
}

export const ListHolidayZonesRequest: MessageFns<ListHolidayZonesRequest> = {
  encode(message: ListHolidayZonesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.countryCode !== "") {
      writer.uint32(18).string(message.countryCode);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidayZonesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidayZonesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHolidayZonesRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      countryCode: isSet(object.countryCode)
        ? globalThis.String(object.countryCode)
        : isSet(object.country_code)
        ? globalThis.String(object.country_code)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListHolidayZonesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHolidayZonesRequest>, I>>(base?: I): ListHolidayZonesRequest {
    return ListHolidayZonesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHolidayZonesRequest>, I>>(object: I): ListHolidayZonesRequest {
    const message = createBaseListHolidayZonesRequest();
    message.organisationId = object.organisationId ?? "";
    message.countryCode = object.countryCode ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListHolidayZonesResponse(): ListHolidayZonesResponse {
  return { zones: [], pagination: undefined };
}

export const ListHolidayZonesResponse: MessageFns<ListHolidayZonesResponse> = {
  encode(message: ListHolidayZonesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.zones) {
      HolidayZone.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidayZonesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidayZonesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.zones.push(HolidayZone.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHolidayZonesResponse {
    return {
      zones: globalThis.Array.isArray(object?.zones) ? object.zones.map((e: any) => HolidayZone.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListHolidayZonesResponse): unknown {
    const obj: any = {};
    if (message.zones?.length) {
      obj.zones = message.zones.map((e) => HolidayZone.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHolidayZonesResponse>, I>>(base?: I): ListHolidayZonesResponse {
    return ListHolidayZonesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHolidayZonesResponse>, I>>(object: I): ListHolidayZonesResponse {
    const message = createBaseListHolidayZonesResponse();
    message.zones = object.zones?.map((e) => HolidayZone.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteHolidayZoneRequest(): DeleteHolidayZoneRequest {
  return { id: "" };
}

export const DeleteHolidayZoneRequest: MessageFns<DeleteHolidayZoneRequest> = {
  encode(message: DeleteHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteHolidayZoneRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteHolidayZoneRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteHolidayZoneRequest>, I>>(base?: I): DeleteHolidayZoneRequest {
    return DeleteHolidayZoneRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteHolidayZoneRequest>, I>>(object: I): DeleteHolidayZoneRequest {
    const message = createBaseDeleteHolidayZoneRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateHolidayRequest(): CreateHolidayRequest {
  return {
    holidayZoneId: "",
    date: "",
    name: "",
    holidayType: 0,
    isRecurring: false,
    recurringMonth: 0,
    recurringDay: 0,
  };
}

export const CreateHolidayRequest: MessageFns<CreateHolidayRequest> = {
  encode(message: CreateHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.holidayZoneId !== "") {
      writer.uint32(10).string(message.holidayZoneId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.holidayType !== 0) {
      writer.uint32(32).int32(message.holidayType);
    }
    if (message.isRecurring !== false) {
      writer.uint32(40).bool(message.isRecurring);
    }
    if (message.recurringMonth !== 0) {
      writer.uint32(48).int32(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      writer.uint32(56).int32(message.recurringDay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.holidayType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRecurring = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.recurringMonth = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recurringDay = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateHolidayRequest {
    return {
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      holidayType: isSet(object.holidayType)
        ? holidayTypeFromJSON(object.holidayType)
        : isSet(object.holiday_type)
        ? holidayTypeFromJSON(object.holiday_type)
        : 0,
      isRecurring: isSet(object.isRecurring)
        ? globalThis.Boolean(object.isRecurring)
        : isSet(object.is_recurring)
        ? globalThis.Boolean(object.is_recurring)
        : false,
      recurringMonth: isSet(object.recurringMonth)
        ? globalThis.Number(object.recurringMonth)
        : isSet(object.recurring_month)
        ? globalThis.Number(object.recurring_month)
        : 0,
      recurringDay: isSet(object.recurringDay)
        ? globalThis.Number(object.recurringDay)
        : isSet(object.recurring_day)
        ? globalThis.Number(object.recurring_day)
        : 0,
    };
  },

  toJSON(message: CreateHolidayRequest): unknown {
    const obj: any = {};
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.holidayType !== 0) {
      obj.holidayType = holidayTypeToJSON(message.holidayType);
    }
    if (message.isRecurring !== false) {
      obj.isRecurring = message.isRecurring;
    }
    if (message.recurringMonth !== 0) {
      obj.recurringMonth = Math.round(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      obj.recurringDay = Math.round(message.recurringDay);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateHolidayRequest>, I>>(base?: I): CreateHolidayRequest {
    return CreateHolidayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateHolidayRequest>, I>>(object: I): CreateHolidayRequest {
    const message = createBaseCreateHolidayRequest();
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.date = object.date ?? "";
    message.name = object.name ?? "";
    message.holidayType = object.holidayType ?? 0;
    message.isRecurring = object.isRecurring ?? false;
    message.recurringMonth = object.recurringMonth ?? 0;
    message.recurringDay = object.recurringDay ?? 0;
    return message;
  },
};

function createBaseUpdateHolidayRequest(): UpdateHolidayRequest {
  return {
    id: "",
    date: "",
    name: "",
    holidayType: 0,
    isRecurring: false,
    recurringMonth: 0,
    recurringDay: 0,
    isActive: false,
  };
}

export const UpdateHolidayRequest: MessageFns<UpdateHolidayRequest> = {
  encode(message: UpdateHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.holidayType !== 0) {
      writer.uint32(32).int32(message.holidayType);
    }
    if (message.isRecurring !== false) {
      writer.uint32(40).bool(message.isRecurring);
    }
    if (message.recurringMonth !== 0) {
      writer.uint32(48).int32(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      writer.uint32(56).int32(message.recurringDay);
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.holidayType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRecurring = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.recurringMonth = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recurringDay = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateHolidayRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      holidayType: isSet(object.holidayType)
        ? holidayTypeFromJSON(object.holidayType)
        : isSet(object.holiday_type)
        ? holidayTypeFromJSON(object.holiday_type)
        : 0,
      isRecurring: isSet(object.isRecurring)
        ? globalThis.Boolean(object.isRecurring)
        : isSet(object.is_recurring)
        ? globalThis.Boolean(object.is_recurring)
        : false,
      recurringMonth: isSet(object.recurringMonth)
        ? globalThis.Number(object.recurringMonth)
        : isSet(object.recurring_month)
        ? globalThis.Number(object.recurring_month)
        : 0,
      recurringDay: isSet(object.recurringDay)
        ? globalThis.Number(object.recurringDay)
        : isSet(object.recurring_day)
        ? globalThis.Number(object.recurring_day)
        : 0,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: UpdateHolidayRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.holidayType !== 0) {
      obj.holidayType = holidayTypeToJSON(message.holidayType);
    }
    if (message.isRecurring !== false) {
      obj.isRecurring = message.isRecurring;
    }
    if (message.recurringMonth !== 0) {
      obj.recurringMonth = Math.round(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      obj.recurringDay = Math.round(message.recurringDay);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateHolidayRequest>, I>>(base?: I): UpdateHolidayRequest {
    return UpdateHolidayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateHolidayRequest>, I>>(object: I): UpdateHolidayRequest {
    const message = createBaseUpdateHolidayRequest();
    message.id = object.id ?? "";
    message.date = object.date ?? "";
    message.name = object.name ?? "";
    message.holidayType = object.holidayType ?? 0;
    message.isRecurring = object.isRecurring ?? false;
    message.recurringMonth = object.recurringMonth ?? 0;
    message.recurringDay = object.recurringDay ?? 0;
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetHolidayRequest(): GetHolidayRequest {
  return { id: "" };
}

export const GetHolidayRequest: MessageFns<GetHolidayRequest> = {
  encode(message: GetHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHolidayRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetHolidayRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHolidayRequest>, I>>(base?: I): GetHolidayRequest {
    return GetHolidayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHolidayRequest>, I>>(object: I): GetHolidayRequest {
    const message = createBaseGetHolidayRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListHolidaysRequest(): ListHolidaysRequest {
  return { holidayZoneId: "", year: 0, pagination: undefined };
}

export const ListHolidaysRequest: MessageFns<ListHolidaysRequest> = {
  encode(message: ListHolidaysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.holidayZoneId !== "") {
      writer.uint32(10).string(message.holidayZoneId);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidaysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidaysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHolidaysRequest {
    return {
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListHolidaysRequest): unknown {
    const obj: any = {};
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHolidaysRequest>, I>>(base?: I): ListHolidaysRequest {
    return ListHolidaysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHolidaysRequest>, I>>(object: I): ListHolidaysRequest {
    const message = createBaseListHolidaysRequest();
    message.holidayZoneId = object.holidayZoneId ?? "";
    message.year = object.year ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListHolidaysResponse(): ListHolidaysResponse {
  return { holidays: [], pagination: undefined };
}

export const ListHolidaysResponse: MessageFns<ListHolidaysResponse> = {
  encode(message: ListHolidaysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.holidays) {
      Holiday.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidaysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidaysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holidays.push(Holiday.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHolidaysResponse {
    return {
      holidays: globalThis.Array.isArray(object?.holidays) ? object.holidays.map((e: any) => Holiday.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListHolidaysResponse): unknown {
    const obj: any = {};
    if (message.holidays?.length) {
      obj.holidays = message.holidays.map((e) => Holiday.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHolidaysResponse>, I>>(base?: I): ListHolidaysResponse {
    return ListHolidaysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHolidaysResponse>, I>>(object: I): ListHolidaysResponse {
    const message = createBaseListHolidaysResponse();
    message.holidays = object.holidays?.map((e) => Holiday.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteHolidayRequest(): DeleteHolidayRequest {
  return { id: "" };
}

export const DeleteHolidayRequest: MessageFns<DeleteHolidayRequest> = {
  encode(message: DeleteHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteHolidayRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteHolidayRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteHolidayRequest>, I>>(base?: I): DeleteHolidayRequest {
    return DeleteHolidayRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteHolidayRequest>, I>>(object: I): DeleteHolidayRequest {
    const message = createBaseDeleteHolidayRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseImportHolidaysByCountryRequest(): ImportHolidaysByCountryRequest {
  return { organisationId: "", countryCode: "", year: 0, includeRegional: false };
}

export const ImportHolidaysByCountryRequest: MessageFns<ImportHolidaysByCountryRequest> = {
  encode(message: ImportHolidaysByCountryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.countryCode !== "") {
      writer.uint32(18).string(message.countryCode);
    }
    if (message.year !== 0) {
      writer.uint32(24).int32(message.year);
    }
    if (message.includeRegional !== false) {
      writer.uint32(32).bool(message.includeRegional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportHolidaysByCountryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportHolidaysByCountryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeRegional = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportHolidaysByCountryRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      countryCode: isSet(object.countryCode)
        ? globalThis.String(object.countryCode)
        : isSet(object.country_code)
        ? globalThis.String(object.country_code)
        : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      includeRegional: isSet(object.includeRegional)
        ? globalThis.Boolean(object.includeRegional)
        : isSet(object.include_regional)
        ? globalThis.Boolean(object.include_regional)
        : false,
    };
  },

  toJSON(message: ImportHolidaysByCountryRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.includeRegional !== false) {
      obj.includeRegional = message.includeRegional;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportHolidaysByCountryRequest>, I>>(base?: I): ImportHolidaysByCountryRequest {
    return ImportHolidaysByCountryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportHolidaysByCountryRequest>, I>>(
    object: I,
  ): ImportHolidaysByCountryRequest {
    const message = createBaseImportHolidaysByCountryRequest();
    message.organisationId = object.organisationId ?? "";
    message.countryCode = object.countryCode ?? "";
    message.year = object.year ?? 0;
    message.includeRegional = object.includeRegional ?? false;
    return message;
  },
};

function createBaseImportHolidaysByCountryResponse(): ImportHolidaysByCountryResponse {
  return { success: false, importedCount: 0, holidayZoneId: "" };
}

export const ImportHolidaysByCountryResponse: MessageFns<ImportHolidaysByCountryResponse> = {
  encode(message: ImportHolidaysByCountryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.importedCount !== 0) {
      writer.uint32(16).int32(message.importedCount);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(26).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportHolidaysByCountryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportHolidaysByCountryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.importedCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportHolidaysByCountryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      importedCount: isSet(object.importedCount)
        ? globalThis.Number(object.importedCount)
        : isSet(object.imported_count)
        ? globalThis.Number(object.imported_count)
        : 0,
      holidayZoneId: isSet(object.holidayZoneId)
        ? globalThis.String(object.holidayZoneId)
        : isSet(object.holiday_zone_id)
        ? globalThis.String(object.holiday_zone_id)
        : "",
    };
  },

  toJSON(message: ImportHolidaysByCountryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.importedCount !== 0) {
      obj.importedCount = Math.round(message.importedCount);
    }
    if (message.holidayZoneId !== "") {
      obj.holidayZoneId = message.holidayZoneId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportHolidaysByCountryResponse>, I>>(base?: I): ImportHolidaysByCountryResponse {
    return ImportHolidaysByCountryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportHolidaysByCountryResponse>, I>>(
    object: I,
  ): ImportHolidaysByCountryResponse {
    const message = createBaseImportHolidaysByCountryResponse();
    message.success = object.success ?? false;
    message.importedCount = object.importedCount ?? 0;
    message.holidayZoneId = object.holidayZoneId ?? "";
    return message;
  },
};

function createBaseCreateVolumeThresholdRequest(): CreateVolumeThresholdRequest {
  return {
    organisationId: "",
    societeId: "",
    maxTransactionCount: 0,
    maxAmountCents: 0,
    currency: "",
    alertOnExceed: false,
    alertEmail: "",
  };
}

export const CreateVolumeThresholdRequest: MessageFns<CreateVolumeThresholdRequest> = {
  encode(message: CreateVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.maxTransactionCount !== 0) {
      writer.uint32(24).int32(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      writer.uint32(32).int64(message.maxAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.alertOnExceed !== false) {
      writer.uint32(48).bool(message.alertOnExceed);
    }
    if (message.alertEmail !== "") {
      writer.uint32(58).string(message.alertEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxTransactionCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.alertOnExceed = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.alertEmail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVolumeThresholdRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      maxTransactionCount: isSet(object.maxTransactionCount)
        ? globalThis.Number(object.maxTransactionCount)
        : isSet(object.max_transaction_count)
        ? globalThis.Number(object.max_transaction_count)
        : 0,
      maxAmountCents: isSet(object.maxAmountCents)
        ? globalThis.Number(object.maxAmountCents)
        : isSet(object.max_amount_cents)
        ? globalThis.Number(object.max_amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      alertOnExceed: isSet(object.alertOnExceed)
        ? globalThis.Boolean(object.alertOnExceed)
        : isSet(object.alert_on_exceed)
        ? globalThis.Boolean(object.alert_on_exceed)
        : false,
      alertEmail: isSet(object.alertEmail)
        ? globalThis.String(object.alertEmail)
        : isSet(object.alert_email)
        ? globalThis.String(object.alert_email)
        : "",
    };
  },

  toJSON(message: CreateVolumeThresholdRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.maxTransactionCount !== 0) {
      obj.maxTransactionCount = Math.round(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      obj.maxAmountCents = Math.round(message.maxAmountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.alertOnExceed !== false) {
      obj.alertOnExceed = message.alertOnExceed;
    }
    if (message.alertEmail !== "") {
      obj.alertEmail = message.alertEmail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateVolumeThresholdRequest>, I>>(base?: I): CreateVolumeThresholdRequest {
    return CreateVolumeThresholdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateVolumeThresholdRequest>, I>>(object: I): CreateVolumeThresholdRequest {
    const message = createBaseCreateVolumeThresholdRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.maxTransactionCount = object.maxTransactionCount ?? 0;
    message.maxAmountCents = object.maxAmountCents ?? 0;
    message.currency = object.currency ?? "";
    message.alertOnExceed = object.alertOnExceed ?? false;
    message.alertEmail = object.alertEmail ?? "";
    return message;
  },
};

function createBaseUpdateVolumeThresholdRequest(): UpdateVolumeThresholdRequest {
  return {
    id: "",
    maxTransactionCount: 0,
    maxAmountCents: 0,
    currency: "",
    alertOnExceed: false,
    alertEmail: "",
    isActive: false,
  };
}

export const UpdateVolumeThresholdRequest: MessageFns<UpdateVolumeThresholdRequest> = {
  encode(message: UpdateVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.maxTransactionCount !== 0) {
      writer.uint32(16).int32(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      writer.uint32(24).int64(message.maxAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.alertOnExceed !== false) {
      writer.uint32(40).bool(message.alertOnExceed);
    }
    if (message.alertEmail !== "") {
      writer.uint32(50).string(message.alertEmail);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxTransactionCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.alertOnExceed = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.alertEmail = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVolumeThresholdRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      maxTransactionCount: isSet(object.maxTransactionCount)
        ? globalThis.Number(object.maxTransactionCount)
        : isSet(object.max_transaction_count)
        ? globalThis.Number(object.max_transaction_count)
        : 0,
      maxAmountCents: isSet(object.maxAmountCents)
        ? globalThis.Number(object.maxAmountCents)
        : isSet(object.max_amount_cents)
        ? globalThis.Number(object.max_amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      alertOnExceed: isSet(object.alertOnExceed)
        ? globalThis.Boolean(object.alertOnExceed)
        : isSet(object.alert_on_exceed)
        ? globalThis.Boolean(object.alert_on_exceed)
        : false,
      alertEmail: isSet(object.alertEmail)
        ? globalThis.String(object.alertEmail)
        : isSet(object.alert_email)
        ? globalThis.String(object.alert_email)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: UpdateVolumeThresholdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.maxTransactionCount !== 0) {
      obj.maxTransactionCount = Math.round(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      obj.maxAmountCents = Math.round(message.maxAmountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.alertOnExceed !== false) {
      obj.alertOnExceed = message.alertOnExceed;
    }
    if (message.alertEmail !== "") {
      obj.alertEmail = message.alertEmail;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateVolumeThresholdRequest>, I>>(base?: I): UpdateVolumeThresholdRequest {
    return UpdateVolumeThresholdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateVolumeThresholdRequest>, I>>(object: I): UpdateVolumeThresholdRequest {
    const message = createBaseUpdateVolumeThresholdRequest();
    message.id = object.id ?? "";
    message.maxTransactionCount = object.maxTransactionCount ?? 0;
    message.maxAmountCents = object.maxAmountCents ?? 0;
    message.currency = object.currency ?? "";
    message.alertOnExceed = object.alertOnExceed ?? false;
    message.alertEmail = object.alertEmail ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseGetVolumeThresholdRequest(): GetVolumeThresholdRequest {
  return { id: "" };
}

export const GetVolumeThresholdRequest: MessageFns<GetVolumeThresholdRequest> = {
  encode(message: GetVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVolumeThresholdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetVolumeThresholdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetVolumeThresholdRequest>, I>>(base?: I): GetVolumeThresholdRequest {
    return GetVolumeThresholdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetVolumeThresholdRequest>, I>>(object: I): GetVolumeThresholdRequest {
    const message = createBaseGetVolumeThresholdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListVolumeThresholdsRequest(): ListVolumeThresholdsRequest {
  return { organisationId: "", societeId: "", pagination: undefined };
}

export const ListVolumeThresholdsRequest: MessageFns<ListVolumeThresholdsRequest> = {
  encode(message: ListVolumeThresholdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumeThresholdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumeThresholdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVolumeThresholdsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListVolumeThresholdsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListVolumeThresholdsRequest>, I>>(base?: I): ListVolumeThresholdsRequest {
    return ListVolumeThresholdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListVolumeThresholdsRequest>, I>>(object: I): ListVolumeThresholdsRequest {
    const message = createBaseListVolumeThresholdsRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListVolumeThresholdsResponse(): ListVolumeThresholdsResponse {
  return { thresholds: [], pagination: undefined };
}

export const ListVolumeThresholdsResponse: MessageFns<ListVolumeThresholdsResponse> = {
  encode(message: ListVolumeThresholdsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.thresholds) {
      VolumeThreshold.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumeThresholdsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumeThresholdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.thresholds.push(VolumeThreshold.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVolumeThresholdsResponse {
    return {
      thresholds: globalThis.Array.isArray(object?.thresholds)
        ? object.thresholds.map((e: any) => VolumeThreshold.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListVolumeThresholdsResponse): unknown {
    const obj: any = {};
    if (message.thresholds?.length) {
      obj.thresholds = message.thresholds.map((e) => VolumeThreshold.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListVolumeThresholdsResponse>, I>>(base?: I): ListVolumeThresholdsResponse {
    return ListVolumeThresholdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListVolumeThresholdsResponse>, I>>(object: I): ListVolumeThresholdsResponse {
    const message = createBaseListVolumeThresholdsResponse();
    message.thresholds = object.thresholds?.map((e) => VolumeThreshold.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseDeleteVolumeThresholdRequest(): DeleteVolumeThresholdRequest {
  return { id: "" };
}

export const DeleteVolumeThresholdRequest: MessageFns<DeleteVolumeThresholdRequest> = {
  encode(message: DeleteVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteVolumeThresholdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteVolumeThresholdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteVolumeThresholdRequest>, I>>(base?: I): DeleteVolumeThresholdRequest {
    return DeleteVolumeThresholdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteVolumeThresholdRequest>, I>>(object: I): DeleteVolumeThresholdRequest {
    const message = createBaseDeleteVolumeThresholdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetAuditLogsRequest(): GetAuditLogsRequest {
  return {
    organisationId: "",
    entityType: "",
    entityId: "",
    actorUserId: "",
    source: 0,
    startDate: "",
    endDate: "",
    pagination: undefined,
  };
}

export const GetAuditLogsRequest: MessageFns<GetAuditLogsRequest> = {
  encode(message: GetAuditLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(26).string(message.entityId);
    }
    if (message.actorUserId !== "") {
      writer.uint32(34).string(message.actorUserId);
    }
    if (message.source !== 0) {
      writer.uint32(40).int32(message.source);
    }
    if (message.startDate !== "") {
      writer.uint32(50).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(58).string(message.endDate);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actorUserId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditLogsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      entityType: isSet(object.entityType)
        ? globalThis.String(object.entityType)
        : isSet(object.entity_type)
        ? globalThis.String(object.entity_type)
        : "",
      entityId: isSet(object.entityId)
        ? globalThis.String(object.entityId)
        : isSet(object.entity_id)
        ? globalThis.String(object.entity_id)
        : "",
      actorUserId: isSet(object.actorUserId)
        ? globalThis.String(object.actorUserId)
        : isSet(object.actor_user_id)
        ? globalThis.String(object.actor_user_id)
        : "",
      source: isSet(object.source) ? auditSourceFromJSON(object.source) : 0,
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetAuditLogsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.actorUserId !== "") {
      obj.actorUserId = message.actorUserId;
    }
    if (message.source !== 0) {
      obj.source = auditSourceToJSON(message.source);
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuditLogsRequest>, I>>(base?: I): GetAuditLogsRequest {
    return GetAuditLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuditLogsRequest>, I>>(object: I): GetAuditLogsRequest {
    const message = createBaseGetAuditLogsRequest();
    message.organisationId = object.organisationId ?? "";
    message.entityType = object.entityType ?? "";
    message.entityId = object.entityId ?? "";
    message.actorUserId = object.actorUserId ?? "";
    message.source = object.source ?? 0;
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetAuditLogsResponse(): GetAuditLogsResponse {
  return { logs: [], pagination: undefined };
}

export const GetAuditLogsResponse: MessageFns<GetAuditLogsResponse> = {
  encode(message: GetAuditLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      CalendarAuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(CalendarAuditLog.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditLogsResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => CalendarAuditLog.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetAuditLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => CalendarAuditLog.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuditLogsResponse>, I>>(base?: I): GetAuditLogsResponse {
    return GetAuditLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuditLogsResponse>, I>>(object: I): GetAuditLogsResponse {
    const message = createBaseGetAuditLogsResponse();
    message.logs = object.logs?.map((e) => CalendarAuditLog.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

/** Service de calcul du Calendar Engine */
export type CalendarEngineServiceService = typeof CalendarEngineServiceService;
export const CalendarEngineServiceService = {
  /** Calcul de date unique */
  calculatePlannedDate: {
    path: "/calendar.CalendarEngineService/CalculatePlannedDate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CalculatePlannedDateRequest): Buffer =>
      Buffer.from(CalculatePlannedDateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CalculatePlannedDateRequest => CalculatePlannedDateRequest.decode(value),
    responseSerialize: (value: CalculatePlannedDateResponse): Buffer =>
      Buffer.from(CalculatePlannedDateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalculatePlannedDateResponse => CalculatePlannedDateResponse.decode(value),
  },
  /** Calcul en lot */
  calculatePlannedDatesBatch: {
    path: "/calendar.CalendarEngineService/CalculatePlannedDatesBatch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CalculatePlannedDatesBatchRequest): Buffer =>
      Buffer.from(CalculatePlannedDatesBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CalculatePlannedDatesBatchRequest =>
      CalculatePlannedDatesBatchRequest.decode(value),
    responseSerialize: (value: CalculatePlannedDatesBatchResponse): Buffer =>
      Buffer.from(CalculatePlannedDatesBatchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalculatePlannedDatesBatchResponse =>
      CalculatePlannedDatesBatchResponse.decode(value),
  },
  /** Vérification d'éligibilité */
  checkDateEligibility: {
    path: "/calendar.CalendarEngineService/CheckDateEligibility",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckDateEligibilityRequest): Buffer =>
      Buffer.from(CheckDateEligibilityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckDateEligibilityRequest => CheckDateEligibilityRequest.decode(value),
    responseSerialize: (value: CheckDateEligibilityResponse): Buffer =>
      Buffer.from(CheckDateEligibilityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckDateEligibilityResponse => CheckDateEligibilityResponse.decode(value),
  },
} as const;

export interface CalendarEngineServiceServer extends UntypedServiceImplementation {
  /** Calcul de date unique */
  calculatePlannedDate: handleUnaryCall<CalculatePlannedDateRequest, CalculatePlannedDateResponse>;
  /** Calcul en lot */
  calculatePlannedDatesBatch: handleUnaryCall<CalculatePlannedDatesBatchRequest, CalculatePlannedDatesBatchResponse>;
  /** Vérification d'éligibilité */
  checkDateEligibility: handleUnaryCall<CheckDateEligibilityRequest, CheckDateEligibilityResponse>;
}

/** Service de gestion des configurations */
export type DebitConfigurationServiceService = typeof DebitConfigurationServiceService;
export const DebitConfigurationServiceService = {
  /** Configuration système */
  getSystemConfig: {
    path: "/calendar.DebitConfigurationService/GetSystemConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSystemConfigRequest): Buffer =>
      Buffer.from(GetSystemConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSystemConfigRequest => GetSystemConfigRequest.decode(value),
    responseSerialize: (value: SystemDebitConfiguration): Buffer =>
      Buffer.from(SystemDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): SystemDebitConfiguration => SystemDebitConfiguration.decode(value),
  },
  updateSystemConfig: {
    path: "/calendar.DebitConfigurationService/UpdateSystemConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSystemConfigRequest): Buffer =>
      Buffer.from(UpdateSystemConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSystemConfigRequest => UpdateSystemConfigRequest.decode(value),
    responseSerialize: (value: SystemDebitConfiguration): Buffer =>
      Buffer.from(SystemDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): SystemDebitConfiguration => SystemDebitConfiguration.decode(value),
  },
  /** Configuration société */
  createCompanyConfig: {
    path: "/calendar.DebitConfigurationService/CreateCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCompanyConfigRequest): Buffer =>
      Buffer.from(CreateCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCompanyConfigRequest => CreateCompanyConfigRequest.decode(value),
    responseSerialize: (value: CompanyDebitConfiguration): Buffer =>
      Buffer.from(CompanyDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): CompanyDebitConfiguration => CompanyDebitConfiguration.decode(value),
  },
  updateCompanyConfig: {
    path: "/calendar.DebitConfigurationService/UpdateCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCompanyConfigRequest): Buffer =>
      Buffer.from(UpdateCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateCompanyConfigRequest => UpdateCompanyConfigRequest.decode(value),
    responseSerialize: (value: CompanyDebitConfiguration): Buffer =>
      Buffer.from(CompanyDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): CompanyDebitConfiguration => CompanyDebitConfiguration.decode(value),
  },
  getCompanyConfig: {
    path: "/calendar.DebitConfigurationService/GetCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCompanyConfigRequest): Buffer =>
      Buffer.from(GetCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCompanyConfigRequest => GetCompanyConfigRequest.decode(value),
    responseSerialize: (value: CompanyDebitConfiguration): Buffer =>
      Buffer.from(CompanyDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): CompanyDebitConfiguration => CompanyDebitConfiguration.decode(value),
  },
  listCompanyConfigs: {
    path: "/calendar.DebitConfigurationService/ListCompanyConfigs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCompanyConfigsRequest): Buffer =>
      Buffer.from(ListCompanyConfigsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCompanyConfigsRequest => ListCompanyConfigsRequest.decode(value),
    responseSerialize: (value: ListCompanyConfigsResponse): Buffer =>
      Buffer.from(ListCompanyConfigsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCompanyConfigsResponse => ListCompanyConfigsResponse.decode(value),
  },
  deleteCompanyConfig: {
    path: "/calendar.DebitConfigurationService/DeleteCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCompanyConfigRequest): Buffer =>
      Buffer.from(DeleteCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCompanyConfigRequest => DeleteCompanyConfigRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Configuration client */
  createClientConfig: {
    path: "/calendar.DebitConfigurationService/CreateClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateClientConfigRequest): Buffer =>
      Buffer.from(CreateClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateClientConfigRequest => CreateClientConfigRequest.decode(value),
    responseSerialize: (value: ClientDebitConfiguration): Buffer =>
      Buffer.from(ClientDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClientDebitConfiguration => ClientDebitConfiguration.decode(value),
  },
  updateClientConfig: {
    path: "/calendar.DebitConfigurationService/UpdateClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateClientConfigRequest): Buffer =>
      Buffer.from(UpdateClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateClientConfigRequest => UpdateClientConfigRequest.decode(value),
    responseSerialize: (value: ClientDebitConfiguration): Buffer =>
      Buffer.from(ClientDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClientDebitConfiguration => ClientDebitConfiguration.decode(value),
  },
  getClientConfig: {
    path: "/calendar.DebitConfigurationService/GetClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetClientConfigRequest): Buffer =>
      Buffer.from(GetClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetClientConfigRequest => GetClientConfigRequest.decode(value),
    responseSerialize: (value: ClientDebitConfiguration): Buffer =>
      Buffer.from(ClientDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClientDebitConfiguration => ClientDebitConfiguration.decode(value),
  },
  listClientConfigs: {
    path: "/calendar.DebitConfigurationService/ListClientConfigs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListClientConfigsRequest): Buffer =>
      Buffer.from(ListClientConfigsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListClientConfigsRequest => ListClientConfigsRequest.decode(value),
    responseSerialize: (value: ListClientConfigsResponse): Buffer =>
      Buffer.from(ListClientConfigsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListClientConfigsResponse => ListClientConfigsResponse.decode(value),
  },
  deleteClientConfig: {
    path: "/calendar.DebitConfigurationService/DeleteClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteClientConfigRequest): Buffer =>
      Buffer.from(DeleteClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteClientConfigRequest => DeleteClientConfigRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Configuration contrat */
  createContractConfig: {
    path: "/calendar.DebitConfigurationService/CreateContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateContractConfigRequest): Buffer =>
      Buffer.from(CreateContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateContractConfigRequest => CreateContractConfigRequest.decode(value),
    responseSerialize: (value: ContractDebitConfiguration): Buffer =>
      Buffer.from(ContractDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ContractDebitConfiguration => ContractDebitConfiguration.decode(value),
  },
  updateContractConfig: {
    path: "/calendar.DebitConfigurationService/UpdateContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateContractConfigRequest): Buffer =>
      Buffer.from(UpdateContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateContractConfigRequest => UpdateContractConfigRequest.decode(value),
    responseSerialize: (value: ContractDebitConfiguration): Buffer =>
      Buffer.from(ContractDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ContractDebitConfiguration => ContractDebitConfiguration.decode(value),
  },
  getContractConfig: {
    path: "/calendar.DebitConfigurationService/GetContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContractConfigRequest): Buffer =>
      Buffer.from(GetContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContractConfigRequest => GetContractConfigRequest.decode(value),
    responseSerialize: (value: ContractDebitConfiguration): Buffer =>
      Buffer.from(ContractDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ContractDebitConfiguration => ContractDebitConfiguration.decode(value),
  },
  listContractConfigs: {
    path: "/calendar.DebitConfigurationService/ListContractConfigs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListContractConfigsRequest): Buffer =>
      Buffer.from(ListContractConfigsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListContractConfigsRequest => ListContractConfigsRequest.decode(value),
    responseSerialize: (value: ListContractConfigsResponse): Buffer =>
      Buffer.from(ListContractConfigsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListContractConfigsResponse => ListContractConfigsResponse.decode(value),
  },
  deleteContractConfig: {
    path: "/calendar.DebitConfigurationService/DeleteContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteContractConfigRequest): Buffer =>
      Buffer.from(DeleteContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteContractConfigRequest => DeleteContractConfigRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Résolution de configuration */
  resolveConfiguration: {
    path: "/calendar.DebitConfigurationService/ResolveConfiguration",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResolveConfigurationRequest): Buffer =>
      Buffer.from(ResolveConfigurationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResolveConfigurationRequest => ResolveConfigurationRequest.decode(value),
    responseSerialize: (value: ResolvedDebitConfiguration): Buffer =>
      Buffer.from(ResolvedDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResolvedDebitConfiguration => ResolvedDebitConfiguration.decode(value),
  },
} as const;

export interface DebitConfigurationServiceServer extends UntypedServiceImplementation {
  /** Configuration système */
  getSystemConfig: handleUnaryCall<GetSystemConfigRequest, SystemDebitConfiguration>;
  updateSystemConfig: handleUnaryCall<UpdateSystemConfigRequest, SystemDebitConfiguration>;
  /** Configuration société */
  createCompanyConfig: handleUnaryCall<CreateCompanyConfigRequest, CompanyDebitConfiguration>;
  updateCompanyConfig: handleUnaryCall<UpdateCompanyConfigRequest, CompanyDebitConfiguration>;
  getCompanyConfig: handleUnaryCall<GetCompanyConfigRequest, CompanyDebitConfiguration>;
  listCompanyConfigs: handleUnaryCall<ListCompanyConfigsRequest, ListCompanyConfigsResponse>;
  deleteCompanyConfig: handleUnaryCall<DeleteCompanyConfigRequest, DeleteResponse>;
  /** Configuration client */
  createClientConfig: handleUnaryCall<CreateClientConfigRequest, ClientDebitConfiguration>;
  updateClientConfig: handleUnaryCall<UpdateClientConfigRequest, ClientDebitConfiguration>;
  getClientConfig: handleUnaryCall<GetClientConfigRequest, ClientDebitConfiguration>;
  listClientConfigs: handleUnaryCall<ListClientConfigsRequest, ListClientConfigsResponse>;
  deleteClientConfig: handleUnaryCall<DeleteClientConfigRequest, DeleteResponse>;
  /** Configuration contrat */
  createContractConfig: handleUnaryCall<CreateContractConfigRequest, ContractDebitConfiguration>;
  updateContractConfig: handleUnaryCall<UpdateContractConfigRequest, ContractDebitConfiguration>;
  getContractConfig: handleUnaryCall<GetContractConfigRequest, ContractDebitConfiguration>;
  listContractConfigs: handleUnaryCall<ListContractConfigsRequest, ListContractConfigsResponse>;
  deleteContractConfig: handleUnaryCall<DeleteContractConfigRequest, DeleteResponse>;
  /** Résolution de configuration */
  resolveConfiguration: handleUnaryCall<ResolveConfigurationRequest, ResolvedDebitConfiguration>;
}

/** Service de gestion des jours fériés */
export type HolidayServiceService = typeof HolidayServiceService;
export const HolidayServiceService = {
  /** Zones */
  createHolidayZone: {
    path: "/calendar.HolidayService/CreateHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateHolidayZoneRequest): Buffer =>
      Buffer.from(CreateHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateHolidayZoneRequest => CreateHolidayZoneRequest.decode(value),
    responseSerialize: (value: HolidayZone): Buffer => Buffer.from(HolidayZone.encode(value).finish()),
    responseDeserialize: (value: Buffer): HolidayZone => HolidayZone.decode(value),
  },
  updateHolidayZone: {
    path: "/calendar.HolidayService/UpdateHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateHolidayZoneRequest): Buffer =>
      Buffer.from(UpdateHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateHolidayZoneRequest => UpdateHolidayZoneRequest.decode(value),
    responseSerialize: (value: HolidayZone): Buffer => Buffer.from(HolidayZone.encode(value).finish()),
    responseDeserialize: (value: Buffer): HolidayZone => HolidayZone.decode(value),
  },
  getHolidayZone: {
    path: "/calendar.HolidayService/GetHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHolidayZoneRequest): Buffer =>
      Buffer.from(GetHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetHolidayZoneRequest => GetHolidayZoneRequest.decode(value),
    responseSerialize: (value: HolidayZone): Buffer => Buffer.from(HolidayZone.encode(value).finish()),
    responseDeserialize: (value: Buffer): HolidayZone => HolidayZone.decode(value),
  },
  listHolidayZones: {
    path: "/calendar.HolidayService/ListHolidayZones",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListHolidayZonesRequest): Buffer =>
      Buffer.from(ListHolidayZonesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListHolidayZonesRequest => ListHolidayZonesRequest.decode(value),
    responseSerialize: (value: ListHolidayZonesResponse): Buffer =>
      Buffer.from(ListHolidayZonesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHolidayZonesResponse => ListHolidayZonesResponse.decode(value),
  },
  deleteHolidayZone: {
    path: "/calendar.HolidayService/DeleteHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteHolidayZoneRequest): Buffer =>
      Buffer.from(DeleteHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteHolidayZoneRequest => DeleteHolidayZoneRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Jours fériés */
  createHoliday: {
    path: "/calendar.HolidayService/CreateHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateHolidayRequest): Buffer => Buffer.from(CreateHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateHolidayRequest => CreateHolidayRequest.decode(value),
    responseSerialize: (value: Holiday): Buffer => Buffer.from(Holiday.encode(value).finish()),
    responseDeserialize: (value: Buffer): Holiday => Holiday.decode(value),
  },
  updateHoliday: {
    path: "/calendar.HolidayService/UpdateHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateHolidayRequest): Buffer => Buffer.from(UpdateHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateHolidayRequest => UpdateHolidayRequest.decode(value),
    responseSerialize: (value: Holiday): Buffer => Buffer.from(Holiday.encode(value).finish()),
    responseDeserialize: (value: Buffer): Holiday => Holiday.decode(value),
  },
  getHoliday: {
    path: "/calendar.HolidayService/GetHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHolidayRequest): Buffer => Buffer.from(GetHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetHolidayRequest => GetHolidayRequest.decode(value),
    responseSerialize: (value: Holiday): Buffer => Buffer.from(Holiday.encode(value).finish()),
    responseDeserialize: (value: Buffer): Holiday => Holiday.decode(value),
  },
  listHolidays: {
    path: "/calendar.HolidayService/ListHolidays",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListHolidaysRequest): Buffer => Buffer.from(ListHolidaysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListHolidaysRequest => ListHolidaysRequest.decode(value),
    responseSerialize: (value: ListHolidaysResponse): Buffer =>
      Buffer.from(ListHolidaysResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHolidaysResponse => ListHolidaysResponse.decode(value),
  },
  deleteHoliday: {
    path: "/calendar.HolidayService/DeleteHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteHolidayRequest): Buffer => Buffer.from(DeleteHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteHolidayRequest => DeleteHolidayRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Import jours fériés par pays */
  importHolidaysByCountry: {
    path: "/calendar.HolidayService/ImportHolidaysByCountry",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportHolidaysByCountryRequest): Buffer =>
      Buffer.from(ImportHolidaysByCountryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImportHolidaysByCountryRequest => ImportHolidaysByCountryRequest.decode(value),
    responseSerialize: (value: ImportHolidaysByCountryResponse): Buffer =>
      Buffer.from(ImportHolidaysByCountryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ImportHolidaysByCountryResponse =>
      ImportHolidaysByCountryResponse.decode(value),
  },
} as const;

export interface HolidayServiceServer extends UntypedServiceImplementation {
  /** Zones */
  createHolidayZone: handleUnaryCall<CreateHolidayZoneRequest, HolidayZone>;
  updateHolidayZone: handleUnaryCall<UpdateHolidayZoneRequest, HolidayZone>;
  getHolidayZone: handleUnaryCall<GetHolidayZoneRequest, HolidayZone>;
  listHolidayZones: handleUnaryCall<ListHolidayZonesRequest, ListHolidayZonesResponse>;
  deleteHolidayZone: handleUnaryCall<DeleteHolidayZoneRequest, DeleteResponse>;
  /** Jours fériés */
  createHoliday: handleUnaryCall<CreateHolidayRequest, Holiday>;
  updateHoliday: handleUnaryCall<UpdateHolidayRequest, Holiday>;
  getHoliday: handleUnaryCall<GetHolidayRequest, Holiday>;
  listHolidays: handleUnaryCall<ListHolidaysRequest, ListHolidaysResponse>;
  deleteHoliday: handleUnaryCall<DeleteHolidayRequest, DeleteResponse>;
  /** Import jours fériés par pays */
  importHolidaysByCountry: handleUnaryCall<ImportHolidaysByCountryRequest, ImportHolidaysByCountryResponse>;
}

/** Service Admin UI */
export type CalendarAdminServiceService = typeof CalendarAdminServiceService;
export const CalendarAdminServiceService = {
  /** Vue calendrier */
  getCalendarView: {
    path: "/calendar.CalendarAdminService/GetCalendarView",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCalendarViewRequest): Buffer =>
      Buffer.from(GetCalendarViewRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCalendarViewRequest => GetCalendarViewRequest.decode(value),
    responseSerialize: (value: GetCalendarViewResponse): Buffer =>
      Buffer.from(GetCalendarViewResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetCalendarViewResponse => GetCalendarViewResponse.decode(value),
  },
  getDateDetails: {
    path: "/calendar.CalendarAdminService/GetDateDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDateDetailsRequest): Buffer =>
      Buffer.from(GetDateDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDateDetailsRequest => GetDateDetailsRequest.decode(value),
    responseSerialize: (value: GetDateDetailsResponse): Buffer =>
      Buffer.from(GetDateDetailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetDateDetailsResponse => GetDateDetailsResponse.decode(value),
  },
  /** Heatmap volumes */
  getVolumeHeatmap: {
    path: "/calendar.CalendarAdminService/GetVolumeHeatmap",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVolumeHeatmapRequest): Buffer =>
      Buffer.from(GetVolumeHeatmapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetVolumeHeatmapRequest => GetVolumeHeatmapRequest.decode(value),
    responseSerialize: (value: GetVolumeHeatmapResponse): Buffer =>
      Buffer.from(GetVolumeHeatmapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetVolumeHeatmapResponse => GetVolumeHeatmapResponse.decode(value),
  },
  /** Import/Export CSV */
  importCsv: {
    path: "/calendar.CalendarAdminService/ImportCsv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportCsvRequest): Buffer => Buffer.from(ImportCsvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImportCsvRequest => ImportCsvRequest.decode(value),
    responseSerialize: (value: ImportCsvResponse): Buffer => Buffer.from(ImportCsvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ImportCsvResponse => ImportCsvResponse.decode(value),
  },
  confirmCsvImport: {
    path: "/calendar.CalendarAdminService/ConfirmCsvImport",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConfirmCsvImportRequest): Buffer =>
      Buffer.from(ConfirmCsvImportRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ConfirmCsvImportRequest => ConfirmCsvImportRequest.decode(value),
    responseSerialize: (value: ConfirmCsvImportResponse): Buffer =>
      Buffer.from(ConfirmCsvImportResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConfirmCsvImportResponse => ConfirmCsvImportResponse.decode(value),
  },
  exportCalendarCsv: {
    path: "/calendar.CalendarAdminService/ExportCalendarCsv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExportCalendarCsvRequest): Buffer =>
      Buffer.from(ExportCalendarCsvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExportCalendarCsvRequest => ExportCalendarCsvRequest.decode(value),
    responseSerialize: (value: ExportCalendarCsvResponse): Buffer =>
      Buffer.from(ExportCalendarCsvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExportCalendarCsvResponse => ExportCalendarCsvResponse.decode(value),
  },
  /** Seuils */
  createVolumeThreshold: {
    path: "/calendar.CalendarAdminService/CreateVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateVolumeThresholdRequest): Buffer =>
      Buffer.from(CreateVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateVolumeThresholdRequest => CreateVolumeThresholdRequest.decode(value),
    responseSerialize: (value: VolumeThreshold): Buffer => Buffer.from(VolumeThreshold.encode(value).finish()),
    responseDeserialize: (value: Buffer): VolumeThreshold => VolumeThreshold.decode(value),
  },
  updateVolumeThreshold: {
    path: "/calendar.CalendarAdminService/UpdateVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateVolumeThresholdRequest): Buffer =>
      Buffer.from(UpdateVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateVolumeThresholdRequest => UpdateVolumeThresholdRequest.decode(value),
    responseSerialize: (value: VolumeThreshold): Buffer => Buffer.from(VolumeThreshold.encode(value).finish()),
    responseDeserialize: (value: Buffer): VolumeThreshold => VolumeThreshold.decode(value),
  },
  getVolumeThreshold: {
    path: "/calendar.CalendarAdminService/GetVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVolumeThresholdRequest): Buffer =>
      Buffer.from(GetVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetVolumeThresholdRequest => GetVolumeThresholdRequest.decode(value),
    responseSerialize: (value: VolumeThreshold): Buffer => Buffer.from(VolumeThreshold.encode(value).finish()),
    responseDeserialize: (value: Buffer): VolumeThreshold => VolumeThreshold.decode(value),
  },
  listVolumeThresholds: {
    path: "/calendar.CalendarAdminService/ListVolumeThresholds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListVolumeThresholdsRequest): Buffer =>
      Buffer.from(ListVolumeThresholdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListVolumeThresholdsRequest => ListVolumeThresholdsRequest.decode(value),
    responseSerialize: (value: ListVolumeThresholdsResponse): Buffer =>
      Buffer.from(ListVolumeThresholdsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListVolumeThresholdsResponse => ListVolumeThresholdsResponse.decode(value),
  },
  deleteVolumeThreshold: {
    path: "/calendar.CalendarAdminService/DeleteVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteVolumeThresholdRequest): Buffer =>
      Buffer.from(DeleteVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteVolumeThresholdRequest => DeleteVolumeThresholdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Audit */
  getAuditLogs: {
    path: "/calendar.CalendarAdminService/GetAuditLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditLogsRequest): Buffer => Buffer.from(GetAuditLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuditLogsRequest => GetAuditLogsRequest.decode(value),
    responseSerialize: (value: GetAuditLogsResponse): Buffer =>
      Buffer.from(GetAuditLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAuditLogsResponse => GetAuditLogsResponse.decode(value),
  },
} as const;

export interface CalendarAdminServiceServer extends UntypedServiceImplementation {
  /** Vue calendrier */
  getCalendarView: handleUnaryCall<GetCalendarViewRequest, GetCalendarViewResponse>;
  getDateDetails: handleUnaryCall<GetDateDetailsRequest, GetDateDetailsResponse>;
  /** Heatmap volumes */
  getVolumeHeatmap: handleUnaryCall<GetVolumeHeatmapRequest, GetVolumeHeatmapResponse>;
  /** Import/Export CSV */
  importCsv: handleUnaryCall<ImportCsvRequest, ImportCsvResponse>;
  confirmCsvImport: handleUnaryCall<ConfirmCsvImportRequest, ConfirmCsvImportResponse>;
  exportCalendarCsv: handleUnaryCall<ExportCalendarCsvRequest, ExportCalendarCsvResponse>;
  /** Seuils */
  createVolumeThreshold: handleUnaryCall<CreateVolumeThresholdRequest, VolumeThreshold>;
  updateVolumeThreshold: handleUnaryCall<UpdateVolumeThresholdRequest, VolumeThreshold>;
  getVolumeThreshold: handleUnaryCall<GetVolumeThresholdRequest, VolumeThreshold>;
  listVolumeThresholds: handleUnaryCall<ListVolumeThresholdsRequest, ListVolumeThresholdsResponse>;
  deleteVolumeThreshold: handleUnaryCall<DeleteVolumeThresholdRequest, DeleteResponse>;
  /** Audit */
  getAuditLogs: handleUnaryCall<GetAuditLogsRequest, GetAuditLogsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
