// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: calendar/calendar.proto

/* eslint-disable */

/**
 * Définition des lots de prélèvement (fenêtres d'émission)
 * L1 = Semaine 1 du mois (jours 1-7)
 * L2 = Semaine 2 du mois (jours 8-14)
 * L3 = Semaine 3 du mois (jours 15-21)
 * L4 = Semaine 4 du mois (jours 22-fin)
 */
export enum DebitBatch {
  DEBIT_BATCH_UNSPECIFIED = 0,
  /** DEBIT_BATCH_L1 - Semaine 1: jours 1-7 */
  DEBIT_BATCH_L1 = 1,
  /** DEBIT_BATCH_L2 - Semaine 2: jours 8-14 */
  DEBIT_BATCH_L2 = 2,
  /** DEBIT_BATCH_L3 - Semaine 3: jours 15-21 */
  DEBIT_BATCH_L3 = 3,
  /** DEBIT_BATCH_L4 - Semaine 4: jours 22-fin du mois */
  DEBIT_BATCH_L4 = 4,
  UNRECOGNIZED = -1,
}

/** Mode de calcul de la date de prélèvement */
export enum DebitDateMode {
  DEBIT_DATE_MODE_UNSPECIFIED = 0,
  /** DEBIT_DATE_MODE_BATCH - Utilise le lot L1-L4 (premier jour ouvré du lot) */
  DEBIT_DATE_MODE_BATCH = 1,
  /** DEBIT_DATE_MODE_FIXED_DAY - Utilise un jour fixe du mois (ex: le 5) */
  DEBIT_DATE_MODE_FIXED_DAY = 2,
  UNRECOGNIZED = -1,
}

/** Stratégie de report si date non éligible (weekend/férié) */
export enum DateShiftStrategy {
  DATE_SHIFT_STRATEGY_UNSPECIFIED = 0,
  /** DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY - Reporter au prochain jour ouvré */
  DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY = 1,
  /** DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY - Anticiper au jour ouvré précédent */
  DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY = 2,
  /** DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY - Reporter à la semaine suivante, même jour */
  DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY = 3,
  UNRECOGNIZED = -1,
}

/** Niveau de configuration (pour la priorité) */
export enum ConfigurationLevel {
  CONFIGURATION_LEVEL_UNSPECIFIED = 0,
  /** CONFIGURATION_LEVEL_SYSTEM_DEFAULT - Priorité la plus basse */
  CONFIGURATION_LEVEL_SYSTEM_DEFAULT = 1,
  /** CONFIGURATION_LEVEL_COMPANY - Niveau société */
  CONFIGURATION_LEVEL_COMPANY = 2,
  /** CONFIGURATION_LEVEL_CLIENT - Niveau client */
  CONFIGURATION_LEVEL_CLIENT = 3,
  /** CONFIGURATION_LEVEL_CONTRACT - Priorité la plus haute */
  CONFIGURATION_LEVEL_CONTRACT = 4,
  UNRECOGNIZED = -1,
}

/** Statut d'une date planifiée */
export enum PlannedDateStatus {
  PLANNED_DATE_STATUS_UNSPECIFIED = 0,
  /** PLANNED_DATE_STATUS_PLANNED - Date calculée, en attente */
  PLANNED_DATE_STATUS_PLANNED = 1,
  /** PLANNED_DATE_STATUS_CONFIRMED - Date confirmée pour émission */
  PLANNED_DATE_STATUS_CONFIRMED = 2,
  /** PLANNED_DATE_STATUS_PROCESSING - En cours de traitement */
  PLANNED_DATE_STATUS_PROCESSING = 3,
  /** PLANNED_DATE_STATUS_EXECUTED - Prélèvement exécuté */
  PLANNED_DATE_STATUS_EXECUTED = 4,
  /** PLANNED_DATE_STATUS_FAILED - Échec du prélèvement */
  PLANNED_DATE_STATUS_FAILED = 5,
  /** PLANNED_DATE_STATUS_CANCELLED - Annulé */
  PLANNED_DATE_STATUS_CANCELLED = 6,
  UNRECOGNIZED = -1,
}

/** Type de jour férié */
export enum HolidayType {
  HOLIDAY_TYPE_UNSPECIFIED = 0,
  /** HOLIDAY_TYPE_PUBLIC - Jour férié légal */
  HOLIDAY_TYPE_PUBLIC = 1,
  /** HOLIDAY_TYPE_BANK - Jour de fermeture bancaire */
  HOLIDAY_TYPE_BANK = 2,
  /** HOLIDAY_TYPE_REGIONAL - Jour férié régional */
  HOLIDAY_TYPE_REGIONAL = 3,
  /** HOLIDAY_TYPE_COMPANY - Jour de fermeture société */
  HOLIDAY_TYPE_COMPANY = 4,
  UNRECOGNIZED = -1,
}

/** Source de modification pour audit */
export enum AuditSource {
  AUDIT_SOURCE_UNSPECIFIED = 0,
  /** AUDIT_SOURCE_UI - Interface admin */
  AUDIT_SOURCE_UI = 1,
  /** AUDIT_SOURCE_CSV_IMPORT - Import CSV */
  AUDIT_SOURCE_CSV_IMPORT = 2,
  /** AUDIT_SOURCE_API - Appel API */
  AUDIT_SOURCE_API = 3,
  /** AUDIT_SOURCE_SYSTEM - Calcul automatique système */
  AUDIT_SOURCE_SYSTEM = 4,
  UNRECOGNIZED = -1,
}

/** Configuration des jours fériés par zone/pays */
export interface HolidayZone {
  id: string;
  organisationId: string;
  /** Ex: "FR", "FR-ALS" (Alsace), "DE", "BE" */
  code: string;
  /** Ex: "France", "Alsace-Moselle" */
  name: string;
  /** ISO 3166-1 alpha-2: "FR", "DE", "BE" */
  countryCode: string;
  /** Code région optionnel (ex: "ALS", "IDF") */
  regionCode: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Jour férié individuel */
export interface Holiday {
  id: string;
  holidayZoneId: string;
  /** Format ISO: "2026-01-01" */
  date: string;
  /** Ex: "Jour de l'An", "Lundi de Pâques" */
  name: string;
  holidayType: HolidayType;
  /** True si récurrent chaque année (même jour/mois) */
  isRecurring: boolean;
  /** 1-12 si récurrent */
  recurringMonth: number;
  /** 1-31 si récurrent */
  recurringDay: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration du cutoff horaire */
export interface CutoffConfiguration {
  id: string;
  organisationId: string;
  /** Ex: "Cutoff SEPA Standard" */
  name: string;
  /** Format HH:mm en timezone locale, ex: "14:00" */
  cutoffTime: string;
  /** Ex: "Europe/Paris" */
  timezone: string;
  /** J-X avant la date de valeur (ex: 2 pour SEPA) */
  daysBeforeValueDate: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot par défaut système */
export interface SystemDebitConfiguration {
  id: string;
  organisationId: string;
  defaultMode: DebitDateMode;
  /** Si mode = BATCH */
  defaultBatch: DebitBatch;
  /** Si mode = FIXED_DAY (1-28) */
  defaultFixedDay: number;
  shiftStrategy: DateShiftStrategy;
  /** Zone de jours fériés par défaut */
  holidayZoneId: string;
  /** Configuration cutoff par défaut */
  cutoffConfigId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau société */
export interface CompanyDebitConfiguration {
  id: string;
  organisationId: string;
  societeId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau client */
export interface ClientDebitConfiguration {
  id: string;
  organisationId: string;
  clientId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau contrat (priorité maximale) */
export interface ContractDebitConfiguration {
  id: string;
  organisationId: string;
  contratId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration résolue (après application de la priorité) */
export interface ResolvedDebitConfiguration {
  /** Niveau qui a été appliqué */
  appliedLevel: ConfigurationLevel;
  /** ID de la config appliquée */
  appliedConfigId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

/** Entrée pour le calcul de date de prélèvement */
export interface CalculatePlannedDateRequest {
  organisationId: string;
  /** Optionnel - si fourni, utilise config contrat */
  contratId: string;
  /** Optionnel - si fourni, utilise config client */
  clientId: string;
  /** Optionnel - si fourni, utilise config société */
  societeId: string;
  /** Date de référence pour le calcul (ISO format) */
  referenceDate: string;
  /** Mois cible (1-12) */
  targetMonth: number;
  /** Année cible */
  targetYear: number;
  /** Inclure le détail de la résolution */
  includeResolutionTrace: boolean;
}

/** Résultat du calcul de date de prélèvement */
export interface CalculatePlannedDateResponse {
  /** Date calculée (ISO format) */
  plannedDebitDate: string;
  /** Date cible avant ajustement */
  originalTargetDate: string;
  /** True si la date a été décalée */
  wasShifted: boolean;
  /** Raison du décalage (weekend, férié, etc.) */
  shiftReason: string;
  resolvedConfig?:
    | ResolvedDebitConfiguration
    | undefined;
  /** Trace de résolution si demandée */
  resolutionTrace: DateResolutionStep[];
}

/** Étape de résolution de date (pour debug/audit) */
export interface DateResolutionStep {
  stepOrder: number;
  description: string;
  inputDate: string;
  outputDate: string;
  appliedRule: string;
}

/** Calcul en lot pour plusieurs entités */
export interface CalculatePlannedDatesBatchRequest {
  organisationId: string;
  inputs: PlannedDateCalculationInput[];
  targetMonth: number;
  targetYear: number;
}

export interface PlannedDateCalculationInput {
  contratId: string;
  clientId: string;
  societeId: string;
  /** Montant en centimes */
  amountCents: number;
  currency: string;
}

export interface CalculatePlannedDatesBatchResponse {
  results: PlannedDateCalculationResult[];
  totalCount: number;
  successCount: number;
  errorCount: number;
}

export interface PlannedDateCalculationResult {
  contratId: string;
  success: boolean;
  plannedDebitDate: string;
  errorCode: string;
  errorMessage: string;
  resolvedConfig?: ResolvedDebitConfiguration | undefined;
}

/** Vérification d'éligibilité d'une date */
export interface CheckDateEligibilityRequest {
  organisationId: string;
  /** Date à vérifier (ISO format) */
  date: string;
  /** Zone de jours fériés */
  holidayZoneId: string;
}

export interface CheckDateEligibilityResponse {
  isEligible: boolean;
  isWeekend: boolean;
  isHoliday: boolean;
  /** Nom du jour férié si applicable */
  holidayName: string;
  /** Prochaine date éligible */
  nextEligibleDate: string;
  /** Date éligible précédente */
  previousEligibleDate: string;
}

/** Prélèvement planifié */
export interface PlannedDebit {
  id: string;
  organisationId: string;
  societeId: string;
  clientId: string;
  contratId: string;
  /** Référence vers payment.Schedule */
  scheduleId: string;
  /** Référence vers facture si applicable */
  factureId: string;
  /** Date de prélèvement planifiée */
  plannedDebitDate: string;
  /** Date cible avant ajustement */
  originalTargetDate: string;
  status: PlannedDateStatus;
  /** Lot assigné */
  batch: DebitBatch;
  /** Montant en centimes */
  amountCents: number;
  currency: string;
  resolvedConfig?: ResolvedDebitConfiguration | undefined;
  createdAt: string;
  updatedAt: string;
}

/** Volume agrégé par date/lot */
export interface DebitVolumeAggregate {
  /** Date (ISO format) */
  date: string;
  batch: DebitBatch;
  /** Optionnel, si agrégation par société */
  societeId: string;
  transactionCount: number;
  totalAmountCents: number;
  currency: string;
}

/** Prévision de volume (pour la heatmap) */
export interface VolumeForecast {
  id: string;
  organisationId: string;
  societeId: string;
  year: number;
  month: number;
  day: number;
  batch: DebitBatch;
  expectedTransactionCount: number;
  expectedAmountCents: number;
  currency: string;
  /** Rempli après exécution */
  actualTransactionCount: number;
  actualAmountCents: number;
  createdAt: string;
  updatedAt: string;
}

/** Seuil d'alerte pour les volumes */
export interface VolumeThreshold {
  id: string;
  organisationId: string;
  /** Optionnel */
  societeId: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Requête d'import CSV (dry-run obligatoire) */
export interface ImportCsvRequest {
  organisationId: string;
  /** Contenu du fichier CSV */
  csvContent: Uint8Array;
  /** "DEBIT_CONFIG", "HOLIDAYS", "VOLUME_FORECAST" */
  importType: string;
  /** OBLIGATOIRE: true pour prévisualisation */
  dryRun: boolean;
  uploadedByUserId: string;
}

export interface ImportCsvResponse {
  importId: string;
  success: boolean;
  isDryRun: boolean;
  totalRows: number;
  validRows: number;
  errorRows: number;
  errors: CsvValidationError[];
  /** Aperçu des changements */
  preview: CsvImportPreview[];
}

export interface CsvValidationError {
  rowNumber: number;
  columnName: string;
  value: string;
  errorCode: string;
  errorMessage: string;
}

export interface CsvImportPreview {
  rowNumber: number;
  /** "CREATE", "UPDATE", "SKIP" */
  action: string;
  entityType: string;
  /** Existant si UPDATE */
  entityId: string;
  /** Données à importer */
  data: { [key: string]: string };
  /** Résumé des changements */
  changeSummary: string;
}

export interface CsvImportPreview_DataEntry {
  key: string;
  value: string;
}

/** Confirmation d'import (après dry-run) */
export interface ConfirmCsvImportRequest {
  importId: string;
  organisationId: string;
  confirmedByUserId: string;
}

export interface ConfirmCsvImportResponse {
  success: boolean;
  createdCount: number;
  updatedCount: number;
  skippedCount: number;
  auditLogId: string;
}

/** Entrée de log d'audit */
export interface CalendarAuditLog {
  id: string;
  organisationId: string;
  /** Type d'entité modifiée */
  entityType: string;
  /** ID de l'entité modifiée */
  entityId: string;
  /** "CREATE", "UPDATE", "DELETE" */
  action: string;
  /** Utilisateur ayant effectué l'action */
  actorUserId: string;
  /** Source de la modification */
  source: AuditSource;
  /** État avant (JSON) */
  beforeState: string;
  /** État après (JSON) */
  afterState: string;
  /** Résumé lisible des changements */
  changeSummary: string;
  ipAddress: string;
  userAgent: string;
  createdAt: string;
}

/** Requête de calendrier avec filtres */
export interface GetCalendarViewRequest {
  organisationId: string;
  /** Date début (ISO format) */
  startDate: string;
  /** Date fin (ISO format) */
  endDate: string;
  /** Filtrer par sociétés */
  societeIds: string[];
  /** Filtrer par lots */
  batches: DebitBatch[];
  /** Filtrer par statut */
  statuses: PlannedDateStatus[];
  /** Inclure les volumes agrégés */
  includeVolumes: boolean;
}

export interface GetCalendarViewResponse {
  days: CalendarDay[];
  volumes: DebitVolumeAggregate[];
}

export interface CalendarDay {
  date: string;
  isWeekend: boolean;
  isHoliday: boolean;
  holidayName: string;
  isEligible: boolean;
  debits: PlannedDebitSummary[];
}

export interface PlannedDebitSummary {
  id: string;
  contratId: string;
  clientName: string;
  amountCents: number;
  currency: string;
  status: PlannedDateStatus;
  batch: DebitBatch;
}

/** Requête drill-down (détail d'une date) */
export interface GetDateDetailsRequest {
  organisationId: string;
  date: string;
  societeId: string;
  batch: DebitBatch;
  pagination?: Pagination | undefined;
}

export interface GetDateDetailsResponse {
  debits: PlannedDebit[];
  pagination?: PaginationResult | undefined;
  aggregate?: DebitVolumeAggregate | undefined;
}

/** Requête heatmap */
export interface GetVolumeHeatmapRequest {
  organisationId: string;
  year: number;
  /** Optionnel, si non fourni: année entière */
  month: number;
  societeIds: string[];
  batches: DebitBatch[];
  includeForecast: boolean;
}

export interface GetVolumeHeatmapResponse {
  cells: HeatmapCell[];
  exceededThresholds: VolumeThreshold[];
}

export interface HeatmapCell {
  date: string;
  /** 0=Lundi, 6=Dimanche */
  dayOfWeek: number;
  weekOfMonth: number;
  transactionCount: number;
  totalAmountCents: number;
  currency: string;
  /** "LOW", "MEDIUM", "HIGH", "CRITICAL" */
  intensityLevel: string;
  exceedsThreshold: boolean;
  /** Prévision si demandée */
  forecast?: VolumeForecast | undefined;
}

/** Export CSV */
export interface ExportCalendarCsvRequest {
  organisationId: string;
  startDate: string;
  endDate: string;
  societeIds: string[];
  batches: DebitBatch[];
  /** "PLANNED_DEBITS", "VOLUMES", "HEATMAP" */
  exportType: string;
}

export interface ExportCalendarCsvResponse {
  csvContent: Uint8Array;
  filename: string;
  rowCount: number;
}

export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

/** System Config */
export interface GetSystemConfigRequest {
  organisationId: string;
}

export interface UpdateSystemConfigRequest {
  organisationId: string;
  defaultMode: DebitDateMode;
  defaultBatch: DebitBatch;
  defaultFixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

/** Company Config */
export interface CreateCompanyConfigRequest {
  organisationId: string;
  societeId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

export interface UpdateCompanyConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
  isActive: boolean;
}

export interface GetCompanyConfigRequest {
  id: string;
}

export interface ListCompanyConfigsRequest {
  organisationId: string;
  societeId: string;
  pagination?: Pagination | undefined;
}

export interface ListCompanyConfigsResponse {
  configs: CompanyDebitConfiguration[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteCompanyConfigRequest {
  id: string;
}

/** Client Config */
export interface CreateClientConfigRequest {
  organisationId: string;
  clientId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
}

export interface UpdateClientConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
}

export interface GetClientConfigRequest {
  id: string;
}

export interface ListClientConfigsRequest {
  organisationId: string;
  clientId: string;
  pagination?: Pagination | undefined;
}

export interface ListClientConfigsResponse {
  configs: ClientDebitConfiguration[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteClientConfigRequest {
  id: string;
}

/** Contract Config */
export interface CreateContractConfigRequest {
  organisationId: string;
  contratId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
}

export interface UpdateContractConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
}

export interface GetContractConfigRequest {
  id: string;
}

export interface ListContractConfigsRequest {
  organisationId: string;
  contratId: string;
  pagination?: Pagination | undefined;
}

export interface ListContractConfigsResponse {
  configs: ContractDebitConfiguration[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteContractConfigRequest {
  id: string;
}

/** Resolve Configuration */
export interface ResolveConfigurationRequest {
  organisationId: string;
  contratId: string;
  clientId: string;
  societeId: string;
}

/** Holiday Zone CRUD */
export interface CreateHolidayZoneRequest {
  organisationId: string;
  code: string;
  name: string;
  countryCode: string;
  regionCode: string;
}

export interface UpdateHolidayZoneRequest {
  id: string;
  code: string;
  name: string;
  countryCode: string;
  regionCode: string;
  isActive: boolean;
}

export interface GetHolidayZoneRequest {
  id: string;
}

export interface ListHolidayZonesRequest {
  organisationId: string;
  countryCode: string;
  pagination?: Pagination | undefined;
}

export interface ListHolidayZonesResponse {
  zones: HolidayZone[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteHolidayZoneRequest {
  id: string;
}

/** Holiday CRUD */
export interface CreateHolidayRequest {
  holidayZoneId: string;
  date: string;
  name: string;
  holidayType: HolidayType;
  isRecurring: boolean;
  recurringMonth: number;
  recurringDay: number;
}

export interface UpdateHolidayRequest {
  id: string;
  date: string;
  name: string;
  holidayType: HolidayType;
  isRecurring: boolean;
  recurringMonth: number;
  recurringDay: number;
  isActive: boolean;
}

export interface GetHolidayRequest {
  id: string;
}

export interface ListHolidaysRequest {
  holidayZoneId: string;
  year: number;
  pagination?: Pagination | undefined;
}

export interface ListHolidaysResponse {
  holidays: Holiday[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteHolidayRequest {
  id: string;
}

export interface ImportHolidaysByCountryRequest {
  organisationId: string;
  countryCode: string;
  year: number;
  includeRegional: boolean;
}

export interface ImportHolidaysByCountryResponse {
  success: boolean;
  importedCount: number;
  holidayZoneId: string;
}

/** Volume Threshold CRUD */
export interface CreateVolumeThresholdRequest {
  organisationId: string;
  societeId: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
}

export interface UpdateVolumeThresholdRequest {
  id: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
  isActive: boolean;
}

export interface GetVolumeThresholdRequest {
  id: string;
}

export interface ListVolumeThresholdsRequest {
  organisationId: string;
  societeId: string;
  pagination?: Pagination | undefined;
}

export interface ListVolumeThresholdsResponse {
  thresholds: VolumeThreshold[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteVolumeThresholdRequest {
  id: string;
}

/** Audit */
export interface GetAuditLogsRequest {
  organisationId: string;
  entityType: string;
  entityId: string;
  actorUserId: string;
  source: AuditSource;
  startDate: string;
  endDate: string;
  pagination?: Pagination | undefined;
}

export interface GetAuditLogsResponse {
  logs: CalendarAuditLog[];
  pagination?: PaginationResult | undefined;
}
