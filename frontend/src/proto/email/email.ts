// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: email/email.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";

export const protobufPackage = "email";

export enum MailProvider {
  MAIL_PROVIDER_UNSPECIFIED = 0,
  MAIL_PROVIDER_GMAIL = 1,
  MAIL_PROVIDER_OUTLOOK = 2,
  MAIL_PROVIDER_EXCHANGE = 3,
  MAIL_PROVIDER_SMTP = 4,
  MAIL_PROVIDER_OTHER = 5,
  UNRECOGNIZED = -1,
}

export function mailProviderFromJSON(object: any): MailProvider {
  switch (object) {
    case 0:
    case "MAIL_PROVIDER_UNSPECIFIED":
      return MailProvider.MAIL_PROVIDER_UNSPECIFIED;
    case 1:
    case "MAIL_PROVIDER_GMAIL":
      return MailProvider.MAIL_PROVIDER_GMAIL;
    case 2:
    case "MAIL_PROVIDER_OUTLOOK":
      return MailProvider.MAIL_PROVIDER_OUTLOOK;
    case 3:
    case "MAIL_PROVIDER_EXCHANGE":
      return MailProvider.MAIL_PROVIDER_EXCHANGE;
    case 4:
    case "MAIL_PROVIDER_SMTP":
      return MailProvider.MAIL_PROVIDER_SMTP;
    case 5:
    case "MAIL_PROVIDER_OTHER":
      return MailProvider.MAIL_PROVIDER_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MailProvider.UNRECOGNIZED;
  }
}

export function mailProviderToJSON(object: MailProvider): string {
  switch (object) {
    case MailProvider.MAIL_PROVIDER_UNSPECIFIED:
      return "MAIL_PROVIDER_UNSPECIFIED";
    case MailProvider.MAIL_PROVIDER_GMAIL:
      return "MAIL_PROVIDER_GMAIL";
    case MailProvider.MAIL_PROVIDER_OUTLOOK:
      return "MAIL_PROVIDER_OUTLOOK";
    case MailProvider.MAIL_PROVIDER_EXCHANGE:
      return "MAIL_PROVIDER_EXCHANGE";
    case MailProvider.MAIL_PROVIDER_SMTP:
      return "MAIL_PROVIDER_SMTP";
    case MailProvider.MAIL_PROVIDER_OTHER:
      return "MAIL_PROVIDER_OTHER";
    case MailProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectionType {
  CONNECTION_TYPE_UNSPECIFIED = 0,
  CONNECTION_TYPE_OAUTH2 = 1,
  CONNECTION_TYPE_SMTP_IMAP = 2,
  UNRECOGNIZED = -1,
}

export function connectionTypeFromJSON(object: any): ConnectionType {
  switch (object) {
    case 0:
    case "CONNECTION_TYPE_UNSPECIFIED":
      return ConnectionType.CONNECTION_TYPE_UNSPECIFIED;
    case 1:
    case "CONNECTION_TYPE_OAUTH2":
      return ConnectionType.CONNECTION_TYPE_OAUTH2;
    case 2:
    case "CONNECTION_TYPE_SMTP_IMAP":
      return ConnectionType.CONNECTION_TYPE_SMTP_IMAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionType.UNRECOGNIZED;
  }
}

export function connectionTypeToJSON(object: ConnectionType): string {
  switch (object) {
    case ConnectionType.CONNECTION_TYPE_UNSPECIFIED:
      return "CONNECTION_TYPE_UNSPECIFIED";
    case ConnectionType.CONNECTION_TYPE_OAUTH2:
      return "CONNECTION_TYPE_OAUTH2";
    case ConnectionType.CONNECTION_TYPE_SMTP_IMAP:
      return "CONNECTION_TYPE_SMTP_IMAP";
    case ConnectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Timestamp {
  seconds: number;
  nanos: number;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface OperationResponse {
  success: boolean;
  message: string;
}

export interface Mailbox {
  id: string;
  organisationId: string;
  societeId: string;
  userId: string;
  nom: string;
  adresseEmail: string;
  fournisseur: MailProvider;
  typeConnexion: ConnectionType;
  /** SMTP/IMAP settings (for non-OAuth connections) */
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  imapHost?: string | undefined;
  imapPort?: number | undefined;
  username?:
    | string
    | undefined;
  /** OAuth2 tokens (encrypted) */
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  tokenExpiry?:
    | string
    | undefined;
  /** Additional settings */
  signature?: string | undefined;
  isDefault: boolean;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateMailboxRequest {
  organisationId: string;
  societeId: string;
  userId: string;
  nom: string;
  adresseEmail: string;
  fournisseur: MailProvider;
  typeConnexion: ConnectionType;
  /** SMTP/IMAP settings */
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  imapHost?: string | undefined;
  imapPort?: number | undefined;
  username?: string | undefined;
  password?:
    | string
    | undefined;
  /** OAuth2 tokens */
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  tokenExpiry?: string | undefined;
  signature?: string | undefined;
  isDefault: boolean;
}

export interface GetMailboxRequest {
  id: string;
}

export interface GetMailboxesByOrganisationRequest {
  organisationId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetMailboxesBySocieteRequest {
  societeId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface UpdateMailboxRequest {
  id: string;
  nom?: string | undefined;
  adresseEmail?: string | undefined;
  fournisseur?: MailProvider | undefined;
  typeConnexion?: ConnectionType | undefined;
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  imapHost?: string | undefined;
  imapPort?: number | undefined;
  username?: string | undefined;
  password?: string | undefined;
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  tokenExpiry?: string | undefined;
  signature?: string | undefined;
  isDefault?: boolean | undefined;
  isActive?: boolean | undefined;
}

export interface DeleteMailboxRequest {
  id: string;
}

export interface MailboxResponse {
  mailbox: Mailbox | undefined;
}

export interface MailboxListResponse {
  mailboxes: Mailbox[];
  total: number;
}

export interface GetAuthUrlRequest {
  redirectUri: string;
  state?: string | undefined;
  scopes: string[];
}

export interface AuthUrlResponse {
  authorizationUrl: string;
  state: string;
}

export interface ExchangeCodeRequest {
  code: string;
  redirectUri: string;
}

export interface TokenResponse {
  accessToken: string;
  refreshToken?: string | undefined;
  expiresIn: number;
  tokenType: string;
  idToken?: string | undefined;
}

export interface RefreshTokenRequest {
  refreshToken: string;
  mailboxId: string;
}

export interface RevokeTokenRequest {
  accessToken: string;
  mailboxId: string;
}

export interface GetUserInfoRequest {
  accessToken: string;
}

export interface UserInfoResponse {
  email: string;
  name: string;
  picture?: string | undefined;
  locale?: string | undefined;
}

export interface EmailAttachment {
  filename: string;
  contentType: string;
  content: Uint8Array;
  contentId?: string | undefined;
}

export interface EmailRecipient {
  email: string;
  name?: string | undefined;
}

export interface SendEmailRequest {
  mailboxId: string;
  to: EmailRecipient[];
  cc: EmailRecipient[];
  bcc: EmailRecipient[];
  subject: string;
  textBody?: string | undefined;
  htmlBody?: string | undefined;
  attachments: EmailAttachment[];
  replyTo?: string | undefined;
  headers: { [key: string]: string };
}

export interface SendEmailRequest_HeadersEntry {
  key: string;
  value: string;
}

export interface SendEmailWithTemplateRequest {
  mailboxId: string;
  to: EmailRecipient[];
  cc: EmailRecipient[];
  bcc: EmailRecipient[];
  templateId: string;
  templateVariables: { [key: string]: string };
  attachments: EmailAttachment[];
}

export interface SendEmailWithTemplateRequest_TemplateVariablesEntry {
  key: string;
  value: string;
}

export interface SendEmailResponse {
  success: boolean;
  messageId: string;
  error?: string | undefined;
}

export interface GetEmailsRequest {
  mailboxId: string;
  folder?: string | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
  searchQuery?: string | undefined;
}

export interface GetEmailRequest {
  mailboxId: string;
  emailId: string;
}

export interface Email {
  id: string;
  mailboxId: string;
  messageId: string;
  subject: string;
  from: EmailRecipient | undefined;
  to: EmailRecipient[];
  cc: EmailRecipient[];
  textBody?: string | undefined;
  htmlBody?: string | undefined;
  attachments: EmailAttachment[];
  folder: string;
  isRead: boolean;
  isStarred: boolean;
  receivedAt: string;
}

export interface EmailResponse {
  email: Email | undefined;
}

export interface EmailListResponse {
  emails: Email[];
  total: number;
}

export interface TestConnectionRequest {
  mailboxId: string;
}

export interface TestConnectionResponse {
  success: boolean;
  message: string;
  errorDetails?: string | undefined;
}

function createBaseTimestamp(): Timestamp {
  return { seconds: 0, nanos: 0 };
}

export const Timestamp: MessageFns<Timestamp> = {
  encode(message: Timestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds !== 0) {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Timestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seconds = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nanos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Timestamp {
    return {
      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
    };
  },

  toJSON(message: Timestamp): unknown {
    const obj: any = {};
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Timestamp>, I>>(base?: I): Timestamp {
    return Timestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Timestamp>, I>>(object: I): Timestamp {
    const message = createBaseTimestamp();
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseOperationResponse(): OperationResponse {
  return { success: false, message: "" };
}

export const OperationResponse: MessageFns<OperationResponse> = {
  encode(message: OperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: OperationResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationResponse>, I>>(base?: I): OperationResponse {
    return OperationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationResponse>, I>>(object: I): OperationResponse {
    const message = createBaseOperationResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseMailbox(): Mailbox {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    userId: "",
    nom: "",
    adresseEmail: "",
    fournisseur: 0,
    typeConnexion: 0,
    smtpHost: undefined,
    smtpPort: undefined,
    imapHost: undefined,
    imapPort: undefined,
    username: undefined,
    accessToken: undefined,
    refreshToken: undefined,
    tokenExpiry: undefined,
    signature: undefined,
    isDefault: false,
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Mailbox: MessageFns<Mailbox> = {
  encode(message: Mailbox, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.nom !== "") {
      writer.uint32(42).string(message.nom);
    }
    if (message.adresseEmail !== "") {
      writer.uint32(50).string(message.adresseEmail);
    }
    if (message.fournisseur !== 0) {
      writer.uint32(56).int32(message.fournisseur);
    }
    if (message.typeConnexion !== 0) {
      writer.uint32(64).int32(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      writer.uint32(74).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined) {
      writer.uint32(80).int32(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      writer.uint32(90).string(message.imapHost);
    }
    if (message.imapPort !== undefined) {
      writer.uint32(96).int32(message.imapPort);
    }
    if (message.username !== undefined) {
      writer.uint32(106).string(message.username);
    }
    if (message.accessToken !== undefined) {
      writer.uint32(114).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(122).string(message.refreshToken);
    }
    if (message.tokenExpiry !== undefined) {
      writer.uint32(130).string(message.tokenExpiry);
    }
    if (message.signature !== undefined) {
      writer.uint32(138).string(message.signature);
    }
    if (message.isDefault !== false) {
      writer.uint32(144).bool(message.isDefault);
    }
    if (message.isActive !== false) {
      writer.uint32(152).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(162).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(170).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mailbox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMailbox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fournisseur = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.typeConnexion = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.smtpPort = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.imapHost = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.imapPort = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.tokenExpiry = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mailbox {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      nom: isSet(object.nom) ? globalThis.String(object.nom) : "",
      adresseEmail: isSet(object.adresseEmail)
        ? globalThis.String(object.adresseEmail)
        : isSet(object.adresse_email)
        ? globalThis.String(object.adresse_email)
        : "",
      fournisseur: isSet(object.fournisseur) ? mailProviderFromJSON(object.fournisseur) : 0,
      typeConnexion: isSet(object.typeConnexion)
        ? connectionTypeFromJSON(object.typeConnexion)
        : isSet(object.type_connexion)
        ? connectionTypeFromJSON(object.type_connexion)
        : 0,
      smtpHost: isSet(object.smtpHost)
        ? globalThis.String(object.smtpHost)
        : isSet(object.smtp_host)
        ? globalThis.String(object.smtp_host)
        : undefined,
      smtpPort: isSet(object.smtpPort)
        ? globalThis.Number(object.smtpPort)
        : isSet(object.smtp_port)
        ? globalThis.Number(object.smtp_port)
        : undefined,
      imapHost: isSet(object.imapHost)
        ? globalThis.String(object.imapHost)
        : isSet(object.imap_host)
        ? globalThis.String(object.imap_host)
        : undefined,
      imapPort: isSet(object.imapPort)
        ? globalThis.Number(object.imapPort)
        : isSet(object.imap_port)
        ? globalThis.Number(object.imap_port)
        : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : undefined,
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : undefined,
      tokenExpiry: isSet(object.tokenExpiry)
        ? globalThis.String(object.tokenExpiry)
        : isSet(object.token_expiry)
        ? globalThis.String(object.token_expiry)
        : undefined,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : undefined,
      isDefault: isSet(object.isDefault)
        ? globalThis.Boolean(object.isDefault)
        : isSet(object.is_default)
        ? globalThis.Boolean(object.is_default)
        : false,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: Mailbox): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.nom !== "") {
      obj.nom = message.nom;
    }
    if (message.adresseEmail !== "") {
      obj.adresseEmail = message.adresseEmail;
    }
    if (message.fournisseur !== 0) {
      obj.fournisseur = mailProviderToJSON(message.fournisseur);
    }
    if (message.typeConnexion !== 0) {
      obj.typeConnexion = connectionTypeToJSON(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      obj.smtpHost = message.smtpHost;
    }
    if (message.smtpPort !== undefined) {
      obj.smtpPort = Math.round(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      obj.imapHost = message.imapHost;
    }
    if (message.imapPort !== undefined) {
      obj.imapPort = Math.round(message.imapPort);
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.accessToken !== undefined) {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== undefined) {
      obj.refreshToken = message.refreshToken;
    }
    if (message.tokenExpiry !== undefined) {
      obj.tokenExpiry = message.tokenExpiry;
    }
    if (message.signature !== undefined) {
      obj.signature = message.signature;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mailbox>, I>>(base?: I): Mailbox {
    return Mailbox.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mailbox>, I>>(object: I): Mailbox {
    const message = createBaseMailbox();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.userId = object.userId ?? "";
    message.nom = object.nom ?? "";
    message.adresseEmail = object.adresseEmail ?? "";
    message.fournisseur = object.fournisseur ?? 0;
    message.typeConnexion = object.typeConnexion ?? 0;
    message.smtpHost = object.smtpHost ?? undefined;
    message.smtpPort = object.smtpPort ?? undefined;
    message.imapHost = object.imapHost ?? undefined;
    message.imapPort = object.imapPort ?? undefined;
    message.username = object.username ?? undefined;
    message.accessToken = object.accessToken ?? undefined;
    message.refreshToken = object.refreshToken ?? undefined;
    message.tokenExpiry = object.tokenExpiry ?? undefined;
    message.signature = object.signature ?? undefined;
    message.isDefault = object.isDefault ?? false;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateMailboxRequest(): CreateMailboxRequest {
  return {
    organisationId: "",
    societeId: "",
    userId: "",
    nom: "",
    adresseEmail: "",
    fournisseur: 0,
    typeConnexion: 0,
    smtpHost: undefined,
    smtpPort: undefined,
    imapHost: undefined,
    imapPort: undefined,
    username: undefined,
    password: undefined,
    accessToken: undefined,
    refreshToken: undefined,
    tokenExpiry: undefined,
    signature: undefined,
    isDefault: false,
  };
}

export const CreateMailboxRequest: MessageFns<CreateMailboxRequest> = {
  encode(message: CreateMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.nom !== "") {
      writer.uint32(34).string(message.nom);
    }
    if (message.adresseEmail !== "") {
      writer.uint32(42).string(message.adresseEmail);
    }
    if (message.fournisseur !== 0) {
      writer.uint32(48).int32(message.fournisseur);
    }
    if (message.typeConnexion !== 0) {
      writer.uint32(56).int32(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      writer.uint32(66).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined) {
      writer.uint32(72).int32(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      writer.uint32(82).string(message.imapHost);
    }
    if (message.imapPort !== undefined) {
      writer.uint32(88).int32(message.imapPort);
    }
    if (message.username !== undefined) {
      writer.uint32(98).string(message.username);
    }
    if (message.password !== undefined) {
      writer.uint32(106).string(message.password);
    }
    if (message.accessToken !== undefined) {
      writer.uint32(114).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(122).string(message.refreshToken);
    }
    if (message.tokenExpiry !== undefined) {
      writer.uint32(130).string(message.tokenExpiry);
    }
    if (message.signature !== undefined) {
      writer.uint32(138).string(message.signature);
    }
    if (message.isDefault !== false) {
      writer.uint32(144).bool(message.isDefault);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fournisseur = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.typeConnexion = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.smtpPort = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.imapHost = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.imapPort = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.tokenExpiry = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMailboxRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      userId: isSet(object.userId)
        ? globalThis.String(object.userId)
        : isSet(object.user_id)
        ? globalThis.String(object.user_id)
        : "",
      nom: isSet(object.nom) ? globalThis.String(object.nom) : "",
      adresseEmail: isSet(object.adresseEmail)
        ? globalThis.String(object.adresseEmail)
        : isSet(object.adresse_email)
        ? globalThis.String(object.adresse_email)
        : "",
      fournisseur: isSet(object.fournisseur) ? mailProviderFromJSON(object.fournisseur) : 0,
      typeConnexion: isSet(object.typeConnexion)
        ? connectionTypeFromJSON(object.typeConnexion)
        : isSet(object.type_connexion)
        ? connectionTypeFromJSON(object.type_connexion)
        : 0,
      smtpHost: isSet(object.smtpHost)
        ? globalThis.String(object.smtpHost)
        : isSet(object.smtp_host)
        ? globalThis.String(object.smtp_host)
        : undefined,
      smtpPort: isSet(object.smtpPort)
        ? globalThis.Number(object.smtpPort)
        : isSet(object.smtp_port)
        ? globalThis.Number(object.smtp_port)
        : undefined,
      imapHost: isSet(object.imapHost)
        ? globalThis.String(object.imapHost)
        : isSet(object.imap_host)
        ? globalThis.String(object.imap_host)
        : undefined,
      imapPort: isSet(object.imapPort)
        ? globalThis.Number(object.imapPort)
        : isSet(object.imap_port)
        ? globalThis.Number(object.imap_port)
        : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : undefined,
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : undefined,
      tokenExpiry: isSet(object.tokenExpiry)
        ? globalThis.String(object.tokenExpiry)
        : isSet(object.token_expiry)
        ? globalThis.String(object.token_expiry)
        : undefined,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : undefined,
      isDefault: isSet(object.isDefault)
        ? globalThis.Boolean(object.isDefault)
        : isSet(object.is_default)
        ? globalThis.Boolean(object.is_default)
        : false,
    };
  },

  toJSON(message: CreateMailboxRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.nom !== "") {
      obj.nom = message.nom;
    }
    if (message.adresseEmail !== "") {
      obj.adresseEmail = message.adresseEmail;
    }
    if (message.fournisseur !== 0) {
      obj.fournisseur = mailProviderToJSON(message.fournisseur);
    }
    if (message.typeConnexion !== 0) {
      obj.typeConnexion = connectionTypeToJSON(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      obj.smtpHost = message.smtpHost;
    }
    if (message.smtpPort !== undefined) {
      obj.smtpPort = Math.round(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      obj.imapHost = message.imapHost;
    }
    if (message.imapPort !== undefined) {
      obj.imapPort = Math.round(message.imapPort);
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.password !== undefined) {
      obj.password = message.password;
    }
    if (message.accessToken !== undefined) {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== undefined) {
      obj.refreshToken = message.refreshToken;
    }
    if (message.tokenExpiry !== undefined) {
      obj.tokenExpiry = message.tokenExpiry;
    }
    if (message.signature !== undefined) {
      obj.signature = message.signature;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMailboxRequest>, I>>(base?: I): CreateMailboxRequest {
    return CreateMailboxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMailboxRequest>, I>>(object: I): CreateMailboxRequest {
    const message = createBaseCreateMailboxRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.userId = object.userId ?? "";
    message.nom = object.nom ?? "";
    message.adresseEmail = object.adresseEmail ?? "";
    message.fournisseur = object.fournisseur ?? 0;
    message.typeConnexion = object.typeConnexion ?? 0;
    message.smtpHost = object.smtpHost ?? undefined;
    message.smtpPort = object.smtpPort ?? undefined;
    message.imapHost = object.imapHost ?? undefined;
    message.imapPort = object.imapPort ?? undefined;
    message.username = object.username ?? undefined;
    message.password = object.password ?? undefined;
    message.accessToken = object.accessToken ?? undefined;
    message.refreshToken = object.refreshToken ?? undefined;
    message.tokenExpiry = object.tokenExpiry ?? undefined;
    message.signature = object.signature ?? undefined;
    message.isDefault = object.isDefault ?? false;
    return message;
  },
};

function createBaseGetMailboxRequest(): GetMailboxRequest {
  return { id: "" };
}

export const GetMailboxRequest: MessageFns<GetMailboxRequest> = {
  encode(message: GetMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMailboxRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetMailboxRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMailboxRequest>, I>>(base?: I): GetMailboxRequest {
    return GetMailboxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMailboxRequest>, I>>(object: I): GetMailboxRequest {
    const message = createBaseGetMailboxRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetMailboxesByOrganisationRequest(): GetMailboxesByOrganisationRequest {
  return { organisationId: "", limit: undefined, offset: undefined };
}

export const GetMailboxesByOrganisationRequest: MessageFns<GetMailboxesByOrganisationRequest> = {
  encode(message: GetMailboxesByOrganisationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMailboxesByOrganisationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailboxesByOrganisationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMailboxesByOrganisationRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
    };
  },

  toJSON(message: GetMailboxesByOrganisationRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMailboxesByOrganisationRequest>, I>>(
    base?: I,
  ): GetMailboxesByOrganisationRequest {
    return GetMailboxesByOrganisationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMailboxesByOrganisationRequest>, I>>(
    object: I,
  ): GetMailboxesByOrganisationRequest {
    const message = createBaseGetMailboxesByOrganisationRequest();
    message.organisationId = object.organisationId ?? "";
    message.limit = object.limit ?? undefined;
    message.offset = object.offset ?? undefined;
    return message;
  },
};

function createBaseGetMailboxesBySocieteRequest(): GetMailboxesBySocieteRequest {
  return { societeId: "", limit: undefined, offset: undefined };
}

export const GetMailboxesBySocieteRequest: MessageFns<GetMailboxesBySocieteRequest> = {
  encode(message: GetMailboxesBySocieteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMailboxesBySocieteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailboxesBySocieteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMailboxesBySocieteRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
    };
  },

  toJSON(message: GetMailboxesBySocieteRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMailboxesBySocieteRequest>, I>>(base?: I): GetMailboxesBySocieteRequest {
    return GetMailboxesBySocieteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMailboxesBySocieteRequest>, I>>(object: I): GetMailboxesBySocieteRequest {
    const message = createBaseGetMailboxesBySocieteRequest();
    message.societeId = object.societeId ?? "";
    message.limit = object.limit ?? undefined;
    message.offset = object.offset ?? undefined;
    return message;
  },
};

function createBaseUpdateMailboxRequest(): UpdateMailboxRequest {
  return {
    id: "",
    nom: undefined,
    adresseEmail: undefined,
    fournisseur: undefined,
    typeConnexion: undefined,
    smtpHost: undefined,
    smtpPort: undefined,
    imapHost: undefined,
    imapPort: undefined,
    username: undefined,
    password: undefined,
    accessToken: undefined,
    refreshToken: undefined,
    tokenExpiry: undefined,
    signature: undefined,
    isDefault: undefined,
    isActive: undefined,
  };
}

export const UpdateMailboxRequest: MessageFns<UpdateMailboxRequest> = {
  encode(message: UpdateMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.adresseEmail !== undefined) {
      writer.uint32(26).string(message.adresseEmail);
    }
    if (message.fournisseur !== undefined) {
      writer.uint32(32).int32(message.fournisseur);
    }
    if (message.typeConnexion !== undefined) {
      writer.uint32(40).int32(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      writer.uint32(50).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined) {
      writer.uint32(56).int32(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      writer.uint32(66).string(message.imapHost);
    }
    if (message.imapPort !== undefined) {
      writer.uint32(72).int32(message.imapPort);
    }
    if (message.username !== undefined) {
      writer.uint32(82).string(message.username);
    }
    if (message.password !== undefined) {
      writer.uint32(90).string(message.password);
    }
    if (message.accessToken !== undefined) {
      writer.uint32(98).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(106).string(message.refreshToken);
    }
    if (message.tokenExpiry !== undefined) {
      writer.uint32(114).string(message.tokenExpiry);
    }
    if (message.signature !== undefined) {
      writer.uint32(122).string(message.signature);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(128).bool(message.isDefault);
    }
    if (message.isActive !== undefined) {
      writer.uint32(136).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fournisseur = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.typeConnexion = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.smtpPort = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.imapHost = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.imapPort = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.tokenExpiry = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMailboxRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nom: isSet(object.nom) ? globalThis.String(object.nom) : undefined,
      adresseEmail: isSet(object.adresseEmail)
        ? globalThis.String(object.adresseEmail)
        : isSet(object.adresse_email)
        ? globalThis.String(object.adresse_email)
        : undefined,
      fournisseur: isSet(object.fournisseur) ? mailProviderFromJSON(object.fournisseur) : undefined,
      typeConnexion: isSet(object.typeConnexion)
        ? connectionTypeFromJSON(object.typeConnexion)
        : isSet(object.type_connexion)
        ? connectionTypeFromJSON(object.type_connexion)
        : undefined,
      smtpHost: isSet(object.smtpHost)
        ? globalThis.String(object.smtpHost)
        : isSet(object.smtp_host)
        ? globalThis.String(object.smtp_host)
        : undefined,
      smtpPort: isSet(object.smtpPort)
        ? globalThis.Number(object.smtpPort)
        : isSet(object.smtp_port)
        ? globalThis.Number(object.smtp_port)
        : undefined,
      imapHost: isSet(object.imapHost)
        ? globalThis.String(object.imapHost)
        : isSet(object.imap_host)
        ? globalThis.String(object.imap_host)
        : undefined,
      imapPort: isSet(object.imapPort)
        ? globalThis.Number(object.imapPort)
        : isSet(object.imap_port)
        ? globalThis.Number(object.imap_port)
        : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : undefined,
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : undefined,
      tokenExpiry: isSet(object.tokenExpiry)
        ? globalThis.String(object.tokenExpiry)
        : isSet(object.token_expiry)
        ? globalThis.String(object.token_expiry)
        : undefined,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : undefined,
      isDefault: isSet(object.isDefault)
        ? globalThis.Boolean(object.isDefault)
        : isSet(object.is_default)
        ? globalThis.Boolean(object.is_default)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
    };
  },

  toJSON(message: UpdateMailboxRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nom !== undefined) {
      obj.nom = message.nom;
    }
    if (message.adresseEmail !== undefined) {
      obj.adresseEmail = message.adresseEmail;
    }
    if (message.fournisseur !== undefined) {
      obj.fournisseur = mailProviderToJSON(message.fournisseur);
    }
    if (message.typeConnexion !== undefined) {
      obj.typeConnexion = connectionTypeToJSON(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      obj.smtpHost = message.smtpHost;
    }
    if (message.smtpPort !== undefined) {
      obj.smtpPort = Math.round(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      obj.imapHost = message.imapHost;
    }
    if (message.imapPort !== undefined) {
      obj.imapPort = Math.round(message.imapPort);
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.password !== undefined) {
      obj.password = message.password;
    }
    if (message.accessToken !== undefined) {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== undefined) {
      obj.refreshToken = message.refreshToken;
    }
    if (message.tokenExpiry !== undefined) {
      obj.tokenExpiry = message.tokenExpiry;
    }
    if (message.signature !== undefined) {
      obj.signature = message.signature;
    }
    if (message.isDefault !== undefined) {
      obj.isDefault = message.isDefault;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateMailboxRequest>, I>>(base?: I): UpdateMailboxRequest {
    return UpdateMailboxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateMailboxRequest>, I>>(object: I): UpdateMailboxRequest {
    const message = createBaseUpdateMailboxRequest();
    message.id = object.id ?? "";
    message.nom = object.nom ?? undefined;
    message.adresseEmail = object.adresseEmail ?? undefined;
    message.fournisseur = object.fournisseur ?? undefined;
    message.typeConnexion = object.typeConnexion ?? undefined;
    message.smtpHost = object.smtpHost ?? undefined;
    message.smtpPort = object.smtpPort ?? undefined;
    message.imapHost = object.imapHost ?? undefined;
    message.imapPort = object.imapPort ?? undefined;
    message.username = object.username ?? undefined;
    message.password = object.password ?? undefined;
    message.accessToken = object.accessToken ?? undefined;
    message.refreshToken = object.refreshToken ?? undefined;
    message.tokenExpiry = object.tokenExpiry ?? undefined;
    message.signature = object.signature ?? undefined;
    message.isDefault = object.isDefault ?? undefined;
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

function createBaseDeleteMailboxRequest(): DeleteMailboxRequest {
  return { id: "" };
}

export const DeleteMailboxRequest: MessageFns<DeleteMailboxRequest> = {
  encode(message: DeleteMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMailboxRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteMailboxRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMailboxRequest>, I>>(base?: I): DeleteMailboxRequest {
    return DeleteMailboxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMailboxRequest>, I>>(object: I): DeleteMailboxRequest {
    const message = createBaseDeleteMailboxRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseMailboxResponse(): MailboxResponse {
  return { mailbox: undefined };
}

export const MailboxResponse: MessageFns<MailboxResponse> = {
  encode(message: MailboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailbox !== undefined) {
      Mailbox.encode(message.mailbox, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MailboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMailboxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailbox = Mailbox.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MailboxResponse {
    return { mailbox: isSet(object.mailbox) ? Mailbox.fromJSON(object.mailbox) : undefined };
  },

  toJSON(message: MailboxResponse): unknown {
    const obj: any = {};
    if (message.mailbox !== undefined) {
      obj.mailbox = Mailbox.toJSON(message.mailbox);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MailboxResponse>, I>>(base?: I): MailboxResponse {
    return MailboxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MailboxResponse>, I>>(object: I): MailboxResponse {
    const message = createBaseMailboxResponse();
    message.mailbox = (object.mailbox !== undefined && object.mailbox !== null)
      ? Mailbox.fromPartial(object.mailbox)
      : undefined;
    return message;
  },
};

function createBaseMailboxListResponse(): MailboxListResponse {
  return { mailboxes: [], total: 0 };
}

export const MailboxListResponse: MessageFns<MailboxListResponse> = {
  encode(message: MailboxListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mailboxes) {
      Mailbox.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MailboxListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMailboxListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxes.push(Mailbox.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MailboxListResponse {
    return {
      mailboxes: globalThis.Array.isArray(object?.mailboxes)
        ? object.mailboxes.map((e: any) => Mailbox.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: MailboxListResponse): unknown {
    const obj: any = {};
    if (message.mailboxes?.length) {
      obj.mailboxes = message.mailboxes.map((e) => Mailbox.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MailboxListResponse>, I>>(base?: I): MailboxListResponse {
    return MailboxListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MailboxListResponse>, I>>(object: I): MailboxListResponse {
    const message = createBaseMailboxListResponse();
    message.mailboxes = object.mailboxes?.map((e) => Mailbox.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseGetAuthUrlRequest(): GetAuthUrlRequest {
  return { redirectUri: "", state: undefined, scopes: [] };
}

export const GetAuthUrlRequest: MessageFns<GetAuthUrlRequest> = {
  encode(message: GetAuthUrlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redirectUri !== "") {
      writer.uint32(10).string(message.redirectUri);
    }
    if (message.state !== undefined) {
      writer.uint32(18).string(message.state);
    }
    for (const v of message.scopes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuthUrlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthUrlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuthUrlRequest {
    return {
      redirectUri: isSet(object.redirectUri)
        ? globalThis.String(object.redirectUri)
        : isSet(object.redirect_uri)
        ? globalThis.String(object.redirect_uri)
        : "",
      state: isSet(object.state) ? globalThis.String(object.state) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetAuthUrlRequest): unknown {
    const obj: any = {};
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuthUrlRequest>, I>>(base?: I): GetAuthUrlRequest {
    return GetAuthUrlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuthUrlRequest>, I>>(object: I): GetAuthUrlRequest {
    const message = createBaseGetAuthUrlRequest();
    message.redirectUri = object.redirectUri ?? "";
    message.state = object.state ?? undefined;
    message.scopes = object.scopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseAuthUrlResponse(): AuthUrlResponse {
  return { authorizationUrl: "", state: "" };
}

export const AuthUrlResponse: MessageFns<AuthUrlResponse> = {
  encode(message: AuthUrlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorizationUrl !== "") {
      writer.uint32(10).string(message.authorizationUrl);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthUrlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthUrlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthUrlResponse {
    return {
      authorizationUrl: isSet(object.authorizationUrl)
        ? globalThis.String(object.authorizationUrl)
        : isSet(object.authorization_url)
        ? globalThis.String(object.authorization_url)
        : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
    };
  },

  toJSON(message: AuthUrlResponse): unknown {
    const obj: any = {};
    if (message.authorizationUrl !== "") {
      obj.authorizationUrl = message.authorizationUrl;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthUrlResponse>, I>>(base?: I): AuthUrlResponse {
    return AuthUrlResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthUrlResponse>, I>>(object: I): AuthUrlResponse {
    const message = createBaseAuthUrlResponse();
    message.authorizationUrl = object.authorizationUrl ?? "";
    message.state = object.state ?? "";
    return message;
  },
};

function createBaseExchangeCodeRequest(): ExchangeCodeRequest {
  return { code: "", redirectUri: "" };
}

export const ExchangeCodeRequest: MessageFns<ExchangeCodeRequest> = {
  encode(message: ExchangeCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.redirectUri !== "") {
      writer.uint32(18).string(message.redirectUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeCodeRequest {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      redirectUri: isSet(object.redirectUri)
        ? globalThis.String(object.redirectUri)
        : isSet(object.redirect_uri)
        ? globalThis.String(object.redirect_uri)
        : "",
    };
  },

  toJSON(message: ExchangeCodeRequest): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeCodeRequest>, I>>(base?: I): ExchangeCodeRequest {
    return ExchangeCodeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeCodeRequest>, I>>(object: I): ExchangeCodeRequest {
    const message = createBaseExchangeCodeRequest();
    message.code = object.code ?? "";
    message.redirectUri = object.redirectUri ?? "";
    return message;
  },
};

function createBaseTokenResponse(): TokenResponse {
  return { accessToken: "", refreshToken: undefined, expiresIn: 0, tokenType: "", idToken: undefined };
}

export const TokenResponse: MessageFns<TokenResponse> = {
  encode(message: TokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.expiresIn !== 0) {
      writer.uint32(24).int64(message.expiresIn);
    }
    if (message.tokenType !== "") {
      writer.uint32(34).string(message.tokenType);
    }
    if (message.idToken !== undefined) {
      writer.uint32(42).string(message.idToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresIn = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.idToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenResponse {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : undefined,
      expiresIn: isSet(object.expiresIn)
        ? globalThis.Number(object.expiresIn)
        : isSet(object.expires_in)
        ? globalThis.Number(object.expires_in)
        : 0,
      tokenType: isSet(object.tokenType)
        ? globalThis.String(object.tokenType)
        : isSet(object.token_type)
        ? globalThis.String(object.token_type)
        : "",
      idToken: isSet(object.idToken)
        ? globalThis.String(object.idToken)
        : isSet(object.id_token)
        ? globalThis.String(object.id_token)
        : undefined,
    };
  },

  toJSON(message: TokenResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== undefined) {
      obj.refreshToken = message.refreshToken;
    }
    if (message.expiresIn !== 0) {
      obj.expiresIn = Math.round(message.expiresIn);
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    if (message.idToken !== undefined) {
      obj.idToken = message.idToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenResponse>, I>>(base?: I): TokenResponse {
    return TokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenResponse>, I>>(object: I): TokenResponse {
    const message = createBaseTokenResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? undefined;
    message.expiresIn = object.expiresIn ?? 0;
    message.tokenType = object.tokenType ?? "";
    message.idToken = object.idToken ?? undefined;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "", mailboxId: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    if (message.mailboxId !== "") {
      writer.uint32(18).string(message.mailboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return {
      refreshToken: isSet(object.refreshToken)
        ? globalThis.String(object.refreshToken)
        : isSet(object.refresh_token)
        ? globalThis.String(object.refresh_token)
        : "",
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
    };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    message.mailboxId = object.mailboxId ?? "";
    return message;
  },
};

function createBaseRevokeTokenRequest(): RevokeTokenRequest {
  return { accessToken: "", mailboxId: "" };
}

export const RevokeTokenRequest: MessageFns<RevokeTokenRequest> = {
  encode(message: RevokeTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.mailboxId !== "") {
      writer.uint32(18).string(message.mailboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeTokenRequest {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
    };
  },

  toJSON(message: RevokeTokenRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeTokenRequest>, I>>(base?: I): RevokeTokenRequest {
    return RevokeTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeTokenRequest>, I>>(object: I): RevokeTokenRequest {
    const message = createBaseRevokeTokenRequest();
    message.accessToken = object.accessToken ?? "";
    message.mailboxId = object.mailboxId ?? "";
    return message;
  },
};

function createBaseGetUserInfoRequest(): GetUserInfoRequest {
  return { accessToken: "" };
}

export const GetUserInfoRequest: MessageFns<GetUserInfoRequest> = {
  encode(message: GetUserInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInfoRequest {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
    };
  },

  toJSON(message: GetUserInfoRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInfoRequest>, I>>(base?: I): GetUserInfoRequest {
    return GetUserInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInfoRequest>, I>>(object: I): GetUserInfoRequest {
    const message = createBaseGetUserInfoRequest();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseUserInfoResponse(): UserInfoResponse {
  return { email: "", name: "", picture: undefined, locale: undefined };
}

export const UserInfoResponse: MessageFns<UserInfoResponse> = {
  encode(message: UserInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.picture !== undefined) {
      writer.uint32(26).string(message.picture);
    }
    if (message.locale !== undefined) {
      writer.uint32(34).string(message.locale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.picture = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfoResponse {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      picture: isSet(object.picture) ? globalThis.String(object.picture) : undefined,
      locale: isSet(object.locale) ? globalThis.String(object.locale) : undefined,
    };
  },

  toJSON(message: UserInfoResponse): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.picture !== undefined) {
      obj.picture = message.picture;
    }
    if (message.locale !== undefined) {
      obj.locale = message.locale;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfoResponse>, I>>(base?: I): UserInfoResponse {
    return UserInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfoResponse>, I>>(object: I): UserInfoResponse {
    const message = createBaseUserInfoResponse();
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    message.picture = object.picture ?? undefined;
    message.locale = object.locale ?? undefined;
    return message;
  },
};

function createBaseEmailAttachment(): EmailAttachment {
  return { filename: "", contentType: "", content: new Uint8Array(0), contentId: undefined };
}

export const EmailAttachment: MessageFns<EmailAttachment> = {
  encode(message: EmailAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.contentType !== "") {
      writer.uint32(18).string(message.contentType);
    }
    if (message.content.length !== 0) {
      writer.uint32(26).bytes(message.content);
    }
    if (message.contentId !== undefined) {
      writer.uint32(34).string(message.contentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailAttachment {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      contentType: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : isSet(object.content_type)
        ? globalThis.String(object.content_type)
        : "",
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
      contentId: isSet(object.contentId)
        ? globalThis.String(object.contentId)
        : isSet(object.content_id)
        ? globalThis.String(object.content_id)
        : undefined,
    };
  },

  toJSON(message: EmailAttachment): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.contentId !== undefined) {
      obj.contentId = message.contentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailAttachment>, I>>(base?: I): EmailAttachment {
    return EmailAttachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailAttachment>, I>>(object: I): EmailAttachment {
    const message = createBaseEmailAttachment();
    message.filename = object.filename ?? "";
    message.contentType = object.contentType ?? "";
    message.content = object.content ?? new Uint8Array(0);
    message.contentId = object.contentId ?? undefined;
    return message;
  },
};

function createBaseEmailRecipient(): EmailRecipient {
  return { email: "", name: undefined };
}

export const EmailRecipient: MessageFns<EmailRecipient> = {
  encode(message: EmailRecipient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailRecipient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailRecipient {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
    };
  },

  toJSON(message: EmailRecipient): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailRecipient>, I>>(base?: I): EmailRecipient {
    return EmailRecipient.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailRecipient>, I>>(object: I): EmailRecipient {
    const message = createBaseEmailRecipient();
    message.email = object.email ?? "";
    message.name = object.name ?? undefined;
    return message;
  },
};

function createBaseSendEmailRequest(): SendEmailRequest {
  return {
    mailboxId: "",
    to: [],
    cc: [],
    bcc: [],
    subject: "",
    textBody: undefined,
    htmlBody: undefined,
    attachments: [],
    replyTo: undefined,
    headers: {},
  };
}

export const SendEmailRequest: MessageFns<SendEmailRequest> = {
  encode(message: SendEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    for (const v of message.to) {
      EmailRecipient.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.cc) {
      EmailRecipient.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.bcc) {
      EmailRecipient.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.subject !== "") {
      writer.uint32(42).string(message.subject);
    }
    if (message.textBody !== undefined) {
      writer.uint32(50).string(message.textBody);
    }
    if (message.htmlBody !== undefined) {
      writer.uint32(58).string(message.htmlBody);
    }
    for (const v of message.attachments) {
      EmailAttachment.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.replyTo !== undefined) {
      writer.uint32(74).string(message.replyTo);
    }
    globalThis.Object.entries(message.headers).forEach(([key, value]: [string, string]) => {
      SendEmailRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bcc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.textBody = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.htmlBody = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attachments.push(EmailAttachment.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.replyTo = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = SendEmailRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.headers[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailRequest {
    return {
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
      to: globalThis.Array.isArray(object?.to) ? object.to.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      cc: globalThis.Array.isArray(object?.cc) ? object.cc.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      bcc: globalThis.Array.isArray(object?.bcc) ? object.bcc.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      textBody: isSet(object.textBody)
        ? globalThis.String(object.textBody)
        : isSet(object.text_body)
        ? globalThis.String(object.text_body)
        : undefined,
      htmlBody: isSet(object.htmlBody)
        ? globalThis.String(object.htmlBody)
        : isSet(object.html_body)
        ? globalThis.String(object.html_body)
        : undefined,
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => EmailAttachment.fromJSON(e))
        : [],
      replyTo: isSet(object.replyTo)
        ? globalThis.String(object.replyTo)
        : isSet(object.reply_to)
        ? globalThis.String(object.reply_to)
        : undefined,
      headers: isObject(object.headers)
        ? (globalThis.Object.entries(object.headers) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SendEmailRequest): unknown {
    const obj: any = {};
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    if (message.to?.length) {
      obj.to = message.to.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.cc?.length) {
      obj.cc = message.cc.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.bcc?.length) {
      obj.bcc = message.bcc.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.textBody !== undefined) {
      obj.textBody = message.textBody;
    }
    if (message.htmlBody !== undefined) {
      obj.htmlBody = message.htmlBody;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => EmailAttachment.toJSON(e));
    }
    if (message.replyTo !== undefined) {
      obj.replyTo = message.replyTo;
    }
    if (message.headers) {
      const entries = globalThis.Object.entries(message.headers) as [string, string][];
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailRequest>, I>>(base?: I): SendEmailRequest {
    return SendEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailRequest>, I>>(object: I): SendEmailRequest {
    const message = createBaseSendEmailRequest();
    message.mailboxId = object.mailboxId ?? "";
    message.to = object.to?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.cc = object.cc?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.bcc = object.bcc?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.subject = object.subject ?? "";
    message.textBody = object.textBody ?? undefined;
    message.htmlBody = object.htmlBody ?? undefined;
    message.attachments = object.attachments?.map((e) => EmailAttachment.fromPartial(e)) || [];
    message.replyTo = object.replyTo ?? undefined;
    message.headers = (globalThis.Object.entries(object.headers ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSendEmailRequest_HeadersEntry(): SendEmailRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const SendEmailRequest_HeadersEntry: MessageFns<SendEmailRequest_HeadersEntry> = {
  encode(message: SendEmailRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SendEmailRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailRequest_HeadersEntry>, I>>(base?: I): SendEmailRequest_HeadersEntry {
    return SendEmailRequest_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailRequest_HeadersEntry>, I>>(
    object: I,
  ): SendEmailRequest_HeadersEntry {
    const message = createBaseSendEmailRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSendEmailWithTemplateRequest(): SendEmailWithTemplateRequest {
  return { mailboxId: "", to: [], cc: [], bcc: [], templateId: "", templateVariables: {}, attachments: [] };
}

export const SendEmailWithTemplateRequest: MessageFns<SendEmailWithTemplateRequest> = {
  encode(message: SendEmailWithTemplateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    for (const v of message.to) {
      EmailRecipient.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.cc) {
      EmailRecipient.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.bcc) {
      EmailRecipient.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.templateId !== "") {
      writer.uint32(42).string(message.templateId);
    }
    globalThis.Object.entries(message.templateVariables).forEach(([key, value]: [string, string]) => {
      SendEmailWithTemplateRequest_TemplateVariablesEntry.encode({ key: key as any, value }, writer.uint32(50).fork())
        .join();
    });
    for (const v of message.attachments) {
      EmailAttachment.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailWithTemplateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailWithTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bcc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.templateId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = SendEmailWithTemplateRequest_TemplateVariablesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.templateVariables[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attachments.push(EmailAttachment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailWithTemplateRequest {
    return {
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
      to: globalThis.Array.isArray(object?.to) ? object.to.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      cc: globalThis.Array.isArray(object?.cc) ? object.cc.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      bcc: globalThis.Array.isArray(object?.bcc) ? object.bcc.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      templateId: isSet(object.templateId)
        ? globalThis.String(object.templateId)
        : isSet(object.template_id)
        ? globalThis.String(object.template_id)
        : "",
      templateVariables: isObject(object.templateVariables)
        ? (globalThis.Object.entries(object.templateVariables) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : isObject(object.template_variables)
        ? (globalThis.Object.entries(object.template_variables) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => EmailAttachment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SendEmailWithTemplateRequest): unknown {
    const obj: any = {};
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    if (message.to?.length) {
      obj.to = message.to.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.cc?.length) {
      obj.cc = message.cc.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.bcc?.length) {
      obj.bcc = message.bcc.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.templateId !== "") {
      obj.templateId = message.templateId;
    }
    if (message.templateVariables) {
      const entries = globalThis.Object.entries(message.templateVariables) as [string, string][];
      if (entries.length > 0) {
        obj.templateVariables = {};
        entries.forEach(([k, v]) => {
          obj.templateVariables[k] = v;
        });
      }
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => EmailAttachment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailWithTemplateRequest>, I>>(base?: I): SendEmailWithTemplateRequest {
    return SendEmailWithTemplateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailWithTemplateRequest>, I>>(object: I): SendEmailWithTemplateRequest {
    const message = createBaseSendEmailWithTemplateRequest();
    message.mailboxId = object.mailboxId ?? "";
    message.to = object.to?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.cc = object.cc?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.bcc = object.bcc?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.templateId = object.templateId ?? "";
    message.templateVariables = (globalThis.Object.entries(object.templateVariables ?? {}) as [string, string][])
      .reduce((acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      }, {});
    message.attachments = object.attachments?.map((e) => EmailAttachment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSendEmailWithTemplateRequest_TemplateVariablesEntry(): SendEmailWithTemplateRequest_TemplateVariablesEntry {
  return { key: "", value: "" };
}

export const SendEmailWithTemplateRequest_TemplateVariablesEntry: MessageFns<
  SendEmailWithTemplateRequest_TemplateVariablesEntry
> = {
  encode(
    message: SendEmailWithTemplateRequest_TemplateVariablesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailWithTemplateRequest_TemplateVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailWithTemplateRequest_TemplateVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailWithTemplateRequest_TemplateVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SendEmailWithTemplateRequest_TemplateVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailWithTemplateRequest_TemplateVariablesEntry>, I>>(
    base?: I,
  ): SendEmailWithTemplateRequest_TemplateVariablesEntry {
    return SendEmailWithTemplateRequest_TemplateVariablesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailWithTemplateRequest_TemplateVariablesEntry>, I>>(
    object: I,
  ): SendEmailWithTemplateRequest_TemplateVariablesEntry {
    const message = createBaseSendEmailWithTemplateRequest_TemplateVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSendEmailResponse(): SendEmailResponse {
  return { success: false, messageId: "", error: undefined };
}

export const SendEmailResponse: MessageFns<SendEmailResponse> = {
  encode(message: SendEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : isSet(object.message_id)
        ? globalThis.String(object.message_id)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: SendEmailResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailResponse>, I>>(base?: I): SendEmailResponse {
    return SendEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailResponse>, I>>(object: I): SendEmailResponse {
    const message = createBaseSendEmailResponse();
    message.success = object.success ?? false;
    message.messageId = object.messageId ?? "";
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseGetEmailsRequest(): GetEmailsRequest {
  return { mailboxId: "", folder: undefined, limit: undefined, offset: undefined, searchQuery: undefined };
}

export const GetEmailsRequest: MessageFns<GetEmailsRequest> = {
  encode(message: GetEmailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    if (message.folder !== undefined) {
      writer.uint32(18).string(message.folder);
    }
    if (message.limit !== undefined) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int32(message.offset);
    }
    if (message.searchQuery !== undefined) {
      writer.uint32(42).string(message.searchQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.folder = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEmailsRequest {
    return {
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
      folder: isSet(object.folder) ? globalThis.String(object.folder) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
      searchQuery: isSet(object.searchQuery)
        ? globalThis.String(object.searchQuery)
        : isSet(object.search_query)
        ? globalThis.String(object.search_query)
        : undefined,
    };
  },

  toJSON(message: GetEmailsRequest): unknown {
    const obj: any = {};
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    if (message.folder !== undefined) {
      obj.folder = message.folder;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    if (message.searchQuery !== undefined) {
      obj.searchQuery = message.searchQuery;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEmailsRequest>, I>>(base?: I): GetEmailsRequest {
    return GetEmailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEmailsRequest>, I>>(object: I): GetEmailsRequest {
    const message = createBaseGetEmailsRequest();
    message.mailboxId = object.mailboxId ?? "";
    message.folder = object.folder ?? undefined;
    message.limit = object.limit ?? undefined;
    message.offset = object.offset ?? undefined;
    message.searchQuery = object.searchQuery ?? undefined;
    return message;
  },
};

function createBaseGetEmailRequest(): GetEmailRequest {
  return { mailboxId: "", emailId: "" };
}

export const GetEmailRequest: MessageFns<GetEmailRequest> = {
  encode(message: GetEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    if (message.emailId !== "") {
      writer.uint32(18).string(message.emailId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emailId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEmailRequest {
    return {
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
      emailId: isSet(object.emailId)
        ? globalThis.String(object.emailId)
        : isSet(object.email_id)
        ? globalThis.String(object.email_id)
        : "",
    };
  },

  toJSON(message: GetEmailRequest): unknown {
    const obj: any = {};
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    if (message.emailId !== "") {
      obj.emailId = message.emailId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEmailRequest>, I>>(base?: I): GetEmailRequest {
    return GetEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEmailRequest>, I>>(object: I): GetEmailRequest {
    const message = createBaseGetEmailRequest();
    message.mailboxId = object.mailboxId ?? "";
    message.emailId = object.emailId ?? "";
    return message;
  },
};

function createBaseEmail(): Email {
  return {
    id: "",
    mailboxId: "",
    messageId: "",
    subject: "",
    from: undefined,
    to: [],
    cc: [],
    textBody: undefined,
    htmlBody: undefined,
    attachments: [],
    folder: "",
    isRead: false,
    isStarred: false,
    receivedAt: "",
  };
}

export const Email: MessageFns<Email> = {
  encode(message: Email, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mailboxId !== "") {
      writer.uint32(18).string(message.mailboxId);
    }
    if (message.messageId !== "") {
      writer.uint32(26).string(message.messageId);
    }
    if (message.subject !== "") {
      writer.uint32(34).string(message.subject);
    }
    if (message.from !== undefined) {
      EmailRecipient.encode(message.from, writer.uint32(42).fork()).join();
    }
    for (const v of message.to) {
      EmailRecipient.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.cc) {
      EmailRecipient.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.textBody !== undefined) {
      writer.uint32(66).string(message.textBody);
    }
    if (message.htmlBody !== undefined) {
      writer.uint32(74).string(message.htmlBody);
    }
    for (const v of message.attachments) {
      EmailAttachment.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.folder !== "") {
      writer.uint32(90).string(message.folder);
    }
    if (message.isRead !== false) {
      writer.uint32(96).bool(message.isRead);
    }
    if (message.isStarred !== false) {
      writer.uint32(104).bool(message.isStarred);
    }
    if (message.receivedAt !== "") {
      writer.uint32(114).string(message.receivedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Email {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.from = EmailRecipient.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.to.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.textBody = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.htmlBody = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attachments.push(EmailAttachment.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.folder = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isRead = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Email {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
      messageId: isSet(object.messageId)
        ? globalThis.String(object.messageId)
        : isSet(object.message_id)
        ? globalThis.String(object.message_id)
        : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      from: isSet(object.from) ? EmailRecipient.fromJSON(object.from) : undefined,
      to: globalThis.Array.isArray(object?.to) ? object.to.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      cc: globalThis.Array.isArray(object?.cc) ? object.cc.map((e: any) => EmailRecipient.fromJSON(e)) : [],
      textBody: isSet(object.textBody)
        ? globalThis.String(object.textBody)
        : isSet(object.text_body)
        ? globalThis.String(object.text_body)
        : undefined,
      htmlBody: isSet(object.htmlBody)
        ? globalThis.String(object.htmlBody)
        : isSet(object.html_body)
        ? globalThis.String(object.html_body)
        : undefined,
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => EmailAttachment.fromJSON(e))
        : [],
      folder: isSet(object.folder) ? globalThis.String(object.folder) : "",
      isRead: isSet(object.isRead)
        ? globalThis.Boolean(object.isRead)
        : isSet(object.is_read)
        ? globalThis.Boolean(object.is_read)
        : false,
      isStarred: isSet(object.isStarred)
        ? globalThis.Boolean(object.isStarred)
        : isSet(object.is_starred)
        ? globalThis.Boolean(object.is_starred)
        : false,
      receivedAt: isSet(object.receivedAt)
        ? globalThis.String(object.receivedAt)
        : isSet(object.received_at)
        ? globalThis.String(object.received_at)
        : "",
    };
  },

  toJSON(message: Email): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.from !== undefined) {
      obj.from = EmailRecipient.toJSON(message.from);
    }
    if (message.to?.length) {
      obj.to = message.to.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.cc?.length) {
      obj.cc = message.cc.map((e) => EmailRecipient.toJSON(e));
    }
    if (message.textBody !== undefined) {
      obj.textBody = message.textBody;
    }
    if (message.htmlBody !== undefined) {
      obj.htmlBody = message.htmlBody;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => EmailAttachment.toJSON(e));
    }
    if (message.folder !== "") {
      obj.folder = message.folder;
    }
    if (message.isRead !== false) {
      obj.isRead = message.isRead;
    }
    if (message.isStarred !== false) {
      obj.isStarred = message.isStarred;
    }
    if (message.receivedAt !== "") {
      obj.receivedAt = message.receivedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Email>, I>>(base?: I): Email {
    return Email.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Email>, I>>(object: I): Email {
    const message = createBaseEmail();
    message.id = object.id ?? "";
    message.mailboxId = object.mailboxId ?? "";
    message.messageId = object.messageId ?? "";
    message.subject = object.subject ?? "";
    message.from = (object.from !== undefined && object.from !== null)
      ? EmailRecipient.fromPartial(object.from)
      : undefined;
    message.to = object.to?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.cc = object.cc?.map((e) => EmailRecipient.fromPartial(e)) || [];
    message.textBody = object.textBody ?? undefined;
    message.htmlBody = object.htmlBody ?? undefined;
    message.attachments = object.attachments?.map((e) => EmailAttachment.fromPartial(e)) || [];
    message.folder = object.folder ?? "";
    message.isRead = object.isRead ?? false;
    message.isStarred = object.isStarred ?? false;
    message.receivedAt = object.receivedAt ?? "";
    return message;
  },
};

function createBaseEmailResponse(): EmailResponse {
  return { email: undefined };
}

export const EmailResponse: MessageFns<EmailResponse> = {
  encode(message: EmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== undefined) {
      Email.encode(message.email, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = Email.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailResponse {
    return { email: isSet(object.email) ? Email.fromJSON(object.email) : undefined };
  },

  toJSON(message: EmailResponse): unknown {
    const obj: any = {};
    if (message.email !== undefined) {
      obj.email = Email.toJSON(message.email);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailResponse>, I>>(base?: I): EmailResponse {
    return EmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailResponse>, I>>(object: I): EmailResponse {
    const message = createBaseEmailResponse();
    message.email = (object.email !== undefined && object.email !== null) ? Email.fromPartial(object.email) : undefined;
    return message;
  },
};

function createBaseEmailListResponse(): EmailListResponse {
  return { emails: [], total: 0 };
}

export const EmailListResponse: MessageFns<EmailListResponse> = {
  encode(message: EmailListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.emails) {
      Email.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emails.push(Email.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailListResponse {
    return {
      emails: globalThis.Array.isArray(object?.emails) ? object.emails.map((e: any) => Email.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: EmailListResponse): unknown {
    const obj: any = {};
    if (message.emails?.length) {
      obj.emails = message.emails.map((e) => Email.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailListResponse>, I>>(base?: I): EmailListResponse {
    return EmailListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailListResponse>, I>>(object: I): EmailListResponse {
    const message = createBaseEmailListResponse();
    message.emails = object.emails?.map((e) => Email.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseTestConnectionRequest(): TestConnectionRequest {
  return { mailboxId: "" };
}

export const TestConnectionRequest: MessageFns<TestConnectionRequest> = {
  encode(message: TestConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestConnectionRequest {
    return {
      mailboxId: isSet(object.mailboxId)
        ? globalThis.String(object.mailboxId)
        : isSet(object.mailbox_id)
        ? globalThis.String(object.mailbox_id)
        : "",
    };
  },

  toJSON(message: TestConnectionRequest): unknown {
    const obj: any = {};
    if (message.mailboxId !== "") {
      obj.mailboxId = message.mailboxId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestConnectionRequest>, I>>(base?: I): TestConnectionRequest {
    return TestConnectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestConnectionRequest>, I>>(object: I): TestConnectionRequest {
    const message = createBaseTestConnectionRequest();
    message.mailboxId = object.mailboxId ?? "";
    return message;
  },
};

function createBaseTestConnectionResponse(): TestConnectionResponse {
  return { success: false, message: "", errorDetails: undefined };
}

export const TestConnectionResponse: MessageFns<TestConnectionResponse> = {
  encode(message: TestConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.errorDetails !== undefined) {
      writer.uint32(26).string(message.errorDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorDetails = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestConnectionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      errorDetails: isSet(object.errorDetails)
        ? globalThis.String(object.errorDetails)
        : isSet(object.error_details)
        ? globalThis.String(object.error_details)
        : undefined,
    };
  },

  toJSON(message: TestConnectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.errorDetails !== undefined) {
      obj.errorDetails = message.errorDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestConnectionResponse>, I>>(base?: I): TestConnectionResponse {
    return TestConnectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestConnectionResponse>, I>>(object: I): TestConnectionResponse {
    const message = createBaseTestConnectionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.errorDetails = object.errorDetails ?? undefined;
    return message;
  },
};

/** Main Email Service */
export type EmailServiceService = typeof EmailServiceService;
export const EmailServiceService = {
  /** ===== Mailbox Management ===== */
  createMailbox: {
    path: "/email.EmailService/CreateMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateMailboxRequest): Buffer => Buffer.from(CreateMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateMailboxRequest => CreateMailboxRequest.decode(value),
    responseSerialize: (value: MailboxResponse): Buffer => Buffer.from(MailboxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxResponse => MailboxResponse.decode(value),
  },
  getMailbox: {
    path: "/email.EmailService/GetMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMailboxRequest): Buffer => Buffer.from(GetMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMailboxRequest => GetMailboxRequest.decode(value),
    responseSerialize: (value: MailboxResponse): Buffer => Buffer.from(MailboxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxResponse => MailboxResponse.decode(value),
  },
  getMailboxesByOrganisation: {
    path: "/email.EmailService/GetMailboxesByOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMailboxesByOrganisationRequest): Buffer =>
      Buffer.from(GetMailboxesByOrganisationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMailboxesByOrganisationRequest =>
      GetMailboxesByOrganisationRequest.decode(value),
    responseSerialize: (value: MailboxListResponse): Buffer => Buffer.from(MailboxListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxListResponse => MailboxListResponse.decode(value),
  },
  getMailboxesBySociete: {
    path: "/email.EmailService/GetMailboxesBySociete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMailboxesBySocieteRequest): Buffer =>
      Buffer.from(GetMailboxesBySocieteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMailboxesBySocieteRequest => GetMailboxesBySocieteRequest.decode(value),
    responseSerialize: (value: MailboxListResponse): Buffer => Buffer.from(MailboxListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxListResponse => MailboxListResponse.decode(value),
  },
  updateMailbox: {
    path: "/email.EmailService/UpdateMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateMailboxRequest): Buffer => Buffer.from(UpdateMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateMailboxRequest => UpdateMailboxRequest.decode(value),
    responseSerialize: (value: MailboxResponse): Buffer => Buffer.from(MailboxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxResponse => MailboxResponse.decode(value),
  },
  deleteMailbox: {
    path: "/email.EmailService/DeleteMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteMailboxRequest): Buffer => Buffer.from(DeleteMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteMailboxRequest => DeleteMailboxRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== OAuth2 Authentication ===== */
  getGoogleAuthUrl: {
    path: "/email.EmailService/GetGoogleAuthUrl",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuthUrlRequest): Buffer => Buffer.from(GetAuthUrlRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuthUrlRequest => GetAuthUrlRequest.decode(value),
    responseSerialize: (value: AuthUrlResponse): Buffer => Buffer.from(AuthUrlResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthUrlResponse => AuthUrlResponse.decode(value),
  },
  exchangeGoogleCode: {
    path: "/email.EmailService/ExchangeGoogleCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeCodeRequest): Buffer => Buffer.from(ExchangeCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExchangeCodeRequest => ExchangeCodeRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  refreshGoogleToken: {
    path: "/email.EmailService/RefreshGoogleToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  revokeGoogleToken: {
    path: "/email.EmailService/RevokeGoogleToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokeTokenRequest): Buffer => Buffer.from(RevokeTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RevokeTokenRequest => RevokeTokenRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  getMicrosoftAuthUrl: {
    path: "/email.EmailService/GetMicrosoftAuthUrl",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuthUrlRequest): Buffer => Buffer.from(GetAuthUrlRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuthUrlRequest => GetAuthUrlRequest.decode(value),
    responseSerialize: (value: AuthUrlResponse): Buffer => Buffer.from(AuthUrlResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthUrlResponse => AuthUrlResponse.decode(value),
  },
  exchangeMicrosoftCode: {
    path: "/email.EmailService/ExchangeMicrosoftCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeCodeRequest): Buffer => Buffer.from(ExchangeCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExchangeCodeRequest => ExchangeCodeRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  refreshMicrosoftToken: {
    path: "/email.EmailService/RefreshMicrosoftToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  revokeMicrosoftToken: {
    path: "/email.EmailService/RevokeMicrosoftToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokeTokenRequest): Buffer => Buffer.from(RevokeTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RevokeTokenRequest => RevokeTokenRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  /** ===== Email Operations ===== */
  sendEmail: {
    path: "/email.EmailService/SendEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendEmailRequest): Buffer => Buffer.from(SendEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendEmailRequest => SendEmailRequest.decode(value),
    responseSerialize: (value: SendEmailResponse): Buffer => Buffer.from(SendEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SendEmailResponse => SendEmailResponse.decode(value),
  },
  sendEmailWithTemplate: {
    path: "/email.EmailService/SendEmailWithTemplate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendEmailWithTemplateRequest): Buffer =>
      Buffer.from(SendEmailWithTemplateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendEmailWithTemplateRequest => SendEmailWithTemplateRequest.decode(value),
    responseSerialize: (value: SendEmailResponse): Buffer => Buffer.from(SendEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SendEmailResponse => SendEmailResponse.decode(value),
  },
  getEmails: {
    path: "/email.EmailService/GetEmails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmailsRequest): Buffer => Buffer.from(GetEmailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmailsRequest => GetEmailsRequest.decode(value),
    responseSerialize: (value: EmailListResponse): Buffer => Buffer.from(EmailListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmailListResponse => EmailListResponse.decode(value),
  },
  getEmail: {
    path: "/email.EmailService/GetEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmailRequest): Buffer => Buffer.from(GetEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmailRequest => GetEmailRequest.decode(value),
    responseSerialize: (value: EmailResponse): Buffer => Buffer.from(EmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmailResponse => EmailResponse.decode(value),
  },
  /** ===== User Info ===== */
  getGoogleUserInfo: {
    path: "/email.EmailService/GetGoogleUserInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserInfoRequest): Buffer => Buffer.from(GetUserInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUserInfoRequest => GetUserInfoRequest.decode(value),
    responseSerialize: (value: UserInfoResponse): Buffer => Buffer.from(UserInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UserInfoResponse => UserInfoResponse.decode(value),
  },
  getMicrosoftUserInfo: {
    path: "/email.EmailService/GetMicrosoftUserInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserInfoRequest): Buffer => Buffer.from(GetUserInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUserInfoRequest => GetUserInfoRequest.decode(value),
    responseSerialize: (value: UserInfoResponse): Buffer => Buffer.from(UserInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UserInfoResponse => UserInfoResponse.decode(value),
  },
  /** ===== Connection Test ===== */
  testMailboxConnection: {
    path: "/email.EmailService/TestMailboxConnection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TestConnectionRequest): Buffer =>
      Buffer.from(TestConnectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TestConnectionRequest => TestConnectionRequest.decode(value),
    responseSerialize: (value: TestConnectionResponse): Buffer =>
      Buffer.from(TestConnectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TestConnectionResponse => TestConnectionResponse.decode(value),
  },
} as const;

export interface EmailServiceServer extends UntypedServiceImplementation {
  /** ===== Mailbox Management ===== */
  createMailbox: handleUnaryCall<CreateMailboxRequest, MailboxResponse>;
  getMailbox: handleUnaryCall<GetMailboxRequest, MailboxResponse>;
  getMailboxesByOrganisation: handleUnaryCall<GetMailboxesByOrganisationRequest, MailboxListResponse>;
  getMailboxesBySociete: handleUnaryCall<GetMailboxesBySocieteRequest, MailboxListResponse>;
  updateMailbox: handleUnaryCall<UpdateMailboxRequest, MailboxResponse>;
  deleteMailbox: handleUnaryCall<DeleteMailboxRequest, DeleteResponse>;
  /** ===== OAuth2 Authentication ===== */
  getGoogleAuthUrl: handleUnaryCall<GetAuthUrlRequest, AuthUrlResponse>;
  exchangeGoogleCode: handleUnaryCall<ExchangeCodeRequest, TokenResponse>;
  refreshGoogleToken: handleUnaryCall<RefreshTokenRequest, TokenResponse>;
  revokeGoogleToken: handleUnaryCall<RevokeTokenRequest, OperationResponse>;
  getMicrosoftAuthUrl: handleUnaryCall<GetAuthUrlRequest, AuthUrlResponse>;
  exchangeMicrosoftCode: handleUnaryCall<ExchangeCodeRequest, TokenResponse>;
  refreshMicrosoftToken: handleUnaryCall<RefreshTokenRequest, TokenResponse>;
  revokeMicrosoftToken: handleUnaryCall<RevokeTokenRequest, OperationResponse>;
  /** ===== Email Operations ===== */
  sendEmail: handleUnaryCall<SendEmailRequest, SendEmailResponse>;
  sendEmailWithTemplate: handleUnaryCall<SendEmailWithTemplateRequest, SendEmailResponse>;
  getEmails: handleUnaryCall<GetEmailsRequest, EmailListResponse>;
  getEmail: handleUnaryCall<GetEmailRequest, EmailResponse>;
  /** ===== User Info ===== */
  getGoogleUserInfo: handleUnaryCall<GetUserInfoRequest, UserInfoResponse>;
  getMicrosoftUserInfo: handleUnaryCall<GetUserInfoRequest, UserInfoResponse>;
  /** ===== Connection Test ===== */
  testMailboxConnection: handleUnaryCall<TestConnectionRequest, TestConnectionResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
