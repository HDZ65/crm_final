// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: fulfillment/fulfillment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";

export const protobufPackage = "fulfillment";

/** ========== ENUMS ========== */
export enum BatchStatus {
  BATCH_STATUS_UNSPECIFIED = 0,
  BATCH_STATUS_OPEN = 1,
  BATCH_STATUS_LOCKED = 2,
  BATCH_STATUS_DISPATCHED = 3,
  BATCH_STATUS_COMPLETED = 4,
  BATCH_STATUS_CANCELED = 5,
  UNRECOGNIZED = -1,
}

export function batchStatusFromJSON(object: any): BatchStatus {
  switch (object) {
    case 0:
    case "BATCH_STATUS_UNSPECIFIED":
      return BatchStatus.BATCH_STATUS_UNSPECIFIED;
    case 1:
    case "BATCH_STATUS_OPEN":
      return BatchStatus.BATCH_STATUS_OPEN;
    case 2:
    case "BATCH_STATUS_LOCKED":
      return BatchStatus.BATCH_STATUS_LOCKED;
    case 3:
    case "BATCH_STATUS_DISPATCHED":
      return BatchStatus.BATCH_STATUS_DISPATCHED;
    case 4:
    case "BATCH_STATUS_COMPLETED":
      return BatchStatus.BATCH_STATUS_COMPLETED;
    case 5:
    case "BATCH_STATUS_CANCELED":
      return BatchStatus.BATCH_STATUS_CANCELED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchStatus.UNRECOGNIZED;
  }
}

export function batchStatusToJSON(object: BatchStatus): string {
  switch (object) {
    case BatchStatus.BATCH_STATUS_UNSPECIFIED:
      return "BATCH_STATUS_UNSPECIFIED";
    case BatchStatus.BATCH_STATUS_OPEN:
      return "BATCH_STATUS_OPEN";
    case BatchStatus.BATCH_STATUS_LOCKED:
      return "BATCH_STATUS_LOCKED";
    case BatchStatus.BATCH_STATUS_DISPATCHED:
      return "BATCH_STATUS_DISPATCHED";
    case BatchStatus.BATCH_STATUS_COMPLETED:
      return "BATCH_STATUS_COMPLETED";
    case BatchStatus.BATCH_STATUS_CANCELED:
      return "BATCH_STATUS_CANCELED";
    case BatchStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ========== FULFILLMENT BATCH MESSAGES ========== */
export interface FulfillmentBatch {
  id: string;
  organisationId: string;
  label: string;
  status: BatchStatus;
  cutoffDate: string;
  dispatchDate: string;
  totalLines: number;
  totalItems: number;
  lines: FulfillmentBatchLine[];
  createdAt: string;
  updatedAt: string;
}

export interface FulfillmentBatchLine {
  id: string;
  batchId: string;
  subscriptionId: string;
  clientId: string;
  productId: string;
  productName: string;
  quantity: number;
  snapshot: BatchLineSnapshot | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface BatchLineSnapshot {
  line1: string;
  line2?: string | undefined;
  postalCode: string;
  city: string;
  country: string;
  preferences: { [key: string]: string };
}

export interface BatchLineSnapshot_PreferencesEntry {
  key: string;
  value: string;
}

export interface CreateFulfillmentBatchRequest {
  organisationId: string;
  label: string;
  cutoffDate: string;
}

export interface UpdateFulfillmentBatchRequest {
  id: string;
  label?: string | undefined;
  cutoffDate?: string | undefined;
}

export interface ListFulfillmentBatchRequest {
  organisationId: string;
  status?: BatchStatus | undefined;
  search?: string | undefined;
  pagination: Pagination | undefined;
}

export interface ListFulfillmentBatchResponse {
  batches: FulfillmentBatch[];
  pagination: PaginationResult | undefined;
}

export interface LockFulfillmentBatchRequest {
  id: string;
}

export interface DispatchFulfillmentBatchRequest {
  id: string;
  dispatchDate: string;
}

export interface CompleteFulfillmentBatchRequest {
  id: string;
}

export interface AddFulfillmentBatchLineRequest {
  batchId: string;
  subscriptionId: string;
  clientId: string;
  productId: string;
  productName: string;
  quantity: number;
  snapshot: BatchLineSnapshot | undefined;
}

export interface RemoveFulfillmentBatchLineRequest {
  id: string;
}

/** ========== FULFILLMENT CUTOFF CONFIG MESSAGES ========== */
export interface FulfillmentCutoffConfig {
  id: string;
  organisationId: string;
  cutoffDayOfMonth: number;
  cutoffTime: string;
  processingDays: number;
  autoLock: boolean;
  autoDispatch: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateFulfillmentCutoffConfigRequest {
  organisationId: string;
  cutoffDayOfMonth: number;
  cutoffTime: string;
  processingDays: number;
  autoLock: boolean;
  autoDispatch: boolean;
}

export interface UpdateFulfillmentCutoffConfigRequest {
  id: string;
  cutoffDayOfMonth?: number | undefined;
  cutoffTime?: string | undefined;
  processingDays?: number | undefined;
  autoLock?: boolean | undefined;
  autoDispatch?: boolean | undefined;
}

export interface GetByOrganisationRequest {
  organisationId: string;
}

/** ========== COMMON MESSAGES ========== */
export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface GetByIdRequest {
  id: string;
}

export interface DeleteByIdRequest {
  id: string;
}

export interface DeleteResponse {
  success: boolean;
}

function createBaseFulfillmentBatch(): FulfillmentBatch {
  return {
    id: "",
    organisationId: "",
    label: "",
    status: 0,
    cutoffDate: "",
    dispatchDate: "",
    totalLines: 0,
    totalItems: 0,
    lines: [],
    createdAt: "",
    updatedAt: "",
  };
}

export const FulfillmentBatch: MessageFns<FulfillmentBatch> = {
  encode(message: FulfillmentBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.cutoffDate !== "") {
      writer.uint32(42).string(message.cutoffDate);
    }
    if (message.dispatchDate !== "") {
      writer.uint32(50).string(message.dispatchDate);
    }
    if (message.totalLines !== 0) {
      writer.uint32(56).int32(message.totalLines);
    }
    if (message.totalItems !== 0) {
      writer.uint32(64).int32(message.totalItems);
    }
    for (const v of message.lines) {
      FulfillmentBatchLine.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cutoffDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dispatchDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalLines = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lines.push(FulfillmentBatchLine.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentBatch {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      status: isSet(object.status) ? batchStatusFromJSON(object.status) : 0,
      cutoffDate: isSet(object.cutoffDate)
        ? globalThis.String(object.cutoffDate)
        : isSet(object.cutoff_date)
        ? globalThis.String(object.cutoff_date)
        : "",
      dispatchDate: isSet(object.dispatchDate)
        ? globalThis.String(object.dispatchDate)
        : isSet(object.dispatch_date)
        ? globalThis.String(object.dispatch_date)
        : "",
      totalLines: isSet(object.totalLines)
        ? globalThis.Number(object.totalLines)
        : isSet(object.total_lines)
        ? globalThis.Number(object.total_lines)
        : 0,
      totalItems: isSet(object.totalItems)
        ? globalThis.Number(object.totalItems)
        : isSet(object.total_items)
        ? globalThis.Number(object.total_items)
        : 0,
      lines: globalThis.Array.isArray(object?.lines)
        ? object.lines.map((e: any) => FulfillmentBatchLine.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: FulfillmentBatch): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.status !== 0) {
      obj.status = batchStatusToJSON(message.status);
    }
    if (message.cutoffDate !== "") {
      obj.cutoffDate = message.cutoffDate;
    }
    if (message.dispatchDate !== "") {
      obj.dispatchDate = message.dispatchDate;
    }
    if (message.totalLines !== 0) {
      obj.totalLines = Math.round(message.totalLines);
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => FulfillmentBatchLine.toJSON(e));
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FulfillmentBatch>, I>>(base?: I): FulfillmentBatch {
    return FulfillmentBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FulfillmentBatch>, I>>(object: I): FulfillmentBatch {
    const message = createBaseFulfillmentBatch();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.label = object.label ?? "";
    message.status = object.status ?? 0;
    message.cutoffDate = object.cutoffDate ?? "";
    message.dispatchDate = object.dispatchDate ?? "";
    message.totalLines = object.totalLines ?? 0;
    message.totalItems = object.totalItems ?? 0;
    message.lines = object.lines?.map((e) => FulfillmentBatchLine.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseFulfillmentBatchLine(): FulfillmentBatchLine {
  return {
    id: "",
    batchId: "",
    subscriptionId: "",
    clientId: "",
    productId: "",
    productName: "",
    quantity: 0,
    snapshot: undefined,
    createdAt: "",
    updatedAt: "",
  };
}

export const FulfillmentBatchLine: MessageFns<FulfillmentBatchLine> = {
  encode(message: FulfillmentBatchLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.batchId !== "") {
      writer.uint32(18).string(message.batchId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(26).string(message.subscriptionId);
    }
    if (message.clientId !== "") {
      writer.uint32(34).string(message.clientId);
    }
    if (message.productId !== "") {
      writer.uint32(42).string(message.productId);
    }
    if (message.productName !== "") {
      writer.uint32(50).string(message.productName);
    }
    if (message.quantity !== 0) {
      writer.uint32(56).int32(message.quantity);
    }
    if (message.snapshot !== undefined) {
      BatchLineSnapshot.encode(message.snapshot, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentBatchLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentBatchLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.batchId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.productName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.snapshot = BatchLineSnapshot.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentBatchLine {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      batchId: isSet(object.batchId)
        ? globalThis.String(object.batchId)
        : isSet(object.batch_id)
        ? globalThis.String(object.batch_id)
        : "",
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      productId: isSet(object.productId)
        ? globalThis.String(object.productId)
        : isSet(object.product_id)
        ? globalThis.String(object.product_id)
        : "",
      productName: isSet(object.productName)
        ? globalThis.String(object.productName)
        : isSet(object.product_name)
        ? globalThis.String(object.product_name)
        : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      snapshot: isSet(object.snapshot) ? BatchLineSnapshot.fromJSON(object.snapshot) : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: FulfillmentBatchLine): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.batchId !== "") {
      obj.batchId = message.batchId;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.productName !== "") {
      obj.productName = message.productName;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.snapshot !== undefined) {
      obj.snapshot = BatchLineSnapshot.toJSON(message.snapshot);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FulfillmentBatchLine>, I>>(base?: I): FulfillmentBatchLine {
    return FulfillmentBatchLine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FulfillmentBatchLine>, I>>(object: I): FulfillmentBatchLine {
    const message = createBaseFulfillmentBatchLine();
    message.id = object.id ?? "";
    message.batchId = object.batchId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.clientId = object.clientId ?? "";
    message.productId = object.productId ?? "";
    message.productName = object.productName ?? "";
    message.quantity = object.quantity ?? 0;
    message.snapshot = (object.snapshot !== undefined && object.snapshot !== null)
      ? BatchLineSnapshot.fromPartial(object.snapshot)
      : undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseBatchLineSnapshot(): BatchLineSnapshot {
  return { line1: "", line2: undefined, postalCode: "", city: "", country: "", preferences: {} };
}

export const BatchLineSnapshot: MessageFns<BatchLineSnapshot> = {
  encode(message: BatchLineSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line1 !== "") {
      writer.uint32(10).string(message.line1);
    }
    if (message.line2 !== undefined) {
      writer.uint32(18).string(message.line2);
    }
    if (message.postalCode !== "") {
      writer.uint32(26).string(message.postalCode);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.country !== "") {
      writer.uint32(42).string(message.country);
    }
    globalThis.Object.entries(message.preferences).forEach(([key, value]: [string, string]) => {
      BatchLineSnapshot_PreferencesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchLineSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchLineSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.line1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.line2 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = BatchLineSnapshot_PreferencesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.preferences[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchLineSnapshot {
    return {
      line1: isSet(object.line1) ? globalThis.String(object.line1) : "",
      line2: isSet(object.line2) ? globalThis.String(object.line2) : undefined,
      postalCode: isSet(object.postalCode)
        ? globalThis.String(object.postalCode)
        : isSet(object.postal_code)
        ? globalThis.String(object.postal_code)
        : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      preferences: isObject(object.preferences)
        ? (globalThis.Object.entries(object.preferences) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: BatchLineSnapshot): unknown {
    const obj: any = {};
    if (message.line1 !== "") {
      obj.line1 = message.line1;
    }
    if (message.line2 !== undefined) {
      obj.line2 = message.line2;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.preferences) {
      const entries = globalThis.Object.entries(message.preferences) as [string, string][];
      if (entries.length > 0) {
        obj.preferences = {};
        entries.forEach(([k, v]) => {
          obj.preferences[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchLineSnapshot>, I>>(base?: I): BatchLineSnapshot {
    return BatchLineSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchLineSnapshot>, I>>(object: I): BatchLineSnapshot {
    const message = createBaseBatchLineSnapshot();
    message.line1 = object.line1 ?? "";
    message.line2 = object.line2 ?? undefined;
    message.postalCode = object.postalCode ?? "";
    message.city = object.city ?? "";
    message.country = object.country ?? "";
    message.preferences = (globalThis.Object.entries(object.preferences ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBatchLineSnapshot_PreferencesEntry(): BatchLineSnapshot_PreferencesEntry {
  return { key: "", value: "" };
}

export const BatchLineSnapshot_PreferencesEntry: MessageFns<BatchLineSnapshot_PreferencesEntry> = {
  encode(message: BatchLineSnapshot_PreferencesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchLineSnapshot_PreferencesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchLineSnapshot_PreferencesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchLineSnapshot_PreferencesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BatchLineSnapshot_PreferencesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchLineSnapshot_PreferencesEntry>, I>>(
    base?: I,
  ): BatchLineSnapshot_PreferencesEntry {
    return BatchLineSnapshot_PreferencesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchLineSnapshot_PreferencesEntry>, I>>(
    object: I,
  ): BatchLineSnapshot_PreferencesEntry {
    const message = createBaseBatchLineSnapshot_PreferencesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateFulfillmentBatchRequest(): CreateFulfillmentBatchRequest {
  return { organisationId: "", label: "", cutoffDate: "" };
}

export const CreateFulfillmentBatchRequest: MessageFns<CreateFulfillmentBatchRequest> = {
  encode(message: CreateFulfillmentBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.cutoffDate !== "") {
      writer.uint32(26).string(message.cutoffDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFulfillmentBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFulfillmentBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cutoffDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFulfillmentBatchRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      cutoffDate: isSet(object.cutoffDate)
        ? globalThis.String(object.cutoffDate)
        : isSet(object.cutoff_date)
        ? globalThis.String(object.cutoff_date)
        : "",
    };
  },

  toJSON(message: CreateFulfillmentBatchRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.cutoffDate !== "") {
      obj.cutoffDate = message.cutoffDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFulfillmentBatchRequest>, I>>(base?: I): CreateFulfillmentBatchRequest {
    return CreateFulfillmentBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFulfillmentBatchRequest>, I>>(
    object: I,
  ): CreateFulfillmentBatchRequest {
    const message = createBaseCreateFulfillmentBatchRequest();
    message.organisationId = object.organisationId ?? "";
    message.label = object.label ?? "";
    message.cutoffDate = object.cutoffDate ?? "";
    return message;
  },
};

function createBaseUpdateFulfillmentBatchRequest(): UpdateFulfillmentBatchRequest {
  return { id: "", label: undefined, cutoffDate: undefined };
}

export const UpdateFulfillmentBatchRequest: MessageFns<UpdateFulfillmentBatchRequest> = {
  encode(message: UpdateFulfillmentBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.label !== undefined) {
      writer.uint32(18).string(message.label);
    }
    if (message.cutoffDate !== undefined) {
      writer.uint32(26).string(message.cutoffDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFulfillmentBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFulfillmentBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cutoffDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFulfillmentBatchRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : undefined,
      cutoffDate: isSet(object.cutoffDate)
        ? globalThis.String(object.cutoffDate)
        : isSet(object.cutoff_date)
        ? globalThis.String(object.cutoff_date)
        : undefined,
    };
  },

  toJSON(message: UpdateFulfillmentBatchRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.label !== undefined) {
      obj.label = message.label;
    }
    if (message.cutoffDate !== undefined) {
      obj.cutoffDate = message.cutoffDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFulfillmentBatchRequest>, I>>(base?: I): UpdateFulfillmentBatchRequest {
    return UpdateFulfillmentBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFulfillmentBatchRequest>, I>>(
    object: I,
  ): UpdateFulfillmentBatchRequest {
    const message = createBaseUpdateFulfillmentBatchRequest();
    message.id = object.id ?? "";
    message.label = object.label ?? undefined;
    message.cutoffDate = object.cutoffDate ?? undefined;
    return message;
  },
};

function createBaseListFulfillmentBatchRequest(): ListFulfillmentBatchRequest {
  return { organisationId: "", status: undefined, search: undefined, pagination: undefined };
}

export const ListFulfillmentBatchRequest: MessageFns<ListFulfillmentBatchRequest> = {
  encode(message: ListFulfillmentBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.status !== undefined) {
      writer.uint32(16).int32(message.status);
    }
    if (message.search !== undefined) {
      writer.uint32(26).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFulfillmentBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFulfillmentBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFulfillmentBatchRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      status: isSet(object.status) ? batchStatusFromJSON(object.status) : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : undefined,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListFulfillmentBatchRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.status !== undefined) {
      obj.status = batchStatusToJSON(message.status);
    }
    if (message.search !== undefined) {
      obj.search = message.search;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFulfillmentBatchRequest>, I>>(base?: I): ListFulfillmentBatchRequest {
    return ListFulfillmentBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFulfillmentBatchRequest>, I>>(object: I): ListFulfillmentBatchRequest {
    const message = createBaseListFulfillmentBatchRequest();
    message.organisationId = object.organisationId ?? "";
    message.status = object.status ?? undefined;
    message.search = object.search ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListFulfillmentBatchResponse(): ListFulfillmentBatchResponse {
  return { batches: [], pagination: undefined };
}

export const ListFulfillmentBatchResponse: MessageFns<ListFulfillmentBatchResponse> = {
  encode(message: ListFulfillmentBatchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.batches) {
      FulfillmentBatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFulfillmentBatchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFulfillmentBatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.batches.push(FulfillmentBatch.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFulfillmentBatchResponse {
    return {
      batches: globalThis.Array.isArray(object?.batches)
        ? object.batches.map((e: any) => FulfillmentBatch.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListFulfillmentBatchResponse): unknown {
    const obj: any = {};
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => FulfillmentBatch.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFulfillmentBatchResponse>, I>>(base?: I): ListFulfillmentBatchResponse {
    return ListFulfillmentBatchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFulfillmentBatchResponse>, I>>(object: I): ListFulfillmentBatchResponse {
    const message = createBaseListFulfillmentBatchResponse();
    message.batches = object.batches?.map((e) => FulfillmentBatch.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseLockFulfillmentBatchRequest(): LockFulfillmentBatchRequest {
  return { id: "" };
}

export const LockFulfillmentBatchRequest: MessageFns<LockFulfillmentBatchRequest> = {
  encode(message: LockFulfillmentBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockFulfillmentBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockFulfillmentBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockFulfillmentBatchRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: LockFulfillmentBatchRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LockFulfillmentBatchRequest>, I>>(base?: I): LockFulfillmentBatchRequest {
    return LockFulfillmentBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LockFulfillmentBatchRequest>, I>>(object: I): LockFulfillmentBatchRequest {
    const message = createBaseLockFulfillmentBatchRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDispatchFulfillmentBatchRequest(): DispatchFulfillmentBatchRequest {
  return { id: "", dispatchDate: "" };
}

export const DispatchFulfillmentBatchRequest: MessageFns<DispatchFulfillmentBatchRequest> = {
  encode(message: DispatchFulfillmentBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.dispatchDate !== "") {
      writer.uint32(18).string(message.dispatchDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DispatchFulfillmentBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDispatchFulfillmentBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dispatchDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DispatchFulfillmentBatchRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      dispatchDate: isSet(object.dispatchDate)
        ? globalThis.String(object.dispatchDate)
        : isSet(object.dispatch_date)
        ? globalThis.String(object.dispatch_date)
        : "",
    };
  },

  toJSON(message: DispatchFulfillmentBatchRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.dispatchDate !== "") {
      obj.dispatchDate = message.dispatchDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DispatchFulfillmentBatchRequest>, I>>(base?: I): DispatchFulfillmentBatchRequest {
    return DispatchFulfillmentBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DispatchFulfillmentBatchRequest>, I>>(
    object: I,
  ): DispatchFulfillmentBatchRequest {
    const message = createBaseDispatchFulfillmentBatchRequest();
    message.id = object.id ?? "";
    message.dispatchDate = object.dispatchDate ?? "";
    return message;
  },
};

function createBaseCompleteFulfillmentBatchRequest(): CompleteFulfillmentBatchRequest {
  return { id: "" };
}

export const CompleteFulfillmentBatchRequest: MessageFns<CompleteFulfillmentBatchRequest> = {
  encode(message: CompleteFulfillmentBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteFulfillmentBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteFulfillmentBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteFulfillmentBatchRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: CompleteFulfillmentBatchRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompleteFulfillmentBatchRequest>, I>>(base?: I): CompleteFulfillmentBatchRequest {
    return CompleteFulfillmentBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompleteFulfillmentBatchRequest>, I>>(
    object: I,
  ): CompleteFulfillmentBatchRequest {
    const message = createBaseCompleteFulfillmentBatchRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseAddFulfillmentBatchLineRequest(): AddFulfillmentBatchLineRequest {
  return {
    batchId: "",
    subscriptionId: "",
    clientId: "",
    productId: "",
    productName: "",
    quantity: 0,
    snapshot: undefined,
  };
}

export const AddFulfillmentBatchLineRequest: MessageFns<AddFulfillmentBatchLineRequest> = {
  encode(message: AddFulfillmentBatchLineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.batchId !== "") {
      writer.uint32(10).string(message.batchId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.productId !== "") {
      writer.uint32(34).string(message.productId);
    }
    if (message.productName !== "") {
      writer.uint32(42).string(message.productName);
    }
    if (message.quantity !== 0) {
      writer.uint32(48).int32(message.quantity);
    }
    if (message.snapshot !== undefined) {
      BatchLineSnapshot.encode(message.snapshot, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddFulfillmentBatchLineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFulfillmentBatchLineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.batchId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.productName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.snapshot = BatchLineSnapshot.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFulfillmentBatchLineRequest {
    return {
      batchId: isSet(object.batchId)
        ? globalThis.String(object.batchId)
        : isSet(object.batch_id)
        ? globalThis.String(object.batch_id)
        : "",
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      productId: isSet(object.productId)
        ? globalThis.String(object.productId)
        : isSet(object.product_id)
        ? globalThis.String(object.product_id)
        : "",
      productName: isSet(object.productName)
        ? globalThis.String(object.productName)
        : isSet(object.product_name)
        ? globalThis.String(object.product_name)
        : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      snapshot: isSet(object.snapshot) ? BatchLineSnapshot.fromJSON(object.snapshot) : undefined,
    };
  },

  toJSON(message: AddFulfillmentBatchLineRequest): unknown {
    const obj: any = {};
    if (message.batchId !== "") {
      obj.batchId = message.batchId;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.productName !== "") {
      obj.productName = message.productName;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.snapshot !== undefined) {
      obj.snapshot = BatchLineSnapshot.toJSON(message.snapshot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFulfillmentBatchLineRequest>, I>>(base?: I): AddFulfillmentBatchLineRequest {
    return AddFulfillmentBatchLineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddFulfillmentBatchLineRequest>, I>>(
    object: I,
  ): AddFulfillmentBatchLineRequest {
    const message = createBaseAddFulfillmentBatchLineRequest();
    message.batchId = object.batchId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.clientId = object.clientId ?? "";
    message.productId = object.productId ?? "";
    message.productName = object.productName ?? "";
    message.quantity = object.quantity ?? 0;
    message.snapshot = (object.snapshot !== undefined && object.snapshot !== null)
      ? BatchLineSnapshot.fromPartial(object.snapshot)
      : undefined;
    return message;
  },
};

function createBaseRemoveFulfillmentBatchLineRequest(): RemoveFulfillmentBatchLineRequest {
  return { id: "" };
}

export const RemoveFulfillmentBatchLineRequest: MessageFns<RemoveFulfillmentBatchLineRequest> = {
  encode(message: RemoveFulfillmentBatchLineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFulfillmentBatchLineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFulfillmentBatchLineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFulfillmentBatchLineRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: RemoveFulfillmentBatchLineRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFulfillmentBatchLineRequest>, I>>(
    base?: I,
  ): RemoveFulfillmentBatchLineRequest {
    return RemoveFulfillmentBatchLineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFulfillmentBatchLineRequest>, I>>(
    object: I,
  ): RemoveFulfillmentBatchLineRequest {
    const message = createBaseRemoveFulfillmentBatchLineRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseFulfillmentCutoffConfig(): FulfillmentCutoffConfig {
  return {
    id: "",
    organisationId: "",
    cutoffDayOfMonth: 0,
    cutoffTime: "",
    processingDays: 0,
    autoLock: false,
    autoDispatch: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const FulfillmentCutoffConfig: MessageFns<FulfillmentCutoffConfig> = {
  encode(message: FulfillmentCutoffConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.cutoffDayOfMonth !== 0) {
      writer.uint32(24).int32(message.cutoffDayOfMonth);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(34).string(message.cutoffTime);
    }
    if (message.processingDays !== 0) {
      writer.uint32(40).int32(message.processingDays);
    }
    if (message.autoLock !== false) {
      writer.uint32(48).bool(message.autoLock);
    }
    if (message.autoDispatch !== false) {
      writer.uint32(56).bool(message.autoDispatch);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentCutoffConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentCutoffConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cutoffDayOfMonth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.processingDays = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.autoLock = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoDispatch = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentCutoffConfig {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      cutoffDayOfMonth: isSet(object.cutoffDayOfMonth)
        ? globalThis.Number(object.cutoffDayOfMonth)
        : isSet(object.cutoff_day_of_month)
        ? globalThis.Number(object.cutoff_day_of_month)
        : 0,
      cutoffTime: isSet(object.cutoffTime)
        ? globalThis.String(object.cutoffTime)
        : isSet(object.cutoff_time)
        ? globalThis.String(object.cutoff_time)
        : "",
      processingDays: isSet(object.processingDays)
        ? globalThis.Number(object.processingDays)
        : isSet(object.processing_days)
        ? globalThis.Number(object.processing_days)
        : 0,
      autoLock: isSet(object.autoLock)
        ? globalThis.Boolean(object.autoLock)
        : isSet(object.auto_lock)
        ? globalThis.Boolean(object.auto_lock)
        : false,
      autoDispatch: isSet(object.autoDispatch)
        ? globalThis.Boolean(object.autoDispatch)
        : isSet(object.auto_dispatch)
        ? globalThis.Boolean(object.auto_dispatch)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: FulfillmentCutoffConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.cutoffDayOfMonth !== 0) {
      obj.cutoffDayOfMonth = Math.round(message.cutoffDayOfMonth);
    }
    if (message.cutoffTime !== "") {
      obj.cutoffTime = message.cutoffTime;
    }
    if (message.processingDays !== 0) {
      obj.processingDays = Math.round(message.processingDays);
    }
    if (message.autoLock !== false) {
      obj.autoLock = message.autoLock;
    }
    if (message.autoDispatch !== false) {
      obj.autoDispatch = message.autoDispatch;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FulfillmentCutoffConfig>, I>>(base?: I): FulfillmentCutoffConfig {
    return FulfillmentCutoffConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FulfillmentCutoffConfig>, I>>(object: I): FulfillmentCutoffConfig {
    const message = createBaseFulfillmentCutoffConfig();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.cutoffDayOfMonth = object.cutoffDayOfMonth ?? 0;
    message.cutoffTime = object.cutoffTime ?? "";
    message.processingDays = object.processingDays ?? 0;
    message.autoLock = object.autoLock ?? false;
    message.autoDispatch = object.autoDispatch ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateFulfillmentCutoffConfigRequest(): CreateFulfillmentCutoffConfigRequest {
  return {
    organisationId: "",
    cutoffDayOfMonth: 0,
    cutoffTime: "",
    processingDays: 0,
    autoLock: false,
    autoDispatch: false,
  };
}

export const CreateFulfillmentCutoffConfigRequest: MessageFns<CreateFulfillmentCutoffConfigRequest> = {
  encode(message: CreateFulfillmentCutoffConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.cutoffDayOfMonth !== 0) {
      writer.uint32(16).int32(message.cutoffDayOfMonth);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(26).string(message.cutoffTime);
    }
    if (message.processingDays !== 0) {
      writer.uint32(32).int32(message.processingDays);
    }
    if (message.autoLock !== false) {
      writer.uint32(40).bool(message.autoLock);
    }
    if (message.autoDispatch !== false) {
      writer.uint32(48).bool(message.autoDispatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFulfillmentCutoffConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFulfillmentCutoffConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cutoffDayOfMonth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.processingDays = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.autoLock = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.autoDispatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFulfillmentCutoffConfigRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      cutoffDayOfMonth: isSet(object.cutoffDayOfMonth)
        ? globalThis.Number(object.cutoffDayOfMonth)
        : isSet(object.cutoff_day_of_month)
        ? globalThis.Number(object.cutoff_day_of_month)
        : 0,
      cutoffTime: isSet(object.cutoffTime)
        ? globalThis.String(object.cutoffTime)
        : isSet(object.cutoff_time)
        ? globalThis.String(object.cutoff_time)
        : "",
      processingDays: isSet(object.processingDays)
        ? globalThis.Number(object.processingDays)
        : isSet(object.processing_days)
        ? globalThis.Number(object.processing_days)
        : 0,
      autoLock: isSet(object.autoLock)
        ? globalThis.Boolean(object.autoLock)
        : isSet(object.auto_lock)
        ? globalThis.Boolean(object.auto_lock)
        : false,
      autoDispatch: isSet(object.autoDispatch)
        ? globalThis.Boolean(object.autoDispatch)
        : isSet(object.auto_dispatch)
        ? globalThis.Boolean(object.auto_dispatch)
        : false,
    };
  },

  toJSON(message: CreateFulfillmentCutoffConfigRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.cutoffDayOfMonth !== 0) {
      obj.cutoffDayOfMonth = Math.round(message.cutoffDayOfMonth);
    }
    if (message.cutoffTime !== "") {
      obj.cutoffTime = message.cutoffTime;
    }
    if (message.processingDays !== 0) {
      obj.processingDays = Math.round(message.processingDays);
    }
    if (message.autoLock !== false) {
      obj.autoLock = message.autoLock;
    }
    if (message.autoDispatch !== false) {
      obj.autoDispatch = message.autoDispatch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFulfillmentCutoffConfigRequest>, I>>(
    base?: I,
  ): CreateFulfillmentCutoffConfigRequest {
    return CreateFulfillmentCutoffConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFulfillmentCutoffConfigRequest>, I>>(
    object: I,
  ): CreateFulfillmentCutoffConfigRequest {
    const message = createBaseCreateFulfillmentCutoffConfigRequest();
    message.organisationId = object.organisationId ?? "";
    message.cutoffDayOfMonth = object.cutoffDayOfMonth ?? 0;
    message.cutoffTime = object.cutoffTime ?? "";
    message.processingDays = object.processingDays ?? 0;
    message.autoLock = object.autoLock ?? false;
    message.autoDispatch = object.autoDispatch ?? false;
    return message;
  },
};

function createBaseUpdateFulfillmentCutoffConfigRequest(): UpdateFulfillmentCutoffConfigRequest {
  return {
    id: "",
    cutoffDayOfMonth: undefined,
    cutoffTime: undefined,
    processingDays: undefined,
    autoLock: undefined,
    autoDispatch: undefined,
  };
}

export const UpdateFulfillmentCutoffConfigRequest: MessageFns<UpdateFulfillmentCutoffConfigRequest> = {
  encode(message: UpdateFulfillmentCutoffConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.cutoffDayOfMonth !== undefined) {
      writer.uint32(16).int32(message.cutoffDayOfMonth);
    }
    if (message.cutoffTime !== undefined) {
      writer.uint32(26).string(message.cutoffTime);
    }
    if (message.processingDays !== undefined) {
      writer.uint32(32).int32(message.processingDays);
    }
    if (message.autoLock !== undefined) {
      writer.uint32(40).bool(message.autoLock);
    }
    if (message.autoDispatch !== undefined) {
      writer.uint32(48).bool(message.autoDispatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFulfillmentCutoffConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFulfillmentCutoffConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cutoffDayOfMonth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.processingDays = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.autoLock = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.autoDispatch = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFulfillmentCutoffConfigRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      cutoffDayOfMonth: isSet(object.cutoffDayOfMonth)
        ? globalThis.Number(object.cutoffDayOfMonth)
        : isSet(object.cutoff_day_of_month)
        ? globalThis.Number(object.cutoff_day_of_month)
        : undefined,
      cutoffTime: isSet(object.cutoffTime)
        ? globalThis.String(object.cutoffTime)
        : isSet(object.cutoff_time)
        ? globalThis.String(object.cutoff_time)
        : undefined,
      processingDays: isSet(object.processingDays)
        ? globalThis.Number(object.processingDays)
        : isSet(object.processing_days)
        ? globalThis.Number(object.processing_days)
        : undefined,
      autoLock: isSet(object.autoLock)
        ? globalThis.Boolean(object.autoLock)
        : isSet(object.auto_lock)
        ? globalThis.Boolean(object.auto_lock)
        : undefined,
      autoDispatch: isSet(object.autoDispatch)
        ? globalThis.Boolean(object.autoDispatch)
        : isSet(object.auto_dispatch)
        ? globalThis.Boolean(object.auto_dispatch)
        : undefined,
    };
  },

  toJSON(message: UpdateFulfillmentCutoffConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.cutoffDayOfMonth !== undefined) {
      obj.cutoffDayOfMonth = Math.round(message.cutoffDayOfMonth);
    }
    if (message.cutoffTime !== undefined) {
      obj.cutoffTime = message.cutoffTime;
    }
    if (message.processingDays !== undefined) {
      obj.processingDays = Math.round(message.processingDays);
    }
    if (message.autoLock !== undefined) {
      obj.autoLock = message.autoLock;
    }
    if (message.autoDispatch !== undefined) {
      obj.autoDispatch = message.autoDispatch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFulfillmentCutoffConfigRequest>, I>>(
    base?: I,
  ): UpdateFulfillmentCutoffConfigRequest {
    return UpdateFulfillmentCutoffConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFulfillmentCutoffConfigRequest>, I>>(
    object: I,
  ): UpdateFulfillmentCutoffConfigRequest {
    const message = createBaseUpdateFulfillmentCutoffConfigRequest();
    message.id = object.id ?? "";
    message.cutoffDayOfMonth = object.cutoffDayOfMonth ?? undefined;
    message.cutoffTime = object.cutoffTime ?? undefined;
    message.processingDays = object.processingDays ?? undefined;
    message.autoLock = object.autoLock ?? undefined;
    message.autoDispatch = object.autoDispatch ?? undefined;
    return message;
  },
};

function createBaseGetByOrganisationRequest(): GetByOrganisationRequest {
  return { organisationId: "" };
}

export const GetByOrganisationRequest: MessageFns<GetByOrganisationRequest> = {
  encode(message: GetByOrganisationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByOrganisationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByOrganisationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetByOrganisationRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
    };
  },

  toJSON(message: GetByOrganisationRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetByOrganisationRequest>, I>>(base?: I): GetByOrganisationRequest {
    return GetByOrganisationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetByOrganisationRequest>, I>>(object: I): GetByOrganisationRequest {
    const message = createBaseGetByOrganisationRequest();
    message.organisationId = object.organisationId ?? "";
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pagination {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      sortBy: isSet(object.sortBy)
        ? globalThis.String(object.sortBy)
        : isSet(object.sort_by)
        ? globalThis.String(object.sort_by)
        : "",
      sortOrder: isSet(object.sortOrder)
        ? globalThis.String(object.sortOrder)
        : isSet(object.sort_order)
        ? globalThis.String(object.sort_order)
        : "",
    };
  },

  toJSON(message: Pagination): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pagination>, I>>(base?: I): Pagination {
    return Pagination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pagination>, I>>(object: I): Pagination {
    const message = createBasePagination();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResult {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: PaginationResult): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResult>, I>>(base?: I): PaginationResult {
    return PaginationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResult>, I>>(object: I): PaginationResult {
    const message = createBasePaginationResult();
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "" };
}

export const GetByIdRequest: MessageFns<GetByIdRequest> = {
  encode(message: GetByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetByIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetByIdRequest>, I>>(base?: I): GetByIdRequest {
    return GetByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetByIdRequest>, I>>(object: I): GetByIdRequest {
    const message = createBaseGetByIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteByIdRequest(): DeleteByIdRequest {
  return { id: "" };
}

export const DeleteByIdRequest: MessageFns<DeleteByIdRequest> = {
  encode(message: DeleteByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteByIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteByIdRequest>, I>>(base?: I): DeleteByIdRequest {
    return DeleteByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteByIdRequest>, I>>(object: I): DeleteByIdRequest {
    const message = createBaseDeleteByIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    return message;
  },
};

/** ========== FULFILLMENT BATCH SERVICE ========== */
export type FulfillmentBatchServiceService = typeof FulfillmentBatchServiceService;
export const FulfillmentBatchServiceService = {
  create: {
    path: "/fulfillment.FulfillmentBatchService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateFulfillmentBatchRequest): Buffer =>
      Buffer.from(CreateFulfillmentBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateFulfillmentBatchRequest => CreateFulfillmentBatchRequest.decode(value),
    responseSerialize: (value: FulfillmentBatch): Buffer => Buffer.from(FulfillmentBatch.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentBatch => FulfillmentBatch.decode(value),
  },
  update: {
    path: "/fulfillment.FulfillmentBatchService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateFulfillmentBatchRequest): Buffer =>
      Buffer.from(UpdateFulfillmentBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateFulfillmentBatchRequest => UpdateFulfillmentBatchRequest.decode(value),
    responseSerialize: (value: FulfillmentBatch): Buffer => Buffer.from(FulfillmentBatch.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentBatch => FulfillmentBatch.decode(value),
  },
  get: {
    path: "/fulfillment.FulfillmentBatchService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: FulfillmentBatch): Buffer => Buffer.from(FulfillmentBatch.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentBatch => FulfillmentBatch.decode(value),
  },
  list: {
    path: "/fulfillment.FulfillmentBatchService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListFulfillmentBatchRequest): Buffer =>
      Buffer.from(ListFulfillmentBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListFulfillmentBatchRequest => ListFulfillmentBatchRequest.decode(value),
    responseSerialize: (value: ListFulfillmentBatchResponse): Buffer =>
      Buffer.from(ListFulfillmentBatchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListFulfillmentBatchResponse => ListFulfillmentBatchResponse.decode(value),
  },
  delete: {
    path: "/fulfillment.FulfillmentBatchService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteByIdRequest): Buffer => Buffer.from(DeleteByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteByIdRequest => DeleteByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  lock: {
    path: "/fulfillment.FulfillmentBatchService/Lock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LockFulfillmentBatchRequest): Buffer =>
      Buffer.from(LockFulfillmentBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LockFulfillmentBatchRequest => LockFulfillmentBatchRequest.decode(value),
    responseSerialize: (value: FulfillmentBatch): Buffer => Buffer.from(FulfillmentBatch.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentBatch => FulfillmentBatch.decode(value),
  },
  dispatch: {
    path: "/fulfillment.FulfillmentBatchService/Dispatch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DispatchFulfillmentBatchRequest): Buffer =>
      Buffer.from(DispatchFulfillmentBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DispatchFulfillmentBatchRequest =>
      DispatchFulfillmentBatchRequest.decode(value),
    responseSerialize: (value: FulfillmentBatch): Buffer => Buffer.from(FulfillmentBatch.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentBatch => FulfillmentBatch.decode(value),
  },
  complete: {
    path: "/fulfillment.FulfillmentBatchService/Complete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CompleteFulfillmentBatchRequest): Buffer =>
      Buffer.from(CompleteFulfillmentBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CompleteFulfillmentBatchRequest =>
      CompleteFulfillmentBatchRequest.decode(value),
    responseSerialize: (value: FulfillmentBatch): Buffer => Buffer.from(FulfillmentBatch.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentBatch => FulfillmentBatch.decode(value),
  },
  addLine: {
    path: "/fulfillment.FulfillmentBatchService/AddLine",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddFulfillmentBatchLineRequest): Buffer =>
      Buffer.from(AddFulfillmentBatchLineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AddFulfillmentBatchLineRequest => AddFulfillmentBatchLineRequest.decode(value),
    responseSerialize: (value: FulfillmentBatchLine): Buffer =>
      Buffer.from(FulfillmentBatchLine.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentBatchLine => FulfillmentBatchLine.decode(value),
  },
  removeLine: {
    path: "/fulfillment.FulfillmentBatchService/RemoveLine",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveFulfillmentBatchLineRequest): Buffer =>
      Buffer.from(RemoveFulfillmentBatchLineRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RemoveFulfillmentBatchLineRequest =>
      RemoveFulfillmentBatchLineRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface FulfillmentBatchServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateFulfillmentBatchRequest, FulfillmentBatch>;
  update: handleUnaryCall<UpdateFulfillmentBatchRequest, FulfillmentBatch>;
  get: handleUnaryCall<GetByIdRequest, FulfillmentBatch>;
  list: handleUnaryCall<ListFulfillmentBatchRequest, ListFulfillmentBatchResponse>;
  delete: handleUnaryCall<DeleteByIdRequest, DeleteResponse>;
  lock: handleUnaryCall<LockFulfillmentBatchRequest, FulfillmentBatch>;
  dispatch: handleUnaryCall<DispatchFulfillmentBatchRequest, FulfillmentBatch>;
  complete: handleUnaryCall<CompleteFulfillmentBatchRequest, FulfillmentBatch>;
  addLine: handleUnaryCall<AddFulfillmentBatchLineRequest, FulfillmentBatchLine>;
  removeLine: handleUnaryCall<RemoveFulfillmentBatchLineRequest, DeleteResponse>;
}

/** ========== FULFILLMENT CUTOFF CONFIG SERVICE ========== */
export type FulfillmentCutoffConfigServiceService = typeof FulfillmentCutoffConfigServiceService;
export const FulfillmentCutoffConfigServiceService = {
  create: {
    path: "/fulfillment.FulfillmentCutoffConfigService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateFulfillmentCutoffConfigRequest): Buffer =>
      Buffer.from(CreateFulfillmentCutoffConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateFulfillmentCutoffConfigRequest =>
      CreateFulfillmentCutoffConfigRequest.decode(value),
    responseSerialize: (value: FulfillmentCutoffConfig): Buffer =>
      Buffer.from(FulfillmentCutoffConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentCutoffConfig => FulfillmentCutoffConfig.decode(value),
  },
  update: {
    path: "/fulfillment.FulfillmentCutoffConfigService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateFulfillmentCutoffConfigRequest): Buffer =>
      Buffer.from(UpdateFulfillmentCutoffConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateFulfillmentCutoffConfigRequest =>
      UpdateFulfillmentCutoffConfigRequest.decode(value),
    responseSerialize: (value: FulfillmentCutoffConfig): Buffer =>
      Buffer.from(FulfillmentCutoffConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentCutoffConfig => FulfillmentCutoffConfig.decode(value),
  },
  get: {
    path: "/fulfillment.FulfillmentCutoffConfigService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: FulfillmentCutoffConfig): Buffer =>
      Buffer.from(FulfillmentCutoffConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentCutoffConfig => FulfillmentCutoffConfig.decode(value),
  },
  getByOrganisation: {
    path: "/fulfillment.FulfillmentCutoffConfigService/GetByOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByOrganisationRequest): Buffer =>
      Buffer.from(GetByOrganisationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByOrganisationRequest => GetByOrganisationRequest.decode(value),
    responseSerialize: (value: FulfillmentCutoffConfig): Buffer =>
      Buffer.from(FulfillmentCutoffConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer): FulfillmentCutoffConfig => FulfillmentCutoffConfig.decode(value),
  },
  delete: {
    path: "/fulfillment.FulfillmentCutoffConfigService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteByIdRequest): Buffer => Buffer.from(DeleteByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteByIdRequest => DeleteByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface FulfillmentCutoffConfigServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateFulfillmentCutoffConfigRequest, FulfillmentCutoffConfig>;
  update: handleUnaryCall<UpdateFulfillmentCutoffConfigRequest, FulfillmentCutoffConfig>;
  get: handleUnaryCall<GetByIdRequest, FulfillmentCutoffConfig>;
  getByOrganisation: handleUnaryCall<GetByOrganisationRequest, FulfillmentCutoffConfig>;
  delete: handleUnaryCall<DeleteByIdRequest, DeleteResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
