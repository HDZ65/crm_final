// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: payments/payment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";

export const protobufPackage = "payment";

export enum PaymentStatus {
  PAYMENT_STATUS_UNSPECIFIED = 0,
  PAYMENT_STATUS_PENDING = 1,
  PAYMENT_STATUS_SUBMITTED = 2,
  PAYMENT_STATUS_PAID = 3,
  PAYMENT_STATUS_REJECTED = 4,
  PAYMENT_STATUS_REFUNDED = 5,
  PAYMENT_STATUS_CANCELLED = 6,
  PAYMENT_STATUS_FAILED = 7,
  UNRECOGNIZED = -1,
}

export function paymentStatusFromJSON(object: any): PaymentStatus {
  switch (object) {
    case 0:
    case "PAYMENT_STATUS_UNSPECIFIED":
      return PaymentStatus.PAYMENT_STATUS_UNSPECIFIED;
    case 1:
    case "PAYMENT_STATUS_PENDING":
      return PaymentStatus.PAYMENT_STATUS_PENDING;
    case 2:
    case "PAYMENT_STATUS_SUBMITTED":
      return PaymentStatus.PAYMENT_STATUS_SUBMITTED;
    case 3:
    case "PAYMENT_STATUS_PAID":
      return PaymentStatus.PAYMENT_STATUS_PAID;
    case 4:
    case "PAYMENT_STATUS_REJECTED":
      return PaymentStatus.PAYMENT_STATUS_REJECTED;
    case 5:
    case "PAYMENT_STATUS_REFUNDED":
      return PaymentStatus.PAYMENT_STATUS_REFUNDED;
    case 6:
    case "PAYMENT_STATUS_CANCELLED":
      return PaymentStatus.PAYMENT_STATUS_CANCELLED;
    case 7:
    case "PAYMENT_STATUS_FAILED":
      return PaymentStatus.PAYMENT_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentStatus.UNRECOGNIZED;
  }
}

export function paymentStatusToJSON(object: PaymentStatus): string {
  switch (object) {
    case PaymentStatus.PAYMENT_STATUS_UNSPECIFIED:
      return "PAYMENT_STATUS_UNSPECIFIED";
    case PaymentStatus.PAYMENT_STATUS_PENDING:
      return "PAYMENT_STATUS_PENDING";
    case PaymentStatus.PAYMENT_STATUS_SUBMITTED:
      return "PAYMENT_STATUS_SUBMITTED";
    case PaymentStatus.PAYMENT_STATUS_PAID:
      return "PAYMENT_STATUS_PAID";
    case PaymentStatus.PAYMENT_STATUS_REJECTED:
      return "PAYMENT_STATUS_REJECTED";
    case PaymentStatus.PAYMENT_STATUS_REFUNDED:
      return "PAYMENT_STATUS_REFUNDED";
    case PaymentStatus.PAYMENT_STATUS_CANCELLED:
      return "PAYMENT_STATUS_CANCELLED";
    case PaymentStatus.PAYMENT_STATUS_FAILED:
      return "PAYMENT_STATUS_FAILED";
    case PaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MandateStatus {
  MANDATE_STATUS_UNSPECIFIED = 0,
  MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL = 1,
  MANDATE_STATUS_PENDING_SUBMISSION = 2,
  MANDATE_STATUS_SUBMITTED = 3,
  MANDATE_STATUS_ACTIVE = 4,
  MANDATE_STATUS_SUSPENDED_BY_PAYER = 5,
  MANDATE_STATUS_FAILED = 6,
  MANDATE_STATUS_CANCELLED = 7,
  MANDATE_STATUS_EXPIRED = 8,
  MANDATE_STATUS_CONSUMED = 9,
  MANDATE_STATUS_BLOCKED = 10,
  UNRECOGNIZED = -1,
}

export function mandateStatusFromJSON(object: any): MandateStatus {
  switch (object) {
    case 0:
    case "MANDATE_STATUS_UNSPECIFIED":
      return MandateStatus.MANDATE_STATUS_UNSPECIFIED;
    case 1:
    case "MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL":
      return MandateStatus.MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL;
    case 2:
    case "MANDATE_STATUS_PENDING_SUBMISSION":
      return MandateStatus.MANDATE_STATUS_PENDING_SUBMISSION;
    case 3:
    case "MANDATE_STATUS_SUBMITTED":
      return MandateStatus.MANDATE_STATUS_SUBMITTED;
    case 4:
    case "MANDATE_STATUS_ACTIVE":
      return MandateStatus.MANDATE_STATUS_ACTIVE;
    case 5:
    case "MANDATE_STATUS_SUSPENDED_BY_PAYER":
      return MandateStatus.MANDATE_STATUS_SUSPENDED_BY_PAYER;
    case 6:
    case "MANDATE_STATUS_FAILED":
      return MandateStatus.MANDATE_STATUS_FAILED;
    case 7:
    case "MANDATE_STATUS_CANCELLED":
      return MandateStatus.MANDATE_STATUS_CANCELLED;
    case 8:
    case "MANDATE_STATUS_EXPIRED":
      return MandateStatus.MANDATE_STATUS_EXPIRED;
    case 9:
    case "MANDATE_STATUS_CONSUMED":
      return MandateStatus.MANDATE_STATUS_CONSUMED;
    case 10:
    case "MANDATE_STATUS_BLOCKED":
      return MandateStatus.MANDATE_STATUS_BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MandateStatus.UNRECOGNIZED;
  }
}

export function mandateStatusToJSON(object: MandateStatus): string {
  switch (object) {
    case MandateStatus.MANDATE_STATUS_UNSPECIFIED:
      return "MANDATE_STATUS_UNSPECIFIED";
    case MandateStatus.MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL:
      return "MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL";
    case MandateStatus.MANDATE_STATUS_PENDING_SUBMISSION:
      return "MANDATE_STATUS_PENDING_SUBMISSION";
    case MandateStatus.MANDATE_STATUS_SUBMITTED:
      return "MANDATE_STATUS_SUBMITTED";
    case MandateStatus.MANDATE_STATUS_ACTIVE:
      return "MANDATE_STATUS_ACTIVE";
    case MandateStatus.MANDATE_STATUS_SUSPENDED_BY_PAYER:
      return "MANDATE_STATUS_SUSPENDED_BY_PAYER";
    case MandateStatus.MANDATE_STATUS_FAILED:
      return "MANDATE_STATUS_FAILED";
    case MandateStatus.MANDATE_STATUS_CANCELLED:
      return "MANDATE_STATUS_CANCELLED";
    case MandateStatus.MANDATE_STATUS_EXPIRED:
      return "MANDATE_STATUS_EXPIRED";
    case MandateStatus.MANDATE_STATUS_CONSUMED:
      return "MANDATE_STATUS_CONSUMED";
    case MandateStatus.MANDATE_STATUS_BLOCKED:
      return "MANDATE_STATUS_BLOCKED";
    case MandateStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ScheduleStatus {
  SCHEDULE_STATUS_UNSPECIFIED = 0,
  SCHEDULE_STATUS_ACTIVE = 1,
  SCHEDULE_STATUS_PAUSED = 2,
  SCHEDULE_STATUS_CANCELLED = 3,
  SCHEDULE_STATUS_COMPLETED = 4,
  UNRECOGNIZED = -1,
}

export function scheduleStatusFromJSON(object: any): ScheduleStatus {
  switch (object) {
    case 0:
    case "SCHEDULE_STATUS_UNSPECIFIED":
      return ScheduleStatus.SCHEDULE_STATUS_UNSPECIFIED;
    case 1:
    case "SCHEDULE_STATUS_ACTIVE":
      return ScheduleStatus.SCHEDULE_STATUS_ACTIVE;
    case 2:
    case "SCHEDULE_STATUS_PAUSED":
      return ScheduleStatus.SCHEDULE_STATUS_PAUSED;
    case 3:
    case "SCHEDULE_STATUS_CANCELLED":
      return ScheduleStatus.SCHEDULE_STATUS_CANCELLED;
    case 4:
    case "SCHEDULE_STATUS_COMPLETED":
      return ScheduleStatus.SCHEDULE_STATUS_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScheduleStatus.UNRECOGNIZED;
  }
}

export function scheduleStatusToJSON(object: ScheduleStatus): string {
  switch (object) {
    case ScheduleStatus.SCHEDULE_STATUS_UNSPECIFIED:
      return "SCHEDULE_STATUS_UNSPECIFIED";
    case ScheduleStatus.SCHEDULE_STATUS_ACTIVE:
      return "SCHEDULE_STATUS_ACTIVE";
    case ScheduleStatus.SCHEDULE_STATUS_PAUSED:
      return "SCHEDULE_STATUS_PAUSED";
    case ScheduleStatus.SCHEDULE_STATUS_CANCELLED:
      return "SCHEDULE_STATUS_CANCELLED";
    case ScheduleStatus.SCHEDULE_STATUS_COMPLETED:
      return "SCHEDULE_STATUS_COMPLETED";
    case ScheduleStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AuditAction {
  AUDIT_ACTION_UNSPECIFIED = 0,
  AUDIT_ACTION_PAYMENT_CREATED = 1,
  AUDIT_ACTION_PAYMENT_SUBMITTED = 2,
  AUDIT_ACTION_PAYMENT_SUCCEEDED = 3,
  AUDIT_ACTION_PAYMENT_FAILED = 4,
  AUDIT_ACTION_PAYMENT_CANCELLED = 5,
  AUDIT_ACTION_PAYMENT_REFUNDED = 6,
  AUDIT_ACTION_MANDATE_CREATED = 7,
  AUDIT_ACTION_MANDATE_ACTIVATED = 8,
  AUDIT_ACTION_MANDATE_CANCELLED = 9,
  AUDIT_ACTION_SCHEDULE_CREATED = 10,
  AUDIT_ACTION_SCHEDULE_PAUSED = 11,
  AUDIT_ACTION_SCHEDULE_RESUMED = 12,
  AUDIT_ACTION_SCHEDULE_CANCELLED = 13,
  UNRECOGNIZED = -1,
}

export function auditActionFromJSON(object: any): AuditAction {
  switch (object) {
    case 0:
    case "AUDIT_ACTION_UNSPECIFIED":
      return AuditAction.AUDIT_ACTION_UNSPECIFIED;
    case 1:
    case "AUDIT_ACTION_PAYMENT_CREATED":
      return AuditAction.AUDIT_ACTION_PAYMENT_CREATED;
    case 2:
    case "AUDIT_ACTION_PAYMENT_SUBMITTED":
      return AuditAction.AUDIT_ACTION_PAYMENT_SUBMITTED;
    case 3:
    case "AUDIT_ACTION_PAYMENT_SUCCEEDED":
      return AuditAction.AUDIT_ACTION_PAYMENT_SUCCEEDED;
    case 4:
    case "AUDIT_ACTION_PAYMENT_FAILED":
      return AuditAction.AUDIT_ACTION_PAYMENT_FAILED;
    case 5:
    case "AUDIT_ACTION_PAYMENT_CANCELLED":
      return AuditAction.AUDIT_ACTION_PAYMENT_CANCELLED;
    case 6:
    case "AUDIT_ACTION_PAYMENT_REFUNDED":
      return AuditAction.AUDIT_ACTION_PAYMENT_REFUNDED;
    case 7:
    case "AUDIT_ACTION_MANDATE_CREATED":
      return AuditAction.AUDIT_ACTION_MANDATE_CREATED;
    case 8:
    case "AUDIT_ACTION_MANDATE_ACTIVATED":
      return AuditAction.AUDIT_ACTION_MANDATE_ACTIVATED;
    case 9:
    case "AUDIT_ACTION_MANDATE_CANCELLED":
      return AuditAction.AUDIT_ACTION_MANDATE_CANCELLED;
    case 10:
    case "AUDIT_ACTION_SCHEDULE_CREATED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_CREATED;
    case 11:
    case "AUDIT_ACTION_SCHEDULE_PAUSED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_PAUSED;
    case 12:
    case "AUDIT_ACTION_SCHEDULE_RESUMED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_RESUMED;
    case 13:
    case "AUDIT_ACTION_SCHEDULE_CANCELLED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuditAction.UNRECOGNIZED;
  }
}

export function auditActionToJSON(object: AuditAction): string {
  switch (object) {
    case AuditAction.AUDIT_ACTION_UNSPECIFIED:
      return "AUDIT_ACTION_UNSPECIFIED";
    case AuditAction.AUDIT_ACTION_PAYMENT_CREATED:
      return "AUDIT_ACTION_PAYMENT_CREATED";
    case AuditAction.AUDIT_ACTION_PAYMENT_SUBMITTED:
      return "AUDIT_ACTION_PAYMENT_SUBMITTED";
    case AuditAction.AUDIT_ACTION_PAYMENT_SUCCEEDED:
      return "AUDIT_ACTION_PAYMENT_SUCCEEDED";
    case AuditAction.AUDIT_ACTION_PAYMENT_FAILED:
      return "AUDIT_ACTION_PAYMENT_FAILED";
    case AuditAction.AUDIT_ACTION_PAYMENT_CANCELLED:
      return "AUDIT_ACTION_PAYMENT_CANCELLED";
    case AuditAction.AUDIT_ACTION_PAYMENT_REFUNDED:
      return "AUDIT_ACTION_PAYMENT_REFUNDED";
    case AuditAction.AUDIT_ACTION_MANDATE_CREATED:
      return "AUDIT_ACTION_MANDATE_CREATED";
    case AuditAction.AUDIT_ACTION_MANDATE_ACTIVATED:
      return "AUDIT_ACTION_MANDATE_ACTIVATED";
    case AuditAction.AUDIT_ACTION_MANDATE_CANCELLED:
      return "AUDIT_ACTION_MANDATE_CANCELLED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_CREATED:
      return "AUDIT_ACTION_SCHEDULE_CREATED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_PAUSED:
      return "AUDIT_ACTION_SCHEDULE_PAUSED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_RESUMED:
      return "AUDIT_ACTION_SCHEDULE_RESUMED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_CANCELLED:
      return "AUDIT_ACTION_SCHEDULE_CANCELLED";
    case AuditAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Portal session status */
export enum PortalSessionStatus {
  PORTAL_SESSION_STATUS_UNSPECIFIED = 0,
  /** PORTAL_SESSION_CREATED - Session created, token generated */
  PORTAL_SESSION_CREATED = 1,
  /** PORTAL_SESSION_ACTIVE - First accessed */
  PORTAL_SESSION_ACTIVE = 2,
  /** PORTAL_SESSION_REDIRECTED - Redirected to PSP */
  PORTAL_SESSION_REDIRECTED = 3,
  /** PORTAL_SESSION_COMPLETED - Payment completed */
  PORTAL_SESSION_COMPLETED = 4,
  /** PORTAL_SESSION_FAILED - Payment failed */
  PORTAL_SESSION_FAILED = 5,
  /** PORTAL_SESSION_EXPIRED - TTL exceeded */
  PORTAL_SESSION_EXPIRED = 6,
  /** PORTAL_SESSION_CANCELLED - Manually cancelled */
  PORTAL_SESSION_CANCELLED = 7,
  UNRECOGNIZED = -1,
}

export function portalSessionStatusFromJSON(object: any): PortalSessionStatus {
  switch (object) {
    case 0:
    case "PORTAL_SESSION_STATUS_UNSPECIFIED":
      return PortalSessionStatus.PORTAL_SESSION_STATUS_UNSPECIFIED;
    case 1:
    case "PORTAL_SESSION_CREATED":
      return PortalSessionStatus.PORTAL_SESSION_CREATED;
    case 2:
    case "PORTAL_SESSION_ACTIVE":
      return PortalSessionStatus.PORTAL_SESSION_ACTIVE;
    case 3:
    case "PORTAL_SESSION_REDIRECTED":
      return PortalSessionStatus.PORTAL_SESSION_REDIRECTED;
    case 4:
    case "PORTAL_SESSION_COMPLETED":
      return PortalSessionStatus.PORTAL_SESSION_COMPLETED;
    case 5:
    case "PORTAL_SESSION_FAILED":
      return PortalSessionStatus.PORTAL_SESSION_FAILED;
    case 6:
    case "PORTAL_SESSION_EXPIRED":
      return PortalSessionStatus.PORTAL_SESSION_EXPIRED;
    case 7:
    case "PORTAL_SESSION_CANCELLED":
      return PortalSessionStatus.PORTAL_SESSION_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalSessionStatus.UNRECOGNIZED;
  }
}

export function portalSessionStatusToJSON(object: PortalSessionStatus): string {
  switch (object) {
    case PortalSessionStatus.PORTAL_SESSION_STATUS_UNSPECIFIED:
      return "PORTAL_SESSION_STATUS_UNSPECIFIED";
    case PortalSessionStatus.PORTAL_SESSION_CREATED:
      return "PORTAL_SESSION_CREATED";
    case PortalSessionStatus.PORTAL_SESSION_ACTIVE:
      return "PORTAL_SESSION_ACTIVE";
    case PortalSessionStatus.PORTAL_SESSION_REDIRECTED:
      return "PORTAL_SESSION_REDIRECTED";
    case PortalSessionStatus.PORTAL_SESSION_COMPLETED:
      return "PORTAL_SESSION_COMPLETED";
    case PortalSessionStatus.PORTAL_SESSION_FAILED:
      return "PORTAL_SESSION_FAILED";
    case PortalSessionStatus.PORTAL_SESSION_EXPIRED:
      return "PORTAL_SESSION_EXPIRED";
    case PortalSessionStatus.PORTAL_SESSION_CANCELLED:
      return "PORTAL_SESSION_CANCELLED";
    case PortalSessionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Allowed actions on portal */
export enum PortalSessionAction {
  PORTAL_SESSION_ACTION_UNSPECIFIED = 0,
  /** PORTAL_ACTION_PAY_NOW - Immediate payment */
  PORTAL_ACTION_PAY_NOW = 1,
  /** PORTAL_ACTION_UPDATE_CARD - Update payment method */
  PORTAL_ACTION_UPDATE_CARD = 2,
  /** PORTAL_ACTION_SETUP_MANDATE - Setup direct debit mandate */
  PORTAL_ACTION_SETUP_MANDATE = 3,
  UNRECOGNIZED = -1,
}

export function portalSessionActionFromJSON(object: any): PortalSessionAction {
  switch (object) {
    case 0:
    case "PORTAL_SESSION_ACTION_UNSPECIFIED":
      return PortalSessionAction.PORTAL_SESSION_ACTION_UNSPECIFIED;
    case 1:
    case "PORTAL_ACTION_PAY_NOW":
      return PortalSessionAction.PORTAL_ACTION_PAY_NOW;
    case 2:
    case "PORTAL_ACTION_UPDATE_CARD":
      return PortalSessionAction.PORTAL_ACTION_UPDATE_CARD;
    case 3:
    case "PORTAL_ACTION_SETUP_MANDATE":
      return PortalSessionAction.PORTAL_ACTION_SETUP_MANDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalSessionAction.UNRECOGNIZED;
  }
}

export function portalSessionActionToJSON(object: PortalSessionAction): string {
  switch (object) {
    case PortalSessionAction.PORTAL_SESSION_ACTION_UNSPECIFIED:
      return "PORTAL_SESSION_ACTION_UNSPECIFIED";
    case PortalSessionAction.PORTAL_ACTION_PAY_NOW:
      return "PORTAL_ACTION_PAY_NOW";
    case PortalSessionAction.PORTAL_ACTION_UPDATE_CARD:
      return "PORTAL_ACTION_UPDATE_CARD";
    case PortalSessionAction.PORTAL_ACTION_SETUP_MANDATE:
      return "PORTAL_ACTION_SETUP_MANDATE";
    case PortalSessionAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Portal error codes */
export enum PortalErrorCode {
  PORTAL_ERROR_CODE_UNSPECIFIED = 0,
  PORTAL_ERROR_SESSION_NOT_FOUND = 1,
  PORTAL_ERROR_SESSION_EXPIRED = 2,
  PORTAL_ERROR_SESSION_ALREADY_USED = 3,
  PORTAL_ERROR_SESSION_REVOKED = 4,
  PORTAL_ERROR_SESSION_TERMINAL = 5,
  PORTAL_ERROR_INVALID_TOKEN = 6,
  PORTAL_ERROR_TOKEN_MALFORMED = 7,
  PORTAL_ERROR_INVALID_TRANSITION = 8,
  PORTAL_ERROR_ACTION_NOT_ALLOWED = 9,
  UNRECOGNIZED = -1,
}

export function portalErrorCodeFromJSON(object: any): PortalErrorCode {
  switch (object) {
    case 0:
    case "PORTAL_ERROR_CODE_UNSPECIFIED":
      return PortalErrorCode.PORTAL_ERROR_CODE_UNSPECIFIED;
    case 1:
    case "PORTAL_ERROR_SESSION_NOT_FOUND":
      return PortalErrorCode.PORTAL_ERROR_SESSION_NOT_FOUND;
    case 2:
    case "PORTAL_ERROR_SESSION_EXPIRED":
      return PortalErrorCode.PORTAL_ERROR_SESSION_EXPIRED;
    case 3:
    case "PORTAL_ERROR_SESSION_ALREADY_USED":
      return PortalErrorCode.PORTAL_ERROR_SESSION_ALREADY_USED;
    case 4:
    case "PORTAL_ERROR_SESSION_REVOKED":
      return PortalErrorCode.PORTAL_ERROR_SESSION_REVOKED;
    case 5:
    case "PORTAL_ERROR_SESSION_TERMINAL":
      return PortalErrorCode.PORTAL_ERROR_SESSION_TERMINAL;
    case 6:
    case "PORTAL_ERROR_INVALID_TOKEN":
      return PortalErrorCode.PORTAL_ERROR_INVALID_TOKEN;
    case 7:
    case "PORTAL_ERROR_TOKEN_MALFORMED":
      return PortalErrorCode.PORTAL_ERROR_TOKEN_MALFORMED;
    case 8:
    case "PORTAL_ERROR_INVALID_TRANSITION":
      return PortalErrorCode.PORTAL_ERROR_INVALID_TRANSITION;
    case 9:
    case "PORTAL_ERROR_ACTION_NOT_ALLOWED":
      return PortalErrorCode.PORTAL_ERROR_ACTION_NOT_ALLOWED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalErrorCode.UNRECOGNIZED;
  }
}

export function portalErrorCodeToJSON(object: PortalErrorCode): string {
  switch (object) {
    case PortalErrorCode.PORTAL_ERROR_CODE_UNSPECIFIED:
      return "PORTAL_ERROR_CODE_UNSPECIFIED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_NOT_FOUND:
      return "PORTAL_ERROR_SESSION_NOT_FOUND";
    case PortalErrorCode.PORTAL_ERROR_SESSION_EXPIRED:
      return "PORTAL_ERROR_SESSION_EXPIRED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_ALREADY_USED:
      return "PORTAL_ERROR_SESSION_ALREADY_USED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_REVOKED:
      return "PORTAL_ERROR_SESSION_REVOKED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_TERMINAL:
      return "PORTAL_ERROR_SESSION_TERMINAL";
    case PortalErrorCode.PORTAL_ERROR_INVALID_TOKEN:
      return "PORTAL_ERROR_INVALID_TOKEN";
    case PortalErrorCode.PORTAL_ERROR_TOKEN_MALFORMED:
      return "PORTAL_ERROR_TOKEN_MALFORMED";
    case PortalErrorCode.PORTAL_ERROR_INVALID_TRANSITION:
      return "PORTAL_ERROR_INVALID_TRANSITION";
    case PortalErrorCode.PORTAL_ERROR_ACTION_NOT_ALLOWED:
      return "PORTAL_ERROR_ACTION_NOT_ALLOWED";
    case PortalErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** PSP provider for portal */
export enum PortalPspProvider {
  PORTAL_PSP_PROVIDER_UNSPECIFIED = 0,
  PORTAL_PSP_STRIPE = 1,
  PORTAL_PSP_GOCARDLESS = 2,
  PORTAL_PSP_SLIMPAY = 3,
  PORTAL_PSP_EMERCHANTPAY = 4,
  UNRECOGNIZED = -1,
}

export function portalPspProviderFromJSON(object: any): PortalPspProvider {
  switch (object) {
    case 0:
    case "PORTAL_PSP_PROVIDER_UNSPECIFIED":
      return PortalPspProvider.PORTAL_PSP_PROVIDER_UNSPECIFIED;
    case 1:
    case "PORTAL_PSP_STRIPE":
      return PortalPspProvider.PORTAL_PSP_STRIPE;
    case 2:
    case "PORTAL_PSP_GOCARDLESS":
      return PortalPspProvider.PORTAL_PSP_GOCARDLESS;
    case 3:
    case "PORTAL_PSP_SLIMPAY":
      return PortalPspProvider.PORTAL_PSP_SLIMPAY;
    case 4:
    case "PORTAL_PSP_EMERCHANTPAY":
      return PortalPspProvider.PORTAL_PSP_EMERCHANTPAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalPspProvider.UNRECOGNIZED;
  }
}

export function portalPspProviderToJSON(object: PortalPspProvider): string {
  switch (object) {
    case PortalPspProvider.PORTAL_PSP_PROVIDER_UNSPECIFIED:
      return "PORTAL_PSP_PROVIDER_UNSPECIFIED";
    case PortalPspProvider.PORTAL_PSP_STRIPE:
      return "PORTAL_PSP_STRIPE";
    case PortalPspProvider.PORTAL_PSP_GOCARDLESS:
      return "PORTAL_PSP_GOCARDLESS";
    case PortalPspProvider.PORTAL_PSP_SLIMPAY:
      return "PORTAL_PSP_SLIMPAY";
    case PortalPspProvider.PORTAL_PSP_EMERCHANTPAY:
      return "PORTAL_PSP_EMERCHANTPAY";
    case PortalPspProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Portal audit event types */
export enum PortalAuditEventType {
  PORTAL_AUDIT_EVENT_UNSPECIFIED = 0,
  PORTAL_SESSION_CREATED_EVENT = 1,
  PORTAL_SESSION_ACTIVATED_EVENT = 2,
  PORTAL_TOKEN_VALIDATED_EVENT = 3,
  PORTAL_TOKEN_REJECTED_EVENT = 4,
  PORTAL_SESSION_ACCESSED_EVENT = 5,
  PORTAL_REDIRECT_INITIATED_EVENT = 6,
  PORTAL_PAYMENT_INITIATED_EVENT = 7,
  PORTAL_PAYMENT_COMPLETED_EVENT = 8,
  PORTAL_PAYMENT_FAILED_EVENT = 9,
  PORTAL_SESSION_EXPIRED_EVENT = 10,
  PORTAL_SESSION_CANCELLED_EVENT = 11,
  UNRECOGNIZED = -1,
}

export function portalAuditEventTypeFromJSON(object: any): PortalAuditEventType {
  switch (object) {
    case 0:
    case "PORTAL_AUDIT_EVENT_UNSPECIFIED":
      return PortalAuditEventType.PORTAL_AUDIT_EVENT_UNSPECIFIED;
    case 1:
    case "PORTAL_SESSION_CREATED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_CREATED_EVENT;
    case 2:
    case "PORTAL_SESSION_ACTIVATED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_ACTIVATED_EVENT;
    case 3:
    case "PORTAL_TOKEN_VALIDATED_EVENT":
      return PortalAuditEventType.PORTAL_TOKEN_VALIDATED_EVENT;
    case 4:
    case "PORTAL_TOKEN_REJECTED_EVENT":
      return PortalAuditEventType.PORTAL_TOKEN_REJECTED_EVENT;
    case 5:
    case "PORTAL_SESSION_ACCESSED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_ACCESSED_EVENT;
    case 6:
    case "PORTAL_REDIRECT_INITIATED_EVENT":
      return PortalAuditEventType.PORTAL_REDIRECT_INITIATED_EVENT;
    case 7:
    case "PORTAL_PAYMENT_INITIATED_EVENT":
      return PortalAuditEventType.PORTAL_PAYMENT_INITIATED_EVENT;
    case 8:
    case "PORTAL_PAYMENT_COMPLETED_EVENT":
      return PortalAuditEventType.PORTAL_PAYMENT_COMPLETED_EVENT;
    case 9:
    case "PORTAL_PAYMENT_FAILED_EVENT":
      return PortalAuditEventType.PORTAL_PAYMENT_FAILED_EVENT;
    case 10:
    case "PORTAL_SESSION_EXPIRED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_EXPIRED_EVENT;
    case 11:
    case "PORTAL_SESSION_CANCELLED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_CANCELLED_EVENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalAuditEventType.UNRECOGNIZED;
  }
}

export function portalAuditEventTypeToJSON(object: PortalAuditEventType): string {
  switch (object) {
    case PortalAuditEventType.PORTAL_AUDIT_EVENT_UNSPECIFIED:
      return "PORTAL_AUDIT_EVENT_UNSPECIFIED";
    case PortalAuditEventType.PORTAL_SESSION_CREATED_EVENT:
      return "PORTAL_SESSION_CREATED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_ACTIVATED_EVENT:
      return "PORTAL_SESSION_ACTIVATED_EVENT";
    case PortalAuditEventType.PORTAL_TOKEN_VALIDATED_EVENT:
      return "PORTAL_TOKEN_VALIDATED_EVENT";
    case PortalAuditEventType.PORTAL_TOKEN_REJECTED_EVENT:
      return "PORTAL_TOKEN_REJECTED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_ACCESSED_EVENT:
      return "PORTAL_SESSION_ACCESSED_EVENT";
    case PortalAuditEventType.PORTAL_REDIRECT_INITIATED_EVENT:
      return "PORTAL_REDIRECT_INITIATED_EVENT";
    case PortalAuditEventType.PORTAL_PAYMENT_INITIATED_EVENT:
      return "PORTAL_PAYMENT_INITIATED_EVENT";
    case PortalAuditEventType.PORTAL_PAYMENT_COMPLETED_EVENT:
      return "PORTAL_PAYMENT_COMPLETED_EVENT";
    case PortalAuditEventType.PORTAL_PAYMENT_FAILED_EVENT:
      return "PORTAL_PAYMENT_FAILED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_EXPIRED_EVENT:
      return "PORTAL_SESSION_EXPIRED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_CANCELLED_EVENT:
      return "PORTAL_SESSION_CANCELLED_EVENT";
    case PortalAuditEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Actor type for portal audit */
export enum PortalAuditActorType {
  PORTAL_AUDIT_ACTOR_UNSPECIFIED = 0,
  PORTAL_ACTOR_SYSTEM = 1,
  PORTAL_ACTOR_ADMIN = 2,
  PORTAL_ACTOR_PORTAL_TOKEN = 3,
  PORTAL_ACTOR_WEBHOOK = 4,
  UNRECOGNIZED = -1,
}

export function portalAuditActorTypeFromJSON(object: any): PortalAuditActorType {
  switch (object) {
    case 0:
    case "PORTAL_AUDIT_ACTOR_UNSPECIFIED":
      return PortalAuditActorType.PORTAL_AUDIT_ACTOR_UNSPECIFIED;
    case 1:
    case "PORTAL_ACTOR_SYSTEM":
      return PortalAuditActorType.PORTAL_ACTOR_SYSTEM;
    case 2:
    case "PORTAL_ACTOR_ADMIN":
      return PortalAuditActorType.PORTAL_ACTOR_ADMIN;
    case 3:
    case "PORTAL_ACTOR_PORTAL_TOKEN":
      return PortalAuditActorType.PORTAL_ACTOR_PORTAL_TOKEN;
    case 4:
    case "PORTAL_ACTOR_WEBHOOK":
      return PortalAuditActorType.PORTAL_ACTOR_WEBHOOK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalAuditActorType.UNRECOGNIZED;
  }
}

export function portalAuditActorTypeToJSON(object: PortalAuditActorType): string {
  switch (object) {
    case PortalAuditActorType.PORTAL_AUDIT_ACTOR_UNSPECIFIED:
      return "PORTAL_AUDIT_ACTOR_UNSPECIFIED";
    case PortalAuditActorType.PORTAL_ACTOR_SYSTEM:
      return "PORTAL_ACTOR_SYSTEM";
    case PortalAuditActorType.PORTAL_ACTOR_ADMIN:
      return "PORTAL_ACTOR_ADMIN";
    case PortalAuditActorType.PORTAL_ACTOR_PORTAL_TOKEN:
      return "PORTAL_ACTOR_PORTAL_TOKEN";
    case PortalAuditActorType.PORTAL_ACTOR_WEBHOOK:
      return "PORTAL_ACTOR_WEBHOOK";
    case PortalAuditActorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Empty {
}

export interface GetByIdRequest {
  id: string;
  /** Pour le multi-tenant */
  societeId: string;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface CreateStripeCheckoutSessionRequest {
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  /** 'payment', 'subscription', 'setup' */
  mode: string;
  successUrl: string;
  cancelUrl: string;
  customerId?: string | undefined;
  customerEmail?:
    | string
    | undefined;
  /** Pour les abonnements */
  priceId?: string | undefined;
  metadata: { [key: string]: string };
  lineItems: LineItem[];
}

export interface CreateStripeCheckoutSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface LineItem {
  name: string;
  description: string;
  amount: number;
  quantity: number;
  currency: string;
}

export interface StripeCheckoutSessionResponse {
  id: string;
  url: string;
  status: string;
  paymentStatus: string;
  customerId?: string | undefined;
  subscriptionId?: string | undefined;
}

export interface CreateStripePaymentIntentRequest {
  societeId: string;
  amount: number;
  currency: string;
  customerId?: string | undefined;
  description?: string | undefined;
  paymentMethod?: string | undefined;
  confirm: boolean;
  automaticPaymentMethods: boolean;
  metadata: { [key: string]: string };
}

export interface CreateStripePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripePaymentIntentResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  clientSecret?: string | undefined;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeCustomerRequest {
  societeId: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  description?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeCustomerRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeCustomerResponse {
  id: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  created: number;
}

export interface CreateStripeSubscriptionRequest {
  societeId: string;
  customerId: string;
  priceId: string;
  paymentMethod?: string | undefined;
  defaultPaymentMethod?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSubscriptionResponse {
  id: string;
  customerId: string;
  status: string;
  currentPeriodStart: number;
  currentPeriodEnd: number;
  cancelAtPeriodEnd: boolean;
}

export interface CreateStripeRefundRequest {
  societeId: string;
  paymentIntentId: string;
  /** Partial refund, omit for full */
  amount?: number | undefined;
  reason?: string | undefined;
}

export interface StripeRefundResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  paymentIntentId: string;
}

export interface CreateStripeSetupIntentRequest {
  societeId: string;
  customerId?: string | undefined;
  paymentMethodTypes: string[];
  metadata: { [key: string]: string };
}

export interface CreateStripeSetupIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSetupIntentResponse {
  id: string;
  clientSecret: string;
  status: string;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeBillingPortalRequest {
  societeId: string;
  customerId: string;
  returnUrl: string;
}

export interface StripeBillingPortalResponse {
  id: string;
  url: string;
}

export interface CreatePayPalOrderRequest {
  societeId: string;
  /** 'CAPTURE' or 'AUTHORIZE' */
  intent: string;
  purchaseUnits: PayPalPurchaseUnit[];
  returnUrl: string;
  cancelUrl: string;
  metadata: { [key: string]: string };
}

export interface CreatePayPalOrderRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PayPalPurchaseUnit {
  referenceId?:
    | string
    | undefined;
  /** En centimes */
  amount: number;
  currency: string;
  description?: string | undefined;
  customId?: string | undefined;
  invoiceId?: string | undefined;
}

export interface PayPalOrderResponse {
  id: string;
  status: string;
  approveUrl?: string | undefined;
  captureUrl?: string | undefined;
  links: PayPalLink[];
}

export interface PayPalLink {
  href: string;
  rel: string;
  method: string;
}

export interface GetPayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface CapturePayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface PayPalCaptureResponse {
  id: string;
  status: string;
  payer?: PayPalPayer | undefined;
  purchaseUnits: PayPalCapturedPurchaseUnit[];
}

export interface PayPalPayer {
  emailAddress?: string | undefined;
  payerId?: string | undefined;
  givenName?: string | undefined;
  surname?: string | undefined;
}

export interface PayPalCapturedPurchaseUnit {
  referenceId?: string | undefined;
  captures: PayPalCapture[];
}

export interface PayPalCapture {
  id: string;
  status: string;
  amount: PayPalAmount | undefined;
}

export interface PayPalAmount {
  currencyCode: string;
  value: string;
}

export interface SetupGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
  /** 'bacs', 'sepa_core', 'ach', etc. */
  scheme: string;
  description?: string | undefined;
  successRedirectUrl: string;
  sessionToken?: string | undefined;
}

export interface GoCardlessMandateResponse {
  id: string;
  clientId: string;
  mandateId: string;
  status: string;
  scheme: string;
  bankName?: string | undefined;
  accountHolderName?: string | undefined;
  accountNumberEnding?: string | undefined;
  redirectUrl?: string | undefined;
}

export interface GetGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
}

export interface CreateGoCardlessPaymentRequest {
  clientId: string;
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  description?:
    | string
    | undefined;
  /** YYYY-MM-DD */
  chargeDate?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessPaymentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessPaymentResponse {
  id: string;
  paymentId: string;
  amount: number;
  currency: string;
  status: string;
  chargeDate?: string | undefined;
}

export interface CreateGoCardlessSubscriptionRequest {
  clientId: string;
  societeId: string;
  amount: number;
  currency: string;
  /** 'weekly', 'monthly', 'yearly' */
  intervalUnit: string;
  interval: number;
  name?: string | undefined;
  startDate?:
    | string
    | undefined;
  /** Number of payments, omit for indefinite */
  count?: number | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessSubscriptionResponse {
  id: string;
  subscriptionId: string;
  amount: number;
  currency: string;
  status: string;
  intervalUnit: string;
  interval: number;
  nextPaymentDate?: string | undefined;
}

export interface CancelGoCardlessSubscriptionRequest {
  subscriptionId: string;
  societeId: string;
}

export interface CreateScheduleRequest {
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  /** ISO date string */
  dueDate: string;
  description?: string | undefined;
  autoProcess: boolean;
  metadata: { [key: string]: string };
}

export interface CreateScheduleRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface ScheduleResponse {
  id: string;
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  dueDate: string;
  /** PLANNED, PROCESSING, PENDING, PAID, FAILED, UNPAID, CANCELLED, EXPIRED */
  status: string;
  lastAttemptAt?: string | undefined;
  paidAt?: string | undefined;
  retryCount: number;
  errorMessage?: string | undefined;
}

export interface UpdateScheduleRequest {
  id: string;
  amount?: number | undefined;
  dueDate?: string | undefined;
  status?: string | undefined;
  autoProcess?: boolean | undefined;
}

export interface GetDueSchedulesRequest {
  organisationId: string;
  /** Get schedules due before this date */
  beforeDate?: string | undefined;
}

export interface ScheduleListResponse {
  schedules: ScheduleResponse[];
  total: number;
}

export interface ProcessDuePaymentsRequest {
  organisationId: string;
  /** If true, don't actually process */
  dryRun?: boolean | undefined;
}

export interface ProcessDuePaymentsResponse {
  processedCount: number;
  successCount: number;
  failedCount: number;
  results: ProcessedPayment[];
}

export interface ProcessedPayment {
  scheduleId: string;
  success: boolean;
  paymentId?: string | undefined;
  error?: string | undefined;
}

export interface RenewScheduleRequest {
  id: string;
  newDueDate: string;
  newAmount?: number | undefined;
}

export interface CreatePaymentIntentRequest {
  organisationId: string;
  societeId: string;
  scheduleId?:
    | string
    | undefined;
  /** STRIPE, PAYPAL, GOCARDLESS, etc. */
  pspName: string;
  amount: number;
  currency: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreatePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PaymentIntentResponse {
  id: string;
  organisationId: string;
  societeId: string;
  scheduleId?: string | undefined;
  pspName: string;
  pspPaymentId?: string | undefined;
  amount: number;
  currency: string;
  /** PENDING, PROCESSING, SUCCEEDED, FAILED, CANCELLED */
  status: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface UpdatePaymentIntentRequest {
  id: string;
  status?: string | undefined;
  pspPaymentId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface CreatePaymentEventRequest {
  organisationId: string;
  paymentIntentId: string;
  /** PAYMENT_INITIATED, PAYMENT_CONFIRMED, PAYMENT_FAILED, etc. */
  eventType: string;
  /** JSON string */
  rawPayload: string;
}

export interface PaymentEventResponse {
  id: string;
  organisationId: string;
  paymentIntentId: string;
  eventType: string;
  rawPayload: string;
  receivedAt: string;
  processed: boolean;
  processedAt?: string | undefined;
  errorMessage?: string | undefined;
}

export interface GetUnprocessedEventsRequest {
  organisationId: string;
  limit?: number | undefined;
}

export interface PaymentEventListResponse {
  events: PaymentEventResponse[];
  total: number;
}

export interface MarkEventProcessedRequest {
  id: string;
  /** If processing failed */
  errorMessage?: string | undefined;
}

export interface GetPSPAccountsRequest {
  societeId: string;
}

export interface PSPAccountsSummaryResponse {
  stripe?: PSPAccountInfo | undefined;
  paypal?: PSPAccountInfo | undefined;
  gocardless?: PSPAccountInfo | undefined;
  emerchantpay?: PSPAccountInfo | undefined;
  slimpay?: PSPAccountInfo | undefined;
  multisafepay?: PSPAccountInfo | undefined;
}

export interface PSPAccountInfo {
  id: string;
  name: string;
  isActive: boolean;
  isLiveMode: boolean;
  isConfigured: boolean;
}

/** Request to create a portal session */
export interface CreatePortalSessionRequest {
  organisationId: string;
  societeId: string;
  customerId: string;
  contractId?: string | undefined;
  paymentIntentId?: string | undefined;
  allowedActions: PortalSessionAction[];
  /** Time-to-live, default 900 (15 min) */
  ttlSeconds?:
    | number
    | undefined;
  /** Default 1 */
  maxUses?: number | undefined;
  amountCents: number;
  /** Default EUR */
  currency?: string | undefined;
  description?: string | undefined;
  mandateId?:
    | string
    | undefined;
  /** Masked RUM for display */
  rumMasked?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreatePortalSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

/** Response after creating a portal session */
export interface CreatePortalSessionResponse {
  session:
    | PortalPaymentSession
    | undefined;
  /** One-time use token (returned only on creation) */
  token: string;
  /** Full URL to the payment portal */
  portalUrl: string;
  /** True if returned from idempotency cache */
  wasIdempotentHit: boolean;
}

/** Portal payment session entity */
export interface PortalPaymentSession {
  id: string;
  organisationId: string;
  societeId: string;
  customerId: string;
  contractId?: string | undefined;
  paymentIntentId?:
    | string
    | undefined;
  /** Token (hash stored, never exposed) */
  tokenVersion: string;
  /** State */
  status: PortalSessionStatus;
  allowedActions: PortalSessionAction[];
  /** Timing */
  expiresAt: string;
  maxUses: number;
  useCount: number;
  consumedAt?: string | undefined;
  revokedAt?: string | undefined;
  lastAccessedAt?:
    | string
    | undefined;
  /** Payment details */
  amountCents: number;
  currency: string;
  description?: string | undefined;
  mandateId?: string | undefined;
  rumMasked?:
    | string
    | undefined;
  /** PSP state (for redirect flow) */
  pspState?: string | undefined;
  pspRedirectUrl?: string | undefined;
  pspProvider?: PortalPspProvider | undefined;
  pspSessionId?:
    | string
    | undefined;
  /** Metadata */
  metadata: { [key: string]: string };
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

export interface PortalPaymentSession_MetadataEntry {
  key: string;
  value: string;
}

/** Validate a portal token */
export interface ValidatePortalTokenRequest {
  token: string;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface ValidatePortalTokenResponse {
  valid: boolean;
  session?: PortalPaymentSession | undefined;
  errorCode?: PortalErrorCode | undefined;
  errorMessage?: string | undefined;
}

/** Access a portal session (marks as active) */
export interface AccessPortalSessionRequest {
  token: string;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface AccessPortalSessionResponse {
  session: PortalPaymentSession | undefined;
}

/** Consume a portal token (for payment action) */
export interface ConsumePortalTokenRequest {
  token: string;
  action: PortalSessionAction;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface ConsumePortalTokenResponse {
  session: PortalPaymentSession | undefined;
}

/** Cancel a portal session */
export interface CancelPortalSessionRequest {
  sessionId: string;
  reason?: string | undefined;
}

export interface CancelPortalSessionResponse {
  session: PortalPaymentSession | undefined;
}

/** Update PSP info on portal session */
export interface UpdatePortalPspInfoRequest {
  sessionId: string;
  pspState: string;
  pspRedirectUrl: string;
  pspProvider: PortalPspProvider;
  pspSessionId: string;
}

export interface UpdatePortalPspInfoResponse {
  success: boolean;
}

/** Transition portal session status */
export interface TransitionPortalSessionRequest {
  sessionId: string;
  newStatus: PortalSessionStatus;
  reason?: string | undefined;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
}

export interface TransitionPortalSessionResponse {
  session: PortalPaymentSession | undefined;
}

/** Portal session audit log entry */
export interface PortalSessionAuditLog {
  id: string;
  portalSessionId: string;
  eventType: PortalAuditEventType;
  actorType: PortalAuditActorType;
  previousStatus?: string | undefined;
  newStatus?: string | undefined;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
  correlationId?: string | undefined;
  data: { [key: string]: string };
  timestamp: string;
}

export interface PortalSessionAuditLog_DataEntry {
  key: string;
  value: string;
}

/** List portal sessions */
export interface ListPortalSessionsRequest {
  organisationId: string;
  societeId?: string | undefined;
  customerId?: string | undefined;
  status?: PortalSessionStatus | undefined;
  fromDate?: string | undefined;
  toDate?: string | undefined;
  page?: number | undefined;
  limit?: number | undefined;
}

export interface ListPortalSessionsResponse {
  sessions: PortalPaymentSession[];
  total: number;
  page: number;
  totalPages: number;
}

/** Get portal session audit logs */
export interface GetPortalSessionAuditRequest {
  sessionId: string;
}

export interface GetPortalSessionAuditResponse {
  logs: PortalSessionAuditLog[];
}

/** Portal session stats */
export interface GetPortalSessionStatsRequest {
  organisationId: string;
  societeId?: string | undefined;
  fromDate: string;
  toDate: string;
}

export interface GetPortalSessionStatsResponse {
  totalCreated: number;
  totalCompleted: number;
  totalFailed: number;
  totalExpired: number;
  totalCancelled: number;
  completionRate: number;
}

/** Request context for portal operations */
export interface PortalRequestContext {
  ipHash?: string | undefined;
  uaHash?: string | undefined;
  requestId?: string | undefined;
  correlationId?: string | undefined;
}

/** GoCardless configuration */
export interface GoCardlessConfig {
  accessToken: string;
  baseUrl: string;
}

/** Slimpay OAuth token (cached) */
export interface SlimpayToken {
  accessToken: string;
  /** Unix timestamp */
  expiresAt: number;
}

export interface CreateSlimpayMandateRequest {
  societeId: string;
  clientId: string;
  /** 'sepa_core', 'sepa_b2b' */
  scheme: string;
  subscriberReference: string;
  firstName: string;
  lastName: string;
  email: string;
  phone?: string | undefined;
  iban?: string | undefined;
  bic?: string | undefined;
  successUrl: string;
  failureUrl: string;
  metadata: { [key: string]: string };
}

export interface CreateSlimpayMandateRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface SlimpayMandateResponse {
  id: string;
  mandateId: string;
  clientId: string;
  /** PENDING, ACTIVE, SUSPENDED, REVOKED, CANCELLED */
  status: string;
  scheme: string;
  /** Référence Unique de Mandat */
  rum: string;
  subscriberReference?: string | undefined;
  bankName?: string | undefined;
  ibanLast4?: string | undefined;
  bic?: string | undefined;
  signatureDate?:
    | string
    | undefined;
  /** For mandate signature flow */
  redirectUrl?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface GetSlimpayMandateRequest {
  mandateId: string;
  societeId: string;
}

export interface CancelSlimpayMandateRequest {
  mandateId: string;
  societeId: string;
  reason?: string | undefined;
}

export interface CreateSlimpayPaymentRequest {
  societeId: string;
  mandateId: string;
  amountCents: number;
  currency: string;
  /** Payment label / description */
  label: string;
  /** ISO date, defaults to next business day */
  executionDate?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateSlimpayPaymentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface SlimpayPaymentResponse {
  id: string;
  paymentId: string;
  mandateId: string;
  amountCents: number;
  currency: string;
  /** PENDING, PROCESSING, EXECUTED, REJECTED, REFUNDED */
  status: string;
  label?: string | undefined;
  executionDate?: string | undefined;
  rejectionReason?:
    | string
    | undefined;
  /** e.g. AM04 */
  rejectionCode?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface GetSlimpayPaymentRequest {
  paymentId: string;
  societeId: string;
}

export interface CreateMultiSafepayTransactionRequest {
  societeId: string;
  orderId: string;
  amountCents: number;
  currency: string;
  /** 'redirect', 'direct' */
  paymentType: string;
  /** 'IDEAL', 'VISA', 'MASTERCARD', 'BANCONTACT', etc. */
  gateway: string;
  description?: string | undefined;
  notificationUrl: string;
  redirectUrl: string;
  cancelUrl: string;
  customerEmail?: string | undefined;
  customerFirstName?: string | undefined;
  customerLastName?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateMultiSafepayTransactionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface MultiSafepayTransactionResponse {
  id: string;
  transactionId: string;
  orderId: string;
  amountCents: number;
  currency: string;
  /** INITIALIZED, COMPLETED, DECLINED, VOID, REFUNDED, CHARGEBACK */
  status: string;
  gateway: string;
  /** Redirect URL for customer */
  paymentUrl?: string | undefined;
  reason?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface GetMultiSafepayTransactionRequest {
  transactionId: string;
  societeId: string;
}

export interface RefundMultiSafepayTransactionRequest {
  transactionId: string;
  societeId: string;
  /** Partial or full refund */
  amountCents: number;
  description?: string | undefined;
}

export interface CreateEmerchantpayPaymentRequest {
  societeId: string;
  /** Unique merchant transaction ID */
  transactionId: string;
  amountCents: number;
  currency: string;
  /** 'sale', 'authorize', 'init_recurring_sale' */
  transactionType: string;
  cardNumber?: string | undefined;
  cardHolder?: string | undefined;
  expirationDate?: string | undefined;
  cvv?: string | undefined;
  notificationUrl: string;
  returnSuccessUrl: string;
  returnFailureUrl: string;
  customerEmail?: string | undefined;
  customerPhone?:
    | string
    | undefined;
  /** JSON string */
  billingAddress?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateEmerchantpayPaymentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface EmerchantpayPaymentResponse {
  id: string;
  transactionId: string;
  /** Emerchantpay unique ID */
  uniqueId: string;
  amountCents: number;
  currency: string;
  /** PENDING, APPROVED, DECLINED, ERROR, REFUNDED, VOIDED, CHARGEBACKED */
  status: string;
  transactionType: string;
  /** For 3DS or WPF */
  redirectUrl?: string | undefined;
  reason?: string | undefined;
  responseCode?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface GetEmerchantpayPaymentRequest {
  transactionId: string;
  societeId: string;
}

export interface CreateEmerchantpaySepaPaymentRequest {
  societeId: string;
  transactionId: string;
  amountCents: number;
  currency: string;
  iban: string;
  bic: string;
  accountHolder: string;
  mandateReference?:
    | string
    | undefined;
  /** ISO date */
  mandateSignedDate?: string | undefined;
  notificationUrl: string;
  description?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateEmerchantpaySepaPaymentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface RefundEmerchantpayPaymentRequest {
  transactionId: string;
  societeId: string;
  /** Original payment unique_id */
  uniqueId: string;
  /** Partial or full refund */
  amountCents: number;
  reason?: string | undefined;
}

export interface CreateRoutingRuleRequest {
  societeId: string;
  name: string;
  /** 1 = highest */
  priority: number;
  /** JSON: {"source_channel": ["TERRAIN"], "contract_age_months_gte": 4, ...} */
  conditions: string;
  providerAccountId: string;
  isFallback: boolean;
  isEnabled: boolean;
}

export interface RoutingRuleResponse {
  id: string;
  societeId: string;
  name: string;
  priority: number;
  /** JSON */
  conditions: string;
  providerAccountId: string;
  isFallback: boolean;
  isEnabled: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface UpdateRoutingRuleRequest {
  id: string;
  name?: string | undefined;
  priority?:
    | number
    | undefined;
  /** JSON */
  conditions?: string | undefined;
  providerAccountId?: string | undefined;
  isFallback?: boolean | undefined;
  isEnabled?: boolean | undefined;
}

export interface DeleteRoutingRuleRequest {
  id: string;
  societeId: string;
}

export interface DeleteRoutingRuleResponse {
  success: boolean;
  message: string;
}

export interface ListRoutingRulesRequest {
  societeId: string;
  isEnabled?: boolean | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListRoutingRulesResponse {
  rules: RoutingRuleResponse[];
  total: number;
  page: number;
  pageSize: number;
}

export interface TestRoutingRuleRequest {
  societeId: string;
  /** TERRAIN, WEB, etc. */
  sourceChannel: string;
  productCode?: string | undefined;
  contractAgeMonths?: number | undefined;
  amountCents?: number | undefined;
  clientId?: string | undefined;
}

export interface TestRoutingRuleResponse {
  matchedRuleId: string;
  matchedRuleName: string;
  providerAccountId: string;
  providerName: string;
  isFallback: boolean;
  evaluations: RoutingRuleEvaluation[];
}

export interface RoutingRuleEvaluation {
  ruleId: string;
  ruleName: string;
  priority: number;
  matched: boolean;
  reason?: string | undefined;
}

export interface CreateProviderOverrideRequest {
  societeId: string;
  /** 'CLIENT' or 'CONTRAT' */
  scope: string;
  /** Client ID or Contract ID */
  scopeId: string;
  providerAccountId: string;
  reason: string;
}

export interface ProviderOverrideResponse {
  id: string;
  societeId: string;
  scope: string;
  scopeId: string;
  providerAccountId: string;
  reason: string;
  createdBy: string;
  createdAt: string;
}

export interface DeleteProviderOverrideRequest {
  id: string;
  societeId: string;
}

export interface DeleteProviderOverrideResponse {
  success: boolean;
  message: string;
}

export interface ListProviderOverridesRequest {
  societeId: string;
  scope?: string | undefined;
  scopeId?: string | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListProviderOverridesResponse {
  overrides: ProviderOverrideResponse[];
  total: number;
  page: number;
  pageSize: number;
}

export interface CreateReassignmentJobRequest {
  societeId: string;
  fromProviderAccountId: string;
  toProviderAccountId: string;
  /** JSON: criteria for selecting affected items */
  selectionQuery: string;
  dryRun: boolean;
  /** ISO datetime, if not provided runs immediately */
  scheduledAt?: string | undefined;
}

export interface ReassignmentJobResponse {
  id: string;
  societeId: string;
  fromProviderAccountId: string;
  toProviderAccountId: string;
  /** JSON */
  selectionQuery: string;
  /** DRAFT, SCHEDULED, RUNNING, COMPLETED, FAILED, ROLLED_BACK */
  status: string;
  dryRun: boolean;
  scheduledAt?: string | undefined;
  startedAt?: string | undefined;
  completedAt?: string | undefined;
  totalItems: number;
  successCount: number;
  failedCount: number;
  reportFileId?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface GetReassignmentJobRequest {
  id: string;
  societeId: string;
}

export interface ListAlertsRequest {
  societeId: string;
  /** PROVIDER_ROUTING_NOT_FOUND, HIGH_REJECTION_RATE, etc. */
  alertType?:
    | string
    | undefined;
  /** INFO, WARNING, CRITICAL */
  severity?: string | undefined;
  acknowledged?: boolean | undefined;
  fromDate?: string | undefined;
  toDate?: string | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListAlertsResponse {
  alerts: AlertResponse[];
  total: number;
  page: number;
  pageSize: number;
}

export interface AlertResponse {
  id: string;
  societeId: string;
  alertType: string;
  severity: string;
  title: string;
  message: string;
  /** JSON with additional details */
  context: string;
  acknowledged: boolean;
  acknowledgedBy?: string | undefined;
  acknowledgedAt?: string | undefined;
  createdAt: string;
}

export interface AcknowledgeAlertRequest {
  id: string;
  societeId: string;
  acknowledgedBy: string;
}

export interface GetAlertStatsRequest {
  societeId: string;
  fromDate: string;
  toDate: string;
}

export interface AlertStatsResponse {
  totalAlerts: number;
  unacknowledged: number;
  criticalCount: number;
  warningCount: number;
  infoCount: number;
  byType: AlertTypeCount[];
}

export interface AlertTypeCount {
  alertType: string;
  count: number;
}

export interface CreateExportJobRequest {
  societeId: string;
  /** SEPA_XML, CSV_ACCOUNTING, FEC, CUSTOM */
  exportType: string;
  fromDate: string;
  toDate: string;
  /** CSV, XML, JSON */
  format?:
    | string
    | undefined;
  /** JSON: additional filters */
  filters?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateExportJobRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface ExportJobResponse {
  id: string;
  societeId: string;
  exportType: string;
  /** PENDING, PROCESSING, COMPLETED, FAILED */
  status: string;
  fromDate: string;
  toDate: string;
  format?:
    | string
    | undefined;
  /** Download URL when completed */
  fileUrl?: string | undefined;
  fileName?: string | undefined;
  fileSizeBytes?: number | undefined;
  recordCount: number;
  errorMessage?: string | undefined;
  createdAt: string;
  completedAt?: string | undefined;
}

export interface GetExportJobRequest {
  id: string;
  societeId: string;
}

export interface ListExportJobsRequest {
  societeId: string;
  exportType?: string | undefined;
  status?: string | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListExportJobsResponse {
  jobs: ExportJobResponse[];
  total: number;
  page: number;
  pageSize: number;
}

export interface DownloadExportRequest {
  id: string;
  societeId: string;
}

export interface DownloadExportResponse {
  fileContent: Uint8Array;
  fileName: string;
  contentType: string;
  fileSizeBytes: number;
}

export interface GetRiskScoreRequest {
  id: string;
  societeId: string;
}

export interface RiskScoreResponse {
  id: string;
  societeId: string;
  /** CLIENT, CONTRACT, PAYMENT */
  entityType: string;
  entityId: string;
  /** 0-100 */
  score: number;
  /** LOW, MEDIUM, HIGH, CRITICAL */
  riskLevel: string;
  factors: RiskFactor[];
  evaluatedAt: string;
  expiresAt?: string | undefined;
}

export interface RiskFactor {
  name: string;
  weight: number;
  score: number;
  description: string;
}

export interface EvaluateRiskScoreRequest {
  societeId: string;
  /** CLIENT, CONTRACT, PAYMENT */
  entityType: string;
  entityId: string;
  forceRefresh: boolean;
}

export interface ListRiskScoresRequest {
  societeId: string;
  entityType?: string | undefined;
  riskLevel?: string | undefined;
  minScore?: number | undefined;
  maxScore?: number | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListRiskScoresResponse {
  scores: RiskScoreResponse[];
  total: number;
  page: number;
  pageSize: number;
}

export interface GetScoringStatsRequest {
  societeId: string;
  fromDate: string;
  toDate: string;
}

export interface ScoringStatsResponse {
  totalEvaluated: number;
  lowRiskCount: number;
  mediumRiskCount: number;
  highRiskCount: number;
  criticalRiskCount: number;
  averageScore: number;
}

export interface ImportBankStatementRequest {
  societeId: string;
  bankAccountId: string;
  /** CAMT053, MT940, CSV */
  format: string;
  fileContent: Uint8Array;
  fileName: string;
  /** ISO date */
  statementDate?: string | undefined;
}

export interface ImportBankStatementResponse {
  id: string;
  societeId: string;
  /** IMPORTED, PROCESSING, RECONCILED, PARTIAL, FAILED */
  status: string;
  totalTransactions: number;
  matchedCount: number;
  unmatchedCount: number;
  totalCreditCents: number;
  totalDebitCents: number;
  importedAt: string;
}

export interface GetReconciliationStatusRequest {
  societeId: string;
  bankAccountId?: string | undefined;
  fromDate?: string | undefined;
  toDate?: string | undefined;
}

export interface ReconciliationStatusResponse {
  societeId: string;
  totalStatements: number;
  fullyReconciled: number;
  partiallyReconciled: number;
  pending: number;
  totalUnmatchedAmountCents: number;
  /** Percentage */
  reconciliationRate: number;
  lastImportAt?: string | undefined;
}

export interface ForceReconciliationRequest {
  societeId: string;
  bankTransactionId: string;
  paymentId: string;
  reason?: string | undefined;
}

export interface ReconciliationResponse {
  id: string;
  bankTransactionId: string;
  paymentId: string;
  /** MATCHED, FORCED, DISPUTED */
  status: string;
  bankAmountCents: number;
  paymentAmountCents: number;
  reason?: string | undefined;
  reconciledAt: string;
  reconciledBy?: string | undefined;
}

export interface ListUnmatchedPaymentsRequest {
  societeId: string;
  /** BANK or SYSTEM (unmatched from which side) */
  source?: string | undefined;
  fromDate?: string | undefined;
  toDate?: string | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListUnmatchedPaymentsResponse {
  payments: UnmatchedPayment[];
  total: number;
  page: number;
  pageSize: number;
}

export interface UnmatchedPayment {
  id: string;
  /** BANK or SYSTEM */
  source: string;
  amountCents: number;
  currency: string;
  reference?: string | undefined;
  description?: string | undefined;
  date: string;
  /** System-suggested match */
  suggestedMatchId?:
    | string
    | undefined;
  /** 0-100 */
  matchConfidence?: number | undefined;
}

export interface ListProviderStatusMappingsRequest {
  societeId: string;
  /** SLIMPAY, MULTISAFEPAY, EMERCHANTPAY, GOCARDLESS */
  providerName?: string | undefined;
}

export interface ListProviderStatusMappingsResponse {
  mappings: ProviderStatusMappingResponse[];
  total: number;
}

export interface ProviderStatusMappingResponse {
  id: string;
  providerName: string;
  /** Raw status from PSP */
  providerStatus: string;
  /** Mapped internal PaymentStatus */
  internalStatus: string;
  /** e.g. payment.executed, payment.rejected */
  eventType: string;
  /** REJECT_INSUFF_FUNDS, REJECT_OTHER, etc. */
  rejectionCategory?:
    | string
    | undefined;
  /** AUTO, MANUAL, NONE */
  retryAdvice?: string | undefined;
  isActive: boolean;
  updatedAt: string;
}

export interface UpdateProviderStatusMappingRequest {
  id: string;
  internalStatus?: string | undefined;
  rejectionCategory?: string | undefined;
  retryAdvice?: string | undefined;
  isActive?: boolean | undefined;
}

export interface ListRejectionReasonsRequest {
  societeId: string;
  providerName?:
    | string
    | undefined;
  /** INSUFF_FUNDS, ACCOUNT_CLOSED, UNAUTHORIZED, TECHNICAL, OTHER */
  category?: string | undefined;
  isActive?: boolean | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface ListRejectionReasonsResponse {
  reasons: RejectionReasonResponse[];
  total: number;
  page: number;
  pageSize: number;
}

export interface RejectionReasonResponse {
  id: string;
  /** e.g. AM04, AC01, MD01 */
  code: string;
  label: string;
  description: string;
  /** INSUFF_FUNDS, ACCOUNT_CLOSED, UNAUTHORIZED, TECHNICAL, OTHER */
  category: string;
  /** AUTO_RETRY, MANUAL_REVIEW, NO_RETRY */
  retryStrategy: string;
  maxRetries?: number | undefined;
  retryDelayDays?: number | undefined;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateRejectionReasonRequest {
  societeId: string;
  code: string;
  label: string;
  description: string;
  category: string;
  retryStrategy: string;
  maxRetries?: number | undefined;
  retryDelayDays?: number | undefined;
}

export interface UpdateRejectionReasonRequest {
  id: string;
  label?: string | undefined;
  description?: string | undefined;
  category?: string | undefined;
  retryStrategy?: string | undefined;
  maxRetries?: number | undefined;
  retryDelayDays?: number | undefined;
  isActive?: boolean | undefined;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "", societeId: "" };
}

export const GetByIdRequest: MessageFns<GetByIdRequest> = {
  encode(message: GetByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetByIdRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetByIdRequest>, I>>(base?: I): GetByIdRequest {
    return GetByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetByIdRequest>, I>>(object: I): GetByIdRequest {
    const message = createBaseGetByIdRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest(): CreateStripeCheckoutSessionRequest {
  return {
    societeId: "",
    amount: 0,
    currency: "",
    mode: "",
    successUrl: "",
    cancelUrl: "",
    customerId: undefined,
    customerEmail: undefined,
    priceId: undefined,
    metadata: {},
    lineItems: [],
  };
}

export const CreateStripeCheckoutSessionRequest: MessageFns<CreateStripeCheckoutSessionRequest> = {
  encode(message: CreateStripeCheckoutSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.mode !== "") {
      writer.uint32(34).string(message.mode);
    }
    if (message.successUrl !== "") {
      writer.uint32(42).string(message.successUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(50).string(message.cancelUrl);
    }
    if (message.customerId !== undefined) {
      writer.uint32(58).string(message.customerId);
    }
    if (message.customerEmail !== undefined) {
      writer.uint32(66).string(message.customerEmail);
    }
    if (message.priceId !== undefined) {
      writer.uint32(74).string(message.priceId);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeCheckoutSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .join();
    });
    for (const v of message.lineItems) {
      LineItem.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.customerEmail = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.priceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateStripeCheckoutSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lineItems.push(LineItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCheckoutSessionRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      successUrl: isSet(object.successUrl)
        ? globalThis.String(object.successUrl)
        : isSet(object.success_url)
        ? globalThis.String(object.success_url)
        : "",
      cancelUrl: isSet(object.cancelUrl)
        ? globalThis.String(object.cancelUrl)
        : isSet(object.cancel_url)
        ? globalThis.String(object.cancel_url)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      customerEmail: isSet(object.customerEmail)
        ? globalThis.String(object.customerEmail)
        : isSet(object.customer_email)
        ? globalThis.String(object.customer_email)
        : undefined,
      priceId: isSet(object.priceId)
        ? globalThis.String(object.priceId)
        : isSet(object.price_id)
        ? globalThis.String(object.price_id)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      lineItems: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => LineItem.fromJSON(e))
        : globalThis.Array.isArray(object?.line_items)
        ? object.line_items.map((e: any) => LineItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateStripeCheckoutSessionRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.successUrl !== "") {
      obj.successUrl = message.successUrl;
    }
    if (message.cancelUrl !== "") {
      obj.cancelUrl = message.cancelUrl;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.customerEmail !== undefined) {
      obj.customerEmail = message.customerEmail;
    }
    if (message.priceId !== undefined) {
      obj.priceId = message.priceId;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.lineItems?.length) {
      obj.lineItems = message.lineItems.map((e) => LineItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest>, I>>(
    base?: I,
  ): CreateStripeCheckoutSessionRequest {
    return CreateStripeCheckoutSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest>, I>>(
    object: I,
  ): CreateStripeCheckoutSessionRequest {
    const message = createBaseCreateStripeCheckoutSessionRequest();
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.mode = object.mode ?? "";
    message.successUrl = object.successUrl ?? "";
    message.cancelUrl = object.cancelUrl ?? "";
    message.customerId = object.customerId ?? undefined;
    message.customerEmail = object.customerEmail ?? undefined;
    message.priceId = object.priceId ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.lineItems = object.lineItems?.map((e) => LineItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest_MetadataEntry(): CreateStripeCheckoutSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCheckoutSessionRequest_MetadataEntry: MessageFns<
  CreateStripeCheckoutSessionRequest_MetadataEntry
> = {
  encode(
    message: CreateStripeCheckoutSessionRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCheckoutSessionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeCheckoutSessionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeCheckoutSessionRequest_MetadataEntry {
    return CreateStripeCheckoutSessionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeCheckoutSessionRequest_MetadataEntry {
    const message = createBaseCreateStripeCheckoutSessionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLineItem(): LineItem {
  return { name: "", description: "", amount: 0, quantity: 0, currency: "" };
}

export const LineItem: MessageFns<LineItem> = {
  encode(message: LineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: LineItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineItem>, I>>(base?: I): LineItem {
    return LineItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineItem>, I>>(object: I): LineItem {
    const message = createBaseLineItem();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.amount = object.amount ?? 0;
    message.quantity = object.quantity ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseStripeCheckoutSessionResponse(): StripeCheckoutSessionResponse {
  return { id: "", url: "", status: "", paymentStatus: "", customerId: undefined, subscriptionId: undefined };
}

export const StripeCheckoutSessionResponse: MessageFns<StripeCheckoutSessionResponse> = {
  encode(message: StripeCheckoutSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.paymentStatus !== "") {
      writer.uint32(34).string(message.paymentStatus);
    }
    if (message.customerId !== undefined) {
      writer.uint32(42).string(message.customerId);
    }
    if (message.subscriptionId !== undefined) {
      writer.uint32(50).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeCheckoutSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCheckoutSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeCheckoutSessionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      paymentStatus: isSet(object.paymentStatus)
        ? globalThis.String(object.paymentStatus)
        : isSet(object.payment_status)
        ? globalThis.String(object.payment_status)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : undefined,
    };
  },

  toJSON(message: StripeCheckoutSessionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.paymentStatus !== "") {
      obj.paymentStatus = message.paymentStatus;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.subscriptionId !== undefined) {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeCheckoutSessionResponse>, I>>(base?: I): StripeCheckoutSessionResponse {
    return StripeCheckoutSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeCheckoutSessionResponse>, I>>(
    object: I,
  ): StripeCheckoutSessionResponse {
    const message = createBaseStripeCheckoutSessionResponse();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.status = object.status ?? "";
    message.paymentStatus = object.paymentStatus ?? "";
    message.customerId = object.customerId ?? undefined;
    message.subscriptionId = object.subscriptionId ?? undefined;
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest(): CreateStripePaymentIntentRequest {
  return {
    societeId: "",
    amount: 0,
    currency: "",
    customerId: undefined,
    description: undefined,
    paymentMethod: undefined,
    confirm: false,
    automaticPaymentMethods: false,
    metadata: {},
  };
}

export const CreateStripePaymentIntentRequest: MessageFns<CreateStripePaymentIntentRequest> = {
  encode(message: CreateStripePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(50).string(message.paymentMethod);
    }
    if (message.confirm !== false) {
      writer.uint32(56).bool(message.confirm);
    }
    if (message.automaticPaymentMethods !== false) {
      writer.uint32(64).bool(message.automaticPaymentMethods);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.confirm = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.automaticPaymentMethods = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CreateStripePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripePaymentIntentRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
      confirm: isSet(object.confirm) ? globalThis.Boolean(object.confirm) : false,
      automaticPaymentMethods: isSet(object.automaticPaymentMethods)
        ? globalThis.Boolean(object.automaticPaymentMethods)
        : isSet(object.automatic_payment_methods)
        ? globalThis.Boolean(object.automatic_payment_methods)
        : false,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.confirm !== false) {
      obj.confirm = message.confirm;
    }
    if (message.automaticPaymentMethods !== false) {
      obj.automaticPaymentMethods = message.automaticPaymentMethods;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest>, I>>(
    base?: I,
  ): CreateStripePaymentIntentRequest {
    return CreateStripePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest>, I>>(
    object: I,
  ): CreateStripePaymentIntentRequest {
    const message = createBaseCreateStripePaymentIntentRequest();
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.customerId = object.customerId ?? undefined;
    message.description = object.description ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    message.confirm = object.confirm ?? false;
    message.automaticPaymentMethods = object.automaticPaymentMethods ?? false;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest_MetadataEntry(): CreateStripePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripePaymentIntentRequest_MetadataEntry: MessageFns<
  CreateStripePaymentIntentRequest_MetadataEntry
> = {
  encode(
    message: CreateStripePaymentIntentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripePaymentIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripePaymentIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripePaymentIntentRequest_MetadataEntry {
    return CreateStripePaymentIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripePaymentIntentRequest_MetadataEntry {
    const message = createBaseCreateStripePaymentIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripePaymentIntentResponse(): StripePaymentIntentResponse {
  return {
    id: "",
    amount: 0,
    currency: "",
    status: "",
    clientSecret: undefined,
    customerId: undefined,
    paymentMethod: undefined,
  };
}

export const StripePaymentIntentResponse: MessageFns<StripePaymentIntentResponse> = {
  encode(message: StripePaymentIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.clientSecret !== undefined) {
      writer.uint32(42).string(message.clientSecret);
    }
    if (message.customerId !== undefined) {
      writer.uint32(50).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(58).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripePaymentIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripePaymentIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      clientSecret: isSet(object.clientSecret)
        ? globalThis.String(object.clientSecret)
        : isSet(object.client_secret)
        ? globalThis.String(object.client_secret)
        : undefined,
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
    };
  },

  toJSON(message: StripePaymentIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.clientSecret !== undefined) {
      obj.clientSecret = message.clientSecret;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripePaymentIntentResponse>, I>>(base?: I): StripePaymentIntentResponse {
    return StripePaymentIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripePaymentIntentResponse>, I>>(object: I): StripePaymentIntentResponse {
    const message = createBaseStripePaymentIntentResponse();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.clientSecret = object.clientSecret ?? undefined;
    message.customerId = object.customerId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    return message;
  },
};

function createBaseCreateStripeCustomerRequest(): CreateStripeCustomerRequest {
  return { societeId: "", email: "", name: undefined, phone: undefined, description: undefined, metadata: {} };
}

export const CreateStripeCustomerRequest: MessageFns<CreateStripeCustomerRequest> = {
  encode(message: CreateStripeCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeCustomerRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeCustomerRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCustomerRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripeCustomerRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCustomerRequest>, I>>(base?: I): CreateStripeCustomerRequest {
    return CreateStripeCustomerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCustomerRequest>, I>>(object: I): CreateStripeCustomerRequest {
    const message = createBaseCreateStripeCustomerRequest();
    message.societeId = object.societeId ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? undefined;
    message.phone = object.phone ?? undefined;
    message.description = object.description ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripeCustomerRequest_MetadataEntry(): CreateStripeCustomerRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCustomerRequest_MetadataEntry: MessageFns<CreateStripeCustomerRequest_MetadataEntry> = {
  encode(message: CreateStripeCustomerRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCustomerRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCustomerRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeCustomerRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCustomerRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeCustomerRequest_MetadataEntry {
    return CreateStripeCustomerRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCustomerRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeCustomerRequest_MetadataEntry {
    const message = createBaseCreateStripeCustomerRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripeCustomerResponse(): StripeCustomerResponse {
  return { id: "", email: "", name: undefined, phone: undefined, created: 0 };
}

export const StripeCustomerResponse: MessageFns<StripeCustomerResponse> = {
  encode(message: StripeCustomerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.created !== 0) {
      writer.uint32(40).int64(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeCustomerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCustomerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.created = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeCustomerResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      created: isSet(object.created) ? globalThis.Number(object.created) : 0,
    };
  },

  toJSON(message: StripeCustomerResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.created !== 0) {
      obj.created = Math.round(message.created);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeCustomerResponse>, I>>(base?: I): StripeCustomerResponse {
    return StripeCustomerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeCustomerResponse>, I>>(object: I): StripeCustomerResponse {
    const message = createBaseStripeCustomerResponse();
    message.id = object.id ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? undefined;
    message.phone = object.phone ?? undefined;
    message.created = object.created ?? 0;
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest(): CreateStripeSubscriptionRequest {
  return {
    societeId: "",
    customerId: "",
    priceId: "",
    paymentMethod: undefined,
    defaultPaymentMethod: undefined,
    metadata: {},
  };
}

export const CreateStripeSubscriptionRequest: MessageFns<CreateStripeSubscriptionRequest> = {
  encode(message: CreateStripeSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.priceId !== "") {
      writer.uint32(26).string(message.priceId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(34).string(message.paymentMethod);
    }
    if (message.defaultPaymentMethod !== undefined) {
      writer.uint32(42).string(message.defaultPaymentMethod);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultPaymentMethod = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSubscriptionRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      priceId: isSet(object.priceId)
        ? globalThis.String(object.priceId)
        : isSet(object.price_id)
        ? globalThis.String(object.price_id)
        : "",
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
      defaultPaymentMethod: isSet(object.defaultPaymentMethod)
        ? globalThis.String(object.defaultPaymentMethod)
        : isSet(object.default_payment_method)
        ? globalThis.String(object.default_payment_method)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripeSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.priceId !== "") {
      obj.priceId = message.priceId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.defaultPaymentMethod !== undefined) {
      obj.defaultPaymentMethod = message.defaultPaymentMethod;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest>, I>>(base?: I): CreateStripeSubscriptionRequest {
    return CreateStripeSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest>, I>>(
    object: I,
  ): CreateStripeSubscriptionRequest {
    const message = createBaseCreateStripeSubscriptionRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.priceId = object.priceId ?? "";
    message.paymentMethod = object.paymentMethod ?? undefined;
    message.defaultPaymentMethod = object.defaultPaymentMethod ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest_MetadataEntry(): CreateStripeSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSubscriptionRequest_MetadataEntry: MessageFns<CreateStripeSubscriptionRequest_MetadataEntry> =
  {
    encode(
      message: CreateStripeSubscriptionRequest_MetadataEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSubscriptionRequest_MetadataEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateStripeSubscriptionRequest_MetadataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateStripeSubscriptionRequest_MetadataEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: CreateStripeSubscriptionRequest_MetadataEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest_MetadataEntry>, I>>(
      base?: I,
    ): CreateStripeSubscriptionRequest_MetadataEntry {
      return CreateStripeSubscriptionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest_MetadataEntry>, I>>(
      object: I,
    ): CreateStripeSubscriptionRequest_MetadataEntry {
      const message = createBaseCreateStripeSubscriptionRequest_MetadataEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseStripeSubscriptionResponse(): StripeSubscriptionResponse {
  return { id: "", customerId: "", status: "", currentPeriodStart: 0, currentPeriodEnd: 0, cancelAtPeriodEnd: false };
}

export const StripeSubscriptionResponse: MessageFns<StripeSubscriptionResponse> = {
  encode(message: StripeSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.currentPeriodStart !== 0) {
      writer.uint32(32).int64(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== 0) {
      writer.uint32(40).int64(message.currentPeriodEnd);
    }
    if (message.cancelAtPeriodEnd !== false) {
      writer.uint32(48).bool(message.cancelAtPeriodEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currentPeriodStart = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.currentPeriodEnd = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeSubscriptionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      currentPeriodStart: isSet(object.currentPeriodStart)
        ? globalThis.Number(object.currentPeriodStart)
        : isSet(object.current_period_start)
        ? globalThis.Number(object.current_period_start)
        : 0,
      currentPeriodEnd: isSet(object.currentPeriodEnd)
        ? globalThis.Number(object.currentPeriodEnd)
        : isSet(object.current_period_end)
        ? globalThis.Number(object.current_period_end)
        : 0,
      cancelAtPeriodEnd: isSet(object.cancelAtPeriodEnd)
        ? globalThis.Boolean(object.cancelAtPeriodEnd)
        : isSet(object.cancel_at_period_end)
        ? globalThis.Boolean(object.cancel_at_period_end)
        : false,
    };
  },

  toJSON(message: StripeSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.currentPeriodStart !== 0) {
      obj.currentPeriodStart = Math.round(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== 0) {
      obj.currentPeriodEnd = Math.round(message.currentPeriodEnd);
    }
    if (message.cancelAtPeriodEnd !== false) {
      obj.cancelAtPeriodEnd = message.cancelAtPeriodEnd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeSubscriptionResponse>, I>>(base?: I): StripeSubscriptionResponse {
    return StripeSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeSubscriptionResponse>, I>>(object: I): StripeSubscriptionResponse {
    const message = createBaseStripeSubscriptionResponse();
    message.id = object.id ?? "";
    message.customerId = object.customerId ?? "";
    message.status = object.status ?? "";
    message.currentPeriodStart = object.currentPeriodStart ?? 0;
    message.currentPeriodEnd = object.currentPeriodEnd ?? 0;
    message.cancelAtPeriodEnd = object.cancelAtPeriodEnd ?? false;
    return message;
  },
};

function createBaseCreateStripeRefundRequest(): CreateStripeRefundRequest {
  return { societeId: "", paymentIntentId: "", amount: undefined, reason: undefined };
}

export const CreateStripeRefundRequest: MessageFns<CreateStripeRefundRequest> = {
  encode(message: CreateStripeRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.amount !== undefined) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeRefundRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: CreateStripeRefundRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeRefundRequest>, I>>(base?: I): CreateStripeRefundRequest {
    return CreateStripeRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeRefundRequest>, I>>(object: I): CreateStripeRefundRequest {
    const message = createBaseCreateStripeRefundRequest();
    message.societeId = object.societeId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.amount = object.amount ?? undefined;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseStripeRefundResponse(): StripeRefundResponse {
  return { id: "", amount: 0, currency: "", status: "", paymentIntentId: "" };
}

export const StripeRefundResponse: MessageFns<StripeRefundResponse> = {
  encode(message: StripeRefundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(42).string(message.paymentIntentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeRefundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeRefundResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
    };
  },

  toJSON(message: StripeRefundResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeRefundResponse>, I>>(base?: I): StripeRefundResponse {
    return StripeRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeRefundResponse>, I>>(object: I): StripeRefundResponse {
    const message = createBaseStripeRefundResponse();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest(): CreateStripeSetupIntentRequest {
  return { societeId: "", customerId: undefined, paymentMethodTypes: [], metadata: {} };
}

export const CreateStripeSetupIntentRequest: MessageFns<CreateStripeSetupIntentRequest> = {
  encode(message: CreateStripeSetupIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== undefined) {
      writer.uint32(18).string(message.customerId);
    }
    for (const v of message.paymentMethodTypes) {
      writer.uint32(26).string(v!);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeSetupIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSetupIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentMethodTypes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateStripeSetupIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSetupIntentRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      paymentMethodTypes: globalThis.Array.isArray(object?.paymentMethodTypes)
        ? object.paymentMethodTypes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.payment_method_types)
        ? object.payment_method_types.map((e: any) => globalThis.String(e))
        : [],
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripeSetupIntentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethodTypes?.length) {
      obj.paymentMethodTypes = message.paymentMethodTypes;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest>, I>>(base?: I): CreateStripeSetupIntentRequest {
    return CreateStripeSetupIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest>, I>>(
    object: I,
  ): CreateStripeSetupIntentRequest {
    const message = createBaseCreateStripeSetupIntentRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? undefined;
    message.paymentMethodTypes = object.paymentMethodTypes?.map((e) => e) || [];
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest_MetadataEntry(): CreateStripeSetupIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSetupIntentRequest_MetadataEntry: MessageFns<CreateStripeSetupIntentRequest_MetadataEntry> = {
  encode(
    message: CreateStripeSetupIntentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSetupIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSetupIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeSetupIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeSetupIntentRequest_MetadataEntry {
    return CreateStripeSetupIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeSetupIntentRequest_MetadataEntry {
    const message = createBaseCreateStripeSetupIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripeSetupIntentResponse(): StripeSetupIntentResponse {
  return { id: "", clientSecret: "", status: "", customerId: undefined, paymentMethod: undefined };
}

export const StripeSetupIntentResponse: MessageFns<StripeSetupIntentResponse> = {
  encode(message: StripeSetupIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(42).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeSetupIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSetupIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeSetupIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clientSecret: isSet(object.clientSecret)
        ? globalThis.String(object.clientSecret)
        : isSet(object.client_secret)
        ? globalThis.String(object.client_secret)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
    };
  },

  toJSON(message: StripeSetupIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeSetupIntentResponse>, I>>(base?: I): StripeSetupIntentResponse {
    return StripeSetupIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeSetupIntentResponse>, I>>(object: I): StripeSetupIntentResponse {
    const message = createBaseStripeSetupIntentResponse();
    message.id = object.id ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.status = object.status ?? "";
    message.customerId = object.customerId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    return message;
  },
};

function createBaseCreateStripeBillingPortalRequest(): CreateStripeBillingPortalRequest {
  return { societeId: "", customerId: "", returnUrl: "" };
}

export const CreateStripeBillingPortalRequest: MessageFns<CreateStripeBillingPortalRequest> = {
  encode(message: CreateStripeBillingPortalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.returnUrl !== "") {
      writer.uint32(26).string(message.returnUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeBillingPortalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeBillingPortalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeBillingPortalRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      returnUrl: isSet(object.returnUrl)
        ? globalThis.String(object.returnUrl)
        : isSet(object.return_url)
        ? globalThis.String(object.return_url)
        : "",
    };
  },

  toJSON(message: CreateStripeBillingPortalRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.returnUrl !== "") {
      obj.returnUrl = message.returnUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeBillingPortalRequest>, I>>(
    base?: I,
  ): CreateStripeBillingPortalRequest {
    return CreateStripeBillingPortalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeBillingPortalRequest>, I>>(
    object: I,
  ): CreateStripeBillingPortalRequest {
    const message = createBaseCreateStripeBillingPortalRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.returnUrl = object.returnUrl ?? "";
    return message;
  },
};

function createBaseStripeBillingPortalResponse(): StripeBillingPortalResponse {
  return { id: "", url: "" };
}

export const StripeBillingPortalResponse: MessageFns<StripeBillingPortalResponse> = {
  encode(message: StripeBillingPortalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeBillingPortalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeBillingPortalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeBillingPortalResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: StripeBillingPortalResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeBillingPortalResponse>, I>>(base?: I): StripeBillingPortalResponse {
    return StripeBillingPortalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeBillingPortalResponse>, I>>(object: I): StripeBillingPortalResponse {
    const message = createBaseStripeBillingPortalResponse();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseCreatePayPalOrderRequest(): CreatePayPalOrderRequest {
  return { societeId: "", intent: "", purchaseUnits: [], returnUrl: "", cancelUrl: "", metadata: {} };
}

export const CreatePayPalOrderRequest: MessageFns<CreatePayPalOrderRequest> = {
  encode(message: CreatePayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.intent !== "") {
      writer.uint32(18).string(message.intent);
    }
    for (const v of message.purchaseUnits) {
      PayPalPurchaseUnit.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.returnUrl !== "") {
      writer.uint32(34).string(message.returnUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(42).string(message.cancelUrl);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePayPalOrderRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.purchaseUnits.push(PayPalPurchaseUnit.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreatePayPalOrderRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePayPalOrderRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      purchaseUnits: globalThis.Array.isArray(object?.purchaseUnits)
        ? object.purchaseUnits.map((e: any) => PayPalPurchaseUnit.fromJSON(e))
        : globalThis.Array.isArray(object?.purchase_units)
        ? object.purchase_units.map((e: any) => PayPalPurchaseUnit.fromJSON(e))
        : [],
      returnUrl: isSet(object.returnUrl)
        ? globalThis.String(object.returnUrl)
        : isSet(object.return_url)
        ? globalThis.String(object.return_url)
        : "",
      cancelUrl: isSet(object.cancelUrl)
        ? globalThis.String(object.cancelUrl)
        : isSet(object.cancel_url)
        ? globalThis.String(object.cancel_url)
        : "",
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreatePayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.purchaseUnits?.length) {
      obj.purchaseUnits = message.purchaseUnits.map((e) => PayPalPurchaseUnit.toJSON(e));
    }
    if (message.returnUrl !== "") {
      obj.returnUrl = message.returnUrl;
    }
    if (message.cancelUrl !== "") {
      obj.cancelUrl = message.cancelUrl;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePayPalOrderRequest>, I>>(base?: I): CreatePayPalOrderRequest {
    return CreatePayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePayPalOrderRequest>, I>>(object: I): CreatePayPalOrderRequest {
    const message = createBaseCreatePayPalOrderRequest();
    message.societeId = object.societeId ?? "";
    message.intent = object.intent ?? "";
    message.purchaseUnits = object.purchaseUnits?.map((e) => PayPalPurchaseUnit.fromPartial(e)) || [];
    message.returnUrl = object.returnUrl ?? "";
    message.cancelUrl = object.cancelUrl ?? "";
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePayPalOrderRequest_MetadataEntry(): CreatePayPalOrderRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePayPalOrderRequest_MetadataEntry: MessageFns<CreatePayPalOrderRequest_MetadataEntry> = {
  encode(message: CreatePayPalOrderRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePayPalOrderRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePayPalOrderRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePayPalOrderRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePayPalOrderRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePayPalOrderRequest_MetadataEntry {
    return CreatePayPalOrderRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePayPalOrderRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePayPalOrderRequest_MetadataEntry {
    const message = createBaseCreatePayPalOrderRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePayPalPurchaseUnit(): PayPalPurchaseUnit {
  return {
    referenceId: undefined,
    amount: 0,
    currency: "",
    description: undefined,
    customId: undefined,
    invoiceId: undefined,
  };
}

export const PayPalPurchaseUnit: MessageFns<PayPalPurchaseUnit> = {
  encode(message: PayPalPurchaseUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.customId !== undefined) {
      writer.uint32(42).string(message.customId);
    }
    if (message.invoiceId !== undefined) {
      writer.uint32(50).string(message.invoiceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalPurchaseUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalPurchaseUnit {
    return {
      referenceId: isSet(object.referenceId)
        ? globalThis.String(object.referenceId)
        : isSet(object.reference_id)
        ? globalThis.String(object.reference_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      customId: isSet(object.customId)
        ? globalThis.String(object.customId)
        : isSet(object.custom_id)
        ? globalThis.String(object.custom_id)
        : undefined,
      invoiceId: isSet(object.invoiceId)
        ? globalThis.String(object.invoiceId)
        : isSet(object.invoice_id)
        ? globalThis.String(object.invoice_id)
        : undefined,
    };
  },

  toJSON(message: PayPalPurchaseUnit): unknown {
    const obj: any = {};
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.customId !== undefined) {
      obj.customId = message.customId;
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = message.invoiceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalPurchaseUnit>, I>>(base?: I): PayPalPurchaseUnit {
    return PayPalPurchaseUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalPurchaseUnit>, I>>(object: I): PayPalPurchaseUnit {
    const message = createBasePayPalPurchaseUnit();
    message.referenceId = object.referenceId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.customId = object.customId ?? undefined;
    message.invoiceId = object.invoiceId ?? undefined;
    return message;
  },
};

function createBasePayPalOrderResponse(): PayPalOrderResponse {
  return { id: "", status: "", approveUrl: undefined, captureUrl: undefined, links: [] };
}

export const PayPalOrderResponse: MessageFns<PayPalOrderResponse> = {
  encode(message: PayPalOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.approveUrl !== undefined) {
      writer.uint32(26).string(message.approveUrl);
    }
    if (message.captureUrl !== undefined) {
      writer.uint32(34).string(message.captureUrl);
    }
    for (const v of message.links) {
      PayPalLink.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.approveUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.captureUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.links.push(PayPalLink.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalOrderResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      approveUrl: isSet(object.approveUrl)
        ? globalThis.String(object.approveUrl)
        : isSet(object.approve_url)
        ? globalThis.String(object.approve_url)
        : undefined,
      captureUrl: isSet(object.captureUrl)
        ? globalThis.String(object.captureUrl)
        : isSet(object.capture_url)
        ? globalThis.String(object.capture_url)
        : undefined,
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => PayPalLink.fromJSON(e)) : [],
    };
  },

  toJSON(message: PayPalOrderResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.approveUrl !== undefined) {
      obj.approveUrl = message.approveUrl;
    }
    if (message.captureUrl !== undefined) {
      obj.captureUrl = message.captureUrl;
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => PayPalLink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalOrderResponse>, I>>(base?: I): PayPalOrderResponse {
    return PayPalOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalOrderResponse>, I>>(object: I): PayPalOrderResponse {
    const message = createBasePayPalOrderResponse();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.approveUrl = object.approveUrl ?? undefined;
    message.captureUrl = object.captureUrl ?? undefined;
    message.links = object.links?.map((e) => PayPalLink.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalLink(): PayPalLink {
  return { href: "", rel: "", method: "" };
}

export const PayPalLink: MessageFns<PayPalLink> = {
  encode(message: PayPalLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.href !== "") {
      writer.uint32(10).string(message.href);
    }
    if (message.rel !== "") {
      writer.uint32(18).string(message.rel);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.href = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalLink {
    return {
      href: isSet(object.href) ? globalThis.String(object.href) : "",
      rel: isSet(object.rel) ? globalThis.String(object.rel) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
    };
  },

  toJSON(message: PayPalLink): unknown {
    const obj: any = {};
    if (message.href !== "") {
      obj.href = message.href;
    }
    if (message.rel !== "") {
      obj.rel = message.rel;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalLink>, I>>(base?: I): PayPalLink {
    return PayPalLink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalLink>, I>>(object: I): PayPalLink {
    const message = createBasePayPalLink();
    message.href = object.href ?? "";
    message.rel = object.rel ?? "";
    message.method = object.method ?? "";
    return message;
  },
};

function createBaseGetPayPalOrderRequest(): GetPayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const GetPayPalOrderRequest: MessageFns<GetPayPalOrderRequest> = {
  encode(message: GetPayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPayPalOrderRequest {
    return {
      orderId: isSet(object.orderId)
        ? globalThis.String(object.orderId)
        : isSet(object.order_id)
        ? globalThis.String(object.order_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetPayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPayPalOrderRequest>, I>>(base?: I): GetPayPalOrderRequest {
    return GetPayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPayPalOrderRequest>, I>>(object: I): GetPayPalOrderRequest {
    const message = createBaseGetPayPalOrderRequest();
    message.orderId = object.orderId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCapturePayPalOrderRequest(): CapturePayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const CapturePayPalOrderRequest: MessageFns<CapturePayPalOrderRequest> = {
  encode(message: CapturePayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapturePayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapturePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapturePayPalOrderRequest {
    return {
      orderId: isSet(object.orderId)
        ? globalThis.String(object.orderId)
        : isSet(object.order_id)
        ? globalThis.String(object.order_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: CapturePayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CapturePayPalOrderRequest>, I>>(base?: I): CapturePayPalOrderRequest {
    return CapturePayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CapturePayPalOrderRequest>, I>>(object: I): CapturePayPalOrderRequest {
    const message = createBaseCapturePayPalOrderRequest();
    message.orderId = object.orderId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBasePayPalCaptureResponse(): PayPalCaptureResponse {
  return { id: "", status: "", payer: undefined, purchaseUnits: [] };
}

export const PayPalCaptureResponse: MessageFns<PayPalCaptureResponse> = {
  encode(message: PayPalCaptureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.payer !== undefined) {
      PayPalPayer.encode(message.payer, writer.uint32(26).fork()).join();
    }
    for (const v of message.purchaseUnits) {
      PayPalCapturedPurchaseUnit.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCaptureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCaptureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payer = PayPalPayer.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.purchaseUnits.push(PayPalCapturedPurchaseUnit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCaptureResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      payer: isSet(object.payer) ? PayPalPayer.fromJSON(object.payer) : undefined,
      purchaseUnits: globalThis.Array.isArray(object?.purchaseUnits)
        ? object.purchaseUnits.map((e: any) => PayPalCapturedPurchaseUnit.fromJSON(e))
        : globalThis.Array.isArray(object?.purchase_units)
        ? object.purchase_units.map((e: any) => PayPalCapturedPurchaseUnit.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PayPalCaptureResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.payer !== undefined) {
      obj.payer = PayPalPayer.toJSON(message.payer);
    }
    if (message.purchaseUnits?.length) {
      obj.purchaseUnits = message.purchaseUnits.map((e) => PayPalCapturedPurchaseUnit.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCaptureResponse>, I>>(base?: I): PayPalCaptureResponse {
    return PayPalCaptureResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCaptureResponse>, I>>(object: I): PayPalCaptureResponse {
    const message = createBasePayPalCaptureResponse();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.payer = (object.payer !== undefined && object.payer !== null)
      ? PayPalPayer.fromPartial(object.payer)
      : undefined;
    message.purchaseUnits = object.purchaseUnits?.map((e) => PayPalCapturedPurchaseUnit.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalPayer(): PayPalPayer {
  return { emailAddress: undefined, payerId: undefined, givenName: undefined, surname: undefined };
}

export const PayPalPayer: MessageFns<PayPalPayer> = {
  encode(message: PayPalPayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailAddress !== undefined) {
      writer.uint32(10).string(message.emailAddress);
    }
    if (message.payerId !== undefined) {
      writer.uint32(18).string(message.payerId);
    }
    if (message.givenName !== undefined) {
      writer.uint32(26).string(message.givenName);
    }
    if (message.surname !== undefined) {
      writer.uint32(34).string(message.surname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalPayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.givenName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.surname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalPayer {
    return {
      emailAddress: isSet(object.emailAddress)
        ? globalThis.String(object.emailAddress)
        : isSet(object.email_address)
        ? globalThis.String(object.email_address)
        : undefined,
      payerId: isSet(object.payerId)
        ? globalThis.String(object.payerId)
        : isSet(object.payer_id)
        ? globalThis.String(object.payer_id)
        : undefined,
      givenName: isSet(object.givenName)
        ? globalThis.String(object.givenName)
        : isSet(object.given_name)
        ? globalThis.String(object.given_name)
        : undefined,
      surname: isSet(object.surname) ? globalThis.String(object.surname) : undefined,
    };
  },

  toJSON(message: PayPalPayer): unknown {
    const obj: any = {};
    if (message.emailAddress !== undefined) {
      obj.emailAddress = message.emailAddress;
    }
    if (message.payerId !== undefined) {
      obj.payerId = message.payerId;
    }
    if (message.givenName !== undefined) {
      obj.givenName = message.givenName;
    }
    if (message.surname !== undefined) {
      obj.surname = message.surname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalPayer>, I>>(base?: I): PayPalPayer {
    return PayPalPayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalPayer>, I>>(object: I): PayPalPayer {
    const message = createBasePayPalPayer();
    message.emailAddress = object.emailAddress ?? undefined;
    message.payerId = object.payerId ?? undefined;
    message.givenName = object.givenName ?? undefined;
    message.surname = object.surname ?? undefined;
    return message;
  },
};

function createBasePayPalCapturedPurchaseUnit(): PayPalCapturedPurchaseUnit {
  return { referenceId: undefined, captures: [] };
}

export const PayPalCapturedPurchaseUnit: MessageFns<PayPalCapturedPurchaseUnit> = {
  encode(message: PayPalCapturedPurchaseUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    for (const v of message.captures) {
      PayPalCapture.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCapturedPurchaseUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapturedPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.captures.push(PayPalCapture.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCapturedPurchaseUnit {
    return {
      referenceId: isSet(object.referenceId)
        ? globalThis.String(object.referenceId)
        : isSet(object.reference_id)
        ? globalThis.String(object.reference_id)
        : undefined,
      captures: globalThis.Array.isArray(object?.captures)
        ? object.captures.map((e: any) => PayPalCapture.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PayPalCapturedPurchaseUnit): unknown {
    const obj: any = {};
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.captures?.length) {
      obj.captures = message.captures.map((e) => PayPalCapture.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCapturedPurchaseUnit>, I>>(base?: I): PayPalCapturedPurchaseUnit {
    return PayPalCapturedPurchaseUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCapturedPurchaseUnit>, I>>(object: I): PayPalCapturedPurchaseUnit {
    const message = createBasePayPalCapturedPurchaseUnit();
    message.referenceId = object.referenceId ?? undefined;
    message.captures = object.captures?.map((e) => PayPalCapture.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalCapture(): PayPalCapture {
  return { id: "", status: "", amount: undefined };
}

export const PayPalCapture: MessageFns<PayPalCapture> = {
  encode(message: PayPalCapture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.amount !== undefined) {
      PayPalAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCapture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = PayPalAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCapture {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      amount: isSet(object.amount) ? PayPalAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: PayPalCapture): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.amount !== undefined) {
      obj.amount = PayPalAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCapture>, I>>(base?: I): PayPalCapture {
    return PayPalCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCapture>, I>>(object: I): PayPalCapture {
    const message = createBasePayPalCapture();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? PayPalAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBasePayPalAmount(): PayPalAmount {
  return { currencyCode: "", value: "" };
}

export const PayPalAmount: MessageFns<PayPalAmount> = {
  encode(message: PayPalAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalAmount {
    return {
      currencyCode: isSet(object.currencyCode)
        ? globalThis.String(object.currencyCode)
        : isSet(object.currency_code)
        ? globalThis.String(object.currency_code)
        : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PayPalAmount): unknown {
    const obj: any = {};
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalAmount>, I>>(base?: I): PayPalAmount {
    return PayPalAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalAmount>, I>>(object: I): PayPalAmount {
    const message = createBasePayPalAmount();
    message.currencyCode = object.currencyCode ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetupGoCardlessMandateRequest(): SetupGoCardlessMandateRequest {
  return {
    clientId: "",
    societeId: "",
    scheme: "",
    description: undefined,
    successRedirectUrl: "",
    sessionToken: undefined,
  };
}

export const SetupGoCardlessMandateRequest: MessageFns<SetupGoCardlessMandateRequest> = {
  encode(message: SetupGoCardlessMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheme !== "") {
      writer.uint32(26).string(message.scheme);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.successRedirectUrl !== "") {
      writer.uint32(42).string(message.successRedirectUrl);
    }
    if (message.sessionToken !== undefined) {
      writer.uint32(50).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupGoCardlessMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.successRedirectUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupGoCardlessMandateRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      successRedirectUrl: isSet(object.successRedirectUrl)
        ? globalThis.String(object.successRedirectUrl)
        : isSet(object.success_redirect_url)
        ? globalThis.String(object.success_redirect_url)
        : "",
      sessionToken: isSet(object.sessionToken)
        ? globalThis.String(object.sessionToken)
        : isSet(object.session_token)
        ? globalThis.String(object.session_token)
        : undefined,
    };
  },

  toJSON(message: SetupGoCardlessMandateRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.successRedirectUrl !== "") {
      obj.successRedirectUrl = message.successRedirectUrl;
    }
    if (message.sessionToken !== undefined) {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetupGoCardlessMandateRequest>, I>>(base?: I): SetupGoCardlessMandateRequest {
    return SetupGoCardlessMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetupGoCardlessMandateRequest>, I>>(
    object: I,
  ): SetupGoCardlessMandateRequest {
    const message = createBaseSetupGoCardlessMandateRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheme = object.scheme ?? "";
    message.description = object.description ?? undefined;
    message.successRedirectUrl = object.successRedirectUrl ?? "";
    message.sessionToken = object.sessionToken ?? undefined;
    return message;
  },
};

function createBaseGoCardlessMandateResponse(): GoCardlessMandateResponse {
  return {
    id: "",
    clientId: "",
    mandateId: "",
    status: "",
    scheme: "",
    bankName: undefined,
    accountHolderName: undefined,
    accountNumberEnding: undefined,
    redirectUrl: undefined,
  };
}

export const GoCardlessMandateResponse: MessageFns<GoCardlessMandateResponse> = {
  encode(message: GoCardlessMandateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.mandateId !== "") {
      writer.uint32(26).string(message.mandateId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.scheme !== "") {
      writer.uint32(42).string(message.scheme);
    }
    if (message.bankName !== undefined) {
      writer.uint32(50).string(message.bankName);
    }
    if (message.accountHolderName !== undefined) {
      writer.uint32(58).string(message.accountHolderName);
    }
    if (message.accountNumberEnding !== undefined) {
      writer.uint32(66).string(message.accountNumberEnding);
    }
    if (message.redirectUrl !== undefined) {
      writer.uint32(74).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessMandateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessMandateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accountHolderName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.accountNumberEnding = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessMandateResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      bankName: isSet(object.bankName)
        ? globalThis.String(object.bankName)
        : isSet(object.bank_name)
        ? globalThis.String(object.bank_name)
        : undefined,
      accountHolderName: isSet(object.accountHolderName)
        ? globalThis.String(object.accountHolderName)
        : isSet(object.account_holder_name)
        ? globalThis.String(object.account_holder_name)
        : undefined,
      accountNumberEnding: isSet(object.accountNumberEnding)
        ? globalThis.String(object.accountNumberEnding)
        : isSet(object.account_number_ending)
        ? globalThis.String(object.account_number_ending)
        : undefined,
      redirectUrl: isSet(object.redirectUrl)
        ? globalThis.String(object.redirectUrl)
        : isSet(object.redirect_url)
        ? globalThis.String(object.redirect_url)
        : undefined,
    };
  },

  toJSON(message: GoCardlessMandateResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.bankName !== undefined) {
      obj.bankName = message.bankName;
    }
    if (message.accountHolderName !== undefined) {
      obj.accountHolderName = message.accountHolderName;
    }
    if (message.accountNumberEnding !== undefined) {
      obj.accountNumberEnding = message.accountNumberEnding;
    }
    if (message.redirectUrl !== undefined) {
      obj.redirectUrl = message.redirectUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessMandateResponse>, I>>(base?: I): GoCardlessMandateResponse {
    return GoCardlessMandateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessMandateResponse>, I>>(object: I): GoCardlessMandateResponse {
    const message = createBaseGoCardlessMandateResponse();
    message.id = object.id ?? "";
    message.clientId = object.clientId ?? "";
    message.mandateId = object.mandateId ?? "";
    message.status = object.status ?? "";
    message.scheme = object.scheme ?? "";
    message.bankName = object.bankName ?? undefined;
    message.accountHolderName = object.accountHolderName ?? undefined;
    message.accountNumberEnding = object.accountNumberEnding ?? undefined;
    message.redirectUrl = object.redirectUrl ?? undefined;
    return message;
  },
};

function createBaseGetGoCardlessMandateRequest(): GetGoCardlessMandateRequest {
  return { clientId: "", societeId: "" };
}

export const GetGoCardlessMandateRequest: MessageFns<GetGoCardlessMandateRequest> = {
  encode(message: GetGoCardlessMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGoCardlessMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGoCardlessMandateRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetGoCardlessMandateRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGoCardlessMandateRequest>, I>>(base?: I): GetGoCardlessMandateRequest {
    return GetGoCardlessMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGoCardlessMandateRequest>, I>>(object: I): GetGoCardlessMandateRequest {
    const message = createBaseGetGoCardlessMandateRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest(): CreateGoCardlessPaymentRequest {
  return {
    clientId: "",
    societeId: "",
    amount: 0,
    currency: "",
    description: undefined,
    chargeDate: undefined,
    metadata: {},
  };
}

export const CreateGoCardlessPaymentRequest: MessageFns<CreateGoCardlessPaymentRequest> = {
  encode(message: CreateGoCardlessPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateGoCardlessPaymentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = CreateGoCardlessPaymentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessPaymentRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      chargeDate: isSet(object.chargeDate)
        ? globalThis.String(object.chargeDate)
        : isSet(object.charge_date)
        ? globalThis.String(object.charge_date)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateGoCardlessPaymentRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.chargeDate !== undefined) {
      obj.chargeDate = message.chargeDate;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest>, I>>(base?: I): CreateGoCardlessPaymentRequest {
    return CreateGoCardlessPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest>, I>>(
    object: I,
  ): CreateGoCardlessPaymentRequest {
    const message = createBaseCreateGoCardlessPaymentRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.chargeDate = object.chargeDate ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest_MetadataEntry(): CreateGoCardlessPaymentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessPaymentRequest_MetadataEntry: MessageFns<CreateGoCardlessPaymentRequest_MetadataEntry> = {
  encode(
    message: CreateGoCardlessPaymentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessPaymentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateGoCardlessPaymentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateGoCardlessPaymentRequest_MetadataEntry {
    return CreateGoCardlessPaymentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateGoCardlessPaymentRequest_MetadataEntry {
    const message = createBaseCreateGoCardlessPaymentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGoCardlessPaymentResponse(): GoCardlessPaymentResponse {
  return { id: "", paymentId: "", amount: 0, currency: "", status: "", chargeDate: undefined };
}

export const GoCardlessPaymentResponse: MessageFns<GoCardlessPaymentResponse> = {
  encode(message: GoCardlessPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessPaymentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      chargeDate: isSet(object.chargeDate)
        ? globalThis.String(object.chargeDate)
        : isSet(object.charge_date)
        ? globalThis.String(object.charge_date)
        : undefined,
    };
  },

  toJSON(message: GoCardlessPaymentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.chargeDate !== undefined) {
      obj.chargeDate = message.chargeDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessPaymentResponse>, I>>(base?: I): GoCardlessPaymentResponse {
    return GoCardlessPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessPaymentResponse>, I>>(object: I): GoCardlessPaymentResponse {
    const message = createBaseGoCardlessPaymentResponse();
    message.id = object.id ?? "";
    message.paymentId = object.paymentId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.chargeDate = object.chargeDate ?? undefined;
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest(): CreateGoCardlessSubscriptionRequest {
  return {
    clientId: "",
    societeId: "",
    amount: 0,
    currency: "",
    intervalUnit: "",
    interval: 0,
    name: undefined,
    startDate: undefined,
    count: undefined,
    metadata: {},
  };
}

export const CreateGoCardlessSubscriptionRequest: MessageFns<CreateGoCardlessSubscriptionRequest> = {
  encode(message: CreateGoCardlessSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(42).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(48).int32(message.interval);
    }
    if (message.name !== undefined) {
      writer.uint32(58).string(message.name);
    }
    if (message.startDate !== undefined) {
      writer.uint32(66).string(message.startDate);
    }
    if (message.count !== undefined) {
      writer.uint32(72).int32(message.count);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateGoCardlessSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.interval = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateGoCardlessSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessSubscriptionRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      intervalUnit: isSet(object.intervalUnit)
        ? globalThis.String(object.intervalUnit)
        : isSet(object.interval_unit)
        ? globalThis.String(object.interval_unit)
        : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : undefined,
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateGoCardlessSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.intervalUnit !== "") {
      obj.intervalUnit = message.intervalUnit;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest>, I>>(
    base?: I,
  ): CreateGoCardlessSubscriptionRequest {
    return CreateGoCardlessSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest>, I>>(
    object: I,
  ): CreateGoCardlessSubscriptionRequest {
    const message = createBaseCreateGoCardlessSubscriptionRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.intervalUnit = object.intervalUnit ?? "";
    message.interval = object.interval ?? 0;
    message.name = object.name ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.count = object.count ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry(): CreateGoCardlessSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessSubscriptionRequest_MetadataEntry: MessageFns<
  CreateGoCardlessSubscriptionRequest_MetadataEntry
> = {
  encode(
    message: CreateGoCardlessSubscriptionRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateGoCardlessSubscriptionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    return CreateGoCardlessSubscriptionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    const message = createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGoCardlessSubscriptionResponse(): GoCardlessSubscriptionResponse {
  return {
    id: "",
    subscriptionId: "",
    amount: 0,
    currency: "",
    status: "",
    intervalUnit: "",
    interval: 0,
    nextPaymentDate: undefined,
  };
}

export const GoCardlessSubscriptionResponse: MessageFns<GoCardlessSubscriptionResponse> = {
  encode(message: GoCardlessSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(50).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(56).int32(message.interval);
    }
    if (message.nextPaymentDate !== undefined) {
      writer.uint32(66).string(message.nextPaymentDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.interval = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nextPaymentDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessSubscriptionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      intervalUnit: isSet(object.intervalUnit)
        ? globalThis.String(object.intervalUnit)
        : isSet(object.interval_unit)
        ? globalThis.String(object.interval_unit)
        : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      nextPaymentDate: isSet(object.nextPaymentDate)
        ? globalThis.String(object.nextPaymentDate)
        : isSet(object.next_payment_date)
        ? globalThis.String(object.next_payment_date)
        : undefined,
    };
  },

  toJSON(message: GoCardlessSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.intervalUnit !== "") {
      obj.intervalUnit = message.intervalUnit;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.nextPaymentDate !== undefined) {
      obj.nextPaymentDate = message.nextPaymentDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessSubscriptionResponse>, I>>(base?: I): GoCardlessSubscriptionResponse {
    return GoCardlessSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessSubscriptionResponse>, I>>(
    object: I,
  ): GoCardlessSubscriptionResponse {
    const message = createBaseGoCardlessSubscriptionResponse();
    message.id = object.id ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.intervalUnit = object.intervalUnit ?? "";
    message.interval = object.interval ?? 0;
    message.nextPaymentDate = object.nextPaymentDate ?? undefined;
    return message;
  },
};

function createBaseCancelGoCardlessSubscriptionRequest(): CancelGoCardlessSubscriptionRequest {
  return { subscriptionId: "", societeId: "" };
}

export const CancelGoCardlessSubscriptionRequest: MessageFns<CancelGoCardlessSubscriptionRequest> = {
  encode(message: CancelGoCardlessSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelGoCardlessSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelGoCardlessSubscriptionRequest {
    return {
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: CancelGoCardlessSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelGoCardlessSubscriptionRequest>, I>>(
    base?: I,
  ): CancelGoCardlessSubscriptionRequest {
    return CancelGoCardlessSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelGoCardlessSubscriptionRequest>, I>>(
    object: I,
  ): CancelGoCardlessSubscriptionRequest {
    const message = createBaseCancelGoCardlessSubscriptionRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateScheduleRequest(): CreateScheduleRequest {
  return {
    organisationId: "",
    societeId: "",
    contratId: undefined,
    factureId: undefined,
    clientId: undefined,
    amount: 0,
    currency: "",
    dueDate: "",
    description: undefined,
    autoProcess: false,
    metadata: {},
  };
}

export const CreateScheduleRequest: MessageFns<CreateScheduleRequest> = {
  encode(message: CreateScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(26).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(34).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(42).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(48).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(66).string(message.dueDate);
    }
    if (message.description !== undefined) {
      writer.uint32(74).string(message.description);
    }
    if (message.autoProcess !== false) {
      writer.uint32(80).bool(message.autoProcess);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateScheduleRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = CreateScheduleRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.metadata[entry11.key] = entry11.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateScheduleRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : undefined,
      factureId: isSet(object.factureId)
        ? globalThis.String(object.factureId)
        : isSet(object.facture_id)
        ? globalThis.String(object.facture_id)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      dueDate: isSet(object.dueDate)
        ? globalThis.String(object.dueDate)
        : isSet(object.due_date)
        ? globalThis.String(object.due_date)
        : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      autoProcess: isSet(object.autoProcess)
        ? globalThis.Boolean(object.autoProcess)
        : isSet(object.auto_process)
        ? globalThis.Boolean(object.auto_process)
        : false,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateScheduleRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.dueDate !== "") {
      obj.dueDate = message.dueDate;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.autoProcess !== false) {
      obj.autoProcess = message.autoProcess;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateScheduleRequest>, I>>(base?: I): CreateScheduleRequest {
    return CreateScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateScheduleRequest>, I>>(object: I): CreateScheduleRequest {
    const message = createBaseCreateScheduleRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.contratId = object.contratId ?? undefined;
    message.factureId = object.factureId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.dueDate = object.dueDate ?? "";
    message.description = object.description ?? undefined;
    message.autoProcess = object.autoProcess ?? false;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateScheduleRequest_MetadataEntry(): CreateScheduleRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateScheduleRequest_MetadataEntry: MessageFns<CreateScheduleRequest_MetadataEntry> = {
  encode(message: CreateScheduleRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateScheduleRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateScheduleRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateScheduleRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateScheduleRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateScheduleRequest_MetadataEntry {
    return CreateScheduleRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateScheduleRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateScheduleRequest_MetadataEntry {
    const message = createBaseCreateScheduleRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseScheduleResponse(): ScheduleResponse {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    contratId: undefined,
    factureId: undefined,
    clientId: undefined,
    amount: 0,
    currency: "",
    dueDate: "",
    status: "",
    lastAttemptAt: undefined,
    paidAt: undefined,
    retryCount: 0,
    errorMessage: undefined,
  };
}

export const ScheduleResponse: MessageFns<ScheduleResponse> = {
  encode(message: ScheduleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(42).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(50).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(74).string(message.dueDate);
    }
    if (message.status !== "") {
      writer.uint32(82).string(message.status);
    }
    if (message.lastAttemptAt !== undefined) {
      writer.uint32(90).string(message.lastAttemptAt);
    }
    if (message.paidAt !== undefined) {
      writer.uint32(98).string(message.paidAt);
    }
    if (message.retryCount !== 0) {
      writer.uint32(104).int32(message.retryCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(114).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lastAttemptAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.paidAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : undefined,
      factureId: isSet(object.factureId)
        ? globalThis.String(object.factureId)
        : isSet(object.facture_id)
        ? globalThis.String(object.facture_id)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      dueDate: isSet(object.dueDate)
        ? globalThis.String(object.dueDate)
        : isSet(object.due_date)
        ? globalThis.String(object.due_date)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      lastAttemptAt: isSet(object.lastAttemptAt)
        ? globalThis.String(object.lastAttemptAt)
        : isSet(object.last_attempt_at)
        ? globalThis.String(object.last_attempt_at)
        : undefined,
      paidAt: isSet(object.paidAt)
        ? globalThis.String(object.paidAt)
        : isSet(object.paid_at)
        ? globalThis.String(object.paid_at)
        : undefined,
      retryCount: isSet(object.retryCount)
        ? globalThis.Number(object.retryCount)
        : isSet(object.retry_count)
        ? globalThis.Number(object.retry_count)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: ScheduleResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.dueDate !== "") {
      obj.dueDate = message.dueDate;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.lastAttemptAt !== undefined) {
      obj.lastAttemptAt = message.lastAttemptAt;
    }
    if (message.paidAt !== undefined) {
      obj.paidAt = message.paidAt;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleResponse>, I>>(base?: I): ScheduleResponse {
    return ScheduleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleResponse>, I>>(object: I): ScheduleResponse {
    const message = createBaseScheduleResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.contratId = object.contratId ?? undefined;
    message.factureId = object.factureId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.dueDate = object.dueDate ?? "";
    message.status = object.status ?? "";
    message.lastAttemptAt = object.lastAttemptAt ?? undefined;
    message.paidAt = object.paidAt ?? undefined;
    message.retryCount = object.retryCount ?? 0;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseUpdateScheduleRequest(): UpdateScheduleRequest {
  return { id: "", amount: undefined, dueDate: undefined, status: undefined, autoProcess: undefined };
}

export const UpdateScheduleRequest: MessageFns<UpdateScheduleRequest> = {
  encode(message: UpdateScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== undefined) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.dueDate !== undefined) {
      writer.uint32(26).string(message.dueDate);
    }
    if (message.status !== undefined) {
      writer.uint32(34).string(message.status);
    }
    if (message.autoProcess !== undefined) {
      writer.uint32(40).bool(message.autoProcess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
      dueDate: isSet(object.dueDate)
        ? globalThis.String(object.dueDate)
        : isSet(object.due_date)
        ? globalThis.String(object.due_date)
        : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      autoProcess: isSet(object.autoProcess)
        ? globalThis.Boolean(object.autoProcess)
        : isSet(object.auto_process)
        ? globalThis.Boolean(object.auto_process)
        : undefined,
    };
  },

  toJSON(message: UpdateScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.autoProcess !== undefined) {
      obj.autoProcess = message.autoProcess;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateScheduleRequest>, I>>(base?: I): UpdateScheduleRequest {
    return UpdateScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateScheduleRequest>, I>>(object: I): UpdateScheduleRequest {
    const message = createBaseUpdateScheduleRequest();
    message.id = object.id ?? "";
    message.amount = object.amount ?? undefined;
    message.dueDate = object.dueDate ?? undefined;
    message.status = object.status ?? undefined;
    message.autoProcess = object.autoProcess ?? undefined;
    return message;
  },
};

function createBaseGetDueSchedulesRequest(): GetDueSchedulesRequest {
  return { organisationId: "", beforeDate: undefined };
}

export const GetDueSchedulesRequest: MessageFns<GetDueSchedulesRequest> = {
  encode(message: GetDueSchedulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.beforeDate !== undefined) {
      writer.uint32(18).string(message.beforeDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDueSchedulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDueSchedulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDueSchedulesRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      beforeDate: isSet(object.beforeDate)
        ? globalThis.String(object.beforeDate)
        : isSet(object.before_date)
        ? globalThis.String(object.before_date)
        : undefined,
    };
  },

  toJSON(message: GetDueSchedulesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.beforeDate !== undefined) {
      obj.beforeDate = message.beforeDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDueSchedulesRequest>, I>>(base?: I): GetDueSchedulesRequest {
    return GetDueSchedulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDueSchedulesRequest>, I>>(object: I): GetDueSchedulesRequest {
    const message = createBaseGetDueSchedulesRequest();
    message.organisationId = object.organisationId ?? "";
    message.beforeDate = object.beforeDate ?? undefined;
    return message;
  },
};

function createBaseScheduleListResponse(): ScheduleListResponse {
  return { schedules: [], total: 0 };
}

export const ScheduleListResponse: MessageFns<ScheduleListResponse> = {
  encode(message: ScheduleListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schedules) {
      ScheduleResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedules.push(ScheduleResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleListResponse {
    return {
      schedules: globalThis.Array.isArray(object?.schedules)
        ? object.schedules.map((e: any) => ScheduleResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ScheduleListResponse): unknown {
    const obj: any = {};
    if (message.schedules?.length) {
      obj.schedules = message.schedules.map((e) => ScheduleResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleListResponse>, I>>(base?: I): ScheduleListResponse {
    return ScheduleListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleListResponse>, I>>(object: I): ScheduleListResponse {
    const message = createBaseScheduleListResponse();
    message.schedules = object.schedules?.map((e) => ScheduleResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseProcessDuePaymentsRequest(): ProcessDuePaymentsRequest {
  return { organisationId: "", dryRun: undefined };
}

export const ProcessDuePaymentsRequest: MessageFns<ProcessDuePaymentsRequest> = {
  encode(message: ProcessDuePaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.dryRun !== undefined) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDuePaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDuePaymentsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : undefined,
    };
  },

  toJSON(message: ProcessDuePaymentsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.dryRun !== undefined) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDuePaymentsRequest>, I>>(base?: I): ProcessDuePaymentsRequest {
    return ProcessDuePaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDuePaymentsRequest>, I>>(object: I): ProcessDuePaymentsRequest {
    const message = createBaseProcessDuePaymentsRequest();
    message.organisationId = object.organisationId ?? "";
    message.dryRun = object.dryRun ?? undefined;
    return message;
  },
};

function createBaseProcessDuePaymentsResponse(): ProcessDuePaymentsResponse {
  return { processedCount: 0, successCount: 0, failedCount: 0, results: [] };
}

export const ProcessDuePaymentsResponse: MessageFns<ProcessDuePaymentsResponse> = {
  encode(message: ProcessDuePaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processedCount !== 0) {
      writer.uint32(8).int32(message.processedCount);
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(24).int32(message.failedCount);
    }
    for (const v of message.results) {
      ProcessedPayment.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDuePaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processedCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.results.push(ProcessedPayment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDuePaymentsResponse {
    return {
      processedCount: isSet(object.processedCount)
        ? globalThis.Number(object.processedCount)
        : isSet(object.processed_count)
        ? globalThis.Number(object.processed_count)
        : 0,
      successCount: isSet(object.successCount)
        ? globalThis.Number(object.successCount)
        : isSet(object.success_count)
        ? globalThis.Number(object.success_count)
        : 0,
      failedCount: isSet(object.failedCount)
        ? globalThis.Number(object.failedCount)
        : isSet(object.failed_count)
        ? globalThis.Number(object.failed_count)
        : 0,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ProcessedPayment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessDuePaymentsResponse): unknown {
    const obj: any = {};
    if (message.processedCount !== 0) {
      obj.processedCount = Math.round(message.processedCount);
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => ProcessedPayment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDuePaymentsResponse>, I>>(base?: I): ProcessDuePaymentsResponse {
    return ProcessDuePaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDuePaymentsResponse>, I>>(object: I): ProcessDuePaymentsResponse {
    const message = createBaseProcessDuePaymentsResponse();
    message.processedCount = object.processedCount ?? 0;
    message.successCount = object.successCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    message.results = object.results?.map((e) => ProcessedPayment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessedPayment(): ProcessedPayment {
  return { scheduleId: "", success: false, paymentId: undefined, error: undefined };
}

export const ProcessedPayment: MessageFns<ProcessedPayment> = {
  encode(message: ProcessedPayment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduleId !== "") {
      writer.uint32(10).string(message.scheduleId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.paymentId !== undefined) {
      writer.uint32(26).string(message.paymentId);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessedPayment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessedPayment {
    return {
      scheduleId: isSet(object.scheduleId)
        ? globalThis.String(object.scheduleId)
        : isSet(object.schedule_id)
        ? globalThis.String(object.schedule_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: ProcessedPayment): unknown {
    const obj: any = {};
    if (message.scheduleId !== "") {
      obj.scheduleId = message.scheduleId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.paymentId !== undefined) {
      obj.paymentId = message.paymentId;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessedPayment>, I>>(base?: I): ProcessedPayment {
    return ProcessedPayment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessedPayment>, I>>(object: I): ProcessedPayment {
    const message = createBaseProcessedPayment();
    message.scheduleId = object.scheduleId ?? "";
    message.success = object.success ?? false;
    message.paymentId = object.paymentId ?? undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseRenewScheduleRequest(): RenewScheduleRequest {
  return { id: "", newDueDate: "", newAmount: undefined };
}

export const RenewScheduleRequest: MessageFns<RenewScheduleRequest> = {
  encode(message: RenewScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newDueDate !== "") {
      writer.uint32(18).string(message.newDueDate);
    }
    if (message.newAmount !== undefined) {
      writer.uint32(24).int64(message.newAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newDueDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newAmount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      newDueDate: isSet(object.newDueDate)
        ? globalThis.String(object.newDueDate)
        : isSet(object.new_due_date)
        ? globalThis.String(object.new_due_date)
        : "",
      newAmount: isSet(object.newAmount)
        ? globalThis.Number(object.newAmount)
        : isSet(object.new_amount)
        ? globalThis.Number(object.new_amount)
        : undefined,
    };
  },

  toJSON(message: RenewScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.newDueDate !== "") {
      obj.newDueDate = message.newDueDate;
    }
    if (message.newAmount !== undefined) {
      obj.newAmount = Math.round(message.newAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenewScheduleRequest>, I>>(base?: I): RenewScheduleRequest {
    return RenewScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenewScheduleRequest>, I>>(object: I): RenewScheduleRequest {
    const message = createBaseRenewScheduleRequest();
    message.id = object.id ?? "";
    message.newDueDate = object.newDueDate ?? "";
    message.newAmount = object.newAmount ?? undefined;
    return message;
  },
};

function createBaseCreatePaymentIntentRequest(): CreatePaymentIntentRequest {
  return {
    organisationId: "",
    societeId: "",
    scheduleId: undefined,
    pspName: "",
    amount: 0,
    currency: "",
    mandateReference: undefined,
    idempotencyKey: undefined,
    metadata: {},
  };
}

export const CreatePaymentIntentRequest: MessageFns<CreatePaymentIntentRequest> = {
  encode(message: CreatePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(26).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(34).string(message.pspName);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(58).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(66).string(message.idempotencyKey);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pspName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CreatePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentIntentRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scheduleId: isSet(object.scheduleId)
        ? globalThis.String(object.scheduleId)
        : isSet(object.schedule_id)
        ? globalThis.String(object.schedule_id)
        : undefined,
      pspName: isSet(object.pspName)
        ? globalThis.String(object.pspName)
        : isSet(object.psp_name)
        ? globalThis.String(object.psp_name)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      mandateReference: isSet(object.mandateReference)
        ? globalThis.String(object.mandateReference)
        : isSet(object.mandate_reference)
        ? globalThis.String(object.mandate_reference)
        : undefined,
      idempotencyKey: isSet(object.idempotencyKey)
        ? globalThis.String(object.idempotencyKey)
        : isSet(object.idempotency_key)
        ? globalThis.String(object.idempotency_key)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreatePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheduleId !== undefined) {
      obj.scheduleId = message.scheduleId;
    }
    if (message.pspName !== "") {
      obj.pspName = message.pspName;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = message.mandateReference;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentIntentRequest>, I>>(base?: I): CreatePaymentIntentRequest {
    return CreatePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentIntentRequest>, I>>(object: I): CreatePaymentIntentRequest {
    const message = createBaseCreatePaymentIntentRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheduleId = object.scheduleId ?? undefined;
    message.pspName = object.pspName ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.mandateReference = object.mandateReference ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePaymentIntentRequest_MetadataEntry(): CreatePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePaymentIntentRequest_MetadataEntry: MessageFns<CreatePaymentIntentRequest_MetadataEntry> = {
  encode(message: CreatePaymentIntentRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePaymentIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePaymentIntentRequest_MetadataEntry {
    return CreatePaymentIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePaymentIntentRequest_MetadataEntry {
    const message = createBaseCreatePaymentIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePaymentIntentResponse(): PaymentIntentResponse {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    scheduleId: undefined,
    pspName: "",
    pspPaymentId: undefined,
    amount: 0,
    currency: "",
    status: "",
    mandateReference: undefined,
    idempotencyKey: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const PaymentIntentResponse: MessageFns<PaymentIntentResponse> = {
  encode(message: PaymentIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(34).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(42).string(message.pspName);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(50).string(message.pspPaymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(82).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(90).string(message.idempotencyKey);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(98).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(106).string(message.errorMessage);
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(122).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pspName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scheduleId: isSet(object.scheduleId)
        ? globalThis.String(object.scheduleId)
        : isSet(object.schedule_id)
        ? globalThis.String(object.schedule_id)
        : undefined,
      pspName: isSet(object.pspName)
        ? globalThis.String(object.pspName)
        : isSet(object.psp_name)
        ? globalThis.String(object.psp_name)
        : "",
      pspPaymentId: isSet(object.pspPaymentId)
        ? globalThis.String(object.pspPaymentId)
        : isSet(object.psp_payment_id)
        ? globalThis.String(object.psp_payment_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      mandateReference: isSet(object.mandateReference)
        ? globalThis.String(object.mandateReference)
        : isSet(object.mandate_reference)
        ? globalThis.String(object.mandate_reference)
        : undefined,
      idempotencyKey: isSet(object.idempotencyKey)
        ? globalThis.String(object.idempotencyKey)
        : isSet(object.idempotency_key)
        ? globalThis.String(object.idempotency_key)
        : undefined,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: PaymentIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheduleId !== undefined) {
      obj.scheduleId = message.scheduleId;
    }
    if (message.pspName !== "") {
      obj.pspName = message.pspName;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = message.mandateReference;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentIntentResponse>, I>>(base?: I): PaymentIntentResponse {
    return PaymentIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentIntentResponse>, I>>(object: I): PaymentIntentResponse {
    const message = createBasePaymentIntentResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheduleId = object.scheduleId ?? undefined;
    message.pspName = object.pspName ?? "";
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.mandateReference = object.mandateReference ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseUpdatePaymentIntentRequest(): UpdatePaymentIntentRequest {
  return { id: "", status: undefined, pspPaymentId: undefined, errorCode: undefined, errorMessage: undefined };
}

export const UpdatePaymentIntentRequest: MessageFns<UpdatePaymentIntentRequest> = {
  encode(message: UpdatePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      writer.uint32(18).string(message.status);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(26).string(message.pspPaymentId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePaymentIntentRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      pspPaymentId: isSet(object.pspPaymentId)
        ? globalThis.String(object.pspPaymentId)
        : isSet(object.psp_payment_id)
        ? globalThis.String(object.psp_payment_id)
        : undefined,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: UpdatePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePaymentIntentRequest>, I>>(base?: I): UpdatePaymentIntentRequest {
    return UpdatePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePaymentIntentRequest>, I>>(object: I): UpdatePaymentIntentRequest {
    const message = createBaseUpdatePaymentIntentRequest();
    message.id = object.id ?? "";
    message.status = object.status ?? undefined;
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseCreatePaymentEventRequest(): CreatePaymentEventRequest {
  return { organisationId: "", paymentIntentId: "", eventType: "", rawPayload: "" };
}

export const CreatePaymentEventRequest: MessageFns<CreatePaymentEventRequest> = {
  encode(message: CreatePaymentEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(34).string(message.rawPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentEventRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      rawPayload: isSet(object.rawPayload)
        ? globalThis.String(object.rawPayload)
        : isSet(object.raw_payload)
        ? globalThis.String(object.raw_payload)
        : "",
    };
  },

  toJSON(message: CreatePaymentEventRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentEventRequest>, I>>(base?: I): CreatePaymentEventRequest {
    return CreatePaymentEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentEventRequest>, I>>(object: I): CreatePaymentEventRequest {
    const message = createBaseCreatePaymentEventRequest();
    message.organisationId = object.organisationId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.eventType = object.eventType ?? "";
    message.rawPayload = object.rawPayload ?? "";
    return message;
  },
};

function createBasePaymentEventResponse(): PaymentEventResponse {
  return {
    id: "",
    organisationId: "",
    paymentIntentId: "",
    eventType: "",
    rawPayload: "",
    receivedAt: "",
    processed: false,
    processedAt: undefined,
    errorMessage: undefined,
  };
}

export const PaymentEventResponse: MessageFns<PaymentEventResponse> = {
  encode(message: PaymentEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(26).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(34).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(42).string(message.rawPayload);
    }
    if (message.receivedAt !== "") {
      writer.uint32(50).string(message.receivedAt);
    }
    if (message.processed !== false) {
      writer.uint32(56).bool(message.processed);
    }
    if (message.processedAt !== undefined) {
      writer.uint32(66).string(message.processedAt);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentEventResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      rawPayload: isSet(object.rawPayload)
        ? globalThis.String(object.rawPayload)
        : isSet(object.raw_payload)
        ? globalThis.String(object.raw_payload)
        : "",
      receivedAt: isSet(object.receivedAt)
        ? globalThis.String(object.receivedAt)
        : isSet(object.received_at)
        ? globalThis.String(object.received_at)
        : "",
      processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false,
      processedAt: isSet(object.processedAt)
        ? globalThis.String(object.processedAt)
        : isSet(object.processed_at)
        ? globalThis.String(object.processed_at)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: PaymentEventResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    if (message.receivedAt !== "") {
      obj.receivedAt = message.receivedAt;
    }
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    if (message.processedAt !== undefined) {
      obj.processedAt = message.processedAt;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentEventResponse>, I>>(base?: I): PaymentEventResponse {
    return PaymentEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentEventResponse>, I>>(object: I): PaymentEventResponse {
    const message = createBasePaymentEventResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.eventType = object.eventType ?? "";
    message.rawPayload = object.rawPayload ?? "";
    message.receivedAt = object.receivedAt ?? "";
    message.processed = object.processed ?? false;
    message.processedAt = object.processedAt ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseGetUnprocessedEventsRequest(): GetUnprocessedEventsRequest {
  return { organisationId: "", limit: undefined };
}

export const GetUnprocessedEventsRequest: MessageFns<GetUnprocessedEventsRequest> = {
  encode(message: GetUnprocessedEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnprocessedEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnprocessedEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnprocessedEventsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: GetUnprocessedEventsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUnprocessedEventsRequest>, I>>(base?: I): GetUnprocessedEventsRequest {
    return GetUnprocessedEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUnprocessedEventsRequest>, I>>(object: I): GetUnprocessedEventsRequest {
    const message = createBaseGetUnprocessedEventsRequest();
    message.organisationId = object.organisationId ?? "";
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBasePaymentEventListResponse(): PaymentEventListResponse {
  return { events: [], total: 0 };
}

export const PaymentEventListResponse: MessageFns<PaymentEventListResponse> = {
  encode(message: PaymentEventListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      PaymentEventResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentEventListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(PaymentEventResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentEventListResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => PaymentEventResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: PaymentEventListResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => PaymentEventResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentEventListResponse>, I>>(base?: I): PaymentEventListResponse {
    return PaymentEventListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentEventListResponse>, I>>(object: I): PaymentEventListResponse {
    const message = createBasePaymentEventListResponse();
    message.events = object.events?.map((e) => PaymentEventResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseMarkEventProcessedRequest(): MarkEventProcessedRequest {
  return { id: "", errorMessage: undefined };
}

export const MarkEventProcessedRequest: MessageFns<MarkEventProcessedRequest> = {
  encode(message: MarkEventProcessedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkEventProcessedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkEventProcessedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkEventProcessedRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: MarkEventProcessedRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkEventProcessedRequest>, I>>(base?: I): MarkEventProcessedRequest {
    return MarkEventProcessedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkEventProcessedRequest>, I>>(object: I): MarkEventProcessedRequest {
    const message = createBaseMarkEventProcessedRequest();
    message.id = object.id ?? "";
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseGetPSPAccountsRequest(): GetPSPAccountsRequest {
  return { societeId: "" };
}

export const GetPSPAccountsRequest: MessageFns<GetPSPAccountsRequest> = {
  encode(message: GetPSPAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPSPAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPSPAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPSPAccountsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetPSPAccountsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPSPAccountsRequest>, I>>(base?: I): GetPSPAccountsRequest {
    return GetPSPAccountsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPSPAccountsRequest>, I>>(object: I): GetPSPAccountsRequest {
    const message = createBaseGetPSPAccountsRequest();
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBasePSPAccountsSummaryResponse(): PSPAccountsSummaryResponse {
  return {
    stripe: undefined,
    paypal: undefined,
    gocardless: undefined,
    emerchantpay: undefined,
    slimpay: undefined,
    multisafepay: undefined,
  };
}

export const PSPAccountsSummaryResponse: MessageFns<PSPAccountsSummaryResponse> = {
  encode(message: PSPAccountsSummaryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stripe !== undefined) {
      PSPAccountInfo.encode(message.stripe, writer.uint32(10).fork()).join();
    }
    if (message.paypal !== undefined) {
      PSPAccountInfo.encode(message.paypal, writer.uint32(18).fork()).join();
    }
    if (message.gocardless !== undefined) {
      PSPAccountInfo.encode(message.gocardless, writer.uint32(26).fork()).join();
    }
    if (message.emerchantpay !== undefined) {
      PSPAccountInfo.encode(message.emerchantpay, writer.uint32(34).fork()).join();
    }
    if (message.slimpay !== undefined) {
      PSPAccountInfo.encode(message.slimpay, writer.uint32(42).fork()).join();
    }
    if (message.multisafepay !== undefined) {
      PSPAccountInfo.encode(message.multisafepay, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PSPAccountsSummaryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountsSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stripe = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paypal = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gocardless = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.emerchantpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.slimpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.multisafepay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PSPAccountsSummaryResponse {
    return {
      stripe: isSet(object.stripe) ? PSPAccountInfo.fromJSON(object.stripe) : undefined,
      paypal: isSet(object.paypal) ? PSPAccountInfo.fromJSON(object.paypal) : undefined,
      gocardless: isSet(object.gocardless) ? PSPAccountInfo.fromJSON(object.gocardless) : undefined,
      emerchantpay: isSet(object.emerchantpay) ? PSPAccountInfo.fromJSON(object.emerchantpay) : undefined,
      slimpay: isSet(object.slimpay) ? PSPAccountInfo.fromJSON(object.slimpay) : undefined,
      multisafepay: isSet(object.multisafepay) ? PSPAccountInfo.fromJSON(object.multisafepay) : undefined,
    };
  },

  toJSON(message: PSPAccountsSummaryResponse): unknown {
    const obj: any = {};
    if (message.stripe !== undefined) {
      obj.stripe = PSPAccountInfo.toJSON(message.stripe);
    }
    if (message.paypal !== undefined) {
      obj.paypal = PSPAccountInfo.toJSON(message.paypal);
    }
    if (message.gocardless !== undefined) {
      obj.gocardless = PSPAccountInfo.toJSON(message.gocardless);
    }
    if (message.emerchantpay !== undefined) {
      obj.emerchantpay = PSPAccountInfo.toJSON(message.emerchantpay);
    }
    if (message.slimpay !== undefined) {
      obj.slimpay = PSPAccountInfo.toJSON(message.slimpay);
    }
    if (message.multisafepay !== undefined) {
      obj.multisafepay = PSPAccountInfo.toJSON(message.multisafepay);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PSPAccountsSummaryResponse>, I>>(base?: I): PSPAccountsSummaryResponse {
    return PSPAccountsSummaryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PSPAccountsSummaryResponse>, I>>(object: I): PSPAccountsSummaryResponse {
    const message = createBasePSPAccountsSummaryResponse();
    message.stripe = (object.stripe !== undefined && object.stripe !== null)
      ? PSPAccountInfo.fromPartial(object.stripe)
      : undefined;
    message.paypal = (object.paypal !== undefined && object.paypal !== null)
      ? PSPAccountInfo.fromPartial(object.paypal)
      : undefined;
    message.gocardless = (object.gocardless !== undefined && object.gocardless !== null)
      ? PSPAccountInfo.fromPartial(object.gocardless)
      : undefined;
    message.emerchantpay = (object.emerchantpay !== undefined && object.emerchantpay !== null)
      ? PSPAccountInfo.fromPartial(object.emerchantpay)
      : undefined;
    message.slimpay = (object.slimpay !== undefined && object.slimpay !== null)
      ? PSPAccountInfo.fromPartial(object.slimpay)
      : undefined;
    message.multisafepay = (object.multisafepay !== undefined && object.multisafepay !== null)
      ? PSPAccountInfo.fromPartial(object.multisafepay)
      : undefined;
    return message;
  },
};

function createBasePSPAccountInfo(): PSPAccountInfo {
  return { id: "", name: "", isActive: false, isLiveMode: false, isConfigured: false };
}

export const PSPAccountInfo: MessageFns<PSPAccountInfo> = {
  encode(message: PSPAccountInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.isLiveMode !== false) {
      writer.uint32(32).bool(message.isLiveMode);
    }
    if (message.isConfigured !== false) {
      writer.uint32(40).bool(message.isConfigured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PSPAccountInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isLiveMode = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isConfigured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PSPAccountInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      isLiveMode: isSet(object.isLiveMode)
        ? globalThis.Boolean(object.isLiveMode)
        : isSet(object.is_live_mode)
        ? globalThis.Boolean(object.is_live_mode)
        : false,
      isConfigured: isSet(object.isConfigured)
        ? globalThis.Boolean(object.isConfigured)
        : isSet(object.is_configured)
        ? globalThis.Boolean(object.is_configured)
        : false,
    };
  },

  toJSON(message: PSPAccountInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isLiveMode !== false) {
      obj.isLiveMode = message.isLiveMode;
    }
    if (message.isConfigured !== false) {
      obj.isConfigured = message.isConfigured;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PSPAccountInfo>, I>>(base?: I): PSPAccountInfo {
    return PSPAccountInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PSPAccountInfo>, I>>(object: I): PSPAccountInfo {
    const message = createBasePSPAccountInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isActive = object.isActive ?? false;
    message.isLiveMode = object.isLiveMode ?? false;
    message.isConfigured = object.isConfigured ?? false;
    return message;
  },
};

function createBaseCreatePortalSessionRequest(): CreatePortalSessionRequest {
  return {
    organisationId: "",
    societeId: "",
    customerId: "",
    contractId: undefined,
    paymentIntentId: undefined,
    allowedActions: [],
    ttlSeconds: undefined,
    maxUses: undefined,
    amountCents: 0,
    currency: undefined,
    description: undefined,
    mandateId: undefined,
    rumMasked: undefined,
    idempotencyKey: undefined,
    metadata: {},
  };
}

export const CreatePortalSessionRequest: MessageFns<CreatePortalSessionRequest> = {
  encode(message: CreatePortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(26).string(message.customerId);
    }
    if (message.contractId !== undefined) {
      writer.uint32(34).string(message.contractId);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(42).string(message.paymentIntentId);
    }
    writer.uint32(50).fork();
    for (const v of message.allowedActions) {
      writer.int32(v);
    }
    writer.join();
    if (message.ttlSeconds !== undefined) {
      writer.uint32(56).int32(message.ttlSeconds);
    }
    if (message.maxUses !== undefined) {
      writer.uint32(64).int32(message.maxUses);
    }
    if (message.amountCents !== 0) {
      writer.uint32(72).int64(message.amountCents);
    }
    if (message.currency !== undefined) {
      writer.uint32(82).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(90).string(message.description);
    }
    if (message.mandateId !== undefined) {
      writer.uint32(98).string(message.mandateId);
    }
    if (message.rumMasked !== undefined) {
      writer.uint32(106).string(message.rumMasked);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(114).string(message.idempotencyKey);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePortalSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.allowedActions.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedActions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ttlSeconds = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxUses = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.rumMasked = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = CreatePortalSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.metadata[entry15.key] = entry15.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePortalSessionRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      contractId: isSet(object.contractId)
        ? globalThis.String(object.contractId)
        : isSet(object.contract_id)
        ? globalThis.String(object.contract_id)
        : undefined,
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : undefined,
      allowedActions: globalThis.Array.isArray(object?.allowedActions)
        ? object.allowedActions.map((e: any) => portalSessionActionFromJSON(e))
        : globalThis.Array.isArray(object?.allowed_actions)
        ? object.allowed_actions.map((e: any) => portalSessionActionFromJSON(e))
        : [],
      ttlSeconds: isSet(object.ttlSeconds)
        ? globalThis.Number(object.ttlSeconds)
        : isSet(object.ttl_seconds)
        ? globalThis.Number(object.ttl_seconds)
        : undefined,
      maxUses: isSet(object.maxUses)
        ? globalThis.Number(object.maxUses)
        : isSet(object.max_uses)
        ? globalThis.Number(object.max_uses)
        : undefined,
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : undefined,
      rumMasked: isSet(object.rumMasked)
        ? globalThis.String(object.rumMasked)
        : isSet(object.rum_masked)
        ? globalThis.String(object.rum_masked)
        : undefined,
      idempotencyKey: isSet(object.idempotencyKey)
        ? globalThis.String(object.idempotencyKey)
        : isSet(object.idempotency_key)
        ? globalThis.String(object.idempotency_key)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreatePortalSessionRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.contractId !== undefined) {
      obj.contractId = message.contractId;
    }
    if (message.paymentIntentId !== undefined) {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.allowedActions?.length) {
      obj.allowedActions = message.allowedActions.map((e) => portalSessionActionToJSON(e));
    }
    if (message.ttlSeconds !== undefined) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    if (message.maxUses !== undefined) {
      obj.maxUses = Math.round(message.maxUses);
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== undefined) {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.mandateId !== undefined) {
      obj.mandateId = message.mandateId;
    }
    if (message.rumMasked !== undefined) {
      obj.rumMasked = message.rumMasked;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePortalSessionRequest>, I>>(base?: I): CreatePortalSessionRequest {
    return CreatePortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePortalSessionRequest>, I>>(object: I): CreatePortalSessionRequest {
    const message = createBaseCreatePortalSessionRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.contractId = object.contractId ?? undefined;
    message.paymentIntentId = object.paymentIntentId ?? undefined;
    message.allowedActions = object.allowedActions?.map((e) => e) || [];
    message.ttlSeconds = object.ttlSeconds ?? undefined;
    message.maxUses = object.maxUses ?? undefined;
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? undefined;
    message.description = object.description ?? undefined;
    message.mandateId = object.mandateId ?? undefined;
    message.rumMasked = object.rumMasked ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePortalSessionRequest_MetadataEntry(): CreatePortalSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePortalSessionRequest_MetadataEntry: MessageFns<CreatePortalSessionRequest_MetadataEntry> = {
  encode(message: CreatePortalSessionRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePortalSessionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePortalSessionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePortalSessionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePortalSessionRequest_MetadataEntry {
    return CreatePortalSessionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePortalSessionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePortalSessionRequest_MetadataEntry {
    const message = createBaseCreatePortalSessionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreatePortalSessionResponse(): CreatePortalSessionResponse {
  return { session: undefined, token: "", portalUrl: "", wasIdempotentHit: false };
}

export const CreatePortalSessionResponse: MessageFns<CreatePortalSessionResponse> = {
  encode(message: CreatePortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.portalUrl !== "") {
      writer.uint32(26).string(message.portalUrl);
    }
    if (message.wasIdempotentHit !== false) {
      writer.uint32(32).bool(message.wasIdempotentHit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.portalUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.wasIdempotentHit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePortalSessionResponse {
    return {
      session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      portalUrl: isSet(object.portalUrl)
        ? globalThis.String(object.portalUrl)
        : isSet(object.portal_url)
        ? globalThis.String(object.portal_url)
        : "",
      wasIdempotentHit: isSet(object.wasIdempotentHit)
        ? globalThis.Boolean(object.wasIdempotentHit)
        : isSet(object.was_idempotent_hit)
        ? globalThis.Boolean(object.was_idempotent_hit)
        : false,
    };
  },

  toJSON(message: CreatePortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.portalUrl !== "") {
      obj.portalUrl = message.portalUrl;
    }
    if (message.wasIdempotentHit !== false) {
      obj.wasIdempotentHit = message.wasIdempotentHit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePortalSessionResponse>, I>>(base?: I): CreatePortalSessionResponse {
    return CreatePortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePortalSessionResponse>, I>>(object: I): CreatePortalSessionResponse {
    const message = createBaseCreatePortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    message.token = object.token ?? "";
    message.portalUrl = object.portalUrl ?? "";
    message.wasIdempotentHit = object.wasIdempotentHit ?? false;
    return message;
  },
};

function createBasePortalPaymentSession(): PortalPaymentSession {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    customerId: "",
    contractId: undefined,
    paymentIntentId: undefined,
    tokenVersion: "",
    status: 0,
    allowedActions: [],
    expiresAt: "",
    maxUses: 0,
    useCount: 0,
    consumedAt: undefined,
    revokedAt: undefined,
    lastAccessedAt: undefined,
    amountCents: 0,
    currency: "",
    description: undefined,
    mandateId: undefined,
    rumMasked: undefined,
    pspState: undefined,
    pspRedirectUrl: undefined,
    pspProvider: undefined,
    pspSessionId: undefined,
    metadata: {},
    createdAt: "",
    updatedAt: "",
  };
}

export const PortalPaymentSession: MessageFns<PortalPaymentSession> = {
  encode(message: PortalPaymentSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(34).string(message.customerId);
    }
    if (message.contractId !== undefined) {
      writer.uint32(42).string(message.contractId);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(50).string(message.paymentIntentId);
    }
    if (message.tokenVersion !== "") {
      writer.uint32(58).string(message.tokenVersion);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    writer.uint32(74).fork();
    for (const v of message.allowedActions) {
      writer.int32(v);
    }
    writer.join();
    if (message.expiresAt !== "") {
      writer.uint32(82).string(message.expiresAt);
    }
    if (message.maxUses !== 0) {
      writer.uint32(88).int32(message.maxUses);
    }
    if (message.useCount !== 0) {
      writer.uint32(96).int32(message.useCount);
    }
    if (message.consumedAt !== undefined) {
      writer.uint32(106).string(message.consumedAt);
    }
    if (message.revokedAt !== undefined) {
      writer.uint32(114).string(message.revokedAt);
    }
    if (message.lastAccessedAt !== undefined) {
      writer.uint32(122).string(message.lastAccessedAt);
    }
    if (message.amountCents !== 0) {
      writer.uint32(128).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(138).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(146).string(message.description);
    }
    if (message.mandateId !== undefined) {
      writer.uint32(154).string(message.mandateId);
    }
    if (message.rumMasked !== undefined) {
      writer.uint32(162).string(message.rumMasked);
    }
    if (message.pspState !== undefined) {
      writer.uint32(170).string(message.pspState);
    }
    if (message.pspRedirectUrl !== undefined) {
      writer.uint32(178).string(message.pspRedirectUrl);
    }
    if (message.pspProvider !== undefined) {
      writer.uint32(184).int32(message.pspProvider);
    }
    if (message.pspSessionId !== undefined) {
      writer.uint32(194).string(message.pspSessionId);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      PortalPaymentSession_MetadataEntry.encode({ key: key as any, value }, writer.uint32(202).fork()).join();
    });
    if (message.createdAt !== "") {
      writer.uint32(210).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(218).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalPaymentSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalPaymentSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenVersion = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.allowedActions.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedActions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxUses = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.useCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.consumedAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.revokedAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.lastAccessedAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.rumMasked = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.pspState = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.pspRedirectUrl = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.pspProvider = reader.int32() as any;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.pspSessionId = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          const entry25 = PortalPaymentSession_MetadataEntry.decode(reader, reader.uint32());
          if (entry25.value !== undefined) {
            message.metadata[entry25.key] = entry25.value;
          }
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalPaymentSession {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      contractId: isSet(object.contractId)
        ? globalThis.String(object.contractId)
        : isSet(object.contract_id)
        ? globalThis.String(object.contract_id)
        : undefined,
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : undefined,
      tokenVersion: isSet(object.tokenVersion)
        ? globalThis.String(object.tokenVersion)
        : isSet(object.token_version)
        ? globalThis.String(object.token_version)
        : "",
      status: isSet(object.status) ? portalSessionStatusFromJSON(object.status) : 0,
      allowedActions: globalThis.Array.isArray(object?.allowedActions)
        ? object.allowedActions.map((e: any) => portalSessionActionFromJSON(e))
        : globalThis.Array.isArray(object?.allowed_actions)
        ? object.allowed_actions.map((e: any) => portalSessionActionFromJSON(e))
        : [],
      expiresAt: isSet(object.expiresAt)
        ? globalThis.String(object.expiresAt)
        : isSet(object.expires_at)
        ? globalThis.String(object.expires_at)
        : "",
      maxUses: isSet(object.maxUses)
        ? globalThis.Number(object.maxUses)
        : isSet(object.max_uses)
        ? globalThis.Number(object.max_uses)
        : 0,
      useCount: isSet(object.useCount)
        ? globalThis.Number(object.useCount)
        : isSet(object.use_count)
        ? globalThis.Number(object.use_count)
        : 0,
      consumedAt: isSet(object.consumedAt)
        ? globalThis.String(object.consumedAt)
        : isSet(object.consumed_at)
        ? globalThis.String(object.consumed_at)
        : undefined,
      revokedAt: isSet(object.revokedAt)
        ? globalThis.String(object.revokedAt)
        : isSet(object.revoked_at)
        ? globalThis.String(object.revoked_at)
        : undefined,
      lastAccessedAt: isSet(object.lastAccessedAt)
        ? globalThis.String(object.lastAccessedAt)
        : isSet(object.last_accessed_at)
        ? globalThis.String(object.last_accessed_at)
        : undefined,
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : undefined,
      rumMasked: isSet(object.rumMasked)
        ? globalThis.String(object.rumMasked)
        : isSet(object.rum_masked)
        ? globalThis.String(object.rum_masked)
        : undefined,
      pspState: isSet(object.pspState)
        ? globalThis.String(object.pspState)
        : isSet(object.psp_state)
        ? globalThis.String(object.psp_state)
        : undefined,
      pspRedirectUrl: isSet(object.pspRedirectUrl)
        ? globalThis.String(object.pspRedirectUrl)
        : isSet(object.psp_redirect_url)
        ? globalThis.String(object.psp_redirect_url)
        : undefined,
      pspProvider: isSet(object.pspProvider)
        ? portalPspProviderFromJSON(object.pspProvider)
        : isSet(object.psp_provider)
        ? portalPspProviderFromJSON(object.psp_provider)
        : undefined,
      pspSessionId: isSet(object.pspSessionId)
        ? globalThis.String(object.pspSessionId)
        : isSet(object.psp_session_id)
        ? globalThis.String(object.psp_session_id)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: PortalPaymentSession): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.contractId !== undefined) {
      obj.contractId = message.contractId;
    }
    if (message.paymentIntentId !== undefined) {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.tokenVersion !== "") {
      obj.tokenVersion = message.tokenVersion;
    }
    if (message.status !== 0) {
      obj.status = portalSessionStatusToJSON(message.status);
    }
    if (message.allowedActions?.length) {
      obj.allowedActions = message.allowedActions.map((e) => portalSessionActionToJSON(e));
    }
    if (message.expiresAt !== "") {
      obj.expiresAt = message.expiresAt;
    }
    if (message.maxUses !== 0) {
      obj.maxUses = Math.round(message.maxUses);
    }
    if (message.useCount !== 0) {
      obj.useCount = Math.round(message.useCount);
    }
    if (message.consumedAt !== undefined) {
      obj.consumedAt = message.consumedAt;
    }
    if (message.revokedAt !== undefined) {
      obj.revokedAt = message.revokedAt;
    }
    if (message.lastAccessedAt !== undefined) {
      obj.lastAccessedAt = message.lastAccessedAt;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.mandateId !== undefined) {
      obj.mandateId = message.mandateId;
    }
    if (message.rumMasked !== undefined) {
      obj.rumMasked = message.rumMasked;
    }
    if (message.pspState !== undefined) {
      obj.pspState = message.pspState;
    }
    if (message.pspRedirectUrl !== undefined) {
      obj.pspRedirectUrl = message.pspRedirectUrl;
    }
    if (message.pspProvider !== undefined) {
      obj.pspProvider = portalPspProviderToJSON(message.pspProvider);
    }
    if (message.pspSessionId !== undefined) {
      obj.pspSessionId = message.pspSessionId;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalPaymentSession>, I>>(base?: I): PortalPaymentSession {
    return PortalPaymentSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalPaymentSession>, I>>(object: I): PortalPaymentSession {
    const message = createBasePortalPaymentSession();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.contractId = object.contractId ?? undefined;
    message.paymentIntentId = object.paymentIntentId ?? undefined;
    message.tokenVersion = object.tokenVersion ?? "";
    message.status = object.status ?? 0;
    message.allowedActions = object.allowedActions?.map((e) => e) || [];
    message.expiresAt = object.expiresAt ?? "";
    message.maxUses = object.maxUses ?? 0;
    message.useCount = object.useCount ?? 0;
    message.consumedAt = object.consumedAt ?? undefined;
    message.revokedAt = object.revokedAt ?? undefined;
    message.lastAccessedAt = object.lastAccessedAt ?? undefined;
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.mandateId = object.mandateId ?? undefined;
    message.rumMasked = object.rumMasked ?? undefined;
    message.pspState = object.pspState ?? undefined;
    message.pspRedirectUrl = object.pspRedirectUrl ?? undefined;
    message.pspProvider = object.pspProvider ?? undefined;
    message.pspSessionId = object.pspSessionId ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBasePortalPaymentSession_MetadataEntry(): PortalPaymentSession_MetadataEntry {
  return { key: "", value: "" };
}

export const PortalPaymentSession_MetadataEntry: MessageFns<PortalPaymentSession_MetadataEntry> = {
  encode(message: PortalPaymentSession_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalPaymentSession_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalPaymentSession_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalPaymentSession_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PortalPaymentSession_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalPaymentSession_MetadataEntry>, I>>(
    base?: I,
  ): PortalPaymentSession_MetadataEntry {
    return PortalPaymentSession_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalPaymentSession_MetadataEntry>, I>>(
    object: I,
  ): PortalPaymentSession_MetadataEntry {
    const message = createBasePortalPaymentSession_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseValidatePortalTokenRequest(): ValidatePortalTokenRequest {
  return { token: "", ipAddressHash: undefined, userAgentHash: undefined, requestId: undefined };
}

export const ValidatePortalTokenRequest: MessageFns<ValidatePortalTokenRequest> = {
  encode(message: ValidatePortalTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(18).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(26).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePortalTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePortalTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatePortalTokenRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
    };
  },

  toJSON(message: ValidatePortalTokenRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatePortalTokenRequest>, I>>(base?: I): ValidatePortalTokenRequest {
    return ValidatePortalTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatePortalTokenRequest>, I>>(object: I): ValidatePortalTokenRequest {
    const message = createBaseValidatePortalTokenRequest();
    message.token = object.token ?? "";
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    return message;
  },
};

function createBaseValidatePortalTokenResponse(): ValidatePortalTokenResponse {
  return { valid: false, session: undefined, errorCode: undefined, errorMessage: undefined };
}

export const ValidatePortalTokenResponse: MessageFns<ValidatePortalTokenResponse> = {
  encode(message: ValidatePortalTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(18).fork()).join();
    }
    if (message.errorCode !== undefined) {
      writer.uint32(24).int32(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePortalTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePortalTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatePortalTokenResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined,
      errorCode: isSet(object.errorCode)
        ? portalErrorCodeFromJSON(object.errorCode)
        : isSet(object.error_code)
        ? portalErrorCodeFromJSON(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: ValidatePortalTokenResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = portalErrorCodeToJSON(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatePortalTokenResponse>, I>>(base?: I): ValidatePortalTokenResponse {
    return ValidatePortalTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatePortalTokenResponse>, I>>(object: I): ValidatePortalTokenResponse {
    const message = createBaseValidatePortalTokenResponse();
    message.valid = object.valid ?? false;
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseAccessPortalSessionRequest(): AccessPortalSessionRequest {
  return { token: "", ipAddressHash: undefined, userAgentHash: undefined, requestId: undefined };
}

export const AccessPortalSessionRequest: MessageFns<AccessPortalSessionRequest> = {
  encode(message: AccessPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(18).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(26).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessPortalSessionRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
    };
  },

  toJSON(message: AccessPortalSessionRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessPortalSessionRequest>, I>>(base?: I): AccessPortalSessionRequest {
    return AccessPortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessPortalSessionRequest>, I>>(object: I): AccessPortalSessionRequest {
    const message = createBaseAccessPortalSessionRequest();
    message.token = object.token ?? "";
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    return message;
  },
};

function createBaseAccessPortalSessionResponse(): AccessPortalSessionResponse {
  return { session: undefined };
}

export const AccessPortalSessionResponse: MessageFns<AccessPortalSessionResponse> = {
  encode(message: AccessPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessPortalSessionResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: AccessPortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessPortalSessionResponse>, I>>(base?: I): AccessPortalSessionResponse {
    return AccessPortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessPortalSessionResponse>, I>>(object: I): AccessPortalSessionResponse {
    const message = createBaseAccessPortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseConsumePortalTokenRequest(): ConsumePortalTokenRequest {
  return { token: "", action: 0, ipAddressHash: undefined, userAgentHash: undefined, requestId: undefined };
}

export const ConsumePortalTokenRequest: MessageFns<ConsumePortalTokenRequest> = {
  encode(message: ConsumePortalTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(26).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(34).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumePortalTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumePortalTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumePortalTokenRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      action: isSet(object.action) ? portalSessionActionFromJSON(object.action) : 0,
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
    };
  },

  toJSON(message: ConsumePortalTokenRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.action !== 0) {
      obj.action = portalSessionActionToJSON(message.action);
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumePortalTokenRequest>, I>>(base?: I): ConsumePortalTokenRequest {
    return ConsumePortalTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumePortalTokenRequest>, I>>(object: I): ConsumePortalTokenRequest {
    const message = createBaseConsumePortalTokenRequest();
    message.token = object.token ?? "";
    message.action = object.action ?? 0;
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    return message;
  },
};

function createBaseConsumePortalTokenResponse(): ConsumePortalTokenResponse {
  return { session: undefined };
}

export const ConsumePortalTokenResponse: MessageFns<ConsumePortalTokenResponse> = {
  encode(message: ConsumePortalTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumePortalTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumePortalTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumePortalTokenResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: ConsumePortalTokenResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumePortalTokenResponse>, I>>(base?: I): ConsumePortalTokenResponse {
    return ConsumePortalTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumePortalTokenResponse>, I>>(object: I): ConsumePortalTokenResponse {
    const message = createBaseConsumePortalTokenResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseCancelPortalSessionRequest(): CancelPortalSessionRequest {
  return { sessionId: "", reason: undefined };
}

export const CancelPortalSessionRequest: MessageFns<CancelPortalSessionRequest> = {
  encode(message: CancelPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.reason !== undefined) {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPortalSessionRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: CancelPortalSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPortalSessionRequest>, I>>(base?: I): CancelPortalSessionRequest {
    return CancelPortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPortalSessionRequest>, I>>(object: I): CancelPortalSessionRequest {
    const message = createBaseCancelPortalSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseCancelPortalSessionResponse(): CancelPortalSessionResponse {
  return { session: undefined };
}

export const CancelPortalSessionResponse: MessageFns<CancelPortalSessionResponse> = {
  encode(message: CancelPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPortalSessionResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: CancelPortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPortalSessionResponse>, I>>(base?: I): CancelPortalSessionResponse {
    return CancelPortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPortalSessionResponse>, I>>(object: I): CancelPortalSessionResponse {
    const message = createBaseCancelPortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdatePortalPspInfoRequest(): UpdatePortalPspInfoRequest {
  return { sessionId: "", pspState: "", pspRedirectUrl: "", pspProvider: 0, pspSessionId: "" };
}

export const UpdatePortalPspInfoRequest: MessageFns<UpdatePortalPspInfoRequest> = {
  encode(message: UpdatePortalPspInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.pspState !== "") {
      writer.uint32(18).string(message.pspState);
    }
    if (message.pspRedirectUrl !== "") {
      writer.uint32(26).string(message.pspRedirectUrl);
    }
    if (message.pspProvider !== 0) {
      writer.uint32(32).int32(message.pspProvider);
    }
    if (message.pspSessionId !== "") {
      writer.uint32(42).string(message.pspSessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePortalPspInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePortalPspInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pspState = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pspRedirectUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pspProvider = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pspSessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePortalPspInfoRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      pspState: isSet(object.pspState)
        ? globalThis.String(object.pspState)
        : isSet(object.psp_state)
        ? globalThis.String(object.psp_state)
        : "",
      pspRedirectUrl: isSet(object.pspRedirectUrl)
        ? globalThis.String(object.pspRedirectUrl)
        : isSet(object.psp_redirect_url)
        ? globalThis.String(object.psp_redirect_url)
        : "",
      pspProvider: isSet(object.pspProvider)
        ? portalPspProviderFromJSON(object.pspProvider)
        : isSet(object.psp_provider)
        ? portalPspProviderFromJSON(object.psp_provider)
        : 0,
      pspSessionId: isSet(object.pspSessionId)
        ? globalThis.String(object.pspSessionId)
        : isSet(object.psp_session_id)
        ? globalThis.String(object.psp_session_id)
        : "",
    };
  },

  toJSON(message: UpdatePortalPspInfoRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.pspState !== "") {
      obj.pspState = message.pspState;
    }
    if (message.pspRedirectUrl !== "") {
      obj.pspRedirectUrl = message.pspRedirectUrl;
    }
    if (message.pspProvider !== 0) {
      obj.pspProvider = portalPspProviderToJSON(message.pspProvider);
    }
    if (message.pspSessionId !== "") {
      obj.pspSessionId = message.pspSessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePortalPspInfoRequest>, I>>(base?: I): UpdatePortalPspInfoRequest {
    return UpdatePortalPspInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePortalPspInfoRequest>, I>>(object: I): UpdatePortalPspInfoRequest {
    const message = createBaseUpdatePortalPspInfoRequest();
    message.sessionId = object.sessionId ?? "";
    message.pspState = object.pspState ?? "";
    message.pspRedirectUrl = object.pspRedirectUrl ?? "";
    message.pspProvider = object.pspProvider ?? 0;
    message.pspSessionId = object.pspSessionId ?? "";
    return message;
  },
};

function createBaseUpdatePortalPspInfoResponse(): UpdatePortalPspInfoResponse {
  return { success: false };
}

export const UpdatePortalPspInfoResponse: MessageFns<UpdatePortalPspInfoResponse> = {
  encode(message: UpdatePortalPspInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePortalPspInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePortalPspInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePortalPspInfoResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UpdatePortalPspInfoResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePortalPspInfoResponse>, I>>(base?: I): UpdatePortalPspInfoResponse {
    return UpdatePortalPspInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePortalPspInfoResponse>, I>>(object: I): UpdatePortalPspInfoResponse {
    const message = createBaseUpdatePortalPspInfoResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseTransitionPortalSessionRequest(): TransitionPortalSessionRequest {
  return { sessionId: "", newStatus: 0, reason: undefined, ipAddressHash: undefined, userAgentHash: undefined };
}

export const TransitionPortalSessionRequest: MessageFns<TransitionPortalSessionRequest> = {
  encode(message: TransitionPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.newStatus !== 0) {
      writer.uint32(16).int32(message.newStatus);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(34).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(42).string(message.userAgentHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionPortalSessionRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      newStatus: isSet(object.newStatus)
        ? portalSessionStatusFromJSON(object.newStatus)
        : isSet(object.new_status)
        ? portalSessionStatusFromJSON(object.new_status)
        : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
    };
  },

  toJSON(message: TransitionPortalSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.newStatus !== 0) {
      obj.newStatus = portalSessionStatusToJSON(message.newStatus);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransitionPortalSessionRequest>, I>>(base?: I): TransitionPortalSessionRequest {
    return TransitionPortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransitionPortalSessionRequest>, I>>(
    object: I,
  ): TransitionPortalSessionRequest {
    const message = createBaseTransitionPortalSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.newStatus = object.newStatus ?? 0;
    message.reason = object.reason ?? undefined;
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    return message;
  },
};

function createBaseTransitionPortalSessionResponse(): TransitionPortalSessionResponse {
  return { session: undefined };
}

export const TransitionPortalSessionResponse: MessageFns<TransitionPortalSessionResponse> = {
  encode(message: TransitionPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionPortalSessionResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: TransitionPortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransitionPortalSessionResponse>, I>>(base?: I): TransitionPortalSessionResponse {
    return TransitionPortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransitionPortalSessionResponse>, I>>(
    object: I,
  ): TransitionPortalSessionResponse {
    const message = createBaseTransitionPortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBasePortalSessionAuditLog(): PortalSessionAuditLog {
  return {
    id: "",
    portalSessionId: "",
    eventType: 0,
    actorType: 0,
    previousStatus: undefined,
    newStatus: undefined,
    ipAddressHash: undefined,
    userAgentHash: undefined,
    requestId: undefined,
    correlationId: undefined,
    data: {},
    timestamp: "",
  };
}

export const PortalSessionAuditLog: MessageFns<PortalSessionAuditLog> = {
  encode(message: PortalSessionAuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.portalSessionId !== "") {
      writer.uint32(18).string(message.portalSessionId);
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.actorType !== 0) {
      writer.uint32(32).int32(message.actorType);
    }
    if (message.previousStatus !== undefined) {
      writer.uint32(42).string(message.previousStatus);
    }
    if (message.newStatus !== undefined) {
      writer.uint32(50).string(message.newStatus);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(58).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(66).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(74).string(message.requestId);
    }
    if (message.correlationId !== undefined) {
      writer.uint32(82).string(message.correlationId);
    }
    globalThis.Object.entries(message.data).forEach(([key, value]: [string, string]) => {
      PortalSessionAuditLog_DataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.timestamp !== "") {
      writer.uint32(98).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalSessionAuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalSessionAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.portalSessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actorType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.previousStatus = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.newStatus = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = PortalSessionAuditLog_DataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.data[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalSessionAuditLog {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      portalSessionId: isSet(object.portalSessionId)
        ? globalThis.String(object.portalSessionId)
        : isSet(object.portal_session_id)
        ? globalThis.String(object.portal_session_id)
        : "",
      eventType: isSet(object.eventType)
        ? portalAuditEventTypeFromJSON(object.eventType)
        : isSet(object.event_type)
        ? portalAuditEventTypeFromJSON(object.event_type)
        : 0,
      actorType: isSet(object.actorType)
        ? portalAuditActorTypeFromJSON(object.actorType)
        : isSet(object.actor_type)
        ? portalAuditActorTypeFromJSON(object.actor_type)
        : 0,
      previousStatus: isSet(object.previousStatus)
        ? globalThis.String(object.previousStatus)
        : isSet(object.previous_status)
        ? globalThis.String(object.previous_status)
        : undefined,
      newStatus: isSet(object.newStatus)
        ? globalThis.String(object.newStatus)
        : isSet(object.new_status)
        ? globalThis.String(object.new_status)
        : undefined,
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
      correlationId: isSet(object.correlationId)
        ? globalThis.String(object.correlationId)
        : isSet(object.correlation_id)
        ? globalThis.String(object.correlation_id)
        : undefined,
      data: isObject(object.data)
        ? (globalThis.Object.entries(object.data) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: PortalSessionAuditLog): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.portalSessionId !== "") {
      obj.portalSessionId = message.portalSessionId;
    }
    if (message.eventType !== 0) {
      obj.eventType = portalAuditEventTypeToJSON(message.eventType);
    }
    if (message.actorType !== 0) {
      obj.actorType = portalAuditActorTypeToJSON(message.actorType);
    }
    if (message.previousStatus !== undefined) {
      obj.previousStatus = message.previousStatus;
    }
    if (message.newStatus !== undefined) {
      obj.newStatus = message.newStatus;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    if (message.correlationId !== undefined) {
      obj.correlationId = message.correlationId;
    }
    if (message.data) {
      const entries = globalThis.Object.entries(message.data) as [string, string][];
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalSessionAuditLog>, I>>(base?: I): PortalSessionAuditLog {
    return PortalSessionAuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalSessionAuditLog>, I>>(object: I): PortalSessionAuditLog {
    const message = createBasePortalSessionAuditLog();
    message.id = object.id ?? "";
    message.portalSessionId = object.portalSessionId ?? "";
    message.eventType = object.eventType ?? 0;
    message.actorType = object.actorType ?? 0;
    message.previousStatus = object.previousStatus ?? undefined;
    message.newStatus = object.newStatus ?? undefined;
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    message.correlationId = object.correlationId ?? undefined;
    message.data = (globalThis.Object.entries(object.data ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBasePortalSessionAuditLog_DataEntry(): PortalSessionAuditLog_DataEntry {
  return { key: "", value: "" };
}

export const PortalSessionAuditLog_DataEntry: MessageFns<PortalSessionAuditLog_DataEntry> = {
  encode(message: PortalSessionAuditLog_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalSessionAuditLog_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalSessionAuditLog_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalSessionAuditLog_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PortalSessionAuditLog_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalSessionAuditLog_DataEntry>, I>>(base?: I): PortalSessionAuditLog_DataEntry {
    return PortalSessionAuditLog_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalSessionAuditLog_DataEntry>, I>>(
    object: I,
  ): PortalSessionAuditLog_DataEntry {
    const message = createBasePortalSessionAuditLog_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListPortalSessionsRequest(): ListPortalSessionsRequest {
  return {
    organisationId: "",
    societeId: undefined,
    customerId: undefined,
    status: undefined,
    fromDate: undefined,
    toDate: undefined,
    page: undefined,
    limit: undefined,
  };
}

export const ListPortalSessionsRequest: MessageFns<ListPortalSessionsRequest> = {
  encode(message: ListPortalSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.customerId !== undefined) {
      writer.uint32(26).string(message.customerId);
    }
    if (message.status !== undefined) {
      writer.uint32(32).int32(message.status);
    }
    if (message.fromDate !== undefined) {
      writer.uint32(42).string(message.fromDate);
    }
    if (message.toDate !== undefined) {
      writer.uint32(50).string(message.toDate);
    }
    if (message.page !== undefined) {
      writer.uint32(56).int32(message.page);
    }
    if (message.limit !== undefined) {
      writer.uint32(64).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortalSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortalSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPortalSessionsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      status: isSet(object.status) ? portalSessionStatusFromJSON(object.status) : undefined,
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: ListPortalSessionsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.status !== undefined) {
      obj.status = portalSessionStatusToJSON(message.status);
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPortalSessionsRequest>, I>>(base?: I): ListPortalSessionsRequest {
    return ListPortalSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPortalSessionsRequest>, I>>(object: I): ListPortalSessionsRequest {
    const message = createBaseListPortalSessionsRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.customerId = object.customerId ?? undefined;
    message.status = object.status ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.page = object.page ?? undefined;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseListPortalSessionsResponse(): ListPortalSessionsResponse {
  return { sessions: [], total: 0, page: 0, totalPages: 0 };
}

export const ListPortalSessionsResponse: MessageFns<ListPortalSessionsResponse> = {
  encode(message: ListPortalSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      PortalPaymentSession.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortalSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortalSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(PortalPaymentSession.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPortalSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => PortalPaymentSession.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: ListPortalSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => PortalPaymentSession.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPortalSessionsResponse>, I>>(base?: I): ListPortalSessionsResponse {
    return ListPortalSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPortalSessionsResponse>, I>>(object: I): ListPortalSessionsResponse {
    const message = createBaseListPortalSessionsResponse();
    message.sessions = object.sessions?.map((e) => PortalPaymentSession.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetPortalSessionAuditRequest(): GetPortalSessionAuditRequest {
  return { sessionId: "" };
}

export const GetPortalSessionAuditRequest: MessageFns<GetPortalSessionAuditRequest> = {
  encode(message: GetPortalSessionAuditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionAuditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionAuditRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: GetPortalSessionAuditRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionAuditRequest>, I>>(base?: I): GetPortalSessionAuditRequest {
    return GetPortalSessionAuditRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionAuditRequest>, I>>(object: I): GetPortalSessionAuditRequest {
    const message = createBaseGetPortalSessionAuditRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseGetPortalSessionAuditResponse(): GetPortalSessionAuditResponse {
  return { logs: [] };
}

export const GetPortalSessionAuditResponse: MessageFns<GetPortalSessionAuditResponse> = {
  encode(message: GetPortalSessionAuditResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      PortalSessionAuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionAuditResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(PortalSessionAuditLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionAuditResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs)
        ? object.logs.map((e: any) => PortalSessionAuditLog.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPortalSessionAuditResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => PortalSessionAuditLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionAuditResponse>, I>>(base?: I): GetPortalSessionAuditResponse {
    return GetPortalSessionAuditResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionAuditResponse>, I>>(
    object: I,
  ): GetPortalSessionAuditResponse {
    const message = createBaseGetPortalSessionAuditResponse();
    message.logs = object.logs?.map((e) => PortalSessionAuditLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPortalSessionStatsRequest(): GetPortalSessionStatsRequest {
  return { organisationId: "", societeId: undefined, fromDate: "", toDate: "" };
}

export const GetPortalSessionStatsRequest: MessageFns<GetPortalSessionStatsRequest> = {
  encode(message: GetPortalSessionStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.fromDate !== "") {
      writer.uint32(26).string(message.fromDate);
    }
    if (message.toDate !== "") {
      writer.uint32(34).string(message.toDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionStatsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : "",
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : "",
    };
  },

  toJSON(message: GetPortalSessionStatsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.fromDate !== "") {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== "") {
      obj.toDate = message.toDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionStatsRequest>, I>>(base?: I): GetPortalSessionStatsRequest {
    return GetPortalSessionStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionStatsRequest>, I>>(object: I): GetPortalSessionStatsRequest {
    const message = createBaseGetPortalSessionStatsRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.fromDate = object.fromDate ?? "";
    message.toDate = object.toDate ?? "";
    return message;
  },
};

function createBaseGetPortalSessionStatsResponse(): GetPortalSessionStatsResponse {
  return { totalCreated: 0, totalCompleted: 0, totalFailed: 0, totalExpired: 0, totalCancelled: 0, completionRate: 0 };
}

export const GetPortalSessionStatsResponse: MessageFns<GetPortalSessionStatsResponse> = {
  encode(message: GetPortalSessionStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCreated !== 0) {
      writer.uint32(8).int32(message.totalCreated);
    }
    if (message.totalCompleted !== 0) {
      writer.uint32(16).int32(message.totalCompleted);
    }
    if (message.totalFailed !== 0) {
      writer.uint32(24).int32(message.totalFailed);
    }
    if (message.totalExpired !== 0) {
      writer.uint32(32).int32(message.totalExpired);
    }
    if (message.totalCancelled !== 0) {
      writer.uint32(40).int32(message.totalCancelled);
    }
    if (message.completionRate !== 0) {
      writer.uint32(49).double(message.completionRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCreated = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCompleted = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalFailed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalExpired = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalCancelled = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.completionRate = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionStatsResponse {
    return {
      totalCreated: isSet(object.totalCreated)
        ? globalThis.Number(object.totalCreated)
        : isSet(object.total_created)
        ? globalThis.Number(object.total_created)
        : 0,
      totalCompleted: isSet(object.totalCompleted)
        ? globalThis.Number(object.totalCompleted)
        : isSet(object.total_completed)
        ? globalThis.Number(object.total_completed)
        : 0,
      totalFailed: isSet(object.totalFailed)
        ? globalThis.Number(object.totalFailed)
        : isSet(object.total_failed)
        ? globalThis.Number(object.total_failed)
        : 0,
      totalExpired: isSet(object.totalExpired)
        ? globalThis.Number(object.totalExpired)
        : isSet(object.total_expired)
        ? globalThis.Number(object.total_expired)
        : 0,
      totalCancelled: isSet(object.totalCancelled)
        ? globalThis.Number(object.totalCancelled)
        : isSet(object.total_cancelled)
        ? globalThis.Number(object.total_cancelled)
        : 0,
      completionRate: isSet(object.completionRate)
        ? globalThis.Number(object.completionRate)
        : isSet(object.completion_rate)
        ? globalThis.Number(object.completion_rate)
        : 0,
    };
  },

  toJSON(message: GetPortalSessionStatsResponse): unknown {
    const obj: any = {};
    if (message.totalCreated !== 0) {
      obj.totalCreated = Math.round(message.totalCreated);
    }
    if (message.totalCompleted !== 0) {
      obj.totalCompleted = Math.round(message.totalCompleted);
    }
    if (message.totalFailed !== 0) {
      obj.totalFailed = Math.round(message.totalFailed);
    }
    if (message.totalExpired !== 0) {
      obj.totalExpired = Math.round(message.totalExpired);
    }
    if (message.totalCancelled !== 0) {
      obj.totalCancelled = Math.round(message.totalCancelled);
    }
    if (message.completionRate !== 0) {
      obj.completionRate = message.completionRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionStatsResponse>, I>>(base?: I): GetPortalSessionStatsResponse {
    return GetPortalSessionStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionStatsResponse>, I>>(
    object: I,
  ): GetPortalSessionStatsResponse {
    const message = createBaseGetPortalSessionStatsResponse();
    message.totalCreated = object.totalCreated ?? 0;
    message.totalCompleted = object.totalCompleted ?? 0;
    message.totalFailed = object.totalFailed ?? 0;
    message.totalExpired = object.totalExpired ?? 0;
    message.totalCancelled = object.totalCancelled ?? 0;
    message.completionRate = object.completionRate ?? 0;
    return message;
  },
};

function createBasePortalRequestContext(): PortalRequestContext {
  return { ipHash: undefined, uaHash: undefined, requestId: undefined, correlationId: undefined };
}

export const PortalRequestContext: MessageFns<PortalRequestContext> = {
  encode(message: PortalRequestContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipHash !== undefined) {
      writer.uint32(10).string(message.ipHash);
    }
    if (message.uaHash !== undefined) {
      writer.uint32(18).string(message.uaHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(26).string(message.requestId);
    }
    if (message.correlationId !== undefined) {
      writer.uint32(34).string(message.correlationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalRequestContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalRequestContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uaHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalRequestContext {
    return {
      ipHash: isSet(object.ipHash)
        ? globalThis.String(object.ipHash)
        : isSet(object.ip_hash)
        ? globalThis.String(object.ip_hash)
        : undefined,
      uaHash: isSet(object.uaHash)
        ? globalThis.String(object.uaHash)
        : isSet(object.ua_hash)
        ? globalThis.String(object.ua_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
      correlationId: isSet(object.correlationId)
        ? globalThis.String(object.correlationId)
        : isSet(object.correlation_id)
        ? globalThis.String(object.correlation_id)
        : undefined,
    };
  },

  toJSON(message: PortalRequestContext): unknown {
    const obj: any = {};
    if (message.ipHash !== undefined) {
      obj.ipHash = message.ipHash;
    }
    if (message.uaHash !== undefined) {
      obj.uaHash = message.uaHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    if (message.correlationId !== undefined) {
      obj.correlationId = message.correlationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalRequestContext>, I>>(base?: I): PortalRequestContext {
    return PortalRequestContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalRequestContext>, I>>(object: I): PortalRequestContext {
    const message = createBasePortalRequestContext();
    message.ipHash = object.ipHash ?? undefined;
    message.uaHash = object.uaHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    message.correlationId = object.correlationId ?? undefined;
    return message;
  },
};

function createBaseGoCardlessConfig(): GoCardlessConfig {
  return { accessToken: "", baseUrl: "" };
}

export const GoCardlessConfig: MessageFns<GoCardlessConfig> = {
  encode(message: GoCardlessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessConfig {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      baseUrl: isSet(object.baseUrl)
        ? globalThis.String(object.baseUrl)
        : isSet(object.base_url)
        ? globalThis.String(object.base_url)
        : "",
    };
  },

  toJSON(message: GoCardlessConfig): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessConfig>, I>>(base?: I): GoCardlessConfig {
    return GoCardlessConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessConfig>, I>>(object: I): GoCardlessConfig {
    const message = createBaseGoCardlessConfig();
    message.accessToken = object.accessToken ?? "";
    message.baseUrl = object.baseUrl ?? "";
    return message;
  },
};

function createBaseSlimpayToken(): SlimpayToken {
  return { accessToken: "", expiresAt: 0 };
}

export const SlimpayToken: MessageFns<SlimpayToken> = {
  encode(message: SlimpayToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlimpayToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlimpayToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlimpayToken {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      expiresAt: isSet(object.expiresAt)
        ? globalThis.Number(object.expiresAt)
        : isSet(object.expires_at)
        ? globalThis.Number(object.expires_at)
        : 0,
    };
  },

  toJSON(message: SlimpayToken): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlimpayToken>, I>>(base?: I): SlimpayToken {
    return SlimpayToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlimpayToken>, I>>(object: I): SlimpayToken {
    const message = createBaseSlimpayToken();
    message.accessToken = object.accessToken ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function createBaseCreateSlimpayMandateRequest(): CreateSlimpayMandateRequest {
  return {
    societeId: "",
    clientId: "",
    scheme: "",
    subscriberReference: "",
    firstName: "",
    lastName: "",
    email: "",
    phone: undefined,
    iban: undefined,
    bic: undefined,
    successUrl: "",
    failureUrl: "",
    metadata: {},
  };
}

export const CreateSlimpayMandateRequest: MessageFns<CreateSlimpayMandateRequest> = {
  encode(message: CreateSlimpayMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.scheme !== "") {
      writer.uint32(26).string(message.scheme);
    }
    if (message.subscriberReference !== "") {
      writer.uint32(34).string(message.subscriberReference);
    }
    if (message.firstName !== "") {
      writer.uint32(42).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(50).string(message.lastName);
    }
    if (message.email !== "") {
      writer.uint32(58).string(message.email);
    }
    if (message.phone !== undefined) {
      writer.uint32(66).string(message.phone);
    }
    if (message.iban !== undefined) {
      writer.uint32(74).string(message.iban);
    }
    if (message.bic !== undefined) {
      writer.uint32(82).string(message.bic);
    }
    if (message.successUrl !== "") {
      writer.uint32(90).string(message.successUrl);
    }
    if (message.failureUrl !== "") {
      writer.uint32(98).string(message.failureUrl);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateSlimpayMandateRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSlimpayMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSlimpayMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subscriberReference = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.iban = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.failureUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          const entry13 = CreateSlimpayMandateRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.metadata[entry13.key] = entry13.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSlimpayMandateRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      subscriberReference: isSet(object.subscriberReference)
        ? globalThis.String(object.subscriberReference)
        : isSet(object.subscriber_reference)
        ? globalThis.String(object.subscriber_reference)
        : "",
      firstName: isSet(object.firstName)
        ? globalThis.String(object.firstName)
        : isSet(object.first_name)
        ? globalThis.String(object.first_name)
        : "",
      lastName: isSet(object.lastName)
        ? globalThis.String(object.lastName)
        : isSet(object.last_name)
        ? globalThis.String(object.last_name)
        : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      iban: isSet(object.iban) ? globalThis.String(object.iban) : undefined,
      bic: isSet(object.bic) ? globalThis.String(object.bic) : undefined,
      successUrl: isSet(object.successUrl)
        ? globalThis.String(object.successUrl)
        : isSet(object.success_url)
        ? globalThis.String(object.success_url)
        : "",
      failureUrl: isSet(object.failureUrl)
        ? globalThis.String(object.failureUrl)
        : isSet(object.failure_url)
        ? globalThis.String(object.failure_url)
        : "",
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateSlimpayMandateRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.subscriberReference !== "") {
      obj.subscriberReference = message.subscriberReference;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.iban !== undefined) {
      obj.iban = message.iban;
    }
    if (message.bic !== undefined) {
      obj.bic = message.bic;
    }
    if (message.successUrl !== "") {
      obj.successUrl = message.successUrl;
    }
    if (message.failureUrl !== "") {
      obj.failureUrl = message.failureUrl;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSlimpayMandateRequest>, I>>(base?: I): CreateSlimpayMandateRequest {
    return CreateSlimpayMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSlimpayMandateRequest>, I>>(object: I): CreateSlimpayMandateRequest {
    const message = createBaseCreateSlimpayMandateRequest();
    message.societeId = object.societeId ?? "";
    message.clientId = object.clientId ?? "";
    message.scheme = object.scheme ?? "";
    message.subscriberReference = object.subscriberReference ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.email = object.email ?? "";
    message.phone = object.phone ?? undefined;
    message.iban = object.iban ?? undefined;
    message.bic = object.bic ?? undefined;
    message.successUrl = object.successUrl ?? "";
    message.failureUrl = object.failureUrl ?? "";
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateSlimpayMandateRequest_MetadataEntry(): CreateSlimpayMandateRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateSlimpayMandateRequest_MetadataEntry: MessageFns<CreateSlimpayMandateRequest_MetadataEntry> = {
  encode(message: CreateSlimpayMandateRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSlimpayMandateRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSlimpayMandateRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSlimpayMandateRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSlimpayMandateRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSlimpayMandateRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateSlimpayMandateRequest_MetadataEntry {
    return CreateSlimpayMandateRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSlimpayMandateRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateSlimpayMandateRequest_MetadataEntry {
    const message = createBaseCreateSlimpayMandateRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSlimpayMandateResponse(): SlimpayMandateResponse {
  return {
    id: "",
    mandateId: "",
    clientId: "",
    status: "",
    scheme: "",
    rum: "",
    subscriberReference: undefined,
    bankName: undefined,
    ibanLast4: undefined,
    bic: undefined,
    signatureDate: undefined,
    redirectUrl: undefined,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const SlimpayMandateResponse: MessageFns<SlimpayMandateResponse> = {
  encode(message: SlimpayMandateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mandateId !== "") {
      writer.uint32(18).string(message.mandateId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.scheme !== "") {
      writer.uint32(42).string(message.scheme);
    }
    if (message.rum !== "") {
      writer.uint32(50).string(message.rum);
    }
    if (message.subscriberReference !== undefined) {
      writer.uint32(58).string(message.subscriberReference);
    }
    if (message.bankName !== undefined) {
      writer.uint32(66).string(message.bankName);
    }
    if (message.ibanLast4 !== undefined) {
      writer.uint32(74).string(message.ibanLast4);
    }
    if (message.bic !== undefined) {
      writer.uint32(82).string(message.bic);
    }
    if (message.signatureDate !== undefined) {
      writer.uint32(90).string(message.signatureDate);
    }
    if (message.redirectUrl !== undefined) {
      writer.uint32(98).string(message.redirectUrl);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlimpayMandateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlimpayMandateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rum = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.subscriberReference = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ibanLast4 = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.signatureDate = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlimpayMandateResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      rum: isSet(object.rum) ? globalThis.String(object.rum) : "",
      subscriberReference: isSet(object.subscriberReference)
        ? globalThis.String(object.subscriberReference)
        : isSet(object.subscriber_reference)
        ? globalThis.String(object.subscriber_reference)
        : undefined,
      bankName: isSet(object.bankName)
        ? globalThis.String(object.bankName)
        : isSet(object.bank_name)
        ? globalThis.String(object.bank_name)
        : undefined,
      ibanLast4: isSet(object.ibanLast4)
        ? globalThis.String(object.ibanLast4)
        : isSet(object.iban_last4)
        ? globalThis.String(object.iban_last4)
        : undefined,
      bic: isSet(object.bic) ? globalThis.String(object.bic) : undefined,
      signatureDate: isSet(object.signatureDate)
        ? globalThis.String(object.signatureDate)
        : isSet(object.signature_date)
        ? globalThis.String(object.signature_date)
        : undefined,
      redirectUrl: isSet(object.redirectUrl)
        ? globalThis.String(object.redirectUrl)
        : isSet(object.redirect_url)
        ? globalThis.String(object.redirect_url)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: SlimpayMandateResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.rum !== "") {
      obj.rum = message.rum;
    }
    if (message.subscriberReference !== undefined) {
      obj.subscriberReference = message.subscriberReference;
    }
    if (message.bankName !== undefined) {
      obj.bankName = message.bankName;
    }
    if (message.ibanLast4 !== undefined) {
      obj.ibanLast4 = message.ibanLast4;
    }
    if (message.bic !== undefined) {
      obj.bic = message.bic;
    }
    if (message.signatureDate !== undefined) {
      obj.signatureDate = message.signatureDate;
    }
    if (message.redirectUrl !== undefined) {
      obj.redirectUrl = message.redirectUrl;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlimpayMandateResponse>, I>>(base?: I): SlimpayMandateResponse {
    return SlimpayMandateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlimpayMandateResponse>, I>>(object: I): SlimpayMandateResponse {
    const message = createBaseSlimpayMandateResponse();
    message.id = object.id ?? "";
    message.mandateId = object.mandateId ?? "";
    message.clientId = object.clientId ?? "";
    message.status = object.status ?? "";
    message.scheme = object.scheme ?? "";
    message.rum = object.rum ?? "";
    message.subscriberReference = object.subscriberReference ?? undefined;
    message.bankName = object.bankName ?? undefined;
    message.ibanLast4 = object.ibanLast4 ?? undefined;
    message.bic = object.bic ?? undefined;
    message.signatureDate = object.signatureDate ?? undefined;
    message.redirectUrl = object.redirectUrl ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetSlimpayMandateRequest(): GetSlimpayMandateRequest {
  return { mandateId: "", societeId: "" };
}

export const GetSlimpayMandateRequest: MessageFns<GetSlimpayMandateRequest> = {
  encode(message: GetSlimpayMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mandateId !== "") {
      writer.uint32(10).string(message.mandateId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSlimpayMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSlimpayMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSlimpayMandateRequest {
    return {
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetSlimpayMandateRequest): unknown {
    const obj: any = {};
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSlimpayMandateRequest>, I>>(base?: I): GetSlimpayMandateRequest {
    return GetSlimpayMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSlimpayMandateRequest>, I>>(object: I): GetSlimpayMandateRequest {
    const message = createBaseGetSlimpayMandateRequest();
    message.mandateId = object.mandateId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCancelSlimpayMandateRequest(): CancelSlimpayMandateRequest {
  return { mandateId: "", societeId: "", reason: undefined };
}

export const CancelSlimpayMandateRequest: MessageFns<CancelSlimpayMandateRequest> = {
  encode(message: CancelSlimpayMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mandateId !== "") {
      writer.uint32(10).string(message.mandateId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelSlimpayMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSlimpayMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSlimpayMandateRequest {
    return {
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: CancelSlimpayMandateRequest): unknown {
    const obj: any = {};
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelSlimpayMandateRequest>, I>>(base?: I): CancelSlimpayMandateRequest {
    return CancelSlimpayMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelSlimpayMandateRequest>, I>>(object: I): CancelSlimpayMandateRequest {
    const message = createBaseCancelSlimpayMandateRequest();
    message.mandateId = object.mandateId ?? "";
    message.societeId = object.societeId ?? "";
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseCreateSlimpayPaymentRequest(): CreateSlimpayPaymentRequest {
  return {
    societeId: "",
    mandateId: "",
    amountCents: 0,
    currency: "",
    label: "",
    executionDate: undefined,
    idempotencyKey: undefined,
    metadata: {},
  };
}

export const CreateSlimpayPaymentRequest: MessageFns<CreateSlimpayPaymentRequest> = {
  encode(message: CreateSlimpayPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.mandateId !== "") {
      writer.uint32(18).string(message.mandateId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.label !== "") {
      writer.uint32(42).string(message.label);
    }
    if (message.executionDate !== undefined) {
      writer.uint32(50).string(message.executionDate);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(58).string(message.idempotencyKey);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateSlimpayPaymentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSlimpayPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSlimpayPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.executionDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = CreateSlimpayPaymentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSlimpayPaymentRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      executionDate: isSet(object.executionDate)
        ? globalThis.String(object.executionDate)
        : isSet(object.execution_date)
        ? globalThis.String(object.execution_date)
        : undefined,
      idempotencyKey: isSet(object.idempotencyKey)
        ? globalThis.String(object.idempotencyKey)
        : isSet(object.idempotency_key)
        ? globalThis.String(object.idempotency_key)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateSlimpayPaymentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.executionDate !== undefined) {
      obj.executionDate = message.executionDate;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSlimpayPaymentRequest>, I>>(base?: I): CreateSlimpayPaymentRequest {
    return CreateSlimpayPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSlimpayPaymentRequest>, I>>(object: I): CreateSlimpayPaymentRequest {
    const message = createBaseCreateSlimpayPaymentRequest();
    message.societeId = object.societeId ?? "";
    message.mandateId = object.mandateId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.label = object.label ?? "";
    message.executionDate = object.executionDate ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateSlimpayPaymentRequest_MetadataEntry(): CreateSlimpayPaymentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateSlimpayPaymentRequest_MetadataEntry: MessageFns<CreateSlimpayPaymentRequest_MetadataEntry> = {
  encode(message: CreateSlimpayPaymentRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSlimpayPaymentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSlimpayPaymentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSlimpayPaymentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSlimpayPaymentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSlimpayPaymentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateSlimpayPaymentRequest_MetadataEntry {
    return CreateSlimpayPaymentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSlimpayPaymentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateSlimpayPaymentRequest_MetadataEntry {
    const message = createBaseCreateSlimpayPaymentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSlimpayPaymentResponse(): SlimpayPaymentResponse {
  return {
    id: "",
    paymentId: "",
    mandateId: "",
    amountCents: 0,
    currency: "",
    status: "",
    label: undefined,
    executionDate: undefined,
    rejectionReason: undefined,
    rejectionCode: undefined,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const SlimpayPaymentResponse: MessageFns<SlimpayPaymentResponse> = {
  encode(message: SlimpayPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.mandateId !== "") {
      writer.uint32(26).string(message.mandateId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.label !== undefined) {
      writer.uint32(58).string(message.label);
    }
    if (message.executionDate !== undefined) {
      writer.uint32(66).string(message.executionDate);
    }
    if (message.rejectionReason !== undefined) {
      writer.uint32(74).string(message.rejectionReason);
    }
    if (message.rejectionCode !== undefined) {
      writer.uint32(82).string(message.rejectionCode);
    }
    if (message.createdAt !== "") {
      writer.uint32(90).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(98).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlimpayPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlimpayPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.executionDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rejectionReason = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rejectionCode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlimpayPaymentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : "",
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : undefined,
      executionDate: isSet(object.executionDate)
        ? globalThis.String(object.executionDate)
        : isSet(object.execution_date)
        ? globalThis.String(object.execution_date)
        : undefined,
      rejectionReason: isSet(object.rejectionReason)
        ? globalThis.String(object.rejectionReason)
        : isSet(object.rejection_reason)
        ? globalThis.String(object.rejection_reason)
        : undefined,
      rejectionCode: isSet(object.rejectionCode)
        ? globalThis.String(object.rejectionCode)
        : isSet(object.rejection_code)
        ? globalThis.String(object.rejection_code)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: SlimpayPaymentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.label !== undefined) {
      obj.label = message.label;
    }
    if (message.executionDate !== undefined) {
      obj.executionDate = message.executionDate;
    }
    if (message.rejectionReason !== undefined) {
      obj.rejectionReason = message.rejectionReason;
    }
    if (message.rejectionCode !== undefined) {
      obj.rejectionCode = message.rejectionCode;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlimpayPaymentResponse>, I>>(base?: I): SlimpayPaymentResponse {
    return SlimpayPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlimpayPaymentResponse>, I>>(object: I): SlimpayPaymentResponse {
    const message = createBaseSlimpayPaymentResponse();
    message.id = object.id ?? "";
    message.paymentId = object.paymentId ?? "";
    message.mandateId = object.mandateId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.label = object.label ?? undefined;
    message.executionDate = object.executionDate ?? undefined;
    message.rejectionReason = object.rejectionReason ?? undefined;
    message.rejectionCode = object.rejectionCode ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetSlimpayPaymentRequest(): GetSlimpayPaymentRequest {
  return { paymentId: "", societeId: "" };
}

export const GetSlimpayPaymentRequest: MessageFns<GetSlimpayPaymentRequest> = {
  encode(message: GetSlimpayPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSlimpayPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSlimpayPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSlimpayPaymentRequest {
    return {
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetSlimpayPaymentRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSlimpayPaymentRequest>, I>>(base?: I): GetSlimpayPaymentRequest {
    return GetSlimpayPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSlimpayPaymentRequest>, I>>(object: I): GetSlimpayPaymentRequest {
    const message = createBaseGetSlimpayPaymentRequest();
    message.paymentId = object.paymentId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateMultiSafepayTransactionRequest(): CreateMultiSafepayTransactionRequest {
  return {
    societeId: "",
    orderId: "",
    amountCents: 0,
    currency: "",
    paymentType: "",
    gateway: "",
    description: undefined,
    notificationUrl: "",
    redirectUrl: "",
    cancelUrl: "",
    customerEmail: undefined,
    customerFirstName: undefined,
    customerLastName: undefined,
    metadata: {},
  };
}

export const CreateMultiSafepayTransactionRequest: MessageFns<CreateMultiSafepayTransactionRequest> = {
  encode(message: CreateMultiSafepayTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.paymentType !== "") {
      writer.uint32(42).string(message.paymentType);
    }
    if (message.gateway !== "") {
      writer.uint32(50).string(message.gateway);
    }
    if (message.description !== undefined) {
      writer.uint32(58).string(message.description);
    }
    if (message.notificationUrl !== "") {
      writer.uint32(66).string(message.notificationUrl);
    }
    if (message.redirectUrl !== "") {
      writer.uint32(74).string(message.redirectUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(82).string(message.cancelUrl);
    }
    if (message.customerEmail !== undefined) {
      writer.uint32(90).string(message.customerEmail);
    }
    if (message.customerFirstName !== undefined) {
      writer.uint32(98).string(message.customerFirstName);
    }
    if (message.customerLastName !== undefined) {
      writer.uint32(106).string(message.customerLastName);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateMultiSafepayTransactionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(114).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMultiSafepayTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMultiSafepayTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gateway = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.notificationUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.customerEmail = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.customerFirstName = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.customerLastName = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = CreateMultiSafepayTransactionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.metadata[entry14.key] = entry14.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMultiSafepayTransactionRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      orderId: isSet(object.orderId)
        ? globalThis.String(object.orderId)
        : isSet(object.order_id)
        ? globalThis.String(object.order_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      paymentType: isSet(object.paymentType)
        ? globalThis.String(object.paymentType)
        : isSet(object.payment_type)
        ? globalThis.String(object.payment_type)
        : "",
      gateway: isSet(object.gateway) ? globalThis.String(object.gateway) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      notificationUrl: isSet(object.notificationUrl)
        ? globalThis.String(object.notificationUrl)
        : isSet(object.notification_url)
        ? globalThis.String(object.notification_url)
        : "",
      redirectUrl: isSet(object.redirectUrl)
        ? globalThis.String(object.redirectUrl)
        : isSet(object.redirect_url)
        ? globalThis.String(object.redirect_url)
        : "",
      cancelUrl: isSet(object.cancelUrl)
        ? globalThis.String(object.cancelUrl)
        : isSet(object.cancel_url)
        ? globalThis.String(object.cancel_url)
        : "",
      customerEmail: isSet(object.customerEmail)
        ? globalThis.String(object.customerEmail)
        : isSet(object.customer_email)
        ? globalThis.String(object.customer_email)
        : undefined,
      customerFirstName: isSet(object.customerFirstName)
        ? globalThis.String(object.customerFirstName)
        : isSet(object.customer_first_name)
        ? globalThis.String(object.customer_first_name)
        : undefined,
      customerLastName: isSet(object.customerLastName)
        ? globalThis.String(object.customerLastName)
        : isSet(object.customer_last_name)
        ? globalThis.String(object.customer_last_name)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateMultiSafepayTransactionRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.paymentType !== "") {
      obj.paymentType = message.paymentType;
    }
    if (message.gateway !== "") {
      obj.gateway = message.gateway;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.notificationUrl !== "") {
      obj.notificationUrl = message.notificationUrl;
    }
    if (message.redirectUrl !== "") {
      obj.redirectUrl = message.redirectUrl;
    }
    if (message.cancelUrl !== "") {
      obj.cancelUrl = message.cancelUrl;
    }
    if (message.customerEmail !== undefined) {
      obj.customerEmail = message.customerEmail;
    }
    if (message.customerFirstName !== undefined) {
      obj.customerFirstName = message.customerFirstName;
    }
    if (message.customerLastName !== undefined) {
      obj.customerLastName = message.customerLastName;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMultiSafepayTransactionRequest>, I>>(
    base?: I,
  ): CreateMultiSafepayTransactionRequest {
    return CreateMultiSafepayTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMultiSafepayTransactionRequest>, I>>(
    object: I,
  ): CreateMultiSafepayTransactionRequest {
    const message = createBaseCreateMultiSafepayTransactionRequest();
    message.societeId = object.societeId ?? "";
    message.orderId = object.orderId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.paymentType = object.paymentType ?? "";
    message.gateway = object.gateway ?? "";
    message.description = object.description ?? undefined;
    message.notificationUrl = object.notificationUrl ?? "";
    message.redirectUrl = object.redirectUrl ?? "";
    message.cancelUrl = object.cancelUrl ?? "";
    message.customerEmail = object.customerEmail ?? undefined;
    message.customerFirstName = object.customerFirstName ?? undefined;
    message.customerLastName = object.customerLastName ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateMultiSafepayTransactionRequest_MetadataEntry(): CreateMultiSafepayTransactionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateMultiSafepayTransactionRequest_MetadataEntry: MessageFns<
  CreateMultiSafepayTransactionRequest_MetadataEntry
> = {
  encode(
    message: CreateMultiSafepayTransactionRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMultiSafepayTransactionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMultiSafepayTransactionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMultiSafepayTransactionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateMultiSafepayTransactionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMultiSafepayTransactionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateMultiSafepayTransactionRequest_MetadataEntry {
    return CreateMultiSafepayTransactionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMultiSafepayTransactionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateMultiSafepayTransactionRequest_MetadataEntry {
    const message = createBaseCreateMultiSafepayTransactionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMultiSafepayTransactionResponse(): MultiSafepayTransactionResponse {
  return {
    id: "",
    transactionId: "",
    orderId: "",
    amountCents: 0,
    currency: "",
    status: "",
    gateway: "",
    paymentUrl: undefined,
    reason: undefined,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const MultiSafepayTransactionResponse: MessageFns<MultiSafepayTransactionResponse> = {
  encode(message: MultiSafepayTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.orderId !== "") {
      writer.uint32(26).string(message.orderId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.gateway !== "") {
      writer.uint32(58).string(message.gateway);
    }
    if (message.paymentUrl !== undefined) {
      writer.uint32(66).string(message.paymentUrl);
    }
    if (message.reason !== undefined) {
      writer.uint32(74).string(message.reason);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiSafepayTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiSafepayTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gateway = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.paymentUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiSafepayTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      orderId: isSet(object.orderId)
        ? globalThis.String(object.orderId)
        : isSet(object.order_id)
        ? globalThis.String(object.order_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      gateway: isSet(object.gateway) ? globalThis.String(object.gateway) : "",
      paymentUrl: isSet(object.paymentUrl)
        ? globalThis.String(object.paymentUrl)
        : isSet(object.payment_url)
        ? globalThis.String(object.payment_url)
        : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: MultiSafepayTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.gateway !== "") {
      obj.gateway = message.gateway;
    }
    if (message.paymentUrl !== undefined) {
      obj.paymentUrl = message.paymentUrl;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiSafepayTransactionResponse>, I>>(base?: I): MultiSafepayTransactionResponse {
    return MultiSafepayTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiSafepayTransactionResponse>, I>>(
    object: I,
  ): MultiSafepayTransactionResponse {
    const message = createBaseMultiSafepayTransactionResponse();
    message.id = object.id ?? "";
    message.transactionId = object.transactionId ?? "";
    message.orderId = object.orderId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.gateway = object.gateway ?? "";
    message.paymentUrl = object.paymentUrl ?? undefined;
    message.reason = object.reason ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetMultiSafepayTransactionRequest(): GetMultiSafepayTransactionRequest {
  return { transactionId: "", societeId: "" };
}

export const GetMultiSafepayTransactionRequest: MessageFns<GetMultiSafepayTransactionRequest> = {
  encode(message: GetMultiSafepayTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMultiSafepayTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMultiSafepayTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMultiSafepayTransactionRequest {
    return {
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetMultiSafepayTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMultiSafepayTransactionRequest>, I>>(
    base?: I,
  ): GetMultiSafepayTransactionRequest {
    return GetMultiSafepayTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMultiSafepayTransactionRequest>, I>>(
    object: I,
  ): GetMultiSafepayTransactionRequest {
    const message = createBaseGetMultiSafepayTransactionRequest();
    message.transactionId = object.transactionId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseRefundMultiSafepayTransactionRequest(): RefundMultiSafepayTransactionRequest {
  return { transactionId: "", societeId: "", amountCents: 0, description: undefined };
}

export const RefundMultiSafepayTransactionRequest: MessageFns<RefundMultiSafepayTransactionRequest> = {
  encode(message: RefundMultiSafepayTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int64(message.amountCents);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundMultiSafepayTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundMultiSafepayTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundMultiSafepayTransactionRequest {
    return {
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
    };
  },

  toJSON(message: RefundMultiSafepayTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundMultiSafepayTransactionRequest>, I>>(
    base?: I,
  ): RefundMultiSafepayTransactionRequest {
    return RefundMultiSafepayTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundMultiSafepayTransactionRequest>, I>>(
    object: I,
  ): RefundMultiSafepayTransactionRequest {
    const message = createBaseRefundMultiSafepayTransactionRequest();
    message.transactionId = object.transactionId ?? "";
    message.societeId = object.societeId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBaseCreateEmerchantpayPaymentRequest(): CreateEmerchantpayPaymentRequest {
  return {
    societeId: "",
    transactionId: "",
    amountCents: 0,
    currency: "",
    transactionType: "",
    cardNumber: undefined,
    cardHolder: undefined,
    expirationDate: undefined,
    cvv: undefined,
    notificationUrl: "",
    returnSuccessUrl: "",
    returnFailureUrl: "",
    customerEmail: undefined,
    customerPhone: undefined,
    billingAddress: undefined,
    metadata: {},
  };
}

export const CreateEmerchantpayPaymentRequest: MessageFns<CreateEmerchantpayPaymentRequest> = {
  encode(message: CreateEmerchantpayPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.transactionType !== "") {
      writer.uint32(42).string(message.transactionType);
    }
    if (message.cardNumber !== undefined) {
      writer.uint32(50).string(message.cardNumber);
    }
    if (message.cardHolder !== undefined) {
      writer.uint32(58).string(message.cardHolder);
    }
    if (message.expirationDate !== undefined) {
      writer.uint32(66).string(message.expirationDate);
    }
    if (message.cvv !== undefined) {
      writer.uint32(74).string(message.cvv);
    }
    if (message.notificationUrl !== "") {
      writer.uint32(82).string(message.notificationUrl);
    }
    if (message.returnSuccessUrl !== "") {
      writer.uint32(90).string(message.returnSuccessUrl);
    }
    if (message.returnFailureUrl !== "") {
      writer.uint32(98).string(message.returnFailureUrl);
    }
    if (message.customerEmail !== undefined) {
      writer.uint32(106).string(message.customerEmail);
    }
    if (message.customerPhone !== undefined) {
      writer.uint32(114).string(message.customerPhone);
    }
    if (message.billingAddress !== undefined) {
      writer.uint32(122).string(message.billingAddress);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateEmerchantpayPaymentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(130).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEmerchantpayPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEmerchantpayPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cardNumber = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cardHolder = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expirationDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.cvv = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.notificationUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.returnSuccessUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.returnFailureUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.customerEmail = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.customerPhone = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.billingAddress = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          const entry16 = CreateEmerchantpayPaymentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.metadata[entry16.key] = entry16.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEmerchantpayPaymentRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      transactionType: isSet(object.transactionType)
        ? globalThis.String(object.transactionType)
        : isSet(object.transaction_type)
        ? globalThis.String(object.transaction_type)
        : "",
      cardNumber: isSet(object.cardNumber)
        ? globalThis.String(object.cardNumber)
        : isSet(object.card_number)
        ? globalThis.String(object.card_number)
        : undefined,
      cardHolder: isSet(object.cardHolder)
        ? globalThis.String(object.cardHolder)
        : isSet(object.card_holder)
        ? globalThis.String(object.card_holder)
        : undefined,
      expirationDate: isSet(object.expirationDate)
        ? globalThis.String(object.expirationDate)
        : isSet(object.expiration_date)
        ? globalThis.String(object.expiration_date)
        : undefined,
      cvv: isSet(object.cvv) ? globalThis.String(object.cvv) : undefined,
      notificationUrl: isSet(object.notificationUrl)
        ? globalThis.String(object.notificationUrl)
        : isSet(object.notification_url)
        ? globalThis.String(object.notification_url)
        : "",
      returnSuccessUrl: isSet(object.returnSuccessUrl)
        ? globalThis.String(object.returnSuccessUrl)
        : isSet(object.return_success_url)
        ? globalThis.String(object.return_success_url)
        : "",
      returnFailureUrl: isSet(object.returnFailureUrl)
        ? globalThis.String(object.returnFailureUrl)
        : isSet(object.return_failure_url)
        ? globalThis.String(object.return_failure_url)
        : "",
      customerEmail: isSet(object.customerEmail)
        ? globalThis.String(object.customerEmail)
        : isSet(object.customer_email)
        ? globalThis.String(object.customer_email)
        : undefined,
      customerPhone: isSet(object.customerPhone)
        ? globalThis.String(object.customerPhone)
        : isSet(object.customer_phone)
        ? globalThis.String(object.customer_phone)
        : undefined,
      billingAddress: isSet(object.billingAddress)
        ? globalThis.String(object.billingAddress)
        : isSet(object.billing_address)
        ? globalThis.String(object.billing_address)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateEmerchantpayPaymentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.transactionType !== "") {
      obj.transactionType = message.transactionType;
    }
    if (message.cardNumber !== undefined) {
      obj.cardNumber = message.cardNumber;
    }
    if (message.cardHolder !== undefined) {
      obj.cardHolder = message.cardHolder;
    }
    if (message.expirationDate !== undefined) {
      obj.expirationDate = message.expirationDate;
    }
    if (message.cvv !== undefined) {
      obj.cvv = message.cvv;
    }
    if (message.notificationUrl !== "") {
      obj.notificationUrl = message.notificationUrl;
    }
    if (message.returnSuccessUrl !== "") {
      obj.returnSuccessUrl = message.returnSuccessUrl;
    }
    if (message.returnFailureUrl !== "") {
      obj.returnFailureUrl = message.returnFailureUrl;
    }
    if (message.customerEmail !== undefined) {
      obj.customerEmail = message.customerEmail;
    }
    if (message.customerPhone !== undefined) {
      obj.customerPhone = message.customerPhone;
    }
    if (message.billingAddress !== undefined) {
      obj.billingAddress = message.billingAddress;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateEmerchantpayPaymentRequest>, I>>(
    base?: I,
  ): CreateEmerchantpayPaymentRequest {
    return CreateEmerchantpayPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateEmerchantpayPaymentRequest>, I>>(
    object: I,
  ): CreateEmerchantpayPaymentRequest {
    const message = createBaseCreateEmerchantpayPaymentRequest();
    message.societeId = object.societeId ?? "";
    message.transactionId = object.transactionId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.transactionType = object.transactionType ?? "";
    message.cardNumber = object.cardNumber ?? undefined;
    message.cardHolder = object.cardHolder ?? undefined;
    message.expirationDate = object.expirationDate ?? undefined;
    message.cvv = object.cvv ?? undefined;
    message.notificationUrl = object.notificationUrl ?? "";
    message.returnSuccessUrl = object.returnSuccessUrl ?? "";
    message.returnFailureUrl = object.returnFailureUrl ?? "";
    message.customerEmail = object.customerEmail ?? undefined;
    message.customerPhone = object.customerPhone ?? undefined;
    message.billingAddress = object.billingAddress ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateEmerchantpayPaymentRequest_MetadataEntry(): CreateEmerchantpayPaymentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateEmerchantpayPaymentRequest_MetadataEntry: MessageFns<
  CreateEmerchantpayPaymentRequest_MetadataEntry
> = {
  encode(
    message: CreateEmerchantpayPaymentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEmerchantpayPaymentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEmerchantpayPaymentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEmerchantpayPaymentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateEmerchantpayPaymentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateEmerchantpayPaymentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateEmerchantpayPaymentRequest_MetadataEntry {
    return CreateEmerchantpayPaymentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateEmerchantpayPaymentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateEmerchantpayPaymentRequest_MetadataEntry {
    const message = createBaseCreateEmerchantpayPaymentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEmerchantpayPaymentResponse(): EmerchantpayPaymentResponse {
  return {
    id: "",
    transactionId: "",
    uniqueId: "",
    amountCents: 0,
    currency: "",
    status: "",
    transactionType: "",
    redirectUrl: undefined,
    reason: undefined,
    responseCode: undefined,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const EmerchantpayPaymentResponse: MessageFns<EmerchantpayPaymentResponse> = {
  encode(message: EmerchantpayPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.uniqueId !== "") {
      writer.uint32(26).string(message.uniqueId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.transactionType !== "") {
      writer.uint32(58).string(message.transactionType);
    }
    if (message.redirectUrl !== undefined) {
      writer.uint32(66).string(message.redirectUrl);
    }
    if (message.reason !== undefined) {
      writer.uint32(74).string(message.reason);
    }
    if (message.responseCode !== undefined) {
      writer.uint32(82).string(message.responseCode);
    }
    if (message.createdAt !== "") {
      writer.uint32(90).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(98).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmerchantpayPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmerchantpayPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.transactionType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.responseCode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmerchantpayPaymentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      uniqueId: isSet(object.uniqueId)
        ? globalThis.String(object.uniqueId)
        : isSet(object.unique_id)
        ? globalThis.String(object.unique_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      transactionType: isSet(object.transactionType)
        ? globalThis.String(object.transactionType)
        : isSet(object.transaction_type)
        ? globalThis.String(object.transaction_type)
        : "",
      redirectUrl: isSet(object.redirectUrl)
        ? globalThis.String(object.redirectUrl)
        : isSet(object.redirect_url)
        ? globalThis.String(object.redirect_url)
        : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      responseCode: isSet(object.responseCode)
        ? globalThis.String(object.responseCode)
        : isSet(object.response_code)
        ? globalThis.String(object.response_code)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: EmerchantpayPaymentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.transactionType !== "") {
      obj.transactionType = message.transactionType;
    }
    if (message.redirectUrl !== undefined) {
      obj.redirectUrl = message.redirectUrl;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.responseCode !== undefined) {
      obj.responseCode = message.responseCode;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmerchantpayPaymentResponse>, I>>(base?: I): EmerchantpayPaymentResponse {
    return EmerchantpayPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmerchantpayPaymentResponse>, I>>(object: I): EmerchantpayPaymentResponse {
    const message = createBaseEmerchantpayPaymentResponse();
    message.id = object.id ?? "";
    message.transactionId = object.transactionId ?? "";
    message.uniqueId = object.uniqueId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.transactionType = object.transactionType ?? "";
    message.redirectUrl = object.redirectUrl ?? undefined;
    message.reason = object.reason ?? undefined;
    message.responseCode = object.responseCode ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetEmerchantpayPaymentRequest(): GetEmerchantpayPaymentRequest {
  return { transactionId: "", societeId: "" };
}

export const GetEmerchantpayPaymentRequest: MessageFns<GetEmerchantpayPaymentRequest> = {
  encode(message: GetEmerchantpayPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmerchantpayPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmerchantpayPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEmerchantpayPaymentRequest {
    return {
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetEmerchantpayPaymentRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEmerchantpayPaymentRequest>, I>>(base?: I): GetEmerchantpayPaymentRequest {
    return GetEmerchantpayPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEmerchantpayPaymentRequest>, I>>(
    object: I,
  ): GetEmerchantpayPaymentRequest {
    const message = createBaseGetEmerchantpayPaymentRequest();
    message.transactionId = object.transactionId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateEmerchantpaySepaPaymentRequest(): CreateEmerchantpaySepaPaymentRequest {
  return {
    societeId: "",
    transactionId: "",
    amountCents: 0,
    currency: "",
    iban: "",
    bic: "",
    accountHolder: "",
    mandateReference: undefined,
    mandateSignedDate: undefined,
    notificationUrl: "",
    description: undefined,
    metadata: {},
  };
}

export const CreateEmerchantpaySepaPaymentRequest: MessageFns<CreateEmerchantpaySepaPaymentRequest> = {
  encode(message: CreateEmerchantpaySepaPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.transactionId !== "") {
      writer.uint32(18).string(message.transactionId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.iban !== "") {
      writer.uint32(42).string(message.iban);
    }
    if (message.bic !== "") {
      writer.uint32(50).string(message.bic);
    }
    if (message.accountHolder !== "") {
      writer.uint32(58).string(message.accountHolder);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(66).string(message.mandateReference);
    }
    if (message.mandateSignedDate !== undefined) {
      writer.uint32(74).string(message.mandateSignedDate);
    }
    if (message.notificationUrl !== "") {
      writer.uint32(82).string(message.notificationUrl);
    }
    if (message.description !== undefined) {
      writer.uint32(90).string(message.description);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateEmerchantpaySepaPaymentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(98).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEmerchantpaySepaPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEmerchantpaySepaPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.iban = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accountHolder = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mandateSignedDate = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.notificationUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = CreateEmerchantpaySepaPaymentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.metadata[entry12.key] = entry12.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEmerchantpaySepaPaymentRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      iban: isSet(object.iban) ? globalThis.String(object.iban) : "",
      bic: isSet(object.bic) ? globalThis.String(object.bic) : "",
      accountHolder: isSet(object.accountHolder)
        ? globalThis.String(object.accountHolder)
        : isSet(object.account_holder)
        ? globalThis.String(object.account_holder)
        : "",
      mandateReference: isSet(object.mandateReference)
        ? globalThis.String(object.mandateReference)
        : isSet(object.mandate_reference)
        ? globalThis.String(object.mandate_reference)
        : undefined,
      mandateSignedDate: isSet(object.mandateSignedDate)
        ? globalThis.String(object.mandateSignedDate)
        : isSet(object.mandate_signed_date)
        ? globalThis.String(object.mandate_signed_date)
        : undefined,
      notificationUrl: isSet(object.notificationUrl)
        ? globalThis.String(object.notificationUrl)
        : isSet(object.notification_url)
        ? globalThis.String(object.notification_url)
        : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateEmerchantpaySepaPaymentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.iban !== "") {
      obj.iban = message.iban;
    }
    if (message.bic !== "") {
      obj.bic = message.bic;
    }
    if (message.accountHolder !== "") {
      obj.accountHolder = message.accountHolder;
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = message.mandateReference;
    }
    if (message.mandateSignedDate !== undefined) {
      obj.mandateSignedDate = message.mandateSignedDate;
    }
    if (message.notificationUrl !== "") {
      obj.notificationUrl = message.notificationUrl;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateEmerchantpaySepaPaymentRequest>, I>>(
    base?: I,
  ): CreateEmerchantpaySepaPaymentRequest {
    return CreateEmerchantpaySepaPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateEmerchantpaySepaPaymentRequest>, I>>(
    object: I,
  ): CreateEmerchantpaySepaPaymentRequest {
    const message = createBaseCreateEmerchantpaySepaPaymentRequest();
    message.societeId = object.societeId ?? "";
    message.transactionId = object.transactionId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.iban = object.iban ?? "";
    message.bic = object.bic ?? "";
    message.accountHolder = object.accountHolder ?? "";
    message.mandateReference = object.mandateReference ?? undefined;
    message.mandateSignedDate = object.mandateSignedDate ?? undefined;
    message.notificationUrl = object.notificationUrl ?? "";
    message.description = object.description ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateEmerchantpaySepaPaymentRequest_MetadataEntry(): CreateEmerchantpaySepaPaymentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateEmerchantpaySepaPaymentRequest_MetadataEntry: MessageFns<
  CreateEmerchantpaySepaPaymentRequest_MetadataEntry
> = {
  encode(
    message: CreateEmerchantpaySepaPaymentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEmerchantpaySepaPaymentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEmerchantpaySepaPaymentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEmerchantpaySepaPaymentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateEmerchantpaySepaPaymentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateEmerchantpaySepaPaymentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateEmerchantpaySepaPaymentRequest_MetadataEntry {
    return CreateEmerchantpaySepaPaymentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateEmerchantpaySepaPaymentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateEmerchantpaySepaPaymentRequest_MetadataEntry {
    const message = createBaseCreateEmerchantpaySepaPaymentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRefundEmerchantpayPaymentRequest(): RefundEmerchantpayPaymentRequest {
  return { transactionId: "", societeId: "", uniqueId: "", amountCents: 0, reason: undefined };
}

export const RefundEmerchantpayPaymentRequest: MessageFns<RefundEmerchantpayPaymentRequest> = {
  encode(message: RefundEmerchantpayPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.uniqueId !== "") {
      writer.uint32(26).string(message.uniqueId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.reason !== undefined) {
      writer.uint32(42).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundEmerchantpayPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundEmerchantpayPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundEmerchantpayPaymentRequest {
    return {
      transactionId: isSet(object.transactionId)
        ? globalThis.String(object.transactionId)
        : isSet(object.transaction_id)
        ? globalThis.String(object.transaction_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      uniqueId: isSet(object.uniqueId)
        ? globalThis.String(object.uniqueId)
        : isSet(object.unique_id)
        ? globalThis.String(object.unique_id)
        : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: RefundEmerchantpayPaymentRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundEmerchantpayPaymentRequest>, I>>(
    base?: I,
  ): RefundEmerchantpayPaymentRequest {
    return RefundEmerchantpayPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundEmerchantpayPaymentRequest>, I>>(
    object: I,
  ): RefundEmerchantpayPaymentRequest {
    const message = createBaseRefundEmerchantpayPaymentRequest();
    message.transactionId = object.transactionId ?? "";
    message.societeId = object.societeId ?? "";
    message.uniqueId = object.uniqueId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseCreateRoutingRuleRequest(): CreateRoutingRuleRequest {
  return {
    societeId: "",
    name: "",
    priority: 0,
    conditions: "",
    providerAccountId: "",
    isFallback: false,
    isEnabled: false,
  };
}

export const CreateRoutingRuleRequest: MessageFns<CreateRoutingRuleRequest> = {
  encode(message: CreateRoutingRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.priority !== 0) {
      writer.uint32(24).int32(message.priority);
    }
    if (message.conditions !== "") {
      writer.uint32(34).string(message.conditions);
    }
    if (message.providerAccountId !== "") {
      writer.uint32(42).string(message.providerAccountId);
    }
    if (message.isFallback !== false) {
      writer.uint32(48).bool(message.isFallback);
    }
    if (message.isEnabled !== false) {
      writer.uint32(56).bool(message.isEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRoutingRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoutingRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.conditions = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.providerAccountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isFallback = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isEnabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRoutingRuleRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      conditions: isSet(object.conditions) ? globalThis.String(object.conditions) : "",
      providerAccountId: isSet(object.providerAccountId)
        ? globalThis.String(object.providerAccountId)
        : isSet(object.provider_account_id)
        ? globalThis.String(object.provider_account_id)
        : "",
      isFallback: isSet(object.isFallback)
        ? globalThis.Boolean(object.isFallback)
        : isSet(object.is_fallback)
        ? globalThis.Boolean(object.is_fallback)
        : false,
      isEnabled: isSet(object.isEnabled)
        ? globalThis.Boolean(object.isEnabled)
        : isSet(object.is_enabled)
        ? globalThis.Boolean(object.is_enabled)
        : false,
    };
  },

  toJSON(message: CreateRoutingRuleRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.conditions !== "") {
      obj.conditions = message.conditions;
    }
    if (message.providerAccountId !== "") {
      obj.providerAccountId = message.providerAccountId;
    }
    if (message.isFallback !== false) {
      obj.isFallback = message.isFallback;
    }
    if (message.isEnabled !== false) {
      obj.isEnabled = message.isEnabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRoutingRuleRequest>, I>>(base?: I): CreateRoutingRuleRequest {
    return CreateRoutingRuleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRoutingRuleRequest>, I>>(object: I): CreateRoutingRuleRequest {
    const message = createBaseCreateRoutingRuleRequest();
    message.societeId = object.societeId ?? "";
    message.name = object.name ?? "";
    message.priority = object.priority ?? 0;
    message.conditions = object.conditions ?? "";
    message.providerAccountId = object.providerAccountId ?? "";
    message.isFallback = object.isFallback ?? false;
    message.isEnabled = object.isEnabled ?? false;
    return message;
  },
};

function createBaseRoutingRuleResponse(): RoutingRuleResponse {
  return {
    id: "",
    societeId: "",
    name: "",
    priority: 0,
    conditions: "",
    providerAccountId: "",
    isFallback: false,
    isEnabled: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const RoutingRuleResponse: MessageFns<RoutingRuleResponse> = {
  encode(message: RoutingRuleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.priority !== 0) {
      writer.uint32(32).int32(message.priority);
    }
    if (message.conditions !== "") {
      writer.uint32(42).string(message.conditions);
    }
    if (message.providerAccountId !== "") {
      writer.uint32(50).string(message.providerAccountId);
    }
    if (message.isFallback !== false) {
      writer.uint32(56).bool(message.isFallback);
    }
    if (message.isEnabled !== false) {
      writer.uint32(64).bool(message.isEnabled);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingRuleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingRuleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.conditions = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.providerAccountId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isFallback = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isEnabled = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingRuleResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      conditions: isSet(object.conditions) ? globalThis.String(object.conditions) : "",
      providerAccountId: isSet(object.providerAccountId)
        ? globalThis.String(object.providerAccountId)
        : isSet(object.provider_account_id)
        ? globalThis.String(object.provider_account_id)
        : "",
      isFallback: isSet(object.isFallback)
        ? globalThis.Boolean(object.isFallback)
        : isSet(object.is_fallback)
        ? globalThis.Boolean(object.is_fallback)
        : false,
      isEnabled: isSet(object.isEnabled)
        ? globalThis.Boolean(object.isEnabled)
        : isSet(object.is_enabled)
        ? globalThis.Boolean(object.is_enabled)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: RoutingRuleResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.conditions !== "") {
      obj.conditions = message.conditions;
    }
    if (message.providerAccountId !== "") {
      obj.providerAccountId = message.providerAccountId;
    }
    if (message.isFallback !== false) {
      obj.isFallback = message.isFallback;
    }
    if (message.isEnabled !== false) {
      obj.isEnabled = message.isEnabled;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingRuleResponse>, I>>(base?: I): RoutingRuleResponse {
    return RoutingRuleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingRuleResponse>, I>>(object: I): RoutingRuleResponse {
    const message = createBaseRoutingRuleResponse();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.name = object.name ?? "";
    message.priority = object.priority ?? 0;
    message.conditions = object.conditions ?? "";
    message.providerAccountId = object.providerAccountId ?? "";
    message.isFallback = object.isFallback ?? false;
    message.isEnabled = object.isEnabled ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseUpdateRoutingRuleRequest(): UpdateRoutingRuleRequest {
  return {
    id: "",
    name: undefined,
    priority: undefined,
    conditions: undefined,
    providerAccountId: undefined,
    isFallback: undefined,
    isEnabled: undefined,
  };
}

export const UpdateRoutingRuleRequest: MessageFns<UpdateRoutingRuleRequest> = {
  encode(message: UpdateRoutingRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.priority !== undefined) {
      writer.uint32(24).int32(message.priority);
    }
    if (message.conditions !== undefined) {
      writer.uint32(34).string(message.conditions);
    }
    if (message.providerAccountId !== undefined) {
      writer.uint32(42).string(message.providerAccountId);
    }
    if (message.isFallback !== undefined) {
      writer.uint32(48).bool(message.isFallback);
    }
    if (message.isEnabled !== undefined) {
      writer.uint32(56).bool(message.isEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRoutingRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoutingRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.conditions = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.providerAccountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isFallback = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isEnabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRoutingRuleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : undefined,
      conditions: isSet(object.conditions) ? globalThis.String(object.conditions) : undefined,
      providerAccountId: isSet(object.providerAccountId)
        ? globalThis.String(object.providerAccountId)
        : isSet(object.provider_account_id)
        ? globalThis.String(object.provider_account_id)
        : undefined,
      isFallback: isSet(object.isFallback)
        ? globalThis.Boolean(object.isFallback)
        : isSet(object.is_fallback)
        ? globalThis.Boolean(object.is_fallback)
        : undefined,
      isEnabled: isSet(object.isEnabled)
        ? globalThis.Boolean(object.isEnabled)
        : isSet(object.is_enabled)
        ? globalThis.Boolean(object.is_enabled)
        : undefined,
    };
  },

  toJSON(message: UpdateRoutingRuleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.priority !== undefined) {
      obj.priority = Math.round(message.priority);
    }
    if (message.conditions !== undefined) {
      obj.conditions = message.conditions;
    }
    if (message.providerAccountId !== undefined) {
      obj.providerAccountId = message.providerAccountId;
    }
    if (message.isFallback !== undefined) {
      obj.isFallback = message.isFallback;
    }
    if (message.isEnabled !== undefined) {
      obj.isEnabled = message.isEnabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRoutingRuleRequest>, I>>(base?: I): UpdateRoutingRuleRequest {
    return UpdateRoutingRuleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRoutingRuleRequest>, I>>(object: I): UpdateRoutingRuleRequest {
    const message = createBaseUpdateRoutingRuleRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.priority = object.priority ?? undefined;
    message.conditions = object.conditions ?? undefined;
    message.providerAccountId = object.providerAccountId ?? undefined;
    message.isFallback = object.isFallback ?? undefined;
    message.isEnabled = object.isEnabled ?? undefined;
    return message;
  },
};

function createBaseDeleteRoutingRuleRequest(): DeleteRoutingRuleRequest {
  return { id: "", societeId: "" };
}

export const DeleteRoutingRuleRequest: MessageFns<DeleteRoutingRuleRequest> = {
  encode(message: DeleteRoutingRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoutingRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoutingRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoutingRuleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: DeleteRoutingRuleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoutingRuleRequest>, I>>(base?: I): DeleteRoutingRuleRequest {
    return DeleteRoutingRuleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoutingRuleRequest>, I>>(object: I): DeleteRoutingRuleRequest {
    const message = createBaseDeleteRoutingRuleRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseDeleteRoutingRuleResponse(): DeleteRoutingRuleResponse {
  return { success: false, message: "" };
}

export const DeleteRoutingRuleResponse: MessageFns<DeleteRoutingRuleResponse> = {
  encode(message: DeleteRoutingRuleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoutingRuleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoutingRuleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoutingRuleResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteRoutingRuleResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoutingRuleResponse>, I>>(base?: I): DeleteRoutingRuleResponse {
    return DeleteRoutingRuleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoutingRuleResponse>, I>>(object: I): DeleteRoutingRuleResponse {
    const message = createBaseDeleteRoutingRuleResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseListRoutingRulesRequest(): ListRoutingRulesRequest {
  return { societeId: "", isEnabled: undefined, page: undefined, pageSize: undefined };
}

export const ListRoutingRulesRequest: MessageFns<ListRoutingRulesRequest> = {
  encode(message: ListRoutingRulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.isEnabled !== undefined) {
      writer.uint32(16).bool(message.isEnabled);
    }
    if (message.page !== undefined) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoutingRulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoutingRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isEnabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoutingRulesRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      isEnabled: isSet(object.isEnabled)
        ? globalThis.Boolean(object.isEnabled)
        : isSet(object.is_enabled)
        ? globalThis.Boolean(object.is_enabled)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : undefined,
    };
  },

  toJSON(message: ListRoutingRulesRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.isEnabled !== undefined) {
      obj.isEnabled = message.isEnabled;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRoutingRulesRequest>, I>>(base?: I): ListRoutingRulesRequest {
    return ListRoutingRulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRoutingRulesRequest>, I>>(object: I): ListRoutingRulesRequest {
    const message = createBaseListRoutingRulesRequest();
    message.societeId = object.societeId ?? "";
    message.isEnabled = object.isEnabled ?? undefined;
    message.page = object.page ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    return message;
  },
};

function createBaseListRoutingRulesResponse(): ListRoutingRulesResponse {
  return { rules: [], total: 0, page: 0, pageSize: 0 };
}

export const ListRoutingRulesResponse: MessageFns<ListRoutingRulesResponse> = {
  encode(message: ListRoutingRulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rules) {
      RoutingRuleResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoutingRulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoutingRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rules.push(RoutingRuleResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoutingRulesResponse {
    return {
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => RoutingRuleResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListRoutingRulesResponse): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => RoutingRuleResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRoutingRulesResponse>, I>>(base?: I): ListRoutingRulesResponse {
    return ListRoutingRulesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRoutingRulesResponse>, I>>(object: I): ListRoutingRulesResponse {
    const message = createBaseListRoutingRulesResponse();
    message.rules = object.rules?.map((e) => RoutingRuleResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseTestRoutingRuleRequest(): TestRoutingRuleRequest {
  return {
    societeId: "",
    sourceChannel: "",
    productCode: undefined,
    contractAgeMonths: undefined,
    amountCents: undefined,
    clientId: undefined,
  };
}

export const TestRoutingRuleRequest: MessageFns<TestRoutingRuleRequest> = {
  encode(message: TestRoutingRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.sourceChannel !== "") {
      writer.uint32(18).string(message.sourceChannel);
    }
    if (message.productCode !== undefined) {
      writer.uint32(26).string(message.productCode);
    }
    if (message.contractAgeMonths !== undefined) {
      writer.uint32(32).int32(message.contractAgeMonths);
    }
    if (message.amountCents !== undefined) {
      writer.uint32(40).int64(message.amountCents);
    }
    if (message.clientId !== undefined) {
      writer.uint32(50).string(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestRoutingRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestRoutingRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceChannel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.contractAgeMonths = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestRoutingRuleRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      sourceChannel: isSet(object.sourceChannel)
        ? globalThis.String(object.sourceChannel)
        : isSet(object.source_channel)
        ? globalThis.String(object.source_channel)
        : "",
      productCode: isSet(object.productCode)
        ? globalThis.String(object.productCode)
        : isSet(object.product_code)
        ? globalThis.String(object.product_code)
        : undefined,
      contractAgeMonths: isSet(object.contractAgeMonths)
        ? globalThis.Number(object.contractAgeMonths)
        : isSet(object.contract_age_months)
        ? globalThis.Number(object.contract_age_months)
        : undefined,
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
    };
  },

  toJSON(message: TestRoutingRuleRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.sourceChannel !== "") {
      obj.sourceChannel = message.sourceChannel;
    }
    if (message.productCode !== undefined) {
      obj.productCode = message.productCode;
    }
    if (message.contractAgeMonths !== undefined) {
      obj.contractAgeMonths = Math.round(message.contractAgeMonths);
    }
    if (message.amountCents !== undefined) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestRoutingRuleRequest>, I>>(base?: I): TestRoutingRuleRequest {
    return TestRoutingRuleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestRoutingRuleRequest>, I>>(object: I): TestRoutingRuleRequest {
    const message = createBaseTestRoutingRuleRequest();
    message.societeId = object.societeId ?? "";
    message.sourceChannel = object.sourceChannel ?? "";
    message.productCode = object.productCode ?? undefined;
    message.contractAgeMonths = object.contractAgeMonths ?? undefined;
    message.amountCents = object.amountCents ?? undefined;
    message.clientId = object.clientId ?? undefined;
    return message;
  },
};

function createBaseTestRoutingRuleResponse(): TestRoutingRuleResponse {
  return {
    matchedRuleId: "",
    matchedRuleName: "",
    providerAccountId: "",
    providerName: "",
    isFallback: false,
    evaluations: [],
  };
}

export const TestRoutingRuleResponse: MessageFns<TestRoutingRuleResponse> = {
  encode(message: TestRoutingRuleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchedRuleId !== "") {
      writer.uint32(10).string(message.matchedRuleId);
    }
    if (message.matchedRuleName !== "") {
      writer.uint32(18).string(message.matchedRuleName);
    }
    if (message.providerAccountId !== "") {
      writer.uint32(26).string(message.providerAccountId);
    }
    if (message.providerName !== "") {
      writer.uint32(34).string(message.providerName);
    }
    if (message.isFallback !== false) {
      writer.uint32(40).bool(message.isFallback);
    }
    for (const v of message.evaluations) {
      RoutingRuleEvaluation.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestRoutingRuleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestRoutingRuleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.matchedRuleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matchedRuleName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerAccountId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isFallback = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.evaluations.push(RoutingRuleEvaluation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestRoutingRuleResponse {
    return {
      matchedRuleId: isSet(object.matchedRuleId)
        ? globalThis.String(object.matchedRuleId)
        : isSet(object.matched_rule_id)
        ? globalThis.String(object.matched_rule_id)
        : "",
      matchedRuleName: isSet(object.matchedRuleName)
        ? globalThis.String(object.matchedRuleName)
        : isSet(object.matched_rule_name)
        ? globalThis.String(object.matched_rule_name)
        : "",
      providerAccountId: isSet(object.providerAccountId)
        ? globalThis.String(object.providerAccountId)
        : isSet(object.provider_account_id)
        ? globalThis.String(object.provider_account_id)
        : "",
      providerName: isSet(object.providerName)
        ? globalThis.String(object.providerName)
        : isSet(object.provider_name)
        ? globalThis.String(object.provider_name)
        : "",
      isFallback: isSet(object.isFallback)
        ? globalThis.Boolean(object.isFallback)
        : isSet(object.is_fallback)
        ? globalThis.Boolean(object.is_fallback)
        : false,
      evaluations: globalThis.Array.isArray(object?.evaluations)
        ? object.evaluations.map((e: any) => RoutingRuleEvaluation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TestRoutingRuleResponse): unknown {
    const obj: any = {};
    if (message.matchedRuleId !== "") {
      obj.matchedRuleId = message.matchedRuleId;
    }
    if (message.matchedRuleName !== "") {
      obj.matchedRuleName = message.matchedRuleName;
    }
    if (message.providerAccountId !== "") {
      obj.providerAccountId = message.providerAccountId;
    }
    if (message.providerName !== "") {
      obj.providerName = message.providerName;
    }
    if (message.isFallback !== false) {
      obj.isFallback = message.isFallback;
    }
    if (message.evaluations?.length) {
      obj.evaluations = message.evaluations.map((e) => RoutingRuleEvaluation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestRoutingRuleResponse>, I>>(base?: I): TestRoutingRuleResponse {
    return TestRoutingRuleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestRoutingRuleResponse>, I>>(object: I): TestRoutingRuleResponse {
    const message = createBaseTestRoutingRuleResponse();
    message.matchedRuleId = object.matchedRuleId ?? "";
    message.matchedRuleName = object.matchedRuleName ?? "";
    message.providerAccountId = object.providerAccountId ?? "";
    message.providerName = object.providerName ?? "";
    message.isFallback = object.isFallback ?? false;
    message.evaluations = object.evaluations?.map((e) => RoutingRuleEvaluation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoutingRuleEvaluation(): RoutingRuleEvaluation {
  return { ruleId: "", ruleName: "", priority: 0, matched: false, reason: undefined };
}

export const RoutingRuleEvaluation: MessageFns<RoutingRuleEvaluation> = {
  encode(message: RoutingRuleEvaluation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleId !== "") {
      writer.uint32(10).string(message.ruleId);
    }
    if (message.ruleName !== "") {
      writer.uint32(18).string(message.ruleName);
    }
    if (message.priority !== 0) {
      writer.uint32(24).int32(message.priority);
    }
    if (message.matched !== false) {
      writer.uint32(32).bool(message.matched);
    }
    if (message.reason !== undefined) {
      writer.uint32(42).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoutingRuleEvaluation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingRuleEvaluation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ruleName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.matched = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoutingRuleEvaluation {
    return {
      ruleId: isSet(object.ruleId)
        ? globalThis.String(object.ruleId)
        : isSet(object.rule_id)
        ? globalThis.String(object.rule_id)
        : "",
      ruleName: isSet(object.ruleName)
        ? globalThis.String(object.ruleName)
        : isSet(object.rule_name)
        ? globalThis.String(object.rule_name)
        : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      matched: isSet(object.matched) ? globalThis.Boolean(object.matched) : false,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: RoutingRuleEvaluation): unknown {
    const obj: any = {};
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.ruleName !== "") {
      obj.ruleName = message.ruleName;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.matched !== false) {
      obj.matched = message.matched;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingRuleEvaluation>, I>>(base?: I): RoutingRuleEvaluation {
    return RoutingRuleEvaluation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoutingRuleEvaluation>, I>>(object: I): RoutingRuleEvaluation {
    const message = createBaseRoutingRuleEvaluation();
    message.ruleId = object.ruleId ?? "";
    message.ruleName = object.ruleName ?? "";
    message.priority = object.priority ?? 0;
    message.matched = object.matched ?? false;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseCreateProviderOverrideRequest(): CreateProviderOverrideRequest {
  return { societeId: "", scope: "", scopeId: "", providerAccountId: "", reason: "" };
}

export const CreateProviderOverrideRequest: MessageFns<CreateProviderOverrideRequest> = {
  encode(message: CreateProviderOverrideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.scope !== "") {
      writer.uint32(18).string(message.scope);
    }
    if (message.scopeId !== "") {
      writer.uint32(26).string(message.scopeId);
    }
    if (message.providerAccountId !== "") {
      writer.uint32(34).string(message.providerAccountId);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProviderOverrideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProviderOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerAccountId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProviderOverrideRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      scopeId: isSet(object.scopeId)
        ? globalThis.String(object.scopeId)
        : isSet(object.scope_id)
        ? globalThis.String(object.scope_id)
        : "",
      providerAccountId: isSet(object.providerAccountId)
        ? globalThis.String(object.providerAccountId)
        : isSet(object.provider_account_id)
        ? globalThis.String(object.provider_account_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CreateProviderOverrideRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.scopeId !== "") {
      obj.scopeId = message.scopeId;
    }
    if (message.providerAccountId !== "") {
      obj.providerAccountId = message.providerAccountId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProviderOverrideRequest>, I>>(base?: I): CreateProviderOverrideRequest {
    return CreateProviderOverrideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProviderOverrideRequest>, I>>(
    object: I,
  ): CreateProviderOverrideRequest {
    const message = createBaseCreateProviderOverrideRequest();
    message.societeId = object.societeId ?? "";
    message.scope = object.scope ?? "";
    message.scopeId = object.scopeId ?? "";
    message.providerAccountId = object.providerAccountId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseProviderOverrideResponse(): ProviderOverrideResponse {
  return {
    id: "",
    societeId: "",
    scope: "",
    scopeId: "",
    providerAccountId: "",
    reason: "",
    createdBy: "",
    createdAt: "",
  };
}

export const ProviderOverrideResponse: MessageFns<ProviderOverrideResponse> = {
  encode(message: ProviderOverrideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scope !== "") {
      writer.uint32(26).string(message.scope);
    }
    if (message.scopeId !== "") {
      writer.uint32(34).string(message.scopeId);
    }
    if (message.providerAccountId !== "") {
      writer.uint32(42).string(message.providerAccountId);
    }
    if (message.reason !== "") {
      writer.uint32(50).string(message.reason);
    }
    if (message.createdBy !== "") {
      writer.uint32(58).string(message.createdBy);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderOverrideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderOverrideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.providerAccountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderOverrideResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      scopeId: isSet(object.scopeId)
        ? globalThis.String(object.scopeId)
        : isSet(object.scope_id)
        ? globalThis.String(object.scope_id)
        : "",
      providerAccountId: isSet(object.providerAccountId)
        ? globalThis.String(object.providerAccountId)
        : isSet(object.provider_account_id)
        ? globalThis.String(object.provider_account_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      createdBy: isSet(object.createdBy)
        ? globalThis.String(object.createdBy)
        : isSet(object.created_by)
        ? globalThis.String(object.created_by)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
    };
  },

  toJSON(message: ProviderOverrideResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.scopeId !== "") {
      obj.scopeId = message.scopeId;
    }
    if (message.providerAccountId !== "") {
      obj.providerAccountId = message.providerAccountId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderOverrideResponse>, I>>(base?: I): ProviderOverrideResponse {
    return ProviderOverrideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderOverrideResponse>, I>>(object: I): ProviderOverrideResponse {
    const message = createBaseProviderOverrideResponse();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.scope = object.scope ?? "";
    message.scopeId = object.scopeId ?? "";
    message.providerAccountId = object.providerAccountId ?? "";
    message.reason = object.reason ?? "";
    message.createdBy = object.createdBy ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseDeleteProviderOverrideRequest(): DeleteProviderOverrideRequest {
  return { id: "", societeId: "" };
}

export const DeleteProviderOverrideRequest: MessageFns<DeleteProviderOverrideRequest> = {
  encode(message: DeleteProviderOverrideRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProviderOverrideRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProviderOverrideRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProviderOverrideRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: DeleteProviderOverrideRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProviderOverrideRequest>, I>>(base?: I): DeleteProviderOverrideRequest {
    return DeleteProviderOverrideRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProviderOverrideRequest>, I>>(
    object: I,
  ): DeleteProviderOverrideRequest {
    const message = createBaseDeleteProviderOverrideRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseDeleteProviderOverrideResponse(): DeleteProviderOverrideResponse {
  return { success: false, message: "" };
}

export const DeleteProviderOverrideResponse: MessageFns<DeleteProviderOverrideResponse> = {
  encode(message: DeleteProviderOverrideResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProviderOverrideResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProviderOverrideResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProviderOverrideResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteProviderOverrideResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProviderOverrideResponse>, I>>(base?: I): DeleteProviderOverrideResponse {
    return DeleteProviderOverrideResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProviderOverrideResponse>, I>>(
    object: I,
  ): DeleteProviderOverrideResponse {
    const message = createBaseDeleteProviderOverrideResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseListProviderOverridesRequest(): ListProviderOverridesRequest {
  return { societeId: "", scope: undefined, scopeId: undefined, page: undefined, pageSize: undefined };
}

export const ListProviderOverridesRequest: MessageFns<ListProviderOverridesRequest> = {
  encode(message: ListProviderOverridesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.scope !== undefined) {
      writer.uint32(18).string(message.scope);
    }
    if (message.scopeId !== undefined) {
      writer.uint32(26).string(message.scopeId);
    }
    if (message.page !== undefined) {
      writer.uint32(32).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(40).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProviderOverridesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProviderOverridesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProviderOverridesRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : undefined,
      scopeId: isSet(object.scopeId)
        ? globalThis.String(object.scopeId)
        : isSet(object.scope_id)
        ? globalThis.String(object.scope_id)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : undefined,
    };
  },

  toJSON(message: ListProviderOverridesRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scope !== undefined) {
      obj.scope = message.scope;
    }
    if (message.scopeId !== undefined) {
      obj.scopeId = message.scopeId;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProviderOverridesRequest>, I>>(base?: I): ListProviderOverridesRequest {
    return ListProviderOverridesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProviderOverridesRequest>, I>>(object: I): ListProviderOverridesRequest {
    const message = createBaseListProviderOverridesRequest();
    message.societeId = object.societeId ?? "";
    message.scope = object.scope ?? undefined;
    message.scopeId = object.scopeId ?? undefined;
    message.page = object.page ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    return message;
  },
};

function createBaseListProviderOverridesResponse(): ListProviderOverridesResponse {
  return { overrides: [], total: 0, page: 0, pageSize: 0 };
}

export const ListProviderOverridesResponse: MessageFns<ListProviderOverridesResponse> = {
  encode(message: ListProviderOverridesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.overrides) {
      ProviderOverrideResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProviderOverridesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProviderOverridesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.overrides.push(ProviderOverrideResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProviderOverridesResponse {
    return {
      overrides: globalThis.Array.isArray(object?.overrides)
        ? object.overrides.map((e: any) => ProviderOverrideResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListProviderOverridesResponse): unknown {
    const obj: any = {};
    if (message.overrides?.length) {
      obj.overrides = message.overrides.map((e) => ProviderOverrideResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProviderOverridesResponse>, I>>(base?: I): ListProviderOverridesResponse {
    return ListProviderOverridesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProviderOverridesResponse>, I>>(
    object: I,
  ): ListProviderOverridesResponse {
    const message = createBaseListProviderOverridesResponse();
    message.overrides = object.overrides?.map((e) => ProviderOverrideResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseCreateReassignmentJobRequest(): CreateReassignmentJobRequest {
  return {
    societeId: "",
    fromProviderAccountId: "",
    toProviderAccountId: "",
    selectionQuery: "",
    dryRun: false,
    scheduledAt: undefined,
  };
}

export const CreateReassignmentJobRequest: MessageFns<CreateReassignmentJobRequest> = {
  encode(message: CreateReassignmentJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.fromProviderAccountId !== "") {
      writer.uint32(18).string(message.fromProviderAccountId);
    }
    if (message.toProviderAccountId !== "") {
      writer.uint32(26).string(message.toProviderAccountId);
    }
    if (message.selectionQuery !== "") {
      writer.uint32(34).string(message.selectionQuery);
    }
    if (message.dryRun !== false) {
      writer.uint32(40).bool(message.dryRun);
    }
    if (message.scheduledAt !== undefined) {
      writer.uint32(50).string(message.scheduledAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReassignmentJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReassignmentJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromProviderAccountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toProviderAccountId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.selectionQuery = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scheduledAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReassignmentJobRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      fromProviderAccountId: isSet(object.fromProviderAccountId)
        ? globalThis.String(object.fromProviderAccountId)
        : isSet(object.from_provider_account_id)
        ? globalThis.String(object.from_provider_account_id)
        : "",
      toProviderAccountId: isSet(object.toProviderAccountId)
        ? globalThis.String(object.toProviderAccountId)
        : isSet(object.to_provider_account_id)
        ? globalThis.String(object.to_provider_account_id)
        : "",
      selectionQuery: isSet(object.selectionQuery)
        ? globalThis.String(object.selectionQuery)
        : isSet(object.selection_query)
        ? globalThis.String(object.selection_query)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
      scheduledAt: isSet(object.scheduledAt)
        ? globalThis.String(object.scheduledAt)
        : isSet(object.scheduled_at)
        ? globalThis.String(object.scheduled_at)
        : undefined,
    };
  },

  toJSON(message: CreateReassignmentJobRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.fromProviderAccountId !== "") {
      obj.fromProviderAccountId = message.fromProviderAccountId;
    }
    if (message.toProviderAccountId !== "") {
      obj.toProviderAccountId = message.toProviderAccountId;
    }
    if (message.selectionQuery !== "") {
      obj.selectionQuery = message.selectionQuery;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    if (message.scheduledAt !== undefined) {
      obj.scheduledAt = message.scheduledAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateReassignmentJobRequest>, I>>(base?: I): CreateReassignmentJobRequest {
    return CreateReassignmentJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateReassignmentJobRequest>, I>>(object: I): CreateReassignmentJobRequest {
    const message = createBaseCreateReassignmentJobRequest();
    message.societeId = object.societeId ?? "";
    message.fromProviderAccountId = object.fromProviderAccountId ?? "";
    message.toProviderAccountId = object.toProviderAccountId ?? "";
    message.selectionQuery = object.selectionQuery ?? "";
    message.dryRun = object.dryRun ?? false;
    message.scheduledAt = object.scheduledAt ?? undefined;
    return message;
  },
};

function createBaseReassignmentJobResponse(): ReassignmentJobResponse {
  return {
    id: "",
    societeId: "",
    fromProviderAccountId: "",
    toProviderAccountId: "",
    selectionQuery: "",
    status: "",
    dryRun: false,
    scheduledAt: undefined,
    startedAt: undefined,
    completedAt: undefined,
    totalItems: 0,
    successCount: 0,
    failedCount: 0,
    reportFileId: undefined,
    createdAt: "",
    updatedAt: "",
  };
}

export const ReassignmentJobResponse: MessageFns<ReassignmentJobResponse> = {
  encode(message: ReassignmentJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.fromProviderAccountId !== "") {
      writer.uint32(26).string(message.fromProviderAccountId);
    }
    if (message.toProviderAccountId !== "") {
      writer.uint32(34).string(message.toProviderAccountId);
    }
    if (message.selectionQuery !== "") {
      writer.uint32(42).string(message.selectionQuery);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.dryRun !== false) {
      writer.uint32(56).bool(message.dryRun);
    }
    if (message.scheduledAt !== undefined) {
      writer.uint32(66).string(message.scheduledAt);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(74).string(message.startedAt);
    }
    if (message.completedAt !== undefined) {
      writer.uint32(82).string(message.completedAt);
    }
    if (message.totalItems !== 0) {
      writer.uint32(88).int32(message.totalItems);
    }
    if (message.successCount !== 0) {
      writer.uint32(96).int32(message.successCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(104).int32(message.failedCount);
    }
    if (message.reportFileId !== undefined) {
      writer.uint32(114).string(message.reportFileId);
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReassignmentJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReassignmentJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromProviderAccountId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toProviderAccountId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.selectionQuery = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.scheduledAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.completedAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.reportFileId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReassignmentJobResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      fromProviderAccountId: isSet(object.fromProviderAccountId)
        ? globalThis.String(object.fromProviderAccountId)
        : isSet(object.from_provider_account_id)
        ? globalThis.String(object.from_provider_account_id)
        : "",
      toProviderAccountId: isSet(object.toProviderAccountId)
        ? globalThis.String(object.toProviderAccountId)
        : isSet(object.to_provider_account_id)
        ? globalThis.String(object.to_provider_account_id)
        : "",
      selectionQuery: isSet(object.selectionQuery)
        ? globalThis.String(object.selectionQuery)
        : isSet(object.selection_query)
        ? globalThis.String(object.selection_query)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
      scheduledAt: isSet(object.scheduledAt)
        ? globalThis.String(object.scheduledAt)
        : isSet(object.scheduled_at)
        ? globalThis.String(object.scheduled_at)
        : undefined,
      startedAt: isSet(object.startedAt)
        ? globalThis.String(object.startedAt)
        : isSet(object.started_at)
        ? globalThis.String(object.started_at)
        : undefined,
      completedAt: isSet(object.completedAt)
        ? globalThis.String(object.completedAt)
        : isSet(object.completed_at)
        ? globalThis.String(object.completed_at)
        : undefined,
      totalItems: isSet(object.totalItems)
        ? globalThis.Number(object.totalItems)
        : isSet(object.total_items)
        ? globalThis.Number(object.total_items)
        : 0,
      successCount: isSet(object.successCount)
        ? globalThis.Number(object.successCount)
        : isSet(object.success_count)
        ? globalThis.Number(object.success_count)
        : 0,
      failedCount: isSet(object.failedCount)
        ? globalThis.Number(object.failedCount)
        : isSet(object.failed_count)
        ? globalThis.Number(object.failed_count)
        : 0,
      reportFileId: isSet(object.reportFileId)
        ? globalThis.String(object.reportFileId)
        : isSet(object.report_file_id)
        ? globalThis.String(object.report_file_id)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: ReassignmentJobResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.fromProviderAccountId !== "") {
      obj.fromProviderAccountId = message.fromProviderAccountId;
    }
    if (message.toProviderAccountId !== "") {
      obj.toProviderAccountId = message.toProviderAccountId;
    }
    if (message.selectionQuery !== "") {
      obj.selectionQuery = message.selectionQuery;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    if (message.scheduledAt !== undefined) {
      obj.scheduledAt = message.scheduledAt;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt;
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt;
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    if (message.reportFileId !== undefined) {
      obj.reportFileId = message.reportFileId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReassignmentJobResponse>, I>>(base?: I): ReassignmentJobResponse {
    return ReassignmentJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReassignmentJobResponse>, I>>(object: I): ReassignmentJobResponse {
    const message = createBaseReassignmentJobResponse();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.fromProviderAccountId = object.fromProviderAccountId ?? "";
    message.toProviderAccountId = object.toProviderAccountId ?? "";
    message.selectionQuery = object.selectionQuery ?? "";
    message.status = object.status ?? "";
    message.dryRun = object.dryRun ?? false;
    message.scheduledAt = object.scheduledAt ?? undefined;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.totalItems = object.totalItems ?? 0;
    message.successCount = object.successCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    message.reportFileId = object.reportFileId ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseGetReassignmentJobRequest(): GetReassignmentJobRequest {
  return { id: "", societeId: "" };
}

export const GetReassignmentJobRequest: MessageFns<GetReassignmentJobRequest> = {
  encode(message: GetReassignmentJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReassignmentJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReassignmentJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReassignmentJobRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetReassignmentJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReassignmentJobRequest>, I>>(base?: I): GetReassignmentJobRequest {
    return GetReassignmentJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReassignmentJobRequest>, I>>(object: I): GetReassignmentJobRequest {
    const message = createBaseGetReassignmentJobRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseListAlertsRequest(): ListAlertsRequest {
  return {
    societeId: "",
    alertType: undefined,
    severity: undefined,
    acknowledged: undefined,
    fromDate: undefined,
    toDate: undefined,
    page: undefined,
    pageSize: undefined,
  };
}

export const ListAlertsRequest: MessageFns<ListAlertsRequest> = {
  encode(message: ListAlertsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.alertType !== undefined) {
      writer.uint32(18).string(message.alertType);
    }
    if (message.severity !== undefined) {
      writer.uint32(26).string(message.severity);
    }
    if (message.acknowledged !== undefined) {
      writer.uint32(32).bool(message.acknowledged);
    }
    if (message.fromDate !== undefined) {
      writer.uint32(42).string(message.fromDate);
    }
    if (message.toDate !== undefined) {
      writer.uint32(50).string(message.toDate);
    }
    if (message.page !== undefined) {
      writer.uint32(56).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(64).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAlertsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAlertsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alertType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.acknowledged = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAlertsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      alertType: isSet(object.alertType)
        ? globalThis.String(object.alertType)
        : isSet(object.alert_type)
        ? globalThis.String(object.alert_type)
        : undefined,
      severity: isSet(object.severity) ? globalThis.String(object.severity) : undefined,
      acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : undefined,
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : undefined,
    };
  },

  toJSON(message: ListAlertsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.alertType !== undefined) {
      obj.alertType = message.alertType;
    }
    if (message.severity !== undefined) {
      obj.severity = message.severity;
    }
    if (message.acknowledged !== undefined) {
      obj.acknowledged = message.acknowledged;
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAlertsRequest>, I>>(base?: I): ListAlertsRequest {
    return ListAlertsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAlertsRequest>, I>>(object: I): ListAlertsRequest {
    const message = createBaseListAlertsRequest();
    message.societeId = object.societeId ?? "";
    message.alertType = object.alertType ?? undefined;
    message.severity = object.severity ?? undefined;
    message.acknowledged = object.acknowledged ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.page = object.page ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    return message;
  },
};

function createBaseListAlertsResponse(): ListAlertsResponse {
  return { alerts: [], total: 0, page: 0, pageSize: 0 };
}

export const ListAlertsResponse: MessageFns<ListAlertsResponse> = {
  encode(message: ListAlertsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alerts) {
      AlertResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAlertsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAlertsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alerts.push(AlertResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAlertsResponse {
    return {
      alerts: globalThis.Array.isArray(object?.alerts) ? object.alerts.map((e: any) => AlertResponse.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListAlertsResponse): unknown {
    const obj: any = {};
    if (message.alerts?.length) {
      obj.alerts = message.alerts.map((e) => AlertResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAlertsResponse>, I>>(base?: I): ListAlertsResponse {
    return ListAlertsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAlertsResponse>, I>>(object: I): ListAlertsResponse {
    const message = createBaseListAlertsResponse();
    message.alerts = object.alerts?.map((e) => AlertResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseAlertResponse(): AlertResponse {
  return {
    id: "",
    societeId: "",
    alertType: "",
    severity: "",
    title: "",
    message: "",
    context: "",
    acknowledged: false,
    acknowledgedBy: undefined,
    acknowledgedAt: undefined,
    createdAt: "",
  };
}

export const AlertResponse: MessageFns<AlertResponse> = {
  encode(message: AlertResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.alertType !== "") {
      writer.uint32(26).string(message.alertType);
    }
    if (message.severity !== "") {
      writer.uint32(34).string(message.severity);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(50).string(message.message);
    }
    if (message.context !== "") {
      writer.uint32(58).string(message.context);
    }
    if (message.acknowledged !== false) {
      writer.uint32(64).bool(message.acknowledged);
    }
    if (message.acknowledgedBy !== undefined) {
      writer.uint32(74).string(message.acknowledgedBy);
    }
    if (message.acknowledgedAt !== undefined) {
      writer.uint32(82).string(message.acknowledgedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(90).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.alertType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.acknowledged = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.acknowledgedBy = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.acknowledgedAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      alertType: isSet(object.alertType)
        ? globalThis.String(object.alertType)
        : isSet(object.alert_type)
        ? globalThis.String(object.alert_type)
        : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : false,
      acknowledgedBy: isSet(object.acknowledgedBy)
        ? globalThis.String(object.acknowledgedBy)
        : isSet(object.acknowledged_by)
        ? globalThis.String(object.acknowledged_by)
        : undefined,
      acknowledgedAt: isSet(object.acknowledgedAt)
        ? globalThis.String(object.acknowledgedAt)
        : isSet(object.acknowledged_at)
        ? globalThis.String(object.acknowledged_at)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
    };
  },

  toJSON(message: AlertResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.alertType !== "") {
      obj.alertType = message.alertType;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.acknowledged !== false) {
      obj.acknowledged = message.acknowledged;
    }
    if (message.acknowledgedBy !== undefined) {
      obj.acknowledgedBy = message.acknowledgedBy;
    }
    if (message.acknowledgedAt !== undefined) {
      obj.acknowledgedAt = message.acknowledgedAt;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlertResponse>, I>>(base?: I): AlertResponse {
    return AlertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlertResponse>, I>>(object: I): AlertResponse {
    const message = createBaseAlertResponse();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.alertType = object.alertType ?? "";
    message.severity = object.severity ?? "";
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    message.context = object.context ?? "";
    message.acknowledged = object.acknowledged ?? false;
    message.acknowledgedBy = object.acknowledgedBy ?? undefined;
    message.acknowledgedAt = object.acknowledgedAt ?? undefined;
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseAcknowledgeAlertRequest(): AcknowledgeAlertRequest {
  return { id: "", societeId: "", acknowledgedBy: "" };
}

export const AcknowledgeAlertRequest: MessageFns<AcknowledgeAlertRequest> = {
  encode(message: AcknowledgeAlertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.acknowledgedBy !== "") {
      writer.uint32(26).string(message.acknowledgedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcknowledgeAlertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeAlertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.acknowledgedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeAlertRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      acknowledgedBy: isSet(object.acknowledgedBy)
        ? globalThis.String(object.acknowledgedBy)
        : isSet(object.acknowledged_by)
        ? globalThis.String(object.acknowledged_by)
        : "",
    };
  },

  toJSON(message: AcknowledgeAlertRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.acknowledgedBy !== "") {
      obj.acknowledgedBy = message.acknowledgedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcknowledgeAlertRequest>, I>>(base?: I): AcknowledgeAlertRequest {
    return AcknowledgeAlertRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcknowledgeAlertRequest>, I>>(object: I): AcknowledgeAlertRequest {
    const message = createBaseAcknowledgeAlertRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.acknowledgedBy = object.acknowledgedBy ?? "";
    return message;
  },
};

function createBaseGetAlertStatsRequest(): GetAlertStatsRequest {
  return { societeId: "", fromDate: "", toDate: "" };
}

export const GetAlertStatsRequest: MessageFns<GetAlertStatsRequest> = {
  encode(message: GetAlertStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.fromDate !== "") {
      writer.uint32(18).string(message.fromDate);
    }
    if (message.toDate !== "") {
      writer.uint32(26).string(message.toDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAlertStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAlertStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAlertStatsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : "",
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : "",
    };
  },

  toJSON(message: GetAlertStatsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.fromDate !== "") {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== "") {
      obj.toDate = message.toDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAlertStatsRequest>, I>>(base?: I): GetAlertStatsRequest {
    return GetAlertStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAlertStatsRequest>, I>>(object: I): GetAlertStatsRequest {
    const message = createBaseGetAlertStatsRequest();
    message.societeId = object.societeId ?? "";
    message.fromDate = object.fromDate ?? "";
    message.toDate = object.toDate ?? "";
    return message;
  },
};

function createBaseAlertStatsResponse(): AlertStatsResponse {
  return { totalAlerts: 0, unacknowledged: 0, criticalCount: 0, warningCount: 0, infoCount: 0, byType: [] };
}

export const AlertStatsResponse: MessageFns<AlertStatsResponse> = {
  encode(message: AlertStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalAlerts !== 0) {
      writer.uint32(8).int32(message.totalAlerts);
    }
    if (message.unacknowledged !== 0) {
      writer.uint32(16).int32(message.unacknowledged);
    }
    if (message.criticalCount !== 0) {
      writer.uint32(24).int32(message.criticalCount);
    }
    if (message.warningCount !== 0) {
      writer.uint32(32).int32(message.warningCount);
    }
    if (message.infoCount !== 0) {
      writer.uint32(40).int32(message.infoCount);
    }
    for (const v of message.byType) {
      AlertTypeCount.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalAlerts = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unacknowledged = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.criticalCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.warningCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.infoCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.byType.push(AlertTypeCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertStatsResponse {
    return {
      totalAlerts: isSet(object.totalAlerts)
        ? globalThis.Number(object.totalAlerts)
        : isSet(object.total_alerts)
        ? globalThis.Number(object.total_alerts)
        : 0,
      unacknowledged: isSet(object.unacknowledged) ? globalThis.Number(object.unacknowledged) : 0,
      criticalCount: isSet(object.criticalCount)
        ? globalThis.Number(object.criticalCount)
        : isSet(object.critical_count)
        ? globalThis.Number(object.critical_count)
        : 0,
      warningCount: isSet(object.warningCount)
        ? globalThis.Number(object.warningCount)
        : isSet(object.warning_count)
        ? globalThis.Number(object.warning_count)
        : 0,
      infoCount: isSet(object.infoCount)
        ? globalThis.Number(object.infoCount)
        : isSet(object.info_count)
        ? globalThis.Number(object.info_count)
        : 0,
      byType: globalThis.Array.isArray(object?.byType)
        ? object.byType.map((e: any) => AlertTypeCount.fromJSON(e))
        : globalThis.Array.isArray(object?.by_type)
        ? object.by_type.map((e: any) => AlertTypeCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlertStatsResponse): unknown {
    const obj: any = {};
    if (message.totalAlerts !== 0) {
      obj.totalAlerts = Math.round(message.totalAlerts);
    }
    if (message.unacknowledged !== 0) {
      obj.unacknowledged = Math.round(message.unacknowledged);
    }
    if (message.criticalCount !== 0) {
      obj.criticalCount = Math.round(message.criticalCount);
    }
    if (message.warningCount !== 0) {
      obj.warningCount = Math.round(message.warningCount);
    }
    if (message.infoCount !== 0) {
      obj.infoCount = Math.round(message.infoCount);
    }
    if (message.byType?.length) {
      obj.byType = message.byType.map((e) => AlertTypeCount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlertStatsResponse>, I>>(base?: I): AlertStatsResponse {
    return AlertStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlertStatsResponse>, I>>(object: I): AlertStatsResponse {
    const message = createBaseAlertStatsResponse();
    message.totalAlerts = object.totalAlerts ?? 0;
    message.unacknowledged = object.unacknowledged ?? 0;
    message.criticalCount = object.criticalCount ?? 0;
    message.warningCount = object.warningCount ?? 0;
    message.infoCount = object.infoCount ?? 0;
    message.byType = object.byType?.map((e) => AlertTypeCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlertTypeCount(): AlertTypeCount {
  return { alertType: "", count: 0 };
}

export const AlertTypeCount: MessageFns<AlertTypeCount> = {
  encode(message: AlertTypeCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alertType !== "") {
      writer.uint32(10).string(message.alertType);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertTypeCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertTypeCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alertType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertTypeCount {
    return {
      alertType: isSet(object.alertType)
        ? globalThis.String(object.alertType)
        : isSet(object.alert_type)
        ? globalThis.String(object.alert_type)
        : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: AlertTypeCount): unknown {
    const obj: any = {};
    if (message.alertType !== "") {
      obj.alertType = message.alertType;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlertTypeCount>, I>>(base?: I): AlertTypeCount {
    return AlertTypeCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlertTypeCount>, I>>(object: I): AlertTypeCount {
    const message = createBaseAlertTypeCount();
    message.alertType = object.alertType ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseCreateExportJobRequest(): CreateExportJobRequest {
  return {
    societeId: "",
    exportType: "",
    fromDate: "",
    toDate: "",
    format: undefined,
    filters: undefined,
    metadata: {},
  };
}

export const CreateExportJobRequest: MessageFns<CreateExportJobRequest> = {
  encode(message: CreateExportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.exportType !== "") {
      writer.uint32(18).string(message.exportType);
    }
    if (message.fromDate !== "") {
      writer.uint32(26).string(message.fromDate);
    }
    if (message.toDate !== "") {
      writer.uint32(34).string(message.toDate);
    }
    if (message.format !== undefined) {
      writer.uint32(42).string(message.format);
    }
    if (message.filters !== undefined) {
      writer.uint32(50).string(message.filters);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateExportJobRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exportType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.filters = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = CreateExportJobRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExportJobRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      exportType: isSet(object.exportType)
        ? globalThis.String(object.exportType)
        : isSet(object.export_type)
        ? globalThis.String(object.export_type)
        : "",
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : "",
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : "",
      format: isSet(object.format) ? globalThis.String(object.format) : undefined,
      filters: isSet(object.filters) ? globalThis.String(object.filters) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateExportJobRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.exportType !== "") {
      obj.exportType = message.exportType;
    }
    if (message.fromDate !== "") {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== "") {
      obj.toDate = message.toDate;
    }
    if (message.format !== undefined) {
      obj.format = message.format;
    }
    if (message.filters !== undefined) {
      obj.filters = message.filters;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExportJobRequest>, I>>(base?: I): CreateExportJobRequest {
    return CreateExportJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateExportJobRequest>, I>>(object: I): CreateExportJobRequest {
    const message = createBaseCreateExportJobRequest();
    message.societeId = object.societeId ?? "";
    message.exportType = object.exportType ?? "";
    message.fromDate = object.fromDate ?? "";
    message.toDate = object.toDate ?? "";
    message.format = object.format ?? undefined;
    message.filters = object.filters ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateExportJobRequest_MetadataEntry(): CreateExportJobRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateExportJobRequest_MetadataEntry: MessageFns<CreateExportJobRequest_MetadataEntry> = {
  encode(message: CreateExportJobRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExportJobRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExportJobRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExportJobRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateExportJobRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExportJobRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateExportJobRequest_MetadataEntry {
    return CreateExportJobRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateExportJobRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateExportJobRequest_MetadataEntry {
    const message = createBaseCreateExportJobRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExportJobResponse(): ExportJobResponse {
  return {
    id: "",
    societeId: "",
    exportType: "",
    status: "",
    fromDate: "",
    toDate: "",
    format: undefined,
    fileUrl: undefined,
    fileName: undefined,
    fileSizeBytes: undefined,
    recordCount: 0,
    errorMessage: undefined,
    createdAt: "",
    completedAt: undefined,
  };
}

export const ExportJobResponse: MessageFns<ExportJobResponse> = {
  encode(message: ExportJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.exportType !== "") {
      writer.uint32(26).string(message.exportType);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.fromDate !== "") {
      writer.uint32(42).string(message.fromDate);
    }
    if (message.toDate !== "") {
      writer.uint32(50).string(message.toDate);
    }
    if (message.format !== undefined) {
      writer.uint32(58).string(message.format);
    }
    if (message.fileUrl !== undefined) {
      writer.uint32(66).string(message.fileUrl);
    }
    if (message.fileName !== undefined) {
      writer.uint32(74).string(message.fileName);
    }
    if (message.fileSizeBytes !== undefined) {
      writer.uint32(80).int64(message.fileSizeBytes);
    }
    if (message.recordCount !== 0) {
      writer.uint32(88).int32(message.recordCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(98).string(message.errorMessage);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.completedAt !== undefined) {
      writer.uint32(114).string(message.completedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exportType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.fileSizeBytes = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.recordCount = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.completedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportJobResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      exportType: isSet(object.exportType)
        ? globalThis.String(object.exportType)
        : isSet(object.export_type)
        ? globalThis.String(object.export_type)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : "",
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : "",
      format: isSet(object.format) ? globalThis.String(object.format) : undefined,
      fileUrl: isSet(object.fileUrl)
        ? globalThis.String(object.fileUrl)
        : isSet(object.file_url)
        ? globalThis.String(object.file_url)
        : undefined,
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : undefined,
      fileSizeBytes: isSet(object.fileSizeBytes)
        ? globalThis.Number(object.fileSizeBytes)
        : isSet(object.file_size_bytes)
        ? globalThis.Number(object.file_size_bytes)
        : undefined,
      recordCount: isSet(object.recordCount)
        ? globalThis.Number(object.recordCount)
        : isSet(object.record_count)
        ? globalThis.Number(object.record_count)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      completedAt: isSet(object.completedAt)
        ? globalThis.String(object.completedAt)
        : isSet(object.completed_at)
        ? globalThis.String(object.completed_at)
        : undefined,
    };
  },

  toJSON(message: ExportJobResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.exportType !== "") {
      obj.exportType = message.exportType;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.fromDate !== "") {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== "") {
      obj.toDate = message.toDate;
    }
    if (message.format !== undefined) {
      obj.format = message.format;
    }
    if (message.fileUrl !== undefined) {
      obj.fileUrl = message.fileUrl;
    }
    if (message.fileName !== undefined) {
      obj.fileName = message.fileName;
    }
    if (message.fileSizeBytes !== undefined) {
      obj.fileSizeBytes = Math.round(message.fileSizeBytes);
    }
    if (message.recordCount !== 0) {
      obj.recordCount = Math.round(message.recordCount);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportJobResponse>, I>>(base?: I): ExportJobResponse {
    return ExportJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportJobResponse>, I>>(object: I): ExportJobResponse {
    const message = createBaseExportJobResponse();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.exportType = object.exportType ?? "";
    message.status = object.status ?? "";
    message.fromDate = object.fromDate ?? "";
    message.toDate = object.toDate ?? "";
    message.format = object.format ?? undefined;
    message.fileUrl = object.fileUrl ?? undefined;
    message.fileName = object.fileName ?? undefined;
    message.fileSizeBytes = object.fileSizeBytes ?? undefined;
    message.recordCount = object.recordCount ?? 0;
    message.errorMessage = object.errorMessage ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.completedAt = object.completedAt ?? undefined;
    return message;
  },
};

function createBaseGetExportJobRequest(): GetExportJobRequest {
  return { id: "", societeId: "" };
}

export const GetExportJobRequest: MessageFns<GetExportJobRequest> = {
  encode(message: GetExportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExportJobRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetExportJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExportJobRequest>, I>>(base?: I): GetExportJobRequest {
    return GetExportJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExportJobRequest>, I>>(object: I): GetExportJobRequest {
    const message = createBaseGetExportJobRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseListExportJobsRequest(): ListExportJobsRequest {
  return { societeId: "", exportType: undefined, status: undefined, page: undefined, pageSize: undefined };
}

export const ListExportJobsRequest: MessageFns<ListExportJobsRequest> = {
  encode(message: ListExportJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.exportType !== undefined) {
      writer.uint32(18).string(message.exportType);
    }
    if (message.status !== undefined) {
      writer.uint32(26).string(message.status);
    }
    if (message.page !== undefined) {
      writer.uint32(32).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(40).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExportJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExportJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exportType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExportJobsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      exportType: isSet(object.exportType)
        ? globalThis.String(object.exportType)
        : isSet(object.export_type)
        ? globalThis.String(object.export_type)
        : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : undefined,
    };
  },

  toJSON(message: ListExportJobsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.exportType !== undefined) {
      obj.exportType = message.exportType;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListExportJobsRequest>, I>>(base?: I): ListExportJobsRequest {
    return ListExportJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListExportJobsRequest>, I>>(object: I): ListExportJobsRequest {
    const message = createBaseListExportJobsRequest();
    message.societeId = object.societeId ?? "";
    message.exportType = object.exportType ?? undefined;
    message.status = object.status ?? undefined;
    message.page = object.page ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    return message;
  },
};

function createBaseListExportJobsResponse(): ListExportJobsResponse {
  return { jobs: [], total: 0, page: 0, pageSize: 0 };
}

export const ListExportJobsResponse: MessageFns<ListExportJobsResponse> = {
  encode(message: ListExportJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      ExportJobResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExportJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExportJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(ExportJobResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExportJobsResponse {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => ExportJobResponse.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListExportJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => ExportJobResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListExportJobsResponse>, I>>(base?: I): ListExportJobsResponse {
    return ListExportJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListExportJobsResponse>, I>>(object: I): ListExportJobsResponse {
    const message = createBaseListExportJobsResponse();
    message.jobs = object.jobs?.map((e) => ExportJobResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseDownloadExportRequest(): DownloadExportRequest {
  return { id: "", societeId: "" };
}

export const DownloadExportRequest: MessageFns<DownloadExportRequest> = {
  encode(message: DownloadExportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DownloadExportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadExportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadExportRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: DownloadExportRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadExportRequest>, I>>(base?: I): DownloadExportRequest {
    return DownloadExportRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadExportRequest>, I>>(object: I): DownloadExportRequest {
    const message = createBaseDownloadExportRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseDownloadExportResponse(): DownloadExportResponse {
  return { fileContent: new Uint8Array(0), fileName: "", contentType: "", fileSizeBytes: 0 };
}

export const DownloadExportResponse: MessageFns<DownloadExportResponse> = {
  encode(message: DownloadExportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileContent.length !== 0) {
      writer.uint32(10).bytes(message.fileContent);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.fileSizeBytes !== 0) {
      writer.uint32(32).int64(message.fileSizeBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DownloadExportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadExportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileContent = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fileSizeBytes = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadExportResponse {
    return {
      fileContent: isSet(object.fileContent)
        ? bytesFromBase64(object.fileContent)
        : isSet(object.file_content)
        ? bytesFromBase64(object.file_content)
        : new Uint8Array(0),
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      contentType: isSet(object.contentType)
        ? globalThis.String(object.contentType)
        : isSet(object.content_type)
        ? globalThis.String(object.content_type)
        : "",
      fileSizeBytes: isSet(object.fileSizeBytes)
        ? globalThis.Number(object.fileSizeBytes)
        : isSet(object.file_size_bytes)
        ? globalThis.Number(object.file_size_bytes)
        : 0,
    };
  },

  toJSON(message: DownloadExportResponse): unknown {
    const obj: any = {};
    if (message.fileContent.length !== 0) {
      obj.fileContent = base64FromBytes(message.fileContent);
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.fileSizeBytes !== 0) {
      obj.fileSizeBytes = Math.round(message.fileSizeBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadExportResponse>, I>>(base?: I): DownloadExportResponse {
    return DownloadExportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadExportResponse>, I>>(object: I): DownloadExportResponse {
    const message = createBaseDownloadExportResponse();
    message.fileContent = object.fileContent ?? new Uint8Array(0);
    message.fileName = object.fileName ?? "";
    message.contentType = object.contentType ?? "";
    message.fileSizeBytes = object.fileSizeBytes ?? 0;
    return message;
  },
};

function createBaseGetRiskScoreRequest(): GetRiskScoreRequest {
  return { id: "", societeId: "" };
}

export const GetRiskScoreRequest: MessageFns<GetRiskScoreRequest> = {
  encode(message: GetRiskScoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRiskScoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRiskScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRiskScoreRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetRiskScoreRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRiskScoreRequest>, I>>(base?: I): GetRiskScoreRequest {
    return GetRiskScoreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRiskScoreRequest>, I>>(object: I): GetRiskScoreRequest {
    const message = createBaseGetRiskScoreRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseRiskScoreResponse(): RiskScoreResponse {
  return {
    id: "",
    societeId: "",
    entityType: "",
    entityId: "",
    score: 0,
    riskLevel: "",
    factors: [],
    evaluatedAt: "",
    expiresAt: undefined,
  };
}

export const RiskScoreResponse: MessageFns<RiskScoreResponse> = {
  encode(message: RiskScoreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    if (message.score !== 0) {
      writer.uint32(40).int32(message.score);
    }
    if (message.riskLevel !== "") {
      writer.uint32(50).string(message.riskLevel);
    }
    for (const v of message.factors) {
      RiskFactor.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.evaluatedAt !== "") {
      writer.uint32(66).string(message.evaluatedAt);
    }
    if (message.expiresAt !== undefined) {
      writer.uint32(74).string(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RiskScoreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRiskScoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.riskLevel = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.factors.push(RiskFactor.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.evaluatedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RiskScoreResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      entityType: isSet(object.entityType)
        ? globalThis.String(object.entityType)
        : isSet(object.entity_type)
        ? globalThis.String(object.entity_type)
        : "",
      entityId: isSet(object.entityId)
        ? globalThis.String(object.entityId)
        : isSet(object.entity_id)
        ? globalThis.String(object.entity_id)
        : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      riskLevel: isSet(object.riskLevel)
        ? globalThis.String(object.riskLevel)
        : isSet(object.risk_level)
        ? globalThis.String(object.risk_level)
        : "",
      factors: globalThis.Array.isArray(object?.factors)
        ? object.factors.map((e: any) => RiskFactor.fromJSON(e))
        : [],
      evaluatedAt: isSet(object.evaluatedAt)
        ? globalThis.String(object.evaluatedAt)
        : isSet(object.evaluated_at)
        ? globalThis.String(object.evaluated_at)
        : "",
      expiresAt: isSet(object.expiresAt)
        ? globalThis.String(object.expiresAt)
        : isSet(object.expires_at)
        ? globalThis.String(object.expires_at)
        : undefined,
    };
  },

  toJSON(message: RiskScoreResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.riskLevel !== "") {
      obj.riskLevel = message.riskLevel;
    }
    if (message.factors?.length) {
      obj.factors = message.factors.map((e) => RiskFactor.toJSON(e));
    }
    if (message.evaluatedAt !== "") {
      obj.evaluatedAt = message.evaluatedAt;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RiskScoreResponse>, I>>(base?: I): RiskScoreResponse {
    return RiskScoreResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RiskScoreResponse>, I>>(object: I): RiskScoreResponse {
    const message = createBaseRiskScoreResponse();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.entityType = object.entityType ?? "";
    message.entityId = object.entityId ?? "";
    message.score = object.score ?? 0;
    message.riskLevel = object.riskLevel ?? "";
    message.factors = object.factors?.map((e) => RiskFactor.fromPartial(e)) || [];
    message.evaluatedAt = object.evaluatedAt ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseRiskFactor(): RiskFactor {
  return { name: "", weight: 0, score: 0, description: "" };
}

export const RiskFactor: MessageFns<RiskFactor> = {
  encode(message: RiskFactor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.weight !== 0) {
      writer.uint32(16).int32(message.weight);
    }
    if (message.score !== 0) {
      writer.uint32(24).int32(message.score);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RiskFactor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRiskFactor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RiskFactor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: RiskFactor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RiskFactor>, I>>(base?: I): RiskFactor {
    return RiskFactor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RiskFactor>, I>>(object: I): RiskFactor {
    const message = createBaseRiskFactor();
    message.name = object.name ?? "";
    message.weight = object.weight ?? 0;
    message.score = object.score ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseEvaluateRiskScoreRequest(): EvaluateRiskScoreRequest {
  return { societeId: "", entityType: "", entityId: "", forceRefresh: false };
}

export const EvaluateRiskScoreRequest: MessageFns<EvaluateRiskScoreRequest> = {
  encode(message: EvaluateRiskScoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(26).string(message.entityId);
    }
    if (message.forceRefresh !== false) {
      writer.uint32(32).bool(message.forceRefresh);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluateRiskScoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluateRiskScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.forceRefresh = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluateRiskScoreRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      entityType: isSet(object.entityType)
        ? globalThis.String(object.entityType)
        : isSet(object.entity_type)
        ? globalThis.String(object.entity_type)
        : "",
      entityId: isSet(object.entityId)
        ? globalThis.String(object.entityId)
        : isSet(object.entity_id)
        ? globalThis.String(object.entity_id)
        : "",
      forceRefresh: isSet(object.forceRefresh)
        ? globalThis.Boolean(object.forceRefresh)
        : isSet(object.force_refresh)
        ? globalThis.Boolean(object.force_refresh)
        : false,
    };
  },

  toJSON(message: EvaluateRiskScoreRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.forceRefresh !== false) {
      obj.forceRefresh = message.forceRefresh;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluateRiskScoreRequest>, I>>(base?: I): EvaluateRiskScoreRequest {
    return EvaluateRiskScoreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluateRiskScoreRequest>, I>>(object: I): EvaluateRiskScoreRequest {
    const message = createBaseEvaluateRiskScoreRequest();
    message.societeId = object.societeId ?? "";
    message.entityType = object.entityType ?? "";
    message.entityId = object.entityId ?? "";
    message.forceRefresh = object.forceRefresh ?? false;
    return message;
  },
};

function createBaseListRiskScoresRequest(): ListRiskScoresRequest {
  return {
    societeId: "",
    entityType: undefined,
    riskLevel: undefined,
    minScore: undefined,
    maxScore: undefined,
    page: undefined,
    pageSize: undefined,
  };
}

export const ListRiskScoresRequest: MessageFns<ListRiskScoresRequest> = {
  encode(message: ListRiskScoresRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.entityType !== undefined) {
      writer.uint32(18).string(message.entityType);
    }
    if (message.riskLevel !== undefined) {
      writer.uint32(26).string(message.riskLevel);
    }
    if (message.minScore !== undefined) {
      writer.uint32(32).int32(message.minScore);
    }
    if (message.maxScore !== undefined) {
      writer.uint32(40).int32(message.maxScore);
    }
    if (message.page !== undefined) {
      writer.uint32(48).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(56).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRiskScoresRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRiskScoresRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.riskLevel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minScore = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxScore = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRiskScoresRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      entityType: isSet(object.entityType)
        ? globalThis.String(object.entityType)
        : isSet(object.entity_type)
        ? globalThis.String(object.entity_type)
        : undefined,
      riskLevel: isSet(object.riskLevel)
        ? globalThis.String(object.riskLevel)
        : isSet(object.risk_level)
        ? globalThis.String(object.risk_level)
        : undefined,
      minScore: isSet(object.minScore)
        ? globalThis.Number(object.minScore)
        : isSet(object.min_score)
        ? globalThis.Number(object.min_score)
        : undefined,
      maxScore: isSet(object.maxScore)
        ? globalThis.Number(object.maxScore)
        : isSet(object.max_score)
        ? globalThis.Number(object.max_score)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : undefined,
    };
  },

  toJSON(message: ListRiskScoresRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.entityType !== undefined) {
      obj.entityType = message.entityType;
    }
    if (message.riskLevel !== undefined) {
      obj.riskLevel = message.riskLevel;
    }
    if (message.minScore !== undefined) {
      obj.minScore = Math.round(message.minScore);
    }
    if (message.maxScore !== undefined) {
      obj.maxScore = Math.round(message.maxScore);
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRiskScoresRequest>, I>>(base?: I): ListRiskScoresRequest {
    return ListRiskScoresRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRiskScoresRequest>, I>>(object: I): ListRiskScoresRequest {
    const message = createBaseListRiskScoresRequest();
    message.societeId = object.societeId ?? "";
    message.entityType = object.entityType ?? undefined;
    message.riskLevel = object.riskLevel ?? undefined;
    message.minScore = object.minScore ?? undefined;
    message.maxScore = object.maxScore ?? undefined;
    message.page = object.page ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    return message;
  },
};

function createBaseListRiskScoresResponse(): ListRiskScoresResponse {
  return { scores: [], total: 0, page: 0, pageSize: 0 };
}

export const ListRiskScoresResponse: MessageFns<ListRiskScoresResponse> = {
  encode(message: ListRiskScoresResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.scores) {
      RiskScoreResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRiskScoresResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRiskScoresResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scores.push(RiskScoreResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRiskScoresResponse {
    return {
      scores: globalThis.Array.isArray(object?.scores)
        ? object.scores.map((e: any) => RiskScoreResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListRiskScoresResponse): unknown {
    const obj: any = {};
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => RiskScoreResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRiskScoresResponse>, I>>(base?: I): ListRiskScoresResponse {
    return ListRiskScoresResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRiskScoresResponse>, I>>(object: I): ListRiskScoresResponse {
    const message = createBaseListRiskScoresResponse();
    message.scores = object.scores?.map((e) => RiskScoreResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseGetScoringStatsRequest(): GetScoringStatsRequest {
  return { societeId: "", fromDate: "", toDate: "" };
}

export const GetScoringStatsRequest: MessageFns<GetScoringStatsRequest> = {
  encode(message: GetScoringStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.fromDate !== "") {
      writer.uint32(18).string(message.fromDate);
    }
    if (message.toDate !== "") {
      writer.uint32(26).string(message.toDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetScoringStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetScoringStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetScoringStatsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : "",
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : "",
    };
  },

  toJSON(message: GetScoringStatsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.fromDate !== "") {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== "") {
      obj.toDate = message.toDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetScoringStatsRequest>, I>>(base?: I): GetScoringStatsRequest {
    return GetScoringStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetScoringStatsRequest>, I>>(object: I): GetScoringStatsRequest {
    const message = createBaseGetScoringStatsRequest();
    message.societeId = object.societeId ?? "";
    message.fromDate = object.fromDate ?? "";
    message.toDate = object.toDate ?? "";
    return message;
  },
};

function createBaseScoringStatsResponse(): ScoringStatsResponse {
  return {
    totalEvaluated: 0,
    lowRiskCount: 0,
    mediumRiskCount: 0,
    highRiskCount: 0,
    criticalRiskCount: 0,
    averageScore: 0,
  };
}

export const ScoringStatsResponse: MessageFns<ScoringStatsResponse> = {
  encode(message: ScoringStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalEvaluated !== 0) {
      writer.uint32(8).int32(message.totalEvaluated);
    }
    if (message.lowRiskCount !== 0) {
      writer.uint32(16).int32(message.lowRiskCount);
    }
    if (message.mediumRiskCount !== 0) {
      writer.uint32(24).int32(message.mediumRiskCount);
    }
    if (message.highRiskCount !== 0) {
      writer.uint32(32).int32(message.highRiskCount);
    }
    if (message.criticalRiskCount !== 0) {
      writer.uint32(40).int32(message.criticalRiskCount);
    }
    if (message.averageScore !== 0) {
      writer.uint32(49).double(message.averageScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScoringStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScoringStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalEvaluated = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lowRiskCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mediumRiskCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.highRiskCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.criticalRiskCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.averageScore = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScoringStatsResponse {
    return {
      totalEvaluated: isSet(object.totalEvaluated)
        ? globalThis.Number(object.totalEvaluated)
        : isSet(object.total_evaluated)
        ? globalThis.Number(object.total_evaluated)
        : 0,
      lowRiskCount: isSet(object.lowRiskCount)
        ? globalThis.Number(object.lowRiskCount)
        : isSet(object.low_risk_count)
        ? globalThis.Number(object.low_risk_count)
        : 0,
      mediumRiskCount: isSet(object.mediumRiskCount)
        ? globalThis.Number(object.mediumRiskCount)
        : isSet(object.medium_risk_count)
        ? globalThis.Number(object.medium_risk_count)
        : 0,
      highRiskCount: isSet(object.highRiskCount)
        ? globalThis.Number(object.highRiskCount)
        : isSet(object.high_risk_count)
        ? globalThis.Number(object.high_risk_count)
        : 0,
      criticalRiskCount: isSet(object.criticalRiskCount)
        ? globalThis.Number(object.criticalRiskCount)
        : isSet(object.critical_risk_count)
        ? globalThis.Number(object.critical_risk_count)
        : 0,
      averageScore: isSet(object.averageScore)
        ? globalThis.Number(object.averageScore)
        : isSet(object.average_score)
        ? globalThis.Number(object.average_score)
        : 0,
    };
  },

  toJSON(message: ScoringStatsResponse): unknown {
    const obj: any = {};
    if (message.totalEvaluated !== 0) {
      obj.totalEvaluated = Math.round(message.totalEvaluated);
    }
    if (message.lowRiskCount !== 0) {
      obj.lowRiskCount = Math.round(message.lowRiskCount);
    }
    if (message.mediumRiskCount !== 0) {
      obj.mediumRiskCount = Math.round(message.mediumRiskCount);
    }
    if (message.highRiskCount !== 0) {
      obj.highRiskCount = Math.round(message.highRiskCount);
    }
    if (message.criticalRiskCount !== 0) {
      obj.criticalRiskCount = Math.round(message.criticalRiskCount);
    }
    if (message.averageScore !== 0) {
      obj.averageScore = message.averageScore;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScoringStatsResponse>, I>>(base?: I): ScoringStatsResponse {
    return ScoringStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScoringStatsResponse>, I>>(object: I): ScoringStatsResponse {
    const message = createBaseScoringStatsResponse();
    message.totalEvaluated = object.totalEvaluated ?? 0;
    message.lowRiskCount = object.lowRiskCount ?? 0;
    message.mediumRiskCount = object.mediumRiskCount ?? 0;
    message.highRiskCount = object.highRiskCount ?? 0;
    message.criticalRiskCount = object.criticalRiskCount ?? 0;
    message.averageScore = object.averageScore ?? 0;
    return message;
  },
};

function createBaseImportBankStatementRequest(): ImportBankStatementRequest {
  return {
    societeId: "",
    bankAccountId: "",
    format: "",
    fileContent: new Uint8Array(0),
    fileName: "",
    statementDate: undefined,
  };
}

export const ImportBankStatementRequest: MessageFns<ImportBankStatementRequest> = {
  encode(message: ImportBankStatementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.bankAccountId !== "") {
      writer.uint32(18).string(message.bankAccountId);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.fileContent.length !== 0) {
      writer.uint32(34).bytes(message.fileContent);
    }
    if (message.fileName !== "") {
      writer.uint32(42).string(message.fileName);
    }
    if (message.statementDate !== undefined) {
      writer.uint32(50).string(message.statementDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportBankStatementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportBankStatementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bankAccountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileContent = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.statementDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportBankStatementRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      bankAccountId: isSet(object.bankAccountId)
        ? globalThis.String(object.bankAccountId)
        : isSet(object.bank_account_id)
        ? globalThis.String(object.bank_account_id)
        : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      fileContent: isSet(object.fileContent)
        ? bytesFromBase64(object.fileContent)
        : isSet(object.file_content)
        ? bytesFromBase64(object.file_content)
        : new Uint8Array(0),
      fileName: isSet(object.fileName)
        ? globalThis.String(object.fileName)
        : isSet(object.file_name)
        ? globalThis.String(object.file_name)
        : "",
      statementDate: isSet(object.statementDate)
        ? globalThis.String(object.statementDate)
        : isSet(object.statement_date)
        ? globalThis.String(object.statement_date)
        : undefined,
    };
  },

  toJSON(message: ImportBankStatementRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.bankAccountId !== "") {
      obj.bankAccountId = message.bankAccountId;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.fileContent.length !== 0) {
      obj.fileContent = base64FromBytes(message.fileContent);
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.statementDate !== undefined) {
      obj.statementDate = message.statementDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportBankStatementRequest>, I>>(base?: I): ImportBankStatementRequest {
    return ImportBankStatementRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportBankStatementRequest>, I>>(object: I): ImportBankStatementRequest {
    const message = createBaseImportBankStatementRequest();
    message.societeId = object.societeId ?? "";
    message.bankAccountId = object.bankAccountId ?? "";
    message.format = object.format ?? "";
    message.fileContent = object.fileContent ?? new Uint8Array(0);
    message.fileName = object.fileName ?? "";
    message.statementDate = object.statementDate ?? undefined;
    return message;
  },
};

function createBaseImportBankStatementResponse(): ImportBankStatementResponse {
  return {
    id: "",
    societeId: "",
    status: "",
    totalTransactions: 0,
    matchedCount: 0,
    unmatchedCount: 0,
    totalCreditCents: 0,
    totalDebitCents: 0,
    importedAt: "",
  };
}

export const ImportBankStatementResponse: MessageFns<ImportBankStatementResponse> = {
  encode(message: ImportBankStatementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.totalTransactions !== 0) {
      writer.uint32(32).int32(message.totalTransactions);
    }
    if (message.matchedCount !== 0) {
      writer.uint32(40).int32(message.matchedCount);
    }
    if (message.unmatchedCount !== 0) {
      writer.uint32(48).int32(message.unmatchedCount);
    }
    if (message.totalCreditCents !== 0) {
      writer.uint32(56).int64(message.totalCreditCents);
    }
    if (message.totalDebitCents !== 0) {
      writer.uint32(64).int64(message.totalDebitCents);
    }
    if (message.importedAt !== "") {
      writer.uint32(74).string(message.importedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportBankStatementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportBankStatementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalTransactions = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.matchedCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.unmatchedCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalCreditCents = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalDebitCents = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.importedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportBankStatementResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      totalTransactions: isSet(object.totalTransactions)
        ? globalThis.Number(object.totalTransactions)
        : isSet(object.total_transactions)
        ? globalThis.Number(object.total_transactions)
        : 0,
      matchedCount: isSet(object.matchedCount)
        ? globalThis.Number(object.matchedCount)
        : isSet(object.matched_count)
        ? globalThis.Number(object.matched_count)
        : 0,
      unmatchedCount: isSet(object.unmatchedCount)
        ? globalThis.Number(object.unmatchedCount)
        : isSet(object.unmatched_count)
        ? globalThis.Number(object.unmatched_count)
        : 0,
      totalCreditCents: isSet(object.totalCreditCents)
        ? globalThis.Number(object.totalCreditCents)
        : isSet(object.total_credit_cents)
        ? globalThis.Number(object.total_credit_cents)
        : 0,
      totalDebitCents: isSet(object.totalDebitCents)
        ? globalThis.Number(object.totalDebitCents)
        : isSet(object.total_debit_cents)
        ? globalThis.Number(object.total_debit_cents)
        : 0,
      importedAt: isSet(object.importedAt)
        ? globalThis.String(object.importedAt)
        : isSet(object.imported_at)
        ? globalThis.String(object.imported_at)
        : "",
    };
  },

  toJSON(message: ImportBankStatementResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.totalTransactions !== 0) {
      obj.totalTransactions = Math.round(message.totalTransactions);
    }
    if (message.matchedCount !== 0) {
      obj.matchedCount = Math.round(message.matchedCount);
    }
    if (message.unmatchedCount !== 0) {
      obj.unmatchedCount = Math.round(message.unmatchedCount);
    }
    if (message.totalCreditCents !== 0) {
      obj.totalCreditCents = Math.round(message.totalCreditCents);
    }
    if (message.totalDebitCents !== 0) {
      obj.totalDebitCents = Math.round(message.totalDebitCents);
    }
    if (message.importedAt !== "") {
      obj.importedAt = message.importedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImportBankStatementResponse>, I>>(base?: I): ImportBankStatementResponse {
    return ImportBankStatementResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImportBankStatementResponse>, I>>(object: I): ImportBankStatementResponse {
    const message = createBaseImportBankStatementResponse();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    message.status = object.status ?? "";
    message.totalTransactions = object.totalTransactions ?? 0;
    message.matchedCount = object.matchedCount ?? 0;
    message.unmatchedCount = object.unmatchedCount ?? 0;
    message.totalCreditCents = object.totalCreditCents ?? 0;
    message.totalDebitCents = object.totalDebitCents ?? 0;
    message.importedAt = object.importedAt ?? "";
    return message;
  },
};

function createBaseGetReconciliationStatusRequest(): GetReconciliationStatusRequest {
  return { societeId: "", bankAccountId: undefined, fromDate: undefined, toDate: undefined };
}

export const GetReconciliationStatusRequest: MessageFns<GetReconciliationStatusRequest> = {
  encode(message: GetReconciliationStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.bankAccountId !== undefined) {
      writer.uint32(18).string(message.bankAccountId);
    }
    if (message.fromDate !== undefined) {
      writer.uint32(26).string(message.fromDate);
    }
    if (message.toDate !== undefined) {
      writer.uint32(34).string(message.toDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReconciliationStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReconciliationStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bankAccountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReconciliationStatusRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      bankAccountId: isSet(object.bankAccountId)
        ? globalThis.String(object.bankAccountId)
        : isSet(object.bank_account_id)
        ? globalThis.String(object.bank_account_id)
        : undefined,
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : undefined,
    };
  },

  toJSON(message: GetReconciliationStatusRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.bankAccountId !== undefined) {
      obj.bankAccountId = message.bankAccountId;
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReconciliationStatusRequest>, I>>(base?: I): GetReconciliationStatusRequest {
    return GetReconciliationStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReconciliationStatusRequest>, I>>(
    object: I,
  ): GetReconciliationStatusRequest {
    const message = createBaseGetReconciliationStatusRequest();
    message.societeId = object.societeId ?? "";
    message.bankAccountId = object.bankAccountId ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    return message;
  },
};

function createBaseReconciliationStatusResponse(): ReconciliationStatusResponse {
  return {
    societeId: "",
    totalStatements: 0,
    fullyReconciled: 0,
    partiallyReconciled: 0,
    pending: 0,
    totalUnmatchedAmountCents: 0,
    reconciliationRate: 0,
    lastImportAt: undefined,
  };
}

export const ReconciliationStatusResponse: MessageFns<ReconciliationStatusResponse> = {
  encode(message: ReconciliationStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.totalStatements !== 0) {
      writer.uint32(16).int32(message.totalStatements);
    }
    if (message.fullyReconciled !== 0) {
      writer.uint32(24).int32(message.fullyReconciled);
    }
    if (message.partiallyReconciled !== 0) {
      writer.uint32(32).int32(message.partiallyReconciled);
    }
    if (message.pending !== 0) {
      writer.uint32(40).int32(message.pending);
    }
    if (message.totalUnmatchedAmountCents !== 0) {
      writer.uint32(48).int64(message.totalUnmatchedAmountCents);
    }
    if (message.reconciliationRate !== 0) {
      writer.uint32(57).double(message.reconciliationRate);
    }
    if (message.lastImportAt !== undefined) {
      writer.uint32(66).string(message.lastImportAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconciliationStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconciliationStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalStatements = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fullyReconciled = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.partiallyReconciled = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pending = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalUnmatchedAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.reconciliationRate = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastImportAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconciliationStatusResponse {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      totalStatements: isSet(object.totalStatements)
        ? globalThis.Number(object.totalStatements)
        : isSet(object.total_statements)
        ? globalThis.Number(object.total_statements)
        : 0,
      fullyReconciled: isSet(object.fullyReconciled)
        ? globalThis.Number(object.fullyReconciled)
        : isSet(object.fully_reconciled)
        ? globalThis.Number(object.fully_reconciled)
        : 0,
      partiallyReconciled: isSet(object.partiallyReconciled)
        ? globalThis.Number(object.partiallyReconciled)
        : isSet(object.partially_reconciled)
        ? globalThis.Number(object.partially_reconciled)
        : 0,
      pending: isSet(object.pending) ? globalThis.Number(object.pending) : 0,
      totalUnmatchedAmountCents: isSet(object.totalUnmatchedAmountCents)
        ? globalThis.Number(object.totalUnmatchedAmountCents)
        : isSet(object.total_unmatched_amount_cents)
        ? globalThis.Number(object.total_unmatched_amount_cents)
        : 0,
      reconciliationRate: isSet(object.reconciliationRate)
        ? globalThis.Number(object.reconciliationRate)
        : isSet(object.reconciliation_rate)
        ? globalThis.Number(object.reconciliation_rate)
        : 0,
      lastImportAt: isSet(object.lastImportAt)
        ? globalThis.String(object.lastImportAt)
        : isSet(object.last_import_at)
        ? globalThis.String(object.last_import_at)
        : undefined,
    };
  },

  toJSON(message: ReconciliationStatusResponse): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.totalStatements !== 0) {
      obj.totalStatements = Math.round(message.totalStatements);
    }
    if (message.fullyReconciled !== 0) {
      obj.fullyReconciled = Math.round(message.fullyReconciled);
    }
    if (message.partiallyReconciled !== 0) {
      obj.partiallyReconciled = Math.round(message.partiallyReconciled);
    }
    if (message.pending !== 0) {
      obj.pending = Math.round(message.pending);
    }
    if (message.totalUnmatchedAmountCents !== 0) {
      obj.totalUnmatchedAmountCents = Math.round(message.totalUnmatchedAmountCents);
    }
    if (message.reconciliationRate !== 0) {
      obj.reconciliationRate = message.reconciliationRate;
    }
    if (message.lastImportAt !== undefined) {
      obj.lastImportAt = message.lastImportAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconciliationStatusResponse>, I>>(base?: I): ReconciliationStatusResponse {
    return ReconciliationStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconciliationStatusResponse>, I>>(object: I): ReconciliationStatusResponse {
    const message = createBaseReconciliationStatusResponse();
    message.societeId = object.societeId ?? "";
    message.totalStatements = object.totalStatements ?? 0;
    message.fullyReconciled = object.fullyReconciled ?? 0;
    message.partiallyReconciled = object.partiallyReconciled ?? 0;
    message.pending = object.pending ?? 0;
    message.totalUnmatchedAmountCents = object.totalUnmatchedAmountCents ?? 0;
    message.reconciliationRate = object.reconciliationRate ?? 0;
    message.lastImportAt = object.lastImportAt ?? undefined;
    return message;
  },
};

function createBaseForceReconciliationRequest(): ForceReconciliationRequest {
  return { societeId: "", bankTransactionId: "", paymentId: "", reason: undefined };
}

export const ForceReconciliationRequest: MessageFns<ForceReconciliationRequest> = {
  encode(message: ForceReconciliationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.bankTransactionId !== "") {
      writer.uint32(18).string(message.bankTransactionId);
    }
    if (message.paymentId !== "") {
      writer.uint32(26).string(message.paymentId);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForceReconciliationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForceReconciliationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bankTransactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForceReconciliationRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      bankTransactionId: isSet(object.bankTransactionId)
        ? globalThis.String(object.bankTransactionId)
        : isSet(object.bank_transaction_id)
        ? globalThis.String(object.bank_transaction_id)
        : "",
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: ForceReconciliationRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.bankTransactionId !== "") {
      obj.bankTransactionId = message.bankTransactionId;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForceReconciliationRequest>, I>>(base?: I): ForceReconciliationRequest {
    return ForceReconciliationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForceReconciliationRequest>, I>>(object: I): ForceReconciliationRequest {
    const message = createBaseForceReconciliationRequest();
    message.societeId = object.societeId ?? "";
    message.bankTransactionId = object.bankTransactionId ?? "";
    message.paymentId = object.paymentId ?? "";
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseReconciliationResponse(): ReconciliationResponse {
  return {
    id: "",
    bankTransactionId: "",
    paymentId: "",
    status: "",
    bankAmountCents: 0,
    paymentAmountCents: 0,
    reason: undefined,
    reconciledAt: "",
    reconciledBy: undefined,
  };
}

export const ReconciliationResponse: MessageFns<ReconciliationResponse> = {
  encode(message: ReconciliationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.bankTransactionId !== "") {
      writer.uint32(18).string(message.bankTransactionId);
    }
    if (message.paymentId !== "") {
      writer.uint32(26).string(message.paymentId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.bankAmountCents !== 0) {
      writer.uint32(40).int64(message.bankAmountCents);
    }
    if (message.paymentAmountCents !== 0) {
      writer.uint32(48).int64(message.paymentAmountCents);
    }
    if (message.reason !== undefined) {
      writer.uint32(58).string(message.reason);
    }
    if (message.reconciledAt !== "") {
      writer.uint32(66).string(message.reconciledAt);
    }
    if (message.reconciledBy !== undefined) {
      writer.uint32(74).string(message.reconciledBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconciliationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconciliationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bankTransactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.bankAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.paymentAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reconciledAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.reconciledBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconciliationResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      bankTransactionId: isSet(object.bankTransactionId)
        ? globalThis.String(object.bankTransactionId)
        : isSet(object.bank_transaction_id)
        ? globalThis.String(object.bank_transaction_id)
        : "",
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      bankAmountCents: isSet(object.bankAmountCents)
        ? globalThis.Number(object.bankAmountCents)
        : isSet(object.bank_amount_cents)
        ? globalThis.Number(object.bank_amount_cents)
        : 0,
      paymentAmountCents: isSet(object.paymentAmountCents)
        ? globalThis.Number(object.paymentAmountCents)
        : isSet(object.payment_amount_cents)
        ? globalThis.Number(object.payment_amount_cents)
        : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      reconciledAt: isSet(object.reconciledAt)
        ? globalThis.String(object.reconciledAt)
        : isSet(object.reconciled_at)
        ? globalThis.String(object.reconciled_at)
        : "",
      reconciledBy: isSet(object.reconciledBy)
        ? globalThis.String(object.reconciledBy)
        : isSet(object.reconciled_by)
        ? globalThis.String(object.reconciled_by)
        : undefined,
    };
  },

  toJSON(message: ReconciliationResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.bankTransactionId !== "") {
      obj.bankTransactionId = message.bankTransactionId;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.bankAmountCents !== 0) {
      obj.bankAmountCents = Math.round(message.bankAmountCents);
    }
    if (message.paymentAmountCents !== 0) {
      obj.paymentAmountCents = Math.round(message.paymentAmountCents);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.reconciledAt !== "") {
      obj.reconciledAt = message.reconciledAt;
    }
    if (message.reconciledBy !== undefined) {
      obj.reconciledBy = message.reconciledBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconciliationResponse>, I>>(base?: I): ReconciliationResponse {
    return ReconciliationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReconciliationResponse>, I>>(object: I): ReconciliationResponse {
    const message = createBaseReconciliationResponse();
    message.id = object.id ?? "";
    message.bankTransactionId = object.bankTransactionId ?? "";
    message.paymentId = object.paymentId ?? "";
    message.status = object.status ?? "";
    message.bankAmountCents = object.bankAmountCents ?? 0;
    message.paymentAmountCents = object.paymentAmountCents ?? 0;
    message.reason = object.reason ?? undefined;
    message.reconciledAt = object.reconciledAt ?? "";
    message.reconciledBy = object.reconciledBy ?? undefined;
    return message;
  },
};

function createBaseListUnmatchedPaymentsRequest(): ListUnmatchedPaymentsRequest {
  return {
    societeId: "",
    source: undefined,
    fromDate: undefined,
    toDate: undefined,
    page: undefined,
    pageSize: undefined,
  };
}

export const ListUnmatchedPaymentsRequest: MessageFns<ListUnmatchedPaymentsRequest> = {
  encode(message: ListUnmatchedPaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.source !== undefined) {
      writer.uint32(18).string(message.source);
    }
    if (message.fromDate !== undefined) {
      writer.uint32(26).string(message.fromDate);
    }
    if (message.toDate !== undefined) {
      writer.uint32(34).string(message.toDate);
    }
    if (message.page !== undefined) {
      writer.uint32(40).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(48).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUnmatchedPaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUnmatchedPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUnmatchedPaymentsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      source: isSet(object.source) ? globalThis.String(object.source) : undefined,
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : undefined,
    };
  },

  toJSON(message: ListUnmatchedPaymentsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.source !== undefined) {
      obj.source = message.source;
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUnmatchedPaymentsRequest>, I>>(base?: I): ListUnmatchedPaymentsRequest {
    return ListUnmatchedPaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUnmatchedPaymentsRequest>, I>>(object: I): ListUnmatchedPaymentsRequest {
    const message = createBaseListUnmatchedPaymentsRequest();
    message.societeId = object.societeId ?? "";
    message.source = object.source ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.page = object.page ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    return message;
  },
};

function createBaseListUnmatchedPaymentsResponse(): ListUnmatchedPaymentsResponse {
  return { payments: [], total: 0, page: 0, pageSize: 0 };
}

export const ListUnmatchedPaymentsResponse: MessageFns<ListUnmatchedPaymentsResponse> = {
  encode(message: ListUnmatchedPaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.payments) {
      UnmatchedPayment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUnmatchedPaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUnmatchedPaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payments.push(UnmatchedPayment.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUnmatchedPaymentsResponse {
    return {
      payments: globalThis.Array.isArray(object?.payments)
        ? object.payments.map((e: any) => UnmatchedPayment.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListUnmatchedPaymentsResponse): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => UnmatchedPayment.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUnmatchedPaymentsResponse>, I>>(base?: I): ListUnmatchedPaymentsResponse {
    return ListUnmatchedPaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUnmatchedPaymentsResponse>, I>>(
    object: I,
  ): ListUnmatchedPaymentsResponse {
    const message = createBaseListUnmatchedPaymentsResponse();
    message.payments = object.payments?.map((e) => UnmatchedPayment.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseUnmatchedPayment(): UnmatchedPayment {
  return {
    id: "",
    source: "",
    amountCents: 0,
    currency: "",
    reference: undefined,
    description: undefined,
    date: "",
    suggestedMatchId: undefined,
    matchConfidence: undefined,
  };
}

export const UnmatchedPayment: MessageFns<UnmatchedPayment> = {
  encode(message: UnmatchedPayment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.reference !== undefined) {
      writer.uint32(42).string(message.reference);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    if (message.date !== "") {
      writer.uint32(58).string(message.date);
    }
    if (message.suggestedMatchId !== undefined) {
      writer.uint32(66).string(message.suggestedMatchId);
    }
    if (message.matchConfidence !== undefined) {
      writer.uint32(72).int32(message.matchConfidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmatchedPayment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmatchedPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.suggestedMatchId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.matchConfidence = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnmatchedPayment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      reference: isSet(object.reference) ? globalThis.String(object.reference) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      suggestedMatchId: isSet(object.suggestedMatchId)
        ? globalThis.String(object.suggestedMatchId)
        : isSet(object.suggested_match_id)
        ? globalThis.String(object.suggested_match_id)
        : undefined,
      matchConfidence: isSet(object.matchConfidence)
        ? globalThis.Number(object.matchConfidence)
        : isSet(object.match_confidence)
        ? globalThis.Number(object.match_confidence)
        : undefined,
    };
  },

  toJSON(message: UnmatchedPayment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.reference !== undefined) {
      obj.reference = message.reference;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.suggestedMatchId !== undefined) {
      obj.suggestedMatchId = message.suggestedMatchId;
    }
    if (message.matchConfidence !== undefined) {
      obj.matchConfidence = Math.round(message.matchConfidence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmatchedPayment>, I>>(base?: I): UnmatchedPayment {
    return UnmatchedPayment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmatchedPayment>, I>>(object: I): UnmatchedPayment {
    const message = createBaseUnmatchedPayment();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.reference = object.reference ?? undefined;
    message.description = object.description ?? undefined;
    message.date = object.date ?? "";
    message.suggestedMatchId = object.suggestedMatchId ?? undefined;
    message.matchConfidence = object.matchConfidence ?? undefined;
    return message;
  },
};

function createBaseListProviderStatusMappingsRequest(): ListProviderStatusMappingsRequest {
  return { societeId: "", providerName: undefined };
}

export const ListProviderStatusMappingsRequest: MessageFns<ListProviderStatusMappingsRequest> = {
  encode(message: ListProviderStatusMappingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.providerName !== undefined) {
      writer.uint32(18).string(message.providerName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProviderStatusMappingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProviderStatusMappingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProviderStatusMappingsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      providerName: isSet(object.providerName)
        ? globalThis.String(object.providerName)
        : isSet(object.provider_name)
        ? globalThis.String(object.provider_name)
        : undefined,
    };
  },

  toJSON(message: ListProviderStatusMappingsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.providerName !== undefined) {
      obj.providerName = message.providerName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProviderStatusMappingsRequest>, I>>(
    base?: I,
  ): ListProviderStatusMappingsRequest {
    return ListProviderStatusMappingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProviderStatusMappingsRequest>, I>>(
    object: I,
  ): ListProviderStatusMappingsRequest {
    const message = createBaseListProviderStatusMappingsRequest();
    message.societeId = object.societeId ?? "";
    message.providerName = object.providerName ?? undefined;
    return message;
  },
};

function createBaseListProviderStatusMappingsResponse(): ListProviderStatusMappingsResponse {
  return { mappings: [], total: 0 };
}

export const ListProviderStatusMappingsResponse: MessageFns<ListProviderStatusMappingsResponse> = {
  encode(message: ListProviderStatusMappingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mappings) {
      ProviderStatusMappingResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProviderStatusMappingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProviderStatusMappingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mappings.push(ProviderStatusMappingResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProviderStatusMappingsResponse {
    return {
      mappings: globalThis.Array.isArray(object?.mappings)
        ? object.mappings.map((e: any) => ProviderStatusMappingResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListProviderStatusMappingsResponse): unknown {
    const obj: any = {};
    if (message.mappings?.length) {
      obj.mappings = message.mappings.map((e) => ProviderStatusMappingResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProviderStatusMappingsResponse>, I>>(
    base?: I,
  ): ListProviderStatusMappingsResponse {
    return ListProviderStatusMappingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProviderStatusMappingsResponse>, I>>(
    object: I,
  ): ListProviderStatusMappingsResponse {
    const message = createBaseListProviderStatusMappingsResponse();
    message.mappings = object.mappings?.map((e) => ProviderStatusMappingResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseProviderStatusMappingResponse(): ProviderStatusMappingResponse {
  return {
    id: "",
    providerName: "",
    providerStatus: "",
    internalStatus: "",
    eventType: "",
    rejectionCategory: undefined,
    retryAdvice: undefined,
    isActive: false,
    updatedAt: "",
  };
}

export const ProviderStatusMappingResponse: MessageFns<ProviderStatusMappingResponse> = {
  encode(message: ProviderStatusMappingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.providerName !== "") {
      writer.uint32(18).string(message.providerName);
    }
    if (message.providerStatus !== "") {
      writer.uint32(26).string(message.providerStatus);
    }
    if (message.internalStatus !== "") {
      writer.uint32(34).string(message.internalStatus);
    }
    if (message.eventType !== "") {
      writer.uint32(42).string(message.eventType);
    }
    if (message.rejectionCategory !== undefined) {
      writer.uint32(50).string(message.rejectionCategory);
    }
    if (message.retryAdvice !== undefined) {
      writer.uint32(58).string(message.retryAdvice);
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderStatusMappingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderStatusMappingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerStatus = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.internalStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rejectionCategory = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.retryAdvice = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderStatusMappingResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      providerName: isSet(object.providerName)
        ? globalThis.String(object.providerName)
        : isSet(object.provider_name)
        ? globalThis.String(object.provider_name)
        : "",
      providerStatus: isSet(object.providerStatus)
        ? globalThis.String(object.providerStatus)
        : isSet(object.provider_status)
        ? globalThis.String(object.provider_status)
        : "",
      internalStatus: isSet(object.internalStatus)
        ? globalThis.String(object.internalStatus)
        : isSet(object.internal_status)
        ? globalThis.String(object.internal_status)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      rejectionCategory: isSet(object.rejectionCategory)
        ? globalThis.String(object.rejectionCategory)
        : isSet(object.rejection_category)
        ? globalThis.String(object.rejection_category)
        : undefined,
      retryAdvice: isSet(object.retryAdvice)
        ? globalThis.String(object.retryAdvice)
        : isSet(object.retry_advice)
        ? globalThis.String(object.retry_advice)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: ProviderStatusMappingResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.providerName !== "") {
      obj.providerName = message.providerName;
    }
    if (message.providerStatus !== "") {
      obj.providerStatus = message.providerStatus;
    }
    if (message.internalStatus !== "") {
      obj.internalStatus = message.internalStatus;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rejectionCategory !== undefined) {
      obj.rejectionCategory = message.rejectionCategory;
    }
    if (message.retryAdvice !== undefined) {
      obj.retryAdvice = message.retryAdvice;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderStatusMappingResponse>, I>>(base?: I): ProviderStatusMappingResponse {
    return ProviderStatusMappingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderStatusMappingResponse>, I>>(
    object: I,
  ): ProviderStatusMappingResponse {
    const message = createBaseProviderStatusMappingResponse();
    message.id = object.id ?? "";
    message.providerName = object.providerName ?? "";
    message.providerStatus = object.providerStatus ?? "";
    message.internalStatus = object.internalStatus ?? "";
    message.eventType = object.eventType ?? "";
    message.rejectionCategory = object.rejectionCategory ?? undefined;
    message.retryAdvice = object.retryAdvice ?? undefined;
    message.isActive = object.isActive ?? false;
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseUpdateProviderStatusMappingRequest(): UpdateProviderStatusMappingRequest {
  return {
    id: "",
    internalStatus: undefined,
    rejectionCategory: undefined,
    retryAdvice: undefined,
    isActive: undefined,
  };
}

export const UpdateProviderStatusMappingRequest: MessageFns<UpdateProviderStatusMappingRequest> = {
  encode(message: UpdateProviderStatusMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.internalStatus !== undefined) {
      writer.uint32(18).string(message.internalStatus);
    }
    if (message.rejectionCategory !== undefined) {
      writer.uint32(26).string(message.rejectionCategory);
    }
    if (message.retryAdvice !== undefined) {
      writer.uint32(34).string(message.retryAdvice);
    }
    if (message.isActive !== undefined) {
      writer.uint32(40).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProviderStatusMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProviderStatusMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.internalStatus = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rejectionCategory = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.retryAdvice = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProviderStatusMappingRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      internalStatus: isSet(object.internalStatus)
        ? globalThis.String(object.internalStatus)
        : isSet(object.internal_status)
        ? globalThis.String(object.internal_status)
        : undefined,
      rejectionCategory: isSet(object.rejectionCategory)
        ? globalThis.String(object.rejectionCategory)
        : isSet(object.rejection_category)
        ? globalThis.String(object.rejection_category)
        : undefined,
      retryAdvice: isSet(object.retryAdvice)
        ? globalThis.String(object.retryAdvice)
        : isSet(object.retry_advice)
        ? globalThis.String(object.retry_advice)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
    };
  },

  toJSON(message: UpdateProviderStatusMappingRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.internalStatus !== undefined) {
      obj.internalStatus = message.internalStatus;
    }
    if (message.rejectionCategory !== undefined) {
      obj.rejectionCategory = message.rejectionCategory;
    }
    if (message.retryAdvice !== undefined) {
      obj.retryAdvice = message.retryAdvice;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProviderStatusMappingRequest>, I>>(
    base?: I,
  ): UpdateProviderStatusMappingRequest {
    return UpdateProviderStatusMappingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProviderStatusMappingRequest>, I>>(
    object: I,
  ): UpdateProviderStatusMappingRequest {
    const message = createBaseUpdateProviderStatusMappingRequest();
    message.id = object.id ?? "";
    message.internalStatus = object.internalStatus ?? undefined;
    message.rejectionCategory = object.rejectionCategory ?? undefined;
    message.retryAdvice = object.retryAdvice ?? undefined;
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

function createBaseListRejectionReasonsRequest(): ListRejectionReasonsRequest {
  return {
    societeId: "",
    providerName: undefined,
    category: undefined,
    isActive: undefined,
    page: undefined,
    pageSize: undefined,
  };
}

export const ListRejectionReasonsRequest: MessageFns<ListRejectionReasonsRequest> = {
  encode(message: ListRejectionReasonsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.providerName !== undefined) {
      writer.uint32(18).string(message.providerName);
    }
    if (message.category !== undefined) {
      writer.uint32(26).string(message.category);
    }
    if (message.isActive !== undefined) {
      writer.uint32(32).bool(message.isActive);
    }
    if (message.page !== undefined) {
      writer.uint32(40).int32(message.page);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(48).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRejectionReasonsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRejectionReasonsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRejectionReasonsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      providerName: isSet(object.providerName)
        ? globalThis.String(object.providerName)
        : isSet(object.provider_name)
        ? globalThis.String(object.provider_name)
        : undefined,
      category: isSet(object.category) ? globalThis.String(object.category) : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : undefined,
    };
  },

  toJSON(message: ListRejectionReasonsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.providerName !== undefined) {
      obj.providerName = message.providerName;
    }
    if (message.category !== undefined) {
      obj.category = message.category;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRejectionReasonsRequest>, I>>(base?: I): ListRejectionReasonsRequest {
    return ListRejectionReasonsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRejectionReasonsRequest>, I>>(object: I): ListRejectionReasonsRequest {
    const message = createBaseListRejectionReasonsRequest();
    message.societeId = object.societeId ?? "";
    message.providerName = object.providerName ?? undefined;
    message.category = object.category ?? undefined;
    message.isActive = object.isActive ?? undefined;
    message.page = object.page ?? undefined;
    message.pageSize = object.pageSize ?? undefined;
    return message;
  },
};

function createBaseListRejectionReasonsResponse(): ListRejectionReasonsResponse {
  return { reasons: [], total: 0, page: 0, pageSize: 0 };
}

export const ListRejectionReasonsResponse: MessageFns<ListRejectionReasonsResponse> = {
  encode(message: ListRejectionReasonsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reasons) {
      RejectionReasonResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRejectionReasonsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRejectionReasonsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reasons.push(RejectionReasonResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRejectionReasonsResponse {
    return {
      reasons: globalThis.Array.isArray(object?.reasons)
        ? object.reasons.map((e: any) => RejectionReasonResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize)
        ? globalThis.Number(object.pageSize)
        : isSet(object.page_size)
        ? globalThis.Number(object.page_size)
        : 0,
    };
  },

  toJSON(message: ListRejectionReasonsResponse): unknown {
    const obj: any = {};
    if (message.reasons?.length) {
      obj.reasons = message.reasons.map((e) => RejectionReasonResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRejectionReasonsResponse>, I>>(base?: I): ListRejectionReasonsResponse {
    return ListRejectionReasonsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRejectionReasonsResponse>, I>>(object: I): ListRejectionReasonsResponse {
    const message = createBaseListRejectionReasonsResponse();
    message.reasons = object.reasons?.map((e) => RejectionReasonResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseRejectionReasonResponse(): RejectionReasonResponse {
  return {
    id: "",
    code: "",
    label: "",
    description: "",
    category: "",
    retryStrategy: "",
    maxRetries: undefined,
    retryDelayDays: undefined,
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const RejectionReasonResponse: MessageFns<RejectionReasonResponse> = {
  encode(message: RejectionReasonResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.category !== "") {
      writer.uint32(42).string(message.category);
    }
    if (message.retryStrategy !== "") {
      writer.uint32(50).string(message.retryStrategy);
    }
    if (message.maxRetries !== undefined) {
      writer.uint32(56).int32(message.maxRetries);
    }
    if (message.retryDelayDays !== undefined) {
      writer.uint32(64).int32(message.retryDelayDays);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectionReasonResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectionReasonResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.retryStrategy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxRetries = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.retryDelayDays = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectionReasonResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      retryStrategy: isSet(object.retryStrategy)
        ? globalThis.String(object.retryStrategy)
        : isSet(object.retry_strategy)
        ? globalThis.String(object.retry_strategy)
        : "",
      maxRetries: isSet(object.maxRetries)
        ? globalThis.Number(object.maxRetries)
        : isSet(object.max_retries)
        ? globalThis.Number(object.max_retries)
        : undefined,
      retryDelayDays: isSet(object.retryDelayDays)
        ? globalThis.Number(object.retryDelayDays)
        : isSet(object.retry_delay_days)
        ? globalThis.Number(object.retry_delay_days)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: RejectionReasonResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.retryStrategy !== "") {
      obj.retryStrategy = message.retryStrategy;
    }
    if (message.maxRetries !== undefined) {
      obj.maxRetries = Math.round(message.maxRetries);
    }
    if (message.retryDelayDays !== undefined) {
      obj.retryDelayDays = Math.round(message.retryDelayDays);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RejectionReasonResponse>, I>>(base?: I): RejectionReasonResponse {
    return RejectionReasonResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RejectionReasonResponse>, I>>(object: I): RejectionReasonResponse {
    const message = createBaseRejectionReasonResponse();
    message.id = object.id ?? "";
    message.code = object.code ?? "";
    message.label = object.label ?? "";
    message.description = object.description ?? "";
    message.category = object.category ?? "";
    message.retryStrategy = object.retryStrategy ?? "";
    message.maxRetries = object.maxRetries ?? undefined;
    message.retryDelayDays = object.retryDelayDays ?? undefined;
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateRejectionReasonRequest(): CreateRejectionReasonRequest {
  return {
    societeId: "",
    code: "",
    label: "",
    description: "",
    category: "",
    retryStrategy: "",
    maxRetries: undefined,
    retryDelayDays: undefined,
  };
}

export const CreateRejectionReasonRequest: MessageFns<CreateRejectionReasonRequest> = {
  encode(message: CreateRejectionReasonRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.category !== "") {
      writer.uint32(42).string(message.category);
    }
    if (message.retryStrategy !== "") {
      writer.uint32(50).string(message.retryStrategy);
    }
    if (message.maxRetries !== undefined) {
      writer.uint32(56).int32(message.maxRetries);
    }
    if (message.retryDelayDays !== undefined) {
      writer.uint32(64).int32(message.retryDelayDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRejectionReasonRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRejectionReasonRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.retryStrategy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxRetries = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.retryDelayDays = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRejectionReasonRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      retryStrategy: isSet(object.retryStrategy)
        ? globalThis.String(object.retryStrategy)
        : isSet(object.retry_strategy)
        ? globalThis.String(object.retry_strategy)
        : "",
      maxRetries: isSet(object.maxRetries)
        ? globalThis.Number(object.maxRetries)
        : isSet(object.max_retries)
        ? globalThis.Number(object.max_retries)
        : undefined,
      retryDelayDays: isSet(object.retryDelayDays)
        ? globalThis.Number(object.retryDelayDays)
        : isSet(object.retry_delay_days)
        ? globalThis.Number(object.retry_delay_days)
        : undefined,
    };
  },

  toJSON(message: CreateRejectionReasonRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.retryStrategy !== "") {
      obj.retryStrategy = message.retryStrategy;
    }
    if (message.maxRetries !== undefined) {
      obj.maxRetries = Math.round(message.maxRetries);
    }
    if (message.retryDelayDays !== undefined) {
      obj.retryDelayDays = Math.round(message.retryDelayDays);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRejectionReasonRequest>, I>>(base?: I): CreateRejectionReasonRequest {
    return CreateRejectionReasonRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRejectionReasonRequest>, I>>(object: I): CreateRejectionReasonRequest {
    const message = createBaseCreateRejectionReasonRequest();
    message.societeId = object.societeId ?? "";
    message.code = object.code ?? "";
    message.label = object.label ?? "";
    message.description = object.description ?? "";
    message.category = object.category ?? "";
    message.retryStrategy = object.retryStrategy ?? "";
    message.maxRetries = object.maxRetries ?? undefined;
    message.retryDelayDays = object.retryDelayDays ?? undefined;
    return message;
  },
};

function createBaseUpdateRejectionReasonRequest(): UpdateRejectionReasonRequest {
  return {
    id: "",
    label: undefined,
    description: undefined,
    category: undefined,
    retryStrategy: undefined,
    maxRetries: undefined,
    retryDelayDays: undefined,
    isActive: undefined,
  };
}

export const UpdateRejectionReasonRequest: MessageFns<UpdateRejectionReasonRequest> = {
  encode(message: UpdateRejectionReasonRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.label !== undefined) {
      writer.uint32(18).string(message.label);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.category !== undefined) {
      writer.uint32(34).string(message.category);
    }
    if (message.retryStrategy !== undefined) {
      writer.uint32(42).string(message.retryStrategy);
    }
    if (message.maxRetries !== undefined) {
      writer.uint32(48).int32(message.maxRetries);
    }
    if (message.retryDelayDays !== undefined) {
      writer.uint32(56).int32(message.retryDelayDays);
    }
    if (message.isActive !== undefined) {
      writer.uint32(64).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRejectionReasonRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRejectionReasonRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.retryStrategy = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxRetries = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.retryDelayDays = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRejectionReasonRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      category: isSet(object.category) ? globalThis.String(object.category) : undefined,
      retryStrategy: isSet(object.retryStrategy)
        ? globalThis.String(object.retryStrategy)
        : isSet(object.retry_strategy)
        ? globalThis.String(object.retry_strategy)
        : undefined,
      maxRetries: isSet(object.maxRetries)
        ? globalThis.Number(object.maxRetries)
        : isSet(object.max_retries)
        ? globalThis.Number(object.max_retries)
        : undefined,
      retryDelayDays: isSet(object.retryDelayDays)
        ? globalThis.Number(object.retryDelayDays)
        : isSet(object.retry_delay_days)
        ? globalThis.Number(object.retry_delay_days)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
    };
  },

  toJSON(message: UpdateRejectionReasonRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.label !== undefined) {
      obj.label = message.label;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.category !== undefined) {
      obj.category = message.category;
    }
    if (message.retryStrategy !== undefined) {
      obj.retryStrategy = message.retryStrategy;
    }
    if (message.maxRetries !== undefined) {
      obj.maxRetries = Math.round(message.maxRetries);
    }
    if (message.retryDelayDays !== undefined) {
      obj.retryDelayDays = Math.round(message.retryDelayDays);
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRejectionReasonRequest>, I>>(base?: I): UpdateRejectionReasonRequest {
    return UpdateRejectionReasonRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRejectionReasonRequest>, I>>(object: I): UpdateRejectionReasonRequest {
    const message = createBaseUpdateRejectionReasonRequest();
    message.id = object.id ?? "";
    message.label = object.label ?? undefined;
    message.description = object.description ?? undefined;
    message.category = object.category ?? undefined;
    message.retryStrategy = object.retryStrategy ?? undefined;
    message.maxRetries = object.maxRetries ?? undefined;
    message.retryDelayDays = object.retryDelayDays ?? undefined;
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: {
    path: "/payment.PaymentService/CreateStripeCheckoutSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCheckoutSessionRequest): Buffer =>
      Buffer.from(CreateStripeCheckoutSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeCheckoutSessionRequest =>
      CreateStripeCheckoutSessionRequest.decode(value),
    responseSerialize: (value: StripeCheckoutSessionResponse): Buffer =>
      Buffer.from(StripeCheckoutSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCheckoutSessionResponse => StripeCheckoutSessionResponse.decode(value),
  },
  createStripePaymentIntent: {
    path: "/payment.PaymentService/CreateStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripePaymentIntentRequest): Buffer =>
      Buffer.from(CreateStripePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripePaymentIntentRequest =>
      CreateStripePaymentIntentRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  getStripePaymentIntent: {
    path: "/payment.PaymentService/GetStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  cancelStripePaymentIntent: {
    path: "/payment.PaymentService/CancelStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  /** Customers */
  createStripeCustomer: {
    path: "/payment.PaymentService/CreateStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCustomerRequest): Buffer =>
      Buffer.from(CreateStripeCustomerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeCustomerRequest => CreateStripeCustomerRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse): Buffer =>
      Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCustomerResponse => StripeCustomerResponse.decode(value),
  },
  getStripeCustomer: {
    path: "/payment.PaymentService/GetStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse): Buffer =>
      Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCustomerResponse => StripeCustomerResponse.decode(value),
  },
  /** Subscriptions */
  createStripeSubscription: {
    path: "/payment.PaymentService/CreateStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSubscriptionRequest): Buffer =>
      Buffer.from(CreateStripeSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeSubscriptionRequest =>
      CreateStripeSubscriptionRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  getStripeSubscription: {
    path: "/payment.PaymentService/GetStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  cancelStripeSubscription: {
    path: "/payment.PaymentService/CancelStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  /** Refunds */
  createStripeRefund: {
    path: "/payment.PaymentService/CreateStripeRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeRefundRequest): Buffer =>
      Buffer.from(CreateStripeRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeRefundRequest => CreateStripeRefundRequest.decode(value),
    responseSerialize: (value: StripeRefundResponse): Buffer =>
      Buffer.from(StripeRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeRefundResponse => StripeRefundResponse.decode(value),
  },
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: {
    path: "/payment.PaymentService/CreateStripeSetupIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSetupIntentRequest): Buffer =>
      Buffer.from(CreateStripeSetupIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeSetupIntentRequest => CreateStripeSetupIntentRequest.decode(value),
    responseSerialize: (value: StripeSetupIntentResponse): Buffer =>
      Buffer.from(StripeSetupIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSetupIntentResponse => StripeSetupIntentResponse.decode(value),
  },
  /** Billing Portal */
  createStripeBillingPortalSession: {
    path: "/payment.PaymentService/CreateStripeBillingPortalSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeBillingPortalRequest): Buffer =>
      Buffer.from(CreateStripeBillingPortalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeBillingPortalRequest =>
      CreateStripeBillingPortalRequest.decode(value),
    responseSerialize: (value: StripeBillingPortalResponse): Buffer =>
      Buffer.from(StripeBillingPortalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeBillingPortalResponse => StripeBillingPortalResponse.decode(value),
  },
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: {
    path: "/payment.PaymentService/CreatePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePayPalOrderRequest): Buffer =>
      Buffer.from(CreatePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePayPalOrderRequest => CreatePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  getPayPalOrder: {
    path: "/payment.PaymentService/GetPayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest): Buffer =>
      Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPayPalOrderRequest => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  capturePayPalOrder: {
    path: "/payment.PaymentService/CapturePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CapturePayPalOrderRequest): Buffer =>
      Buffer.from(CapturePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CapturePayPalOrderRequest => CapturePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalCaptureResponse): Buffer =>
      Buffer.from(PayPalCaptureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalCaptureResponse => PayPalCaptureResponse.decode(value),
  },
  authorizePayPalOrder: {
    path: "/payment.PaymentService/AuthorizePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest): Buffer =>
      Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPayPalOrderRequest => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: {
    path: "/payment.PaymentService/SetupGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetupGoCardlessMandateRequest): Buffer =>
      Buffer.from(SetupGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SetupGoCardlessMandateRequest => SetupGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  getGoCardlessMandate: {
    path: "/payment.PaymentService/GetGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest): Buffer =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGoCardlessMandateRequest => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  cancelGoCardlessMandate: {
    path: "/payment.PaymentService/CancelGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest): Buffer =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGoCardlessMandateRequest => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  createGoCardlessPayment: {
    path: "/payment.PaymentService/CreateGoCardlessPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessPaymentRequest): Buffer =>
      Buffer.from(CreateGoCardlessPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGoCardlessPaymentRequest => CreateGoCardlessPaymentRequest.decode(value),
    responseSerialize: (value: GoCardlessPaymentResponse): Buffer =>
      Buffer.from(GoCardlessPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessPaymentResponse => GoCardlessPaymentResponse.decode(value),
  },
  createGoCardlessSubscription: {
    path: "/payment.PaymentService/CreateGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessSubscriptionRequest): Buffer =>
      Buffer.from(CreateGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGoCardlessSubscriptionRequest =>
      CreateGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse): Buffer =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessSubscriptionResponse =>
      GoCardlessSubscriptionResponse.decode(value),
  },
  cancelGoCardlessSubscription: {
    path: "/payment.PaymentService/CancelGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelGoCardlessSubscriptionRequest): Buffer =>
      Buffer.from(CancelGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelGoCardlessSubscriptionRequest =>
      CancelGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse): Buffer =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessSubscriptionResponse =>
      GoCardlessSubscriptionResponse.decode(value),
  },
  /** ==================== SCHEDULES ==================== */
  createSchedule: {
    path: "/payment.PaymentService/CreateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateScheduleRequest): Buffer =>
      Buffer.from(CreateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateScheduleRequest => CreateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  getSchedule: {
    path: "/payment.PaymentService/GetSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  updateSchedule: {
    path: "/payment.PaymentService/UpdateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateScheduleRequest): Buffer =>
      Buffer.from(UpdateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateScheduleRequest => UpdateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  deleteSchedule: {
    path: "/payment.PaymentService/DeleteSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getDueSchedules: {
    path: "/payment.PaymentService/GetDueSchedules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDueSchedulesRequest): Buffer =>
      Buffer.from(GetDueSchedulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDueSchedulesRequest => GetDueSchedulesRequest.decode(value),
    responseSerialize: (value: ScheduleListResponse): Buffer =>
      Buffer.from(ScheduleListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleListResponse => ScheduleListResponse.decode(value),
  },
  processDuePayments: {
    path: "/payment.PaymentService/ProcessDuePayments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDuePaymentsRequest): Buffer =>
      Buffer.from(ProcessDuePaymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessDuePaymentsRequest => ProcessDuePaymentsRequest.decode(value),
    responseSerialize: (value: ProcessDuePaymentsResponse): Buffer =>
      Buffer.from(ProcessDuePaymentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessDuePaymentsResponse => ProcessDuePaymentsResponse.decode(value),
  },
  renewSchedule: {
    path: "/payment.PaymentService/RenewSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenewScheduleRequest): Buffer => Buffer.from(RenewScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RenewScheduleRequest => RenewScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: {
    path: "/payment.PaymentService/CreatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentIntentRequest): Buffer =>
      Buffer.from(CreatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePaymentIntentRequest => CreatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  getPaymentIntent: {
    path: "/payment.PaymentService/GetPaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  updatePaymentIntent: {
    path: "/payment.PaymentService/UpdatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePaymentIntentRequest): Buffer =>
      Buffer.from(UpdatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePaymentIntentRequest => UpdatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  deletePaymentIntent: {
    path: "/payment.PaymentService/DeletePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: {
    path: "/payment.PaymentService/CreatePaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentEventRequest): Buffer =>
      Buffer.from(CreatePaymentEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePaymentEventRequest => CreatePaymentEventRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  getPaymentEvent: {
    path: "/payment.PaymentService/GetPaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  getUnprocessedEvents: {
    path: "/payment.PaymentService/GetUnprocessedEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUnprocessedEventsRequest): Buffer =>
      Buffer.from(GetUnprocessedEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUnprocessedEventsRequest => GetUnprocessedEventsRequest.decode(value),
    responseSerialize: (value: PaymentEventListResponse): Buffer =>
      Buffer.from(PaymentEventListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventListResponse => PaymentEventListResponse.decode(value),
  },
  markEventProcessed: {
    path: "/payment.PaymentService/MarkEventProcessed",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkEventProcessedRequest): Buffer =>
      Buffer.from(MarkEventProcessedRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarkEventProcessedRequest => MarkEventProcessedRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: {
    path: "/payment.PaymentService/GetPSPAccountsSummary",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPSPAccountsRequest): Buffer =>
      Buffer.from(GetPSPAccountsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPSPAccountsRequest => GetPSPAccountsRequest.decode(value),
    responseSerialize: (value: PSPAccountsSummaryResponse): Buffer =>
      Buffer.from(PSPAccountsSummaryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PSPAccountsSummaryResponse => PSPAccountsSummaryResponse.decode(value),
  },
  /** ==================== SLIMPAY ==================== */
  createSlimpayMandate: {
    path: "/payment.PaymentService/CreateSlimpayMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSlimpayMandateRequest): Buffer =>
      Buffer.from(CreateSlimpayMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSlimpayMandateRequest => CreateSlimpayMandateRequest.decode(value),
    responseSerialize: (value: SlimpayMandateResponse): Buffer =>
      Buffer.from(SlimpayMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SlimpayMandateResponse => SlimpayMandateResponse.decode(value),
  },
  getSlimpayMandate: {
    path: "/payment.PaymentService/GetSlimpayMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSlimpayMandateRequest): Buffer =>
      Buffer.from(GetSlimpayMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSlimpayMandateRequest => GetSlimpayMandateRequest.decode(value),
    responseSerialize: (value: SlimpayMandateResponse): Buffer =>
      Buffer.from(SlimpayMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SlimpayMandateResponse => SlimpayMandateResponse.decode(value),
  },
  cancelSlimpayMandate: {
    path: "/payment.PaymentService/CancelSlimpayMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelSlimpayMandateRequest): Buffer =>
      Buffer.from(CancelSlimpayMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelSlimpayMandateRequest => CancelSlimpayMandateRequest.decode(value),
    responseSerialize: (value: SlimpayMandateResponse): Buffer =>
      Buffer.from(SlimpayMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SlimpayMandateResponse => SlimpayMandateResponse.decode(value),
  },
  createSlimpayPayment: {
    path: "/payment.PaymentService/CreateSlimpayPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSlimpayPaymentRequest): Buffer =>
      Buffer.from(CreateSlimpayPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSlimpayPaymentRequest => CreateSlimpayPaymentRequest.decode(value),
    responseSerialize: (value: SlimpayPaymentResponse): Buffer =>
      Buffer.from(SlimpayPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SlimpayPaymentResponse => SlimpayPaymentResponse.decode(value),
  },
  getSlimpayPayment: {
    path: "/payment.PaymentService/GetSlimpayPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSlimpayPaymentRequest): Buffer =>
      Buffer.from(GetSlimpayPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSlimpayPaymentRequest => GetSlimpayPaymentRequest.decode(value),
    responseSerialize: (value: SlimpayPaymentResponse): Buffer =>
      Buffer.from(SlimpayPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SlimpayPaymentResponse => SlimpayPaymentResponse.decode(value),
  },
  /** ==================== MULTISAFEPAY ==================== */
  createMultiSafepayTransaction: {
    path: "/payment.PaymentService/CreateMultiSafepayTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateMultiSafepayTransactionRequest): Buffer =>
      Buffer.from(CreateMultiSafepayTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateMultiSafepayTransactionRequest =>
      CreateMultiSafepayTransactionRequest.decode(value),
    responseSerialize: (value: MultiSafepayTransactionResponse): Buffer =>
      Buffer.from(MultiSafepayTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSafepayTransactionResponse =>
      MultiSafepayTransactionResponse.decode(value),
  },
  getMultiSafepayTransaction: {
    path: "/payment.PaymentService/GetMultiSafepayTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMultiSafepayTransactionRequest): Buffer =>
      Buffer.from(GetMultiSafepayTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMultiSafepayTransactionRequest =>
      GetMultiSafepayTransactionRequest.decode(value),
    responseSerialize: (value: MultiSafepayTransactionResponse): Buffer =>
      Buffer.from(MultiSafepayTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSafepayTransactionResponse =>
      MultiSafepayTransactionResponse.decode(value),
  },
  refundMultiSafepayTransaction: {
    path: "/payment.PaymentService/RefundMultiSafepayTransaction",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefundMultiSafepayTransactionRequest): Buffer =>
      Buffer.from(RefundMultiSafepayTransactionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefundMultiSafepayTransactionRequest =>
      RefundMultiSafepayTransactionRequest.decode(value),
    responseSerialize: (value: MultiSafepayTransactionResponse): Buffer =>
      Buffer.from(MultiSafepayTransactionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MultiSafepayTransactionResponse =>
      MultiSafepayTransactionResponse.decode(value),
  },
  /** ==================== EMERCHANTPAY ==================== */
  createEmerchantpayPayment: {
    path: "/payment.PaymentService/CreateEmerchantpayPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateEmerchantpayPaymentRequest): Buffer =>
      Buffer.from(CreateEmerchantpayPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateEmerchantpayPaymentRequest =>
      CreateEmerchantpayPaymentRequest.decode(value),
    responseSerialize: (value: EmerchantpayPaymentResponse): Buffer =>
      Buffer.from(EmerchantpayPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmerchantpayPaymentResponse => EmerchantpayPaymentResponse.decode(value),
  },
  getEmerchantpayPayment: {
    path: "/payment.PaymentService/GetEmerchantpayPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmerchantpayPaymentRequest): Buffer =>
      Buffer.from(GetEmerchantpayPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmerchantpayPaymentRequest => GetEmerchantpayPaymentRequest.decode(value),
    responseSerialize: (value: EmerchantpayPaymentResponse): Buffer =>
      Buffer.from(EmerchantpayPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmerchantpayPaymentResponse => EmerchantpayPaymentResponse.decode(value),
  },
  createEmerchantpaySepaPayment: {
    path: "/payment.PaymentService/CreateEmerchantpaySepaPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateEmerchantpaySepaPaymentRequest): Buffer =>
      Buffer.from(CreateEmerchantpaySepaPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateEmerchantpaySepaPaymentRequest =>
      CreateEmerchantpaySepaPaymentRequest.decode(value),
    responseSerialize: (value: EmerchantpayPaymentResponse): Buffer =>
      Buffer.from(EmerchantpayPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmerchantpayPaymentResponse => EmerchantpayPaymentResponse.decode(value),
  },
  refundEmerchantpayPayment: {
    path: "/payment.PaymentService/RefundEmerchantpayPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefundEmerchantpayPaymentRequest): Buffer =>
      Buffer.from(RefundEmerchantpayPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefundEmerchantpayPaymentRequest =>
      RefundEmerchantpayPaymentRequest.decode(value),
    responseSerialize: (value: EmerchantpayPaymentResponse): Buffer =>
      Buffer.from(EmerchantpayPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmerchantpayPaymentResponse => EmerchantpayPaymentResponse.decode(value),
  },
  /** ==================== PROVIDER ROUTING ==================== */
  createRoutingRule: {
    path: "/payment.PaymentService/CreateRoutingRule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRoutingRuleRequest): Buffer =>
      Buffer.from(CreateRoutingRuleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateRoutingRuleRequest => CreateRoutingRuleRequest.decode(value),
    responseSerialize: (value: RoutingRuleResponse): Buffer => Buffer.from(RoutingRuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RoutingRuleResponse => RoutingRuleResponse.decode(value),
  },
  updateRoutingRule: {
    path: "/payment.PaymentService/UpdateRoutingRule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateRoutingRuleRequest): Buffer =>
      Buffer.from(UpdateRoutingRuleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateRoutingRuleRequest => UpdateRoutingRuleRequest.decode(value),
    responseSerialize: (value: RoutingRuleResponse): Buffer => Buffer.from(RoutingRuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RoutingRuleResponse => RoutingRuleResponse.decode(value),
  },
  deleteRoutingRule: {
    path: "/payment.PaymentService/DeleteRoutingRule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRoutingRuleRequest): Buffer =>
      Buffer.from(DeleteRoutingRuleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRoutingRuleRequest => DeleteRoutingRuleRequest.decode(value),
    responseSerialize: (value: DeleteRoutingRuleResponse): Buffer =>
      Buffer.from(DeleteRoutingRuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteRoutingRuleResponse => DeleteRoutingRuleResponse.decode(value),
  },
  listRoutingRules: {
    path: "/payment.PaymentService/ListRoutingRules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRoutingRulesRequest): Buffer =>
      Buffer.from(ListRoutingRulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRoutingRulesRequest => ListRoutingRulesRequest.decode(value),
    responseSerialize: (value: ListRoutingRulesResponse): Buffer =>
      Buffer.from(ListRoutingRulesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRoutingRulesResponse => ListRoutingRulesResponse.decode(value),
  },
  testRoutingRule: {
    path: "/payment.PaymentService/TestRoutingRule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TestRoutingRuleRequest): Buffer =>
      Buffer.from(TestRoutingRuleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TestRoutingRuleRequest => TestRoutingRuleRequest.decode(value),
    responseSerialize: (value: TestRoutingRuleResponse): Buffer =>
      Buffer.from(TestRoutingRuleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TestRoutingRuleResponse => TestRoutingRuleResponse.decode(value),
  },
  createProviderOverride: {
    path: "/payment.PaymentService/CreateProviderOverride",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProviderOverrideRequest): Buffer =>
      Buffer.from(CreateProviderOverrideRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProviderOverrideRequest => CreateProviderOverrideRequest.decode(value),
    responseSerialize: (value: ProviderOverrideResponse): Buffer =>
      Buffer.from(ProviderOverrideResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProviderOverrideResponse => ProviderOverrideResponse.decode(value),
  },
  deleteProviderOverride: {
    path: "/payment.PaymentService/DeleteProviderOverride",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProviderOverrideRequest): Buffer =>
      Buffer.from(DeleteProviderOverrideRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteProviderOverrideRequest => DeleteProviderOverrideRequest.decode(value),
    responseSerialize: (value: DeleteProviderOverrideResponse): Buffer =>
      Buffer.from(DeleteProviderOverrideResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteProviderOverrideResponse =>
      DeleteProviderOverrideResponse.decode(value),
  },
  listProviderOverrides: {
    path: "/payment.PaymentService/ListProviderOverrides",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProviderOverridesRequest): Buffer =>
      Buffer.from(ListProviderOverridesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProviderOverridesRequest => ListProviderOverridesRequest.decode(value),
    responseSerialize: (value: ListProviderOverridesResponse): Buffer =>
      Buffer.from(ListProviderOverridesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProviderOverridesResponse => ListProviderOverridesResponse.decode(value),
  },
  createReassignmentJob: {
    path: "/payment.PaymentService/CreateReassignmentJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateReassignmentJobRequest): Buffer =>
      Buffer.from(CreateReassignmentJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateReassignmentJobRequest => CreateReassignmentJobRequest.decode(value),
    responseSerialize: (value: ReassignmentJobResponse): Buffer =>
      Buffer.from(ReassignmentJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReassignmentJobResponse => ReassignmentJobResponse.decode(value),
  },
  getReassignmentJob: {
    path: "/payment.PaymentService/GetReassignmentJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReassignmentJobRequest): Buffer =>
      Buffer.from(GetReassignmentJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReassignmentJobRequest => GetReassignmentJobRequest.decode(value),
    responseSerialize: (value: ReassignmentJobResponse): Buffer =>
      Buffer.from(ReassignmentJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReassignmentJobResponse => ReassignmentJobResponse.decode(value),
  },
  /** ==================== ALERTS ==================== */
  listAlerts: {
    path: "/payment.PaymentService/ListAlerts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAlertsRequest): Buffer => Buffer.from(ListAlertsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAlertsRequest => ListAlertsRequest.decode(value),
    responseSerialize: (value: ListAlertsResponse): Buffer => Buffer.from(ListAlertsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListAlertsResponse => ListAlertsResponse.decode(value),
  },
  acknowledgeAlert: {
    path: "/payment.PaymentService/AcknowledgeAlert",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AcknowledgeAlertRequest): Buffer =>
      Buffer.from(AcknowledgeAlertRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AcknowledgeAlertRequest => AcknowledgeAlertRequest.decode(value),
    responseSerialize: (value: AlertResponse): Buffer => Buffer.from(AlertResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AlertResponse => AlertResponse.decode(value),
  },
  getAlertStats: {
    path: "/payment.PaymentService/GetAlertStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAlertStatsRequest): Buffer => Buffer.from(GetAlertStatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAlertStatsRequest => GetAlertStatsRequest.decode(value),
    responseSerialize: (value: AlertStatsResponse): Buffer => Buffer.from(AlertStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AlertStatsResponse => AlertStatsResponse.decode(value),
  },
  /** ==================== ACCOUNTING EXPORTS ==================== */
  createExportJob: {
    path: "/payment.PaymentService/CreateExportJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateExportJobRequest): Buffer =>
      Buffer.from(CreateExportJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateExportJobRequest => CreateExportJobRequest.decode(value),
    responseSerialize: (value: ExportJobResponse): Buffer => Buffer.from(ExportJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExportJobResponse => ExportJobResponse.decode(value),
  },
  getExportJob: {
    path: "/payment.PaymentService/GetExportJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetExportJobRequest): Buffer => Buffer.from(GetExportJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetExportJobRequest => GetExportJobRequest.decode(value),
    responseSerialize: (value: ExportJobResponse): Buffer => Buffer.from(ExportJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExportJobResponse => ExportJobResponse.decode(value),
  },
  listExportJobs: {
    path: "/payment.PaymentService/ListExportJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListExportJobsRequest): Buffer =>
      Buffer.from(ListExportJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListExportJobsRequest => ListExportJobsRequest.decode(value),
    responseSerialize: (value: ListExportJobsResponse): Buffer =>
      Buffer.from(ListExportJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListExportJobsResponse => ListExportJobsResponse.decode(value),
  },
  downloadExport: {
    path: "/payment.PaymentService/DownloadExport",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DownloadExportRequest): Buffer =>
      Buffer.from(DownloadExportRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DownloadExportRequest => DownloadExportRequest.decode(value),
    responseSerialize: (value: DownloadExportResponse): Buffer =>
      Buffer.from(DownloadExportResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DownloadExportResponse => DownloadExportResponse.decode(value),
  },
  /** ==================== RISK SCORING ==================== */
  getRiskScore: {
    path: "/payment.PaymentService/GetRiskScore",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRiskScoreRequest): Buffer => Buffer.from(GetRiskScoreRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRiskScoreRequest => GetRiskScoreRequest.decode(value),
    responseSerialize: (value: RiskScoreResponse): Buffer => Buffer.from(RiskScoreResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RiskScoreResponse => RiskScoreResponse.decode(value),
  },
  evaluateRiskScore: {
    path: "/payment.PaymentService/EvaluateRiskScore",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EvaluateRiskScoreRequest): Buffer =>
      Buffer.from(EvaluateRiskScoreRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): EvaluateRiskScoreRequest => EvaluateRiskScoreRequest.decode(value),
    responseSerialize: (value: RiskScoreResponse): Buffer => Buffer.from(RiskScoreResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RiskScoreResponse => RiskScoreResponse.decode(value),
  },
  listRiskScores: {
    path: "/payment.PaymentService/ListRiskScores",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRiskScoresRequest): Buffer =>
      Buffer.from(ListRiskScoresRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRiskScoresRequest => ListRiskScoresRequest.decode(value),
    responseSerialize: (value: ListRiskScoresResponse): Buffer =>
      Buffer.from(ListRiskScoresResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRiskScoresResponse => ListRiskScoresResponse.decode(value),
  },
  getScoringStats: {
    path: "/payment.PaymentService/GetScoringStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetScoringStatsRequest): Buffer =>
      Buffer.from(GetScoringStatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetScoringStatsRequest => GetScoringStatsRequest.decode(value),
    responseSerialize: (value: ScoringStatsResponse): Buffer =>
      Buffer.from(ScoringStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScoringStatsResponse => ScoringStatsResponse.decode(value),
  },
  /** ==================== BANK RECONCILIATION ==================== */
  importBankStatement: {
    path: "/payment.PaymentService/ImportBankStatement",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportBankStatementRequest): Buffer =>
      Buffer.from(ImportBankStatementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImportBankStatementRequest => ImportBankStatementRequest.decode(value),
    responseSerialize: (value: ImportBankStatementResponse): Buffer =>
      Buffer.from(ImportBankStatementResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ImportBankStatementResponse => ImportBankStatementResponse.decode(value),
  },
  getReconciliationStatus: {
    path: "/payment.PaymentService/GetReconciliationStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReconciliationStatusRequest): Buffer =>
      Buffer.from(GetReconciliationStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReconciliationStatusRequest => GetReconciliationStatusRequest.decode(value),
    responseSerialize: (value: ReconciliationStatusResponse): Buffer =>
      Buffer.from(ReconciliationStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReconciliationStatusResponse => ReconciliationStatusResponse.decode(value),
  },
  forceReconciliation: {
    path: "/payment.PaymentService/ForceReconciliation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForceReconciliationRequest): Buffer =>
      Buffer.from(ForceReconciliationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ForceReconciliationRequest => ForceReconciliationRequest.decode(value),
    responseSerialize: (value: ReconciliationResponse): Buffer =>
      Buffer.from(ReconciliationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReconciliationResponse => ReconciliationResponse.decode(value),
  },
  listUnmatchedPayments: {
    path: "/payment.PaymentService/ListUnmatchedPayments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListUnmatchedPaymentsRequest): Buffer =>
      Buffer.from(ListUnmatchedPaymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListUnmatchedPaymentsRequest => ListUnmatchedPaymentsRequest.decode(value),
    responseSerialize: (value: ListUnmatchedPaymentsResponse): Buffer =>
      Buffer.from(ListUnmatchedPaymentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListUnmatchedPaymentsResponse => ListUnmatchedPaymentsResponse.decode(value),
  },
  /** ==================== PROVIDER STATUS MAPPING ==================== */
  listProviderStatusMappings: {
    path: "/payment.PaymentService/ListProviderStatusMappings",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProviderStatusMappingsRequest): Buffer =>
      Buffer.from(ListProviderStatusMappingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProviderStatusMappingsRequest =>
      ListProviderStatusMappingsRequest.decode(value),
    responseSerialize: (value: ListProviderStatusMappingsResponse): Buffer =>
      Buffer.from(ListProviderStatusMappingsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProviderStatusMappingsResponse =>
      ListProviderStatusMappingsResponse.decode(value),
  },
  updateProviderStatusMapping: {
    path: "/payment.PaymentService/UpdateProviderStatusMapping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProviderStatusMappingRequest): Buffer =>
      Buffer.from(UpdateProviderStatusMappingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProviderStatusMappingRequest =>
      UpdateProviderStatusMappingRequest.decode(value),
    responseSerialize: (value: ProviderStatusMappingResponse): Buffer =>
      Buffer.from(ProviderStatusMappingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProviderStatusMappingResponse => ProviderStatusMappingResponse.decode(value),
  },
  /** ==================== REJECTION REASONS ==================== */
  listRejectionReasons: {
    path: "/payment.PaymentService/ListRejectionReasons",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRejectionReasonsRequest): Buffer =>
      Buffer.from(ListRejectionReasonsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRejectionReasonsRequest => ListRejectionReasonsRequest.decode(value),
    responseSerialize: (value: ListRejectionReasonsResponse): Buffer =>
      Buffer.from(ListRejectionReasonsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRejectionReasonsResponse => ListRejectionReasonsResponse.decode(value),
  },
  createRejectionReason: {
    path: "/payment.PaymentService/CreateRejectionReason",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRejectionReasonRequest): Buffer =>
      Buffer.from(CreateRejectionReasonRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateRejectionReasonRequest => CreateRejectionReasonRequest.decode(value),
    responseSerialize: (value: RejectionReasonResponse): Buffer =>
      Buffer.from(RejectionReasonResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RejectionReasonResponse => RejectionReasonResponse.decode(value),
  },
  updateRejectionReason: {
    path: "/payment.PaymentService/UpdateRejectionReason",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateRejectionReasonRequest): Buffer =>
      Buffer.from(UpdateRejectionReasonRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateRejectionReasonRequest => UpdateRejectionReasonRequest.decode(value),
    responseSerialize: (value: RejectionReasonResponse): Buffer =>
      Buffer.from(RejectionReasonResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RejectionReasonResponse => RejectionReasonResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: handleUnaryCall<CreateStripeCheckoutSessionRequest, StripeCheckoutSessionResponse>;
  createStripePaymentIntent: handleUnaryCall<CreateStripePaymentIntentRequest, StripePaymentIntentResponse>;
  getStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  cancelStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  /** Customers */
  createStripeCustomer: handleUnaryCall<CreateStripeCustomerRequest, StripeCustomerResponse>;
  getStripeCustomer: handleUnaryCall<GetByIdRequest, StripeCustomerResponse>;
  /** Subscriptions */
  createStripeSubscription: handleUnaryCall<CreateStripeSubscriptionRequest, StripeSubscriptionResponse>;
  getStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  cancelStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  /** Refunds */
  createStripeRefund: handleUnaryCall<CreateStripeRefundRequest, StripeRefundResponse>;
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: handleUnaryCall<CreateStripeSetupIntentRequest, StripeSetupIntentResponse>;
  /** Billing Portal */
  createStripeBillingPortalSession: handleUnaryCall<CreateStripeBillingPortalRequest, StripeBillingPortalResponse>;
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: handleUnaryCall<CreatePayPalOrderRequest, PayPalOrderResponse>;
  getPayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  capturePayPalOrder: handleUnaryCall<CapturePayPalOrderRequest, PayPalCaptureResponse>;
  authorizePayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: handleUnaryCall<SetupGoCardlessMandateRequest, GoCardlessMandateResponse>;
  getGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  cancelGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  createGoCardlessPayment: handleUnaryCall<CreateGoCardlessPaymentRequest, GoCardlessPaymentResponse>;
  createGoCardlessSubscription: handleUnaryCall<CreateGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  cancelGoCardlessSubscription: handleUnaryCall<CancelGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  /** ==================== SCHEDULES ==================== */
  createSchedule: handleUnaryCall<CreateScheduleRequest, ScheduleResponse>;
  getSchedule: handleUnaryCall<GetByIdRequest, ScheduleResponse>;
  updateSchedule: handleUnaryCall<UpdateScheduleRequest, ScheduleResponse>;
  deleteSchedule: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  getDueSchedules: handleUnaryCall<GetDueSchedulesRequest, ScheduleListResponse>;
  processDuePayments: handleUnaryCall<ProcessDuePaymentsRequest, ProcessDuePaymentsResponse>;
  renewSchedule: handleUnaryCall<RenewScheduleRequest, ScheduleResponse>;
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: handleUnaryCall<CreatePaymentIntentRequest, PaymentIntentResponse>;
  getPaymentIntent: handleUnaryCall<GetByIdRequest, PaymentIntentResponse>;
  updatePaymentIntent: handleUnaryCall<UpdatePaymentIntentRequest, PaymentIntentResponse>;
  deletePaymentIntent: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: handleUnaryCall<CreatePaymentEventRequest, PaymentEventResponse>;
  getPaymentEvent: handleUnaryCall<GetByIdRequest, PaymentEventResponse>;
  getUnprocessedEvents: handleUnaryCall<GetUnprocessedEventsRequest, PaymentEventListResponse>;
  markEventProcessed: handleUnaryCall<MarkEventProcessedRequest, PaymentEventResponse>;
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: handleUnaryCall<GetPSPAccountsRequest, PSPAccountsSummaryResponse>;
  /** ==================== SLIMPAY ==================== */
  createSlimpayMandate: handleUnaryCall<CreateSlimpayMandateRequest, SlimpayMandateResponse>;
  getSlimpayMandate: handleUnaryCall<GetSlimpayMandateRequest, SlimpayMandateResponse>;
  cancelSlimpayMandate: handleUnaryCall<CancelSlimpayMandateRequest, SlimpayMandateResponse>;
  createSlimpayPayment: handleUnaryCall<CreateSlimpayPaymentRequest, SlimpayPaymentResponse>;
  getSlimpayPayment: handleUnaryCall<GetSlimpayPaymentRequest, SlimpayPaymentResponse>;
  /** ==================== MULTISAFEPAY ==================== */
  createMultiSafepayTransaction: handleUnaryCall<CreateMultiSafepayTransactionRequest, MultiSafepayTransactionResponse>;
  getMultiSafepayTransaction: handleUnaryCall<GetMultiSafepayTransactionRequest, MultiSafepayTransactionResponse>;
  refundMultiSafepayTransaction: handleUnaryCall<RefundMultiSafepayTransactionRequest, MultiSafepayTransactionResponse>;
  /** ==================== EMERCHANTPAY ==================== */
  createEmerchantpayPayment: handleUnaryCall<CreateEmerchantpayPaymentRequest, EmerchantpayPaymentResponse>;
  getEmerchantpayPayment: handleUnaryCall<GetEmerchantpayPaymentRequest, EmerchantpayPaymentResponse>;
  createEmerchantpaySepaPayment: handleUnaryCall<CreateEmerchantpaySepaPaymentRequest, EmerchantpayPaymentResponse>;
  refundEmerchantpayPayment: handleUnaryCall<RefundEmerchantpayPaymentRequest, EmerchantpayPaymentResponse>;
  /** ==================== PROVIDER ROUTING ==================== */
  createRoutingRule: handleUnaryCall<CreateRoutingRuleRequest, RoutingRuleResponse>;
  updateRoutingRule: handleUnaryCall<UpdateRoutingRuleRequest, RoutingRuleResponse>;
  deleteRoutingRule: handleUnaryCall<DeleteRoutingRuleRequest, DeleteRoutingRuleResponse>;
  listRoutingRules: handleUnaryCall<ListRoutingRulesRequest, ListRoutingRulesResponse>;
  testRoutingRule: handleUnaryCall<TestRoutingRuleRequest, TestRoutingRuleResponse>;
  createProviderOverride: handleUnaryCall<CreateProviderOverrideRequest, ProviderOverrideResponse>;
  deleteProviderOverride: handleUnaryCall<DeleteProviderOverrideRequest, DeleteProviderOverrideResponse>;
  listProviderOverrides: handleUnaryCall<ListProviderOverridesRequest, ListProviderOverridesResponse>;
  createReassignmentJob: handleUnaryCall<CreateReassignmentJobRequest, ReassignmentJobResponse>;
  getReassignmentJob: handleUnaryCall<GetReassignmentJobRequest, ReassignmentJobResponse>;
  /** ==================== ALERTS ==================== */
  listAlerts: handleUnaryCall<ListAlertsRequest, ListAlertsResponse>;
  acknowledgeAlert: handleUnaryCall<AcknowledgeAlertRequest, AlertResponse>;
  getAlertStats: handleUnaryCall<GetAlertStatsRequest, AlertStatsResponse>;
  /** ==================== ACCOUNTING EXPORTS ==================== */
  createExportJob: handleUnaryCall<CreateExportJobRequest, ExportJobResponse>;
  getExportJob: handleUnaryCall<GetExportJobRequest, ExportJobResponse>;
  listExportJobs: handleUnaryCall<ListExportJobsRequest, ListExportJobsResponse>;
  downloadExport: handleUnaryCall<DownloadExportRequest, DownloadExportResponse>;
  /** ==================== RISK SCORING ==================== */
  getRiskScore: handleUnaryCall<GetRiskScoreRequest, RiskScoreResponse>;
  evaluateRiskScore: handleUnaryCall<EvaluateRiskScoreRequest, RiskScoreResponse>;
  listRiskScores: handleUnaryCall<ListRiskScoresRequest, ListRiskScoresResponse>;
  getScoringStats: handleUnaryCall<GetScoringStatsRequest, ScoringStatsResponse>;
  /** ==================== BANK RECONCILIATION ==================== */
  importBankStatement: handleUnaryCall<ImportBankStatementRequest, ImportBankStatementResponse>;
  getReconciliationStatus: handleUnaryCall<GetReconciliationStatusRequest, ReconciliationStatusResponse>;
  forceReconciliation: handleUnaryCall<ForceReconciliationRequest, ReconciliationResponse>;
  listUnmatchedPayments: handleUnaryCall<ListUnmatchedPaymentsRequest, ListUnmatchedPaymentsResponse>;
  /** ==================== PROVIDER STATUS MAPPING ==================== */
  listProviderStatusMappings: handleUnaryCall<ListProviderStatusMappingsRequest, ListProviderStatusMappingsResponse>;
  updateProviderStatusMapping: handleUnaryCall<UpdateProviderStatusMappingRequest, ProviderStatusMappingResponse>;
  /** ==================== REJECTION REASONS ==================== */
  listRejectionReasons: handleUnaryCall<ListRejectionReasonsRequest, ListRejectionReasonsResponse>;
  createRejectionReason: handleUnaryCall<CreateRejectionReasonRequest, RejectionReasonResponse>;
  updateRejectionReason: handleUnaryCall<UpdateRejectionReasonRequest, RejectionReasonResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
