// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: payments/payment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";

export const protobufPackage = "payment";

export enum PaymentStatus {
  PAYMENT_STATUS_UNSPECIFIED = 0,
  PAYMENT_STATUS_PENDING = 1,
  PAYMENT_STATUS_SUBMITTED = 2,
  PAYMENT_STATUS_PAID = 3,
  PAYMENT_STATUS_REJECTED = 4,
  PAYMENT_STATUS_REFUNDED = 5,
  PAYMENT_STATUS_CANCELLED = 6,
  PAYMENT_STATUS_FAILED = 7,
  UNRECOGNIZED = -1,
}

export function paymentStatusFromJSON(object: any): PaymentStatus {
  switch (object) {
    case 0:
    case "PAYMENT_STATUS_UNSPECIFIED":
      return PaymentStatus.PAYMENT_STATUS_UNSPECIFIED;
    case 1:
    case "PAYMENT_STATUS_PENDING":
      return PaymentStatus.PAYMENT_STATUS_PENDING;
    case 2:
    case "PAYMENT_STATUS_SUBMITTED":
      return PaymentStatus.PAYMENT_STATUS_SUBMITTED;
    case 3:
    case "PAYMENT_STATUS_PAID":
      return PaymentStatus.PAYMENT_STATUS_PAID;
    case 4:
    case "PAYMENT_STATUS_REJECTED":
      return PaymentStatus.PAYMENT_STATUS_REJECTED;
    case 5:
    case "PAYMENT_STATUS_REFUNDED":
      return PaymentStatus.PAYMENT_STATUS_REFUNDED;
    case 6:
    case "PAYMENT_STATUS_CANCELLED":
      return PaymentStatus.PAYMENT_STATUS_CANCELLED;
    case 7:
    case "PAYMENT_STATUS_FAILED":
      return PaymentStatus.PAYMENT_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentStatus.UNRECOGNIZED;
  }
}

export function paymentStatusToJSON(object: PaymentStatus): string {
  switch (object) {
    case PaymentStatus.PAYMENT_STATUS_UNSPECIFIED:
      return "PAYMENT_STATUS_UNSPECIFIED";
    case PaymentStatus.PAYMENT_STATUS_PENDING:
      return "PAYMENT_STATUS_PENDING";
    case PaymentStatus.PAYMENT_STATUS_SUBMITTED:
      return "PAYMENT_STATUS_SUBMITTED";
    case PaymentStatus.PAYMENT_STATUS_PAID:
      return "PAYMENT_STATUS_PAID";
    case PaymentStatus.PAYMENT_STATUS_REJECTED:
      return "PAYMENT_STATUS_REJECTED";
    case PaymentStatus.PAYMENT_STATUS_REFUNDED:
      return "PAYMENT_STATUS_REFUNDED";
    case PaymentStatus.PAYMENT_STATUS_CANCELLED:
      return "PAYMENT_STATUS_CANCELLED";
    case PaymentStatus.PAYMENT_STATUS_FAILED:
      return "PAYMENT_STATUS_FAILED";
    case PaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MandateStatus {
  MANDATE_STATUS_UNSPECIFIED = 0,
  MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL = 1,
  MANDATE_STATUS_PENDING_SUBMISSION = 2,
  MANDATE_STATUS_SUBMITTED = 3,
  MANDATE_STATUS_ACTIVE = 4,
  MANDATE_STATUS_SUSPENDED_BY_PAYER = 5,
  MANDATE_STATUS_FAILED = 6,
  MANDATE_STATUS_CANCELLED = 7,
  MANDATE_STATUS_EXPIRED = 8,
  MANDATE_STATUS_CONSUMED = 9,
  MANDATE_STATUS_BLOCKED = 10,
  UNRECOGNIZED = -1,
}

export function mandateStatusFromJSON(object: any): MandateStatus {
  switch (object) {
    case 0:
    case "MANDATE_STATUS_UNSPECIFIED":
      return MandateStatus.MANDATE_STATUS_UNSPECIFIED;
    case 1:
    case "MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL":
      return MandateStatus.MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL;
    case 2:
    case "MANDATE_STATUS_PENDING_SUBMISSION":
      return MandateStatus.MANDATE_STATUS_PENDING_SUBMISSION;
    case 3:
    case "MANDATE_STATUS_SUBMITTED":
      return MandateStatus.MANDATE_STATUS_SUBMITTED;
    case 4:
    case "MANDATE_STATUS_ACTIVE":
      return MandateStatus.MANDATE_STATUS_ACTIVE;
    case 5:
    case "MANDATE_STATUS_SUSPENDED_BY_PAYER":
      return MandateStatus.MANDATE_STATUS_SUSPENDED_BY_PAYER;
    case 6:
    case "MANDATE_STATUS_FAILED":
      return MandateStatus.MANDATE_STATUS_FAILED;
    case 7:
    case "MANDATE_STATUS_CANCELLED":
      return MandateStatus.MANDATE_STATUS_CANCELLED;
    case 8:
    case "MANDATE_STATUS_EXPIRED":
      return MandateStatus.MANDATE_STATUS_EXPIRED;
    case 9:
    case "MANDATE_STATUS_CONSUMED":
      return MandateStatus.MANDATE_STATUS_CONSUMED;
    case 10:
    case "MANDATE_STATUS_BLOCKED":
      return MandateStatus.MANDATE_STATUS_BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MandateStatus.UNRECOGNIZED;
  }
}

export function mandateStatusToJSON(object: MandateStatus): string {
  switch (object) {
    case MandateStatus.MANDATE_STATUS_UNSPECIFIED:
      return "MANDATE_STATUS_UNSPECIFIED";
    case MandateStatus.MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL:
      return "MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL";
    case MandateStatus.MANDATE_STATUS_PENDING_SUBMISSION:
      return "MANDATE_STATUS_PENDING_SUBMISSION";
    case MandateStatus.MANDATE_STATUS_SUBMITTED:
      return "MANDATE_STATUS_SUBMITTED";
    case MandateStatus.MANDATE_STATUS_ACTIVE:
      return "MANDATE_STATUS_ACTIVE";
    case MandateStatus.MANDATE_STATUS_SUSPENDED_BY_PAYER:
      return "MANDATE_STATUS_SUSPENDED_BY_PAYER";
    case MandateStatus.MANDATE_STATUS_FAILED:
      return "MANDATE_STATUS_FAILED";
    case MandateStatus.MANDATE_STATUS_CANCELLED:
      return "MANDATE_STATUS_CANCELLED";
    case MandateStatus.MANDATE_STATUS_EXPIRED:
      return "MANDATE_STATUS_EXPIRED";
    case MandateStatus.MANDATE_STATUS_CONSUMED:
      return "MANDATE_STATUS_CONSUMED";
    case MandateStatus.MANDATE_STATUS_BLOCKED:
      return "MANDATE_STATUS_BLOCKED";
    case MandateStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ScheduleStatus {
  SCHEDULE_STATUS_UNSPECIFIED = 0,
  SCHEDULE_STATUS_ACTIVE = 1,
  SCHEDULE_STATUS_PAUSED = 2,
  SCHEDULE_STATUS_CANCELLED = 3,
  SCHEDULE_STATUS_COMPLETED = 4,
  UNRECOGNIZED = -1,
}

export function scheduleStatusFromJSON(object: any): ScheduleStatus {
  switch (object) {
    case 0:
    case "SCHEDULE_STATUS_UNSPECIFIED":
      return ScheduleStatus.SCHEDULE_STATUS_UNSPECIFIED;
    case 1:
    case "SCHEDULE_STATUS_ACTIVE":
      return ScheduleStatus.SCHEDULE_STATUS_ACTIVE;
    case 2:
    case "SCHEDULE_STATUS_PAUSED":
      return ScheduleStatus.SCHEDULE_STATUS_PAUSED;
    case 3:
    case "SCHEDULE_STATUS_CANCELLED":
      return ScheduleStatus.SCHEDULE_STATUS_CANCELLED;
    case 4:
    case "SCHEDULE_STATUS_COMPLETED":
      return ScheduleStatus.SCHEDULE_STATUS_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScheduleStatus.UNRECOGNIZED;
  }
}

export function scheduleStatusToJSON(object: ScheduleStatus): string {
  switch (object) {
    case ScheduleStatus.SCHEDULE_STATUS_UNSPECIFIED:
      return "SCHEDULE_STATUS_UNSPECIFIED";
    case ScheduleStatus.SCHEDULE_STATUS_ACTIVE:
      return "SCHEDULE_STATUS_ACTIVE";
    case ScheduleStatus.SCHEDULE_STATUS_PAUSED:
      return "SCHEDULE_STATUS_PAUSED";
    case ScheduleStatus.SCHEDULE_STATUS_CANCELLED:
      return "SCHEDULE_STATUS_CANCELLED";
    case ScheduleStatus.SCHEDULE_STATUS_COMPLETED:
      return "SCHEDULE_STATUS_COMPLETED";
    case ScheduleStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AuditAction {
  AUDIT_ACTION_UNSPECIFIED = 0,
  AUDIT_ACTION_PAYMENT_CREATED = 1,
  AUDIT_ACTION_PAYMENT_SUBMITTED = 2,
  AUDIT_ACTION_PAYMENT_SUCCEEDED = 3,
  AUDIT_ACTION_PAYMENT_FAILED = 4,
  AUDIT_ACTION_PAYMENT_CANCELLED = 5,
  AUDIT_ACTION_PAYMENT_REFUNDED = 6,
  AUDIT_ACTION_MANDATE_CREATED = 7,
  AUDIT_ACTION_MANDATE_ACTIVATED = 8,
  AUDIT_ACTION_MANDATE_CANCELLED = 9,
  AUDIT_ACTION_SCHEDULE_CREATED = 10,
  AUDIT_ACTION_SCHEDULE_PAUSED = 11,
  AUDIT_ACTION_SCHEDULE_RESUMED = 12,
  AUDIT_ACTION_SCHEDULE_CANCELLED = 13,
  UNRECOGNIZED = -1,
}

export function auditActionFromJSON(object: any): AuditAction {
  switch (object) {
    case 0:
    case "AUDIT_ACTION_UNSPECIFIED":
      return AuditAction.AUDIT_ACTION_UNSPECIFIED;
    case 1:
    case "AUDIT_ACTION_PAYMENT_CREATED":
      return AuditAction.AUDIT_ACTION_PAYMENT_CREATED;
    case 2:
    case "AUDIT_ACTION_PAYMENT_SUBMITTED":
      return AuditAction.AUDIT_ACTION_PAYMENT_SUBMITTED;
    case 3:
    case "AUDIT_ACTION_PAYMENT_SUCCEEDED":
      return AuditAction.AUDIT_ACTION_PAYMENT_SUCCEEDED;
    case 4:
    case "AUDIT_ACTION_PAYMENT_FAILED":
      return AuditAction.AUDIT_ACTION_PAYMENT_FAILED;
    case 5:
    case "AUDIT_ACTION_PAYMENT_CANCELLED":
      return AuditAction.AUDIT_ACTION_PAYMENT_CANCELLED;
    case 6:
    case "AUDIT_ACTION_PAYMENT_REFUNDED":
      return AuditAction.AUDIT_ACTION_PAYMENT_REFUNDED;
    case 7:
    case "AUDIT_ACTION_MANDATE_CREATED":
      return AuditAction.AUDIT_ACTION_MANDATE_CREATED;
    case 8:
    case "AUDIT_ACTION_MANDATE_ACTIVATED":
      return AuditAction.AUDIT_ACTION_MANDATE_ACTIVATED;
    case 9:
    case "AUDIT_ACTION_MANDATE_CANCELLED":
      return AuditAction.AUDIT_ACTION_MANDATE_CANCELLED;
    case 10:
    case "AUDIT_ACTION_SCHEDULE_CREATED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_CREATED;
    case 11:
    case "AUDIT_ACTION_SCHEDULE_PAUSED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_PAUSED;
    case 12:
    case "AUDIT_ACTION_SCHEDULE_RESUMED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_RESUMED;
    case 13:
    case "AUDIT_ACTION_SCHEDULE_CANCELLED":
      return AuditAction.AUDIT_ACTION_SCHEDULE_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuditAction.UNRECOGNIZED;
  }
}

export function auditActionToJSON(object: AuditAction): string {
  switch (object) {
    case AuditAction.AUDIT_ACTION_UNSPECIFIED:
      return "AUDIT_ACTION_UNSPECIFIED";
    case AuditAction.AUDIT_ACTION_PAYMENT_CREATED:
      return "AUDIT_ACTION_PAYMENT_CREATED";
    case AuditAction.AUDIT_ACTION_PAYMENT_SUBMITTED:
      return "AUDIT_ACTION_PAYMENT_SUBMITTED";
    case AuditAction.AUDIT_ACTION_PAYMENT_SUCCEEDED:
      return "AUDIT_ACTION_PAYMENT_SUCCEEDED";
    case AuditAction.AUDIT_ACTION_PAYMENT_FAILED:
      return "AUDIT_ACTION_PAYMENT_FAILED";
    case AuditAction.AUDIT_ACTION_PAYMENT_CANCELLED:
      return "AUDIT_ACTION_PAYMENT_CANCELLED";
    case AuditAction.AUDIT_ACTION_PAYMENT_REFUNDED:
      return "AUDIT_ACTION_PAYMENT_REFUNDED";
    case AuditAction.AUDIT_ACTION_MANDATE_CREATED:
      return "AUDIT_ACTION_MANDATE_CREATED";
    case AuditAction.AUDIT_ACTION_MANDATE_ACTIVATED:
      return "AUDIT_ACTION_MANDATE_ACTIVATED";
    case AuditAction.AUDIT_ACTION_MANDATE_CANCELLED:
      return "AUDIT_ACTION_MANDATE_CANCELLED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_CREATED:
      return "AUDIT_ACTION_SCHEDULE_CREATED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_PAUSED:
      return "AUDIT_ACTION_SCHEDULE_PAUSED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_RESUMED:
      return "AUDIT_ACTION_SCHEDULE_RESUMED";
    case AuditAction.AUDIT_ACTION_SCHEDULE_CANCELLED:
      return "AUDIT_ACTION_SCHEDULE_CANCELLED";
    case AuditAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Portal session status */
export enum PortalSessionStatus {
  PORTAL_SESSION_STATUS_UNSPECIFIED = 0,
  /** PORTAL_SESSION_CREATED - Session created, token generated */
  PORTAL_SESSION_CREATED = 1,
  /** PORTAL_SESSION_ACTIVE - First accessed */
  PORTAL_SESSION_ACTIVE = 2,
  /** PORTAL_SESSION_REDIRECTED - Redirected to PSP */
  PORTAL_SESSION_REDIRECTED = 3,
  /** PORTAL_SESSION_COMPLETED - Payment completed */
  PORTAL_SESSION_COMPLETED = 4,
  /** PORTAL_SESSION_FAILED - Payment failed */
  PORTAL_SESSION_FAILED = 5,
  /** PORTAL_SESSION_EXPIRED - TTL exceeded */
  PORTAL_SESSION_EXPIRED = 6,
  /** PORTAL_SESSION_CANCELLED - Manually cancelled */
  PORTAL_SESSION_CANCELLED = 7,
  UNRECOGNIZED = -1,
}

export function portalSessionStatusFromJSON(object: any): PortalSessionStatus {
  switch (object) {
    case 0:
    case "PORTAL_SESSION_STATUS_UNSPECIFIED":
      return PortalSessionStatus.PORTAL_SESSION_STATUS_UNSPECIFIED;
    case 1:
    case "PORTAL_SESSION_CREATED":
      return PortalSessionStatus.PORTAL_SESSION_CREATED;
    case 2:
    case "PORTAL_SESSION_ACTIVE":
      return PortalSessionStatus.PORTAL_SESSION_ACTIVE;
    case 3:
    case "PORTAL_SESSION_REDIRECTED":
      return PortalSessionStatus.PORTAL_SESSION_REDIRECTED;
    case 4:
    case "PORTAL_SESSION_COMPLETED":
      return PortalSessionStatus.PORTAL_SESSION_COMPLETED;
    case 5:
    case "PORTAL_SESSION_FAILED":
      return PortalSessionStatus.PORTAL_SESSION_FAILED;
    case 6:
    case "PORTAL_SESSION_EXPIRED":
      return PortalSessionStatus.PORTAL_SESSION_EXPIRED;
    case 7:
    case "PORTAL_SESSION_CANCELLED":
      return PortalSessionStatus.PORTAL_SESSION_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalSessionStatus.UNRECOGNIZED;
  }
}

export function portalSessionStatusToJSON(object: PortalSessionStatus): string {
  switch (object) {
    case PortalSessionStatus.PORTAL_SESSION_STATUS_UNSPECIFIED:
      return "PORTAL_SESSION_STATUS_UNSPECIFIED";
    case PortalSessionStatus.PORTAL_SESSION_CREATED:
      return "PORTAL_SESSION_CREATED";
    case PortalSessionStatus.PORTAL_SESSION_ACTIVE:
      return "PORTAL_SESSION_ACTIVE";
    case PortalSessionStatus.PORTAL_SESSION_REDIRECTED:
      return "PORTAL_SESSION_REDIRECTED";
    case PortalSessionStatus.PORTAL_SESSION_COMPLETED:
      return "PORTAL_SESSION_COMPLETED";
    case PortalSessionStatus.PORTAL_SESSION_FAILED:
      return "PORTAL_SESSION_FAILED";
    case PortalSessionStatus.PORTAL_SESSION_EXPIRED:
      return "PORTAL_SESSION_EXPIRED";
    case PortalSessionStatus.PORTAL_SESSION_CANCELLED:
      return "PORTAL_SESSION_CANCELLED";
    case PortalSessionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Allowed actions on portal */
export enum PortalSessionAction {
  PORTAL_SESSION_ACTION_UNSPECIFIED = 0,
  /** PORTAL_ACTION_PAY_NOW - Immediate payment */
  PORTAL_ACTION_PAY_NOW = 1,
  /** PORTAL_ACTION_UPDATE_CARD - Update payment method */
  PORTAL_ACTION_UPDATE_CARD = 2,
  /** PORTAL_ACTION_SETUP_MANDATE - Setup direct debit mandate */
  PORTAL_ACTION_SETUP_MANDATE = 3,
  UNRECOGNIZED = -1,
}

export function portalSessionActionFromJSON(object: any): PortalSessionAction {
  switch (object) {
    case 0:
    case "PORTAL_SESSION_ACTION_UNSPECIFIED":
      return PortalSessionAction.PORTAL_SESSION_ACTION_UNSPECIFIED;
    case 1:
    case "PORTAL_ACTION_PAY_NOW":
      return PortalSessionAction.PORTAL_ACTION_PAY_NOW;
    case 2:
    case "PORTAL_ACTION_UPDATE_CARD":
      return PortalSessionAction.PORTAL_ACTION_UPDATE_CARD;
    case 3:
    case "PORTAL_ACTION_SETUP_MANDATE":
      return PortalSessionAction.PORTAL_ACTION_SETUP_MANDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalSessionAction.UNRECOGNIZED;
  }
}

export function portalSessionActionToJSON(object: PortalSessionAction): string {
  switch (object) {
    case PortalSessionAction.PORTAL_SESSION_ACTION_UNSPECIFIED:
      return "PORTAL_SESSION_ACTION_UNSPECIFIED";
    case PortalSessionAction.PORTAL_ACTION_PAY_NOW:
      return "PORTAL_ACTION_PAY_NOW";
    case PortalSessionAction.PORTAL_ACTION_UPDATE_CARD:
      return "PORTAL_ACTION_UPDATE_CARD";
    case PortalSessionAction.PORTAL_ACTION_SETUP_MANDATE:
      return "PORTAL_ACTION_SETUP_MANDATE";
    case PortalSessionAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Portal error codes */
export enum PortalErrorCode {
  PORTAL_ERROR_CODE_UNSPECIFIED = 0,
  PORTAL_ERROR_SESSION_NOT_FOUND = 1,
  PORTAL_ERROR_SESSION_EXPIRED = 2,
  PORTAL_ERROR_SESSION_ALREADY_USED = 3,
  PORTAL_ERROR_SESSION_REVOKED = 4,
  PORTAL_ERROR_SESSION_TERMINAL = 5,
  PORTAL_ERROR_INVALID_TOKEN = 6,
  PORTAL_ERROR_TOKEN_MALFORMED = 7,
  PORTAL_ERROR_INVALID_TRANSITION = 8,
  PORTAL_ERROR_ACTION_NOT_ALLOWED = 9,
  UNRECOGNIZED = -1,
}

export function portalErrorCodeFromJSON(object: any): PortalErrorCode {
  switch (object) {
    case 0:
    case "PORTAL_ERROR_CODE_UNSPECIFIED":
      return PortalErrorCode.PORTAL_ERROR_CODE_UNSPECIFIED;
    case 1:
    case "PORTAL_ERROR_SESSION_NOT_FOUND":
      return PortalErrorCode.PORTAL_ERROR_SESSION_NOT_FOUND;
    case 2:
    case "PORTAL_ERROR_SESSION_EXPIRED":
      return PortalErrorCode.PORTAL_ERROR_SESSION_EXPIRED;
    case 3:
    case "PORTAL_ERROR_SESSION_ALREADY_USED":
      return PortalErrorCode.PORTAL_ERROR_SESSION_ALREADY_USED;
    case 4:
    case "PORTAL_ERROR_SESSION_REVOKED":
      return PortalErrorCode.PORTAL_ERROR_SESSION_REVOKED;
    case 5:
    case "PORTAL_ERROR_SESSION_TERMINAL":
      return PortalErrorCode.PORTAL_ERROR_SESSION_TERMINAL;
    case 6:
    case "PORTAL_ERROR_INVALID_TOKEN":
      return PortalErrorCode.PORTAL_ERROR_INVALID_TOKEN;
    case 7:
    case "PORTAL_ERROR_TOKEN_MALFORMED":
      return PortalErrorCode.PORTAL_ERROR_TOKEN_MALFORMED;
    case 8:
    case "PORTAL_ERROR_INVALID_TRANSITION":
      return PortalErrorCode.PORTAL_ERROR_INVALID_TRANSITION;
    case 9:
    case "PORTAL_ERROR_ACTION_NOT_ALLOWED":
      return PortalErrorCode.PORTAL_ERROR_ACTION_NOT_ALLOWED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalErrorCode.UNRECOGNIZED;
  }
}

export function portalErrorCodeToJSON(object: PortalErrorCode): string {
  switch (object) {
    case PortalErrorCode.PORTAL_ERROR_CODE_UNSPECIFIED:
      return "PORTAL_ERROR_CODE_UNSPECIFIED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_NOT_FOUND:
      return "PORTAL_ERROR_SESSION_NOT_FOUND";
    case PortalErrorCode.PORTAL_ERROR_SESSION_EXPIRED:
      return "PORTAL_ERROR_SESSION_EXPIRED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_ALREADY_USED:
      return "PORTAL_ERROR_SESSION_ALREADY_USED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_REVOKED:
      return "PORTAL_ERROR_SESSION_REVOKED";
    case PortalErrorCode.PORTAL_ERROR_SESSION_TERMINAL:
      return "PORTAL_ERROR_SESSION_TERMINAL";
    case PortalErrorCode.PORTAL_ERROR_INVALID_TOKEN:
      return "PORTAL_ERROR_INVALID_TOKEN";
    case PortalErrorCode.PORTAL_ERROR_TOKEN_MALFORMED:
      return "PORTAL_ERROR_TOKEN_MALFORMED";
    case PortalErrorCode.PORTAL_ERROR_INVALID_TRANSITION:
      return "PORTAL_ERROR_INVALID_TRANSITION";
    case PortalErrorCode.PORTAL_ERROR_ACTION_NOT_ALLOWED:
      return "PORTAL_ERROR_ACTION_NOT_ALLOWED";
    case PortalErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** PSP provider for portal */
export enum PortalPspProvider {
  PORTAL_PSP_PROVIDER_UNSPECIFIED = 0,
  PORTAL_PSP_STRIPE = 1,
  PORTAL_PSP_GOCARDLESS = 2,
  PORTAL_PSP_SLIMPAY = 3,
  PORTAL_PSP_EMERCHANTPAY = 4,
  UNRECOGNIZED = -1,
}

export function portalPspProviderFromJSON(object: any): PortalPspProvider {
  switch (object) {
    case 0:
    case "PORTAL_PSP_PROVIDER_UNSPECIFIED":
      return PortalPspProvider.PORTAL_PSP_PROVIDER_UNSPECIFIED;
    case 1:
    case "PORTAL_PSP_STRIPE":
      return PortalPspProvider.PORTAL_PSP_STRIPE;
    case 2:
    case "PORTAL_PSP_GOCARDLESS":
      return PortalPspProvider.PORTAL_PSP_GOCARDLESS;
    case 3:
    case "PORTAL_PSP_SLIMPAY":
      return PortalPspProvider.PORTAL_PSP_SLIMPAY;
    case 4:
    case "PORTAL_PSP_EMERCHANTPAY":
      return PortalPspProvider.PORTAL_PSP_EMERCHANTPAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalPspProvider.UNRECOGNIZED;
  }
}

export function portalPspProviderToJSON(object: PortalPspProvider): string {
  switch (object) {
    case PortalPspProvider.PORTAL_PSP_PROVIDER_UNSPECIFIED:
      return "PORTAL_PSP_PROVIDER_UNSPECIFIED";
    case PortalPspProvider.PORTAL_PSP_STRIPE:
      return "PORTAL_PSP_STRIPE";
    case PortalPspProvider.PORTAL_PSP_GOCARDLESS:
      return "PORTAL_PSP_GOCARDLESS";
    case PortalPspProvider.PORTAL_PSP_SLIMPAY:
      return "PORTAL_PSP_SLIMPAY";
    case PortalPspProvider.PORTAL_PSP_EMERCHANTPAY:
      return "PORTAL_PSP_EMERCHANTPAY";
    case PortalPspProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Portal audit event types */
export enum PortalAuditEventType {
  PORTAL_AUDIT_EVENT_UNSPECIFIED = 0,
  PORTAL_SESSION_CREATED_EVENT = 1,
  PORTAL_SESSION_ACTIVATED_EVENT = 2,
  PORTAL_TOKEN_VALIDATED_EVENT = 3,
  PORTAL_TOKEN_REJECTED_EVENT = 4,
  PORTAL_SESSION_ACCESSED_EVENT = 5,
  PORTAL_REDIRECT_INITIATED_EVENT = 6,
  PORTAL_PAYMENT_INITIATED_EVENT = 7,
  PORTAL_PAYMENT_COMPLETED_EVENT = 8,
  PORTAL_PAYMENT_FAILED_EVENT = 9,
  PORTAL_SESSION_EXPIRED_EVENT = 10,
  PORTAL_SESSION_CANCELLED_EVENT = 11,
  UNRECOGNIZED = -1,
}

export function portalAuditEventTypeFromJSON(object: any): PortalAuditEventType {
  switch (object) {
    case 0:
    case "PORTAL_AUDIT_EVENT_UNSPECIFIED":
      return PortalAuditEventType.PORTAL_AUDIT_EVENT_UNSPECIFIED;
    case 1:
    case "PORTAL_SESSION_CREATED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_CREATED_EVENT;
    case 2:
    case "PORTAL_SESSION_ACTIVATED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_ACTIVATED_EVENT;
    case 3:
    case "PORTAL_TOKEN_VALIDATED_EVENT":
      return PortalAuditEventType.PORTAL_TOKEN_VALIDATED_EVENT;
    case 4:
    case "PORTAL_TOKEN_REJECTED_EVENT":
      return PortalAuditEventType.PORTAL_TOKEN_REJECTED_EVENT;
    case 5:
    case "PORTAL_SESSION_ACCESSED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_ACCESSED_EVENT;
    case 6:
    case "PORTAL_REDIRECT_INITIATED_EVENT":
      return PortalAuditEventType.PORTAL_REDIRECT_INITIATED_EVENT;
    case 7:
    case "PORTAL_PAYMENT_INITIATED_EVENT":
      return PortalAuditEventType.PORTAL_PAYMENT_INITIATED_EVENT;
    case 8:
    case "PORTAL_PAYMENT_COMPLETED_EVENT":
      return PortalAuditEventType.PORTAL_PAYMENT_COMPLETED_EVENT;
    case 9:
    case "PORTAL_PAYMENT_FAILED_EVENT":
      return PortalAuditEventType.PORTAL_PAYMENT_FAILED_EVENT;
    case 10:
    case "PORTAL_SESSION_EXPIRED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_EXPIRED_EVENT;
    case 11:
    case "PORTAL_SESSION_CANCELLED_EVENT":
      return PortalAuditEventType.PORTAL_SESSION_CANCELLED_EVENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalAuditEventType.UNRECOGNIZED;
  }
}

export function portalAuditEventTypeToJSON(object: PortalAuditEventType): string {
  switch (object) {
    case PortalAuditEventType.PORTAL_AUDIT_EVENT_UNSPECIFIED:
      return "PORTAL_AUDIT_EVENT_UNSPECIFIED";
    case PortalAuditEventType.PORTAL_SESSION_CREATED_EVENT:
      return "PORTAL_SESSION_CREATED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_ACTIVATED_EVENT:
      return "PORTAL_SESSION_ACTIVATED_EVENT";
    case PortalAuditEventType.PORTAL_TOKEN_VALIDATED_EVENT:
      return "PORTAL_TOKEN_VALIDATED_EVENT";
    case PortalAuditEventType.PORTAL_TOKEN_REJECTED_EVENT:
      return "PORTAL_TOKEN_REJECTED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_ACCESSED_EVENT:
      return "PORTAL_SESSION_ACCESSED_EVENT";
    case PortalAuditEventType.PORTAL_REDIRECT_INITIATED_EVENT:
      return "PORTAL_REDIRECT_INITIATED_EVENT";
    case PortalAuditEventType.PORTAL_PAYMENT_INITIATED_EVENT:
      return "PORTAL_PAYMENT_INITIATED_EVENT";
    case PortalAuditEventType.PORTAL_PAYMENT_COMPLETED_EVENT:
      return "PORTAL_PAYMENT_COMPLETED_EVENT";
    case PortalAuditEventType.PORTAL_PAYMENT_FAILED_EVENT:
      return "PORTAL_PAYMENT_FAILED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_EXPIRED_EVENT:
      return "PORTAL_SESSION_EXPIRED_EVENT";
    case PortalAuditEventType.PORTAL_SESSION_CANCELLED_EVENT:
      return "PORTAL_SESSION_CANCELLED_EVENT";
    case PortalAuditEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Actor type for portal audit */
export enum PortalAuditActorType {
  PORTAL_AUDIT_ACTOR_UNSPECIFIED = 0,
  PORTAL_ACTOR_SYSTEM = 1,
  PORTAL_ACTOR_ADMIN = 2,
  PORTAL_ACTOR_PORTAL_TOKEN = 3,
  PORTAL_ACTOR_WEBHOOK = 4,
  UNRECOGNIZED = -1,
}

export function portalAuditActorTypeFromJSON(object: any): PortalAuditActorType {
  switch (object) {
    case 0:
    case "PORTAL_AUDIT_ACTOR_UNSPECIFIED":
      return PortalAuditActorType.PORTAL_AUDIT_ACTOR_UNSPECIFIED;
    case 1:
    case "PORTAL_ACTOR_SYSTEM":
      return PortalAuditActorType.PORTAL_ACTOR_SYSTEM;
    case 2:
    case "PORTAL_ACTOR_ADMIN":
      return PortalAuditActorType.PORTAL_ACTOR_ADMIN;
    case 3:
    case "PORTAL_ACTOR_PORTAL_TOKEN":
      return PortalAuditActorType.PORTAL_ACTOR_PORTAL_TOKEN;
    case 4:
    case "PORTAL_ACTOR_WEBHOOK":
      return PortalAuditActorType.PORTAL_ACTOR_WEBHOOK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PortalAuditActorType.UNRECOGNIZED;
  }
}

export function portalAuditActorTypeToJSON(object: PortalAuditActorType): string {
  switch (object) {
    case PortalAuditActorType.PORTAL_AUDIT_ACTOR_UNSPECIFIED:
      return "PORTAL_AUDIT_ACTOR_UNSPECIFIED";
    case PortalAuditActorType.PORTAL_ACTOR_SYSTEM:
      return "PORTAL_ACTOR_SYSTEM";
    case PortalAuditActorType.PORTAL_ACTOR_ADMIN:
      return "PORTAL_ACTOR_ADMIN";
    case PortalAuditActorType.PORTAL_ACTOR_PORTAL_TOKEN:
      return "PORTAL_ACTOR_PORTAL_TOKEN";
    case PortalAuditActorType.PORTAL_ACTOR_WEBHOOK:
      return "PORTAL_ACTOR_WEBHOOK";
    case PortalAuditActorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Empty {
}

export interface GetByIdRequest {
  id: string;
  /** Pour le multi-tenant */
  societeId: string;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface CreateStripeCheckoutSessionRequest {
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  /** 'payment', 'subscription', 'setup' */
  mode: string;
  successUrl: string;
  cancelUrl: string;
  customerId?: string | undefined;
  customerEmail?:
    | string
    | undefined;
  /** Pour les abonnements */
  priceId?: string | undefined;
  metadata: { [key: string]: string };
  lineItems: LineItem[];
}

export interface CreateStripeCheckoutSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface LineItem {
  name: string;
  description: string;
  amount: number;
  quantity: number;
  currency: string;
}

export interface StripeCheckoutSessionResponse {
  id: string;
  url: string;
  status: string;
  paymentStatus: string;
  customerId?: string | undefined;
  subscriptionId?: string | undefined;
}

export interface CreateStripePaymentIntentRequest {
  societeId: string;
  amount: number;
  currency: string;
  customerId?: string | undefined;
  description?: string | undefined;
  paymentMethod?: string | undefined;
  confirm: boolean;
  automaticPaymentMethods: boolean;
  metadata: { [key: string]: string };
}

export interface CreateStripePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripePaymentIntentResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  clientSecret?: string | undefined;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeCustomerRequest {
  societeId: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  description?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeCustomerRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeCustomerResponse {
  id: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  created: number;
}

export interface CreateStripeSubscriptionRequest {
  societeId: string;
  customerId: string;
  priceId: string;
  paymentMethod?: string | undefined;
  defaultPaymentMethod?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSubscriptionResponse {
  id: string;
  customerId: string;
  status: string;
  currentPeriodStart: number;
  currentPeriodEnd: number;
  cancelAtPeriodEnd: boolean;
}

export interface CreateStripeRefundRequest {
  societeId: string;
  paymentIntentId: string;
  /** Partial refund, omit for full */
  amount?: number | undefined;
  reason?: string | undefined;
}

export interface StripeRefundResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  paymentIntentId: string;
}

export interface CreateStripeSetupIntentRequest {
  societeId: string;
  customerId?: string | undefined;
  paymentMethodTypes: string[];
  metadata: { [key: string]: string };
}

export interface CreateStripeSetupIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSetupIntentResponse {
  id: string;
  clientSecret: string;
  status: string;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeBillingPortalRequest {
  societeId: string;
  customerId: string;
  returnUrl: string;
}

export interface StripeBillingPortalResponse {
  id: string;
  url: string;
}

export interface CreatePayPalOrderRequest {
  societeId: string;
  /** 'CAPTURE' or 'AUTHORIZE' */
  intent: string;
  purchaseUnits: PayPalPurchaseUnit[];
  returnUrl: string;
  cancelUrl: string;
  metadata: { [key: string]: string };
}

export interface CreatePayPalOrderRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PayPalPurchaseUnit {
  referenceId?:
    | string
    | undefined;
  /** En centimes */
  amount: number;
  currency: string;
  description?: string | undefined;
  customId?: string | undefined;
  invoiceId?: string | undefined;
}

export interface PayPalOrderResponse {
  id: string;
  status: string;
  approveUrl?: string | undefined;
  captureUrl?: string | undefined;
  links: PayPalLink[];
}

export interface PayPalLink {
  href: string;
  rel: string;
  method: string;
}

export interface GetPayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface CapturePayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface PayPalCaptureResponse {
  id: string;
  status: string;
  payer?: PayPalPayer | undefined;
  purchaseUnits: PayPalCapturedPurchaseUnit[];
}

export interface PayPalPayer {
  emailAddress?: string | undefined;
  payerId?: string | undefined;
  givenName?: string | undefined;
  surname?: string | undefined;
}

export interface PayPalCapturedPurchaseUnit {
  referenceId?: string | undefined;
  captures: PayPalCapture[];
}

export interface PayPalCapture {
  id: string;
  status: string;
  amount: PayPalAmount | undefined;
}

export interface PayPalAmount {
  currencyCode: string;
  value: string;
}

export interface SetupGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
  /** 'bacs', 'sepa_core', 'ach', etc. */
  scheme: string;
  description?: string | undefined;
  successRedirectUrl: string;
  sessionToken?: string | undefined;
}

export interface GoCardlessMandateResponse {
  id: string;
  clientId: string;
  mandateId: string;
  status: string;
  scheme: string;
  bankName?: string | undefined;
  accountHolderName?: string | undefined;
  accountNumberEnding?: string | undefined;
  redirectUrl?: string | undefined;
}

export interface GetGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
}

export interface CreateGoCardlessPaymentRequest {
  clientId: string;
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  description?:
    | string
    | undefined;
  /** YYYY-MM-DD */
  chargeDate?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessPaymentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessPaymentResponse {
  id: string;
  paymentId: string;
  amount: number;
  currency: string;
  status: string;
  chargeDate?: string | undefined;
}

export interface CreateGoCardlessSubscriptionRequest {
  clientId: string;
  societeId: string;
  amount: number;
  currency: string;
  /** 'weekly', 'monthly', 'yearly' */
  intervalUnit: string;
  interval: number;
  name?: string | undefined;
  startDate?:
    | string
    | undefined;
  /** Number of payments, omit for indefinite */
  count?: number | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessSubscriptionResponse {
  id: string;
  subscriptionId: string;
  amount: number;
  currency: string;
  status: string;
  intervalUnit: string;
  interval: number;
  nextPaymentDate?: string | undefined;
}

export interface CancelGoCardlessSubscriptionRequest {
  subscriptionId: string;
  societeId: string;
}

export interface CreateScheduleRequest {
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  /** ISO date string */
  dueDate: string;
  description?: string | undefined;
  autoProcess: boolean;
  metadata: { [key: string]: string };
}

export interface CreateScheduleRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface ScheduleResponse {
  id: string;
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  dueDate: string;
  /** PLANNED, PROCESSING, PENDING, PAID, FAILED, UNPAID, CANCELLED, EXPIRED */
  status: string;
  lastAttemptAt?: string | undefined;
  paidAt?: string | undefined;
  retryCount: number;
  errorMessage?: string | undefined;
}

export interface UpdateScheduleRequest {
  id: string;
  amount?: number | undefined;
  dueDate?: string | undefined;
  status?: string | undefined;
  autoProcess?: boolean | undefined;
}

export interface GetDueSchedulesRequest {
  organisationId: string;
  /** Get schedules due before this date */
  beforeDate?: string | undefined;
}

export interface ScheduleListResponse {
  schedules: ScheduleResponse[];
  total: number;
}

export interface ProcessDuePaymentsRequest {
  organisationId: string;
  /** If true, don't actually process */
  dryRun?: boolean | undefined;
}

export interface ProcessDuePaymentsResponse {
  processedCount: number;
  successCount: number;
  failedCount: number;
  results: ProcessedPayment[];
}

export interface ProcessedPayment {
  scheduleId: string;
  success: boolean;
  paymentId?: string | undefined;
  error?: string | undefined;
}

export interface RenewScheduleRequest {
  id: string;
  newDueDate: string;
  newAmount?: number | undefined;
}

export interface CreatePaymentIntentRequest {
  organisationId: string;
  societeId: string;
  scheduleId?:
    | string
    | undefined;
  /** STRIPE, PAYPAL, GOCARDLESS, etc. */
  pspName: string;
  amount: number;
  currency: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreatePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PaymentIntentResponse {
  id: string;
  organisationId: string;
  societeId: string;
  scheduleId?: string | undefined;
  pspName: string;
  pspPaymentId?: string | undefined;
  amount: number;
  currency: string;
  /** PENDING, PROCESSING, SUCCEEDED, FAILED, CANCELLED */
  status: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface UpdatePaymentIntentRequest {
  id: string;
  status?: string | undefined;
  pspPaymentId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface CreatePaymentEventRequest {
  organisationId: string;
  paymentIntentId: string;
  /** PAYMENT_INITIATED, PAYMENT_CONFIRMED, PAYMENT_FAILED, etc. */
  eventType: string;
  /** JSON string */
  rawPayload: string;
}

export interface PaymentEventResponse {
  id: string;
  organisationId: string;
  paymentIntentId: string;
  eventType: string;
  rawPayload: string;
  receivedAt: string;
  processed: boolean;
  processedAt?: string | undefined;
  errorMessage?: string | undefined;
}

export interface GetUnprocessedEventsRequest {
  organisationId: string;
  limit?: number | undefined;
}

export interface PaymentEventListResponse {
  events: PaymentEventResponse[];
  total: number;
}

export interface MarkEventProcessedRequest {
  id: string;
  /** If processing failed */
  errorMessage?: string | undefined;
}

export interface GetPSPAccountsRequest {
  societeId: string;
}

export interface PSPAccountsSummaryResponse {
  stripe?: PSPAccountInfo | undefined;
  paypal?: PSPAccountInfo | undefined;
  gocardless?: PSPAccountInfo | undefined;
  emerchantpay?: PSPAccountInfo | undefined;
  slimpay?: PSPAccountInfo | undefined;
  multisafepay?: PSPAccountInfo | undefined;
}

export interface PSPAccountInfo {
  id: string;
  name: string;
  isActive: boolean;
  isLiveMode: boolean;
  isConfigured: boolean;
}

/** Request to create a portal session */
export interface CreatePortalSessionRequest {
  organisationId: string;
  societeId: string;
  customerId: string;
  contractId?: string | undefined;
  paymentIntentId?: string | undefined;
  allowedActions: PortalSessionAction[];
  /** Time-to-live, default 900 (15 min) */
  ttlSeconds?:
    | number
    | undefined;
  /** Default 1 */
  maxUses?: number | undefined;
  amountCents: number;
  /** Default EUR */
  currency?: string | undefined;
  description?: string | undefined;
  mandateId?:
    | string
    | undefined;
  /** Masked RUM for display */
  rumMasked?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreatePortalSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

/** Response after creating a portal session */
export interface CreatePortalSessionResponse {
  session:
    | PortalPaymentSession
    | undefined;
  /** One-time use token (returned only on creation) */
  token: string;
  /** Full URL to the payment portal */
  portalUrl: string;
  /** True if returned from idempotency cache */
  wasIdempotentHit: boolean;
}

/** Portal payment session entity */
export interface PortalPaymentSession {
  id: string;
  organisationId: string;
  societeId: string;
  customerId: string;
  contractId?: string | undefined;
  paymentIntentId?:
    | string
    | undefined;
  /** Token (hash stored, never exposed) */
  tokenVersion: string;
  /** State */
  status: PortalSessionStatus;
  allowedActions: PortalSessionAction[];
  /** Timing */
  expiresAt: string;
  maxUses: number;
  useCount: number;
  consumedAt?: string | undefined;
  revokedAt?: string | undefined;
  lastAccessedAt?:
    | string
    | undefined;
  /** Payment details */
  amountCents: number;
  currency: string;
  description?: string | undefined;
  mandateId?: string | undefined;
  rumMasked?:
    | string
    | undefined;
  /** PSP state (for redirect flow) */
  pspState?: string | undefined;
  pspRedirectUrl?: string | undefined;
  pspProvider?: PortalPspProvider | undefined;
  pspSessionId?:
    | string
    | undefined;
  /** Metadata */
  metadata: { [key: string]: string };
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

export interface PortalPaymentSession_MetadataEntry {
  key: string;
  value: string;
}

/** Validate a portal token */
export interface ValidatePortalTokenRequest {
  token: string;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface ValidatePortalTokenResponse {
  valid: boolean;
  session?: PortalPaymentSession | undefined;
  errorCode?: PortalErrorCode | undefined;
  errorMessage?: string | undefined;
}

/** Access a portal session (marks as active) */
export interface AccessPortalSessionRequest {
  token: string;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface AccessPortalSessionResponse {
  session: PortalPaymentSession | undefined;
}

/** Consume a portal token (for payment action) */
export interface ConsumePortalTokenRequest {
  token: string;
  action: PortalSessionAction;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface ConsumePortalTokenResponse {
  session: PortalPaymentSession | undefined;
}

/** Cancel a portal session */
export interface CancelPortalSessionRequest {
  sessionId: string;
  reason?: string | undefined;
}

export interface CancelPortalSessionResponse {
  session: PortalPaymentSession | undefined;
}

/** Update PSP info on portal session */
export interface UpdatePortalPspInfoRequest {
  sessionId: string;
  pspState: string;
  pspRedirectUrl: string;
  pspProvider: PortalPspProvider;
  pspSessionId: string;
}

export interface UpdatePortalPspInfoResponse {
  success: boolean;
}

/** Transition portal session status */
export interface TransitionPortalSessionRequest {
  sessionId: string;
  newStatus: PortalSessionStatus;
  reason?: string | undefined;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
}

export interface TransitionPortalSessionResponse {
  session: PortalPaymentSession | undefined;
}

/** Portal session audit log entry */
export interface PortalSessionAuditLog {
  id: string;
  portalSessionId: string;
  eventType: PortalAuditEventType;
  actorType: PortalAuditActorType;
  previousStatus?: string | undefined;
  newStatus?: string | undefined;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
  correlationId?: string | undefined;
  data: { [key: string]: string };
  timestamp: string;
}

export interface PortalSessionAuditLog_DataEntry {
  key: string;
  value: string;
}

/** List portal sessions */
export interface ListPortalSessionsRequest {
  organisationId: string;
  societeId?: string | undefined;
  customerId?: string | undefined;
  status?: PortalSessionStatus | undefined;
  fromDate?: string | undefined;
  toDate?: string | undefined;
  page?: number | undefined;
  limit?: number | undefined;
}

export interface ListPortalSessionsResponse {
  sessions: PortalPaymentSession[];
  total: number;
  page: number;
  totalPages: number;
}

/** Get portal session audit logs */
export interface GetPortalSessionAuditRequest {
  sessionId: string;
}

export interface GetPortalSessionAuditResponse {
  logs: PortalSessionAuditLog[];
}

/** Portal session stats */
export interface GetPortalSessionStatsRequest {
  organisationId: string;
  societeId?: string | undefined;
  fromDate: string;
  toDate: string;
}

export interface GetPortalSessionStatsResponse {
  totalCreated: number;
  totalCompleted: number;
  totalFailed: number;
  totalExpired: number;
  totalCancelled: number;
  completionRate: number;
}

/** Request context for portal operations */
export interface PortalRequestContext {
  ipHash?: string | undefined;
  uaHash?: string | undefined;
  requestId?: string | undefined;
  correlationId?: string | undefined;
}

/** GoCardless configuration */
export interface GoCardlessConfig {
  accessToken: string;
  baseUrl: string;
}

/** Slimpay OAuth token (cached) */
export interface SlimpayToken {
  accessToken: string;
  /** Unix timestamp */
  expiresAt: number;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "", societeId: "" };
}

export const GetByIdRequest: MessageFns<GetByIdRequest> = {
  encode(message: GetByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetByIdRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetByIdRequest>, I>>(base?: I): GetByIdRequest {
    return GetByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetByIdRequest>, I>>(object: I): GetByIdRequest {
    const message = createBaseGetByIdRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest(): CreateStripeCheckoutSessionRequest {
  return {
    societeId: "",
    amount: 0,
    currency: "",
    mode: "",
    successUrl: "",
    cancelUrl: "",
    customerId: undefined,
    customerEmail: undefined,
    priceId: undefined,
    metadata: {},
    lineItems: [],
  };
}

export const CreateStripeCheckoutSessionRequest: MessageFns<CreateStripeCheckoutSessionRequest> = {
  encode(message: CreateStripeCheckoutSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.mode !== "") {
      writer.uint32(34).string(message.mode);
    }
    if (message.successUrl !== "") {
      writer.uint32(42).string(message.successUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(50).string(message.cancelUrl);
    }
    if (message.customerId !== undefined) {
      writer.uint32(58).string(message.customerId);
    }
    if (message.customerEmail !== undefined) {
      writer.uint32(66).string(message.customerEmail);
    }
    if (message.priceId !== undefined) {
      writer.uint32(74).string(message.priceId);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeCheckoutSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .join();
    });
    for (const v of message.lineItems) {
      LineItem.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.customerEmail = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.priceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateStripeCheckoutSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lineItems.push(LineItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCheckoutSessionRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      successUrl: isSet(object.successUrl)
        ? globalThis.String(object.successUrl)
        : isSet(object.success_url)
        ? globalThis.String(object.success_url)
        : "",
      cancelUrl: isSet(object.cancelUrl)
        ? globalThis.String(object.cancelUrl)
        : isSet(object.cancel_url)
        ? globalThis.String(object.cancel_url)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      customerEmail: isSet(object.customerEmail)
        ? globalThis.String(object.customerEmail)
        : isSet(object.customer_email)
        ? globalThis.String(object.customer_email)
        : undefined,
      priceId: isSet(object.priceId)
        ? globalThis.String(object.priceId)
        : isSet(object.price_id)
        ? globalThis.String(object.price_id)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      lineItems: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => LineItem.fromJSON(e))
        : globalThis.Array.isArray(object?.line_items)
        ? object.line_items.map((e: any) => LineItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateStripeCheckoutSessionRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.successUrl !== "") {
      obj.successUrl = message.successUrl;
    }
    if (message.cancelUrl !== "") {
      obj.cancelUrl = message.cancelUrl;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.customerEmail !== undefined) {
      obj.customerEmail = message.customerEmail;
    }
    if (message.priceId !== undefined) {
      obj.priceId = message.priceId;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.lineItems?.length) {
      obj.lineItems = message.lineItems.map((e) => LineItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest>, I>>(
    base?: I,
  ): CreateStripeCheckoutSessionRequest {
    return CreateStripeCheckoutSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest>, I>>(
    object: I,
  ): CreateStripeCheckoutSessionRequest {
    const message = createBaseCreateStripeCheckoutSessionRequest();
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.mode = object.mode ?? "";
    message.successUrl = object.successUrl ?? "";
    message.cancelUrl = object.cancelUrl ?? "";
    message.customerId = object.customerId ?? undefined;
    message.customerEmail = object.customerEmail ?? undefined;
    message.priceId = object.priceId ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.lineItems = object.lineItems?.map((e) => LineItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest_MetadataEntry(): CreateStripeCheckoutSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCheckoutSessionRequest_MetadataEntry: MessageFns<
  CreateStripeCheckoutSessionRequest_MetadataEntry
> = {
  encode(
    message: CreateStripeCheckoutSessionRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCheckoutSessionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeCheckoutSessionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeCheckoutSessionRequest_MetadataEntry {
    return CreateStripeCheckoutSessionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeCheckoutSessionRequest_MetadataEntry {
    const message = createBaseCreateStripeCheckoutSessionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLineItem(): LineItem {
  return { name: "", description: "", amount: 0, quantity: 0, currency: "" };
}

export const LineItem: MessageFns<LineItem> = {
  encode(message: LineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: LineItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineItem>, I>>(base?: I): LineItem {
    return LineItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineItem>, I>>(object: I): LineItem {
    const message = createBaseLineItem();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.amount = object.amount ?? 0;
    message.quantity = object.quantity ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseStripeCheckoutSessionResponse(): StripeCheckoutSessionResponse {
  return { id: "", url: "", status: "", paymentStatus: "", customerId: undefined, subscriptionId: undefined };
}

export const StripeCheckoutSessionResponse: MessageFns<StripeCheckoutSessionResponse> = {
  encode(message: StripeCheckoutSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.paymentStatus !== "") {
      writer.uint32(34).string(message.paymentStatus);
    }
    if (message.customerId !== undefined) {
      writer.uint32(42).string(message.customerId);
    }
    if (message.subscriptionId !== undefined) {
      writer.uint32(50).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeCheckoutSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCheckoutSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeCheckoutSessionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      paymentStatus: isSet(object.paymentStatus)
        ? globalThis.String(object.paymentStatus)
        : isSet(object.payment_status)
        ? globalThis.String(object.payment_status)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : undefined,
    };
  },

  toJSON(message: StripeCheckoutSessionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.paymentStatus !== "") {
      obj.paymentStatus = message.paymentStatus;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.subscriptionId !== undefined) {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeCheckoutSessionResponse>, I>>(base?: I): StripeCheckoutSessionResponse {
    return StripeCheckoutSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeCheckoutSessionResponse>, I>>(
    object: I,
  ): StripeCheckoutSessionResponse {
    const message = createBaseStripeCheckoutSessionResponse();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.status = object.status ?? "";
    message.paymentStatus = object.paymentStatus ?? "";
    message.customerId = object.customerId ?? undefined;
    message.subscriptionId = object.subscriptionId ?? undefined;
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest(): CreateStripePaymentIntentRequest {
  return {
    societeId: "",
    amount: 0,
    currency: "",
    customerId: undefined,
    description: undefined,
    paymentMethod: undefined,
    confirm: false,
    automaticPaymentMethods: false,
    metadata: {},
  };
}

export const CreateStripePaymentIntentRequest: MessageFns<CreateStripePaymentIntentRequest> = {
  encode(message: CreateStripePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(50).string(message.paymentMethod);
    }
    if (message.confirm !== false) {
      writer.uint32(56).bool(message.confirm);
    }
    if (message.automaticPaymentMethods !== false) {
      writer.uint32(64).bool(message.automaticPaymentMethods);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.confirm = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.automaticPaymentMethods = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CreateStripePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripePaymentIntentRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
      confirm: isSet(object.confirm) ? globalThis.Boolean(object.confirm) : false,
      automaticPaymentMethods: isSet(object.automaticPaymentMethods)
        ? globalThis.Boolean(object.automaticPaymentMethods)
        : isSet(object.automatic_payment_methods)
        ? globalThis.Boolean(object.automatic_payment_methods)
        : false,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.confirm !== false) {
      obj.confirm = message.confirm;
    }
    if (message.automaticPaymentMethods !== false) {
      obj.automaticPaymentMethods = message.automaticPaymentMethods;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest>, I>>(
    base?: I,
  ): CreateStripePaymentIntentRequest {
    return CreateStripePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest>, I>>(
    object: I,
  ): CreateStripePaymentIntentRequest {
    const message = createBaseCreateStripePaymentIntentRequest();
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.customerId = object.customerId ?? undefined;
    message.description = object.description ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    message.confirm = object.confirm ?? false;
    message.automaticPaymentMethods = object.automaticPaymentMethods ?? false;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest_MetadataEntry(): CreateStripePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripePaymentIntentRequest_MetadataEntry: MessageFns<
  CreateStripePaymentIntentRequest_MetadataEntry
> = {
  encode(
    message: CreateStripePaymentIntentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripePaymentIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripePaymentIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripePaymentIntentRequest_MetadataEntry {
    return CreateStripePaymentIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripePaymentIntentRequest_MetadataEntry {
    const message = createBaseCreateStripePaymentIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripePaymentIntentResponse(): StripePaymentIntentResponse {
  return {
    id: "",
    amount: 0,
    currency: "",
    status: "",
    clientSecret: undefined,
    customerId: undefined,
    paymentMethod: undefined,
  };
}

export const StripePaymentIntentResponse: MessageFns<StripePaymentIntentResponse> = {
  encode(message: StripePaymentIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.clientSecret !== undefined) {
      writer.uint32(42).string(message.clientSecret);
    }
    if (message.customerId !== undefined) {
      writer.uint32(50).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(58).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripePaymentIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripePaymentIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      clientSecret: isSet(object.clientSecret)
        ? globalThis.String(object.clientSecret)
        : isSet(object.client_secret)
        ? globalThis.String(object.client_secret)
        : undefined,
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
    };
  },

  toJSON(message: StripePaymentIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.clientSecret !== undefined) {
      obj.clientSecret = message.clientSecret;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripePaymentIntentResponse>, I>>(base?: I): StripePaymentIntentResponse {
    return StripePaymentIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripePaymentIntentResponse>, I>>(object: I): StripePaymentIntentResponse {
    const message = createBaseStripePaymentIntentResponse();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.clientSecret = object.clientSecret ?? undefined;
    message.customerId = object.customerId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    return message;
  },
};

function createBaseCreateStripeCustomerRequest(): CreateStripeCustomerRequest {
  return { societeId: "", email: "", name: undefined, phone: undefined, description: undefined, metadata: {} };
}

export const CreateStripeCustomerRequest: MessageFns<CreateStripeCustomerRequest> = {
  encode(message: CreateStripeCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeCustomerRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeCustomerRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCustomerRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripeCustomerRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCustomerRequest>, I>>(base?: I): CreateStripeCustomerRequest {
    return CreateStripeCustomerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCustomerRequest>, I>>(object: I): CreateStripeCustomerRequest {
    const message = createBaseCreateStripeCustomerRequest();
    message.societeId = object.societeId ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? undefined;
    message.phone = object.phone ?? undefined;
    message.description = object.description ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripeCustomerRequest_MetadataEntry(): CreateStripeCustomerRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCustomerRequest_MetadataEntry: MessageFns<CreateStripeCustomerRequest_MetadataEntry> = {
  encode(message: CreateStripeCustomerRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCustomerRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCustomerRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeCustomerRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCustomerRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeCustomerRequest_MetadataEntry {
    return CreateStripeCustomerRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCustomerRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeCustomerRequest_MetadataEntry {
    const message = createBaseCreateStripeCustomerRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripeCustomerResponse(): StripeCustomerResponse {
  return { id: "", email: "", name: undefined, phone: undefined, created: 0 };
}

export const StripeCustomerResponse: MessageFns<StripeCustomerResponse> = {
  encode(message: StripeCustomerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.created !== 0) {
      writer.uint32(40).int64(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeCustomerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCustomerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.created = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeCustomerResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      created: isSet(object.created) ? globalThis.Number(object.created) : 0,
    };
  },

  toJSON(message: StripeCustomerResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.created !== 0) {
      obj.created = Math.round(message.created);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeCustomerResponse>, I>>(base?: I): StripeCustomerResponse {
    return StripeCustomerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeCustomerResponse>, I>>(object: I): StripeCustomerResponse {
    const message = createBaseStripeCustomerResponse();
    message.id = object.id ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? undefined;
    message.phone = object.phone ?? undefined;
    message.created = object.created ?? 0;
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest(): CreateStripeSubscriptionRequest {
  return {
    societeId: "",
    customerId: "",
    priceId: "",
    paymentMethod: undefined,
    defaultPaymentMethod: undefined,
    metadata: {},
  };
}

export const CreateStripeSubscriptionRequest: MessageFns<CreateStripeSubscriptionRequest> = {
  encode(message: CreateStripeSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.priceId !== "") {
      writer.uint32(26).string(message.priceId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(34).string(message.paymentMethod);
    }
    if (message.defaultPaymentMethod !== undefined) {
      writer.uint32(42).string(message.defaultPaymentMethod);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultPaymentMethod = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSubscriptionRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      priceId: isSet(object.priceId)
        ? globalThis.String(object.priceId)
        : isSet(object.price_id)
        ? globalThis.String(object.price_id)
        : "",
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
      defaultPaymentMethod: isSet(object.defaultPaymentMethod)
        ? globalThis.String(object.defaultPaymentMethod)
        : isSet(object.default_payment_method)
        ? globalThis.String(object.default_payment_method)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripeSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.priceId !== "") {
      obj.priceId = message.priceId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.defaultPaymentMethod !== undefined) {
      obj.defaultPaymentMethod = message.defaultPaymentMethod;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest>, I>>(base?: I): CreateStripeSubscriptionRequest {
    return CreateStripeSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest>, I>>(
    object: I,
  ): CreateStripeSubscriptionRequest {
    const message = createBaseCreateStripeSubscriptionRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.priceId = object.priceId ?? "";
    message.paymentMethod = object.paymentMethod ?? undefined;
    message.defaultPaymentMethod = object.defaultPaymentMethod ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest_MetadataEntry(): CreateStripeSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSubscriptionRequest_MetadataEntry: MessageFns<CreateStripeSubscriptionRequest_MetadataEntry> =
  {
    encode(
      message: CreateStripeSubscriptionRequest_MetadataEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSubscriptionRequest_MetadataEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateStripeSubscriptionRequest_MetadataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CreateStripeSubscriptionRequest_MetadataEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: CreateStripeSubscriptionRequest_MetadataEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest_MetadataEntry>, I>>(
      base?: I,
    ): CreateStripeSubscriptionRequest_MetadataEntry {
      return CreateStripeSubscriptionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest_MetadataEntry>, I>>(
      object: I,
    ): CreateStripeSubscriptionRequest_MetadataEntry {
      const message = createBaseCreateStripeSubscriptionRequest_MetadataEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseStripeSubscriptionResponse(): StripeSubscriptionResponse {
  return { id: "", customerId: "", status: "", currentPeriodStart: 0, currentPeriodEnd: 0, cancelAtPeriodEnd: false };
}

export const StripeSubscriptionResponse: MessageFns<StripeSubscriptionResponse> = {
  encode(message: StripeSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.currentPeriodStart !== 0) {
      writer.uint32(32).int64(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== 0) {
      writer.uint32(40).int64(message.currentPeriodEnd);
    }
    if (message.cancelAtPeriodEnd !== false) {
      writer.uint32(48).bool(message.cancelAtPeriodEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currentPeriodStart = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.currentPeriodEnd = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeSubscriptionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      currentPeriodStart: isSet(object.currentPeriodStart)
        ? globalThis.Number(object.currentPeriodStart)
        : isSet(object.current_period_start)
        ? globalThis.Number(object.current_period_start)
        : 0,
      currentPeriodEnd: isSet(object.currentPeriodEnd)
        ? globalThis.Number(object.currentPeriodEnd)
        : isSet(object.current_period_end)
        ? globalThis.Number(object.current_period_end)
        : 0,
      cancelAtPeriodEnd: isSet(object.cancelAtPeriodEnd)
        ? globalThis.Boolean(object.cancelAtPeriodEnd)
        : isSet(object.cancel_at_period_end)
        ? globalThis.Boolean(object.cancel_at_period_end)
        : false,
    };
  },

  toJSON(message: StripeSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.currentPeriodStart !== 0) {
      obj.currentPeriodStart = Math.round(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== 0) {
      obj.currentPeriodEnd = Math.round(message.currentPeriodEnd);
    }
    if (message.cancelAtPeriodEnd !== false) {
      obj.cancelAtPeriodEnd = message.cancelAtPeriodEnd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeSubscriptionResponse>, I>>(base?: I): StripeSubscriptionResponse {
    return StripeSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeSubscriptionResponse>, I>>(object: I): StripeSubscriptionResponse {
    const message = createBaseStripeSubscriptionResponse();
    message.id = object.id ?? "";
    message.customerId = object.customerId ?? "";
    message.status = object.status ?? "";
    message.currentPeriodStart = object.currentPeriodStart ?? 0;
    message.currentPeriodEnd = object.currentPeriodEnd ?? 0;
    message.cancelAtPeriodEnd = object.cancelAtPeriodEnd ?? false;
    return message;
  },
};

function createBaseCreateStripeRefundRequest(): CreateStripeRefundRequest {
  return { societeId: "", paymentIntentId: "", amount: undefined, reason: undefined };
}

export const CreateStripeRefundRequest: MessageFns<CreateStripeRefundRequest> = {
  encode(message: CreateStripeRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.amount !== undefined) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeRefundRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: CreateStripeRefundRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeRefundRequest>, I>>(base?: I): CreateStripeRefundRequest {
    return CreateStripeRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeRefundRequest>, I>>(object: I): CreateStripeRefundRequest {
    const message = createBaseCreateStripeRefundRequest();
    message.societeId = object.societeId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.amount = object.amount ?? undefined;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseStripeRefundResponse(): StripeRefundResponse {
  return { id: "", amount: 0, currency: "", status: "", paymentIntentId: "" };
}

export const StripeRefundResponse: MessageFns<StripeRefundResponse> = {
  encode(message: StripeRefundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(42).string(message.paymentIntentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeRefundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeRefundResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
    };
  },

  toJSON(message: StripeRefundResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeRefundResponse>, I>>(base?: I): StripeRefundResponse {
    return StripeRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeRefundResponse>, I>>(object: I): StripeRefundResponse {
    const message = createBaseStripeRefundResponse();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest(): CreateStripeSetupIntentRequest {
  return { societeId: "", customerId: undefined, paymentMethodTypes: [], metadata: {} };
}

export const CreateStripeSetupIntentRequest: MessageFns<CreateStripeSetupIntentRequest> = {
  encode(message: CreateStripeSetupIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== undefined) {
      writer.uint32(18).string(message.customerId);
    }
    for (const v of message.paymentMethodTypes) {
      writer.uint32(26).string(v!);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeSetupIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSetupIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentMethodTypes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateStripeSetupIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSetupIntentRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      paymentMethodTypes: globalThis.Array.isArray(object?.paymentMethodTypes)
        ? object.paymentMethodTypes.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.payment_method_types)
        ? object.payment_method_types.map((e: any) => globalThis.String(e))
        : [],
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateStripeSetupIntentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethodTypes?.length) {
      obj.paymentMethodTypes = message.paymentMethodTypes;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest>, I>>(base?: I): CreateStripeSetupIntentRequest {
    return CreateStripeSetupIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest>, I>>(
    object: I,
  ): CreateStripeSetupIntentRequest {
    const message = createBaseCreateStripeSetupIntentRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? undefined;
    message.paymentMethodTypes = object.paymentMethodTypes?.map((e) => e) || [];
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest_MetadataEntry(): CreateStripeSetupIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSetupIntentRequest_MetadataEntry: MessageFns<CreateStripeSetupIntentRequest_MetadataEntry> = {
  encode(
    message: CreateStripeSetupIntentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSetupIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSetupIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeSetupIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeSetupIntentRequest_MetadataEntry {
    return CreateStripeSetupIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeSetupIntentRequest_MetadataEntry {
    const message = createBaseCreateStripeSetupIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripeSetupIntentResponse(): StripeSetupIntentResponse {
  return { id: "", clientSecret: "", status: "", customerId: undefined, paymentMethod: undefined };
}

export const StripeSetupIntentResponse: MessageFns<StripeSetupIntentResponse> = {
  encode(message: StripeSetupIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(42).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeSetupIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSetupIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeSetupIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clientSecret: isSet(object.clientSecret)
        ? globalThis.String(object.clientSecret)
        : isSet(object.client_secret)
        ? globalThis.String(object.client_secret)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      paymentMethod: isSet(object.paymentMethod)
        ? globalThis.String(object.paymentMethod)
        : isSet(object.payment_method)
        ? globalThis.String(object.payment_method)
        : undefined,
    };
  },

  toJSON(message: StripeSetupIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeSetupIntentResponse>, I>>(base?: I): StripeSetupIntentResponse {
    return StripeSetupIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeSetupIntentResponse>, I>>(object: I): StripeSetupIntentResponse {
    const message = createBaseStripeSetupIntentResponse();
    message.id = object.id ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.status = object.status ?? "";
    message.customerId = object.customerId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    return message;
  },
};

function createBaseCreateStripeBillingPortalRequest(): CreateStripeBillingPortalRequest {
  return { societeId: "", customerId: "", returnUrl: "" };
}

export const CreateStripeBillingPortalRequest: MessageFns<CreateStripeBillingPortalRequest> = {
  encode(message: CreateStripeBillingPortalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.returnUrl !== "") {
      writer.uint32(26).string(message.returnUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeBillingPortalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeBillingPortalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeBillingPortalRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      returnUrl: isSet(object.returnUrl)
        ? globalThis.String(object.returnUrl)
        : isSet(object.return_url)
        ? globalThis.String(object.return_url)
        : "",
    };
  },

  toJSON(message: CreateStripeBillingPortalRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.returnUrl !== "") {
      obj.returnUrl = message.returnUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeBillingPortalRequest>, I>>(
    base?: I,
  ): CreateStripeBillingPortalRequest {
    return CreateStripeBillingPortalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeBillingPortalRequest>, I>>(
    object: I,
  ): CreateStripeBillingPortalRequest {
    const message = createBaseCreateStripeBillingPortalRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.returnUrl = object.returnUrl ?? "";
    return message;
  },
};

function createBaseStripeBillingPortalResponse(): StripeBillingPortalResponse {
  return { id: "", url: "" };
}

export const StripeBillingPortalResponse: MessageFns<StripeBillingPortalResponse> = {
  encode(message: StripeBillingPortalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeBillingPortalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeBillingPortalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeBillingPortalResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: StripeBillingPortalResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeBillingPortalResponse>, I>>(base?: I): StripeBillingPortalResponse {
    return StripeBillingPortalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeBillingPortalResponse>, I>>(object: I): StripeBillingPortalResponse {
    const message = createBaseStripeBillingPortalResponse();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseCreatePayPalOrderRequest(): CreatePayPalOrderRequest {
  return { societeId: "", intent: "", purchaseUnits: [], returnUrl: "", cancelUrl: "", metadata: {} };
}

export const CreatePayPalOrderRequest: MessageFns<CreatePayPalOrderRequest> = {
  encode(message: CreatePayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.intent !== "") {
      writer.uint32(18).string(message.intent);
    }
    for (const v of message.purchaseUnits) {
      PayPalPurchaseUnit.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.returnUrl !== "") {
      writer.uint32(34).string(message.returnUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(42).string(message.cancelUrl);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePayPalOrderRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.purchaseUnits.push(PayPalPurchaseUnit.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreatePayPalOrderRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePayPalOrderRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      purchaseUnits: globalThis.Array.isArray(object?.purchaseUnits)
        ? object.purchaseUnits.map((e: any) => PayPalPurchaseUnit.fromJSON(e))
        : globalThis.Array.isArray(object?.purchase_units)
        ? object.purchase_units.map((e: any) => PayPalPurchaseUnit.fromJSON(e))
        : [],
      returnUrl: isSet(object.returnUrl)
        ? globalThis.String(object.returnUrl)
        : isSet(object.return_url)
        ? globalThis.String(object.return_url)
        : "",
      cancelUrl: isSet(object.cancelUrl)
        ? globalThis.String(object.cancelUrl)
        : isSet(object.cancel_url)
        ? globalThis.String(object.cancel_url)
        : "",
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreatePayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.purchaseUnits?.length) {
      obj.purchaseUnits = message.purchaseUnits.map((e) => PayPalPurchaseUnit.toJSON(e));
    }
    if (message.returnUrl !== "") {
      obj.returnUrl = message.returnUrl;
    }
    if (message.cancelUrl !== "") {
      obj.cancelUrl = message.cancelUrl;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePayPalOrderRequest>, I>>(base?: I): CreatePayPalOrderRequest {
    return CreatePayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePayPalOrderRequest>, I>>(object: I): CreatePayPalOrderRequest {
    const message = createBaseCreatePayPalOrderRequest();
    message.societeId = object.societeId ?? "";
    message.intent = object.intent ?? "";
    message.purchaseUnits = object.purchaseUnits?.map((e) => PayPalPurchaseUnit.fromPartial(e)) || [];
    message.returnUrl = object.returnUrl ?? "";
    message.cancelUrl = object.cancelUrl ?? "";
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePayPalOrderRequest_MetadataEntry(): CreatePayPalOrderRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePayPalOrderRequest_MetadataEntry: MessageFns<CreatePayPalOrderRequest_MetadataEntry> = {
  encode(message: CreatePayPalOrderRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePayPalOrderRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePayPalOrderRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePayPalOrderRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePayPalOrderRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePayPalOrderRequest_MetadataEntry {
    return CreatePayPalOrderRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePayPalOrderRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePayPalOrderRequest_MetadataEntry {
    const message = createBaseCreatePayPalOrderRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePayPalPurchaseUnit(): PayPalPurchaseUnit {
  return {
    referenceId: undefined,
    amount: 0,
    currency: "",
    description: undefined,
    customId: undefined,
    invoiceId: undefined,
  };
}

export const PayPalPurchaseUnit: MessageFns<PayPalPurchaseUnit> = {
  encode(message: PayPalPurchaseUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.customId !== undefined) {
      writer.uint32(42).string(message.customId);
    }
    if (message.invoiceId !== undefined) {
      writer.uint32(50).string(message.invoiceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalPurchaseUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalPurchaseUnit {
    return {
      referenceId: isSet(object.referenceId)
        ? globalThis.String(object.referenceId)
        : isSet(object.reference_id)
        ? globalThis.String(object.reference_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      customId: isSet(object.customId)
        ? globalThis.String(object.customId)
        : isSet(object.custom_id)
        ? globalThis.String(object.custom_id)
        : undefined,
      invoiceId: isSet(object.invoiceId)
        ? globalThis.String(object.invoiceId)
        : isSet(object.invoice_id)
        ? globalThis.String(object.invoice_id)
        : undefined,
    };
  },

  toJSON(message: PayPalPurchaseUnit): unknown {
    const obj: any = {};
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.customId !== undefined) {
      obj.customId = message.customId;
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = message.invoiceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalPurchaseUnit>, I>>(base?: I): PayPalPurchaseUnit {
    return PayPalPurchaseUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalPurchaseUnit>, I>>(object: I): PayPalPurchaseUnit {
    const message = createBasePayPalPurchaseUnit();
    message.referenceId = object.referenceId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.customId = object.customId ?? undefined;
    message.invoiceId = object.invoiceId ?? undefined;
    return message;
  },
};

function createBasePayPalOrderResponse(): PayPalOrderResponse {
  return { id: "", status: "", approveUrl: undefined, captureUrl: undefined, links: [] };
}

export const PayPalOrderResponse: MessageFns<PayPalOrderResponse> = {
  encode(message: PayPalOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.approveUrl !== undefined) {
      writer.uint32(26).string(message.approveUrl);
    }
    if (message.captureUrl !== undefined) {
      writer.uint32(34).string(message.captureUrl);
    }
    for (const v of message.links) {
      PayPalLink.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.approveUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.captureUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.links.push(PayPalLink.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalOrderResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      approveUrl: isSet(object.approveUrl)
        ? globalThis.String(object.approveUrl)
        : isSet(object.approve_url)
        ? globalThis.String(object.approve_url)
        : undefined,
      captureUrl: isSet(object.captureUrl)
        ? globalThis.String(object.captureUrl)
        : isSet(object.capture_url)
        ? globalThis.String(object.capture_url)
        : undefined,
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => PayPalLink.fromJSON(e)) : [],
    };
  },

  toJSON(message: PayPalOrderResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.approveUrl !== undefined) {
      obj.approveUrl = message.approveUrl;
    }
    if (message.captureUrl !== undefined) {
      obj.captureUrl = message.captureUrl;
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => PayPalLink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalOrderResponse>, I>>(base?: I): PayPalOrderResponse {
    return PayPalOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalOrderResponse>, I>>(object: I): PayPalOrderResponse {
    const message = createBasePayPalOrderResponse();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.approveUrl = object.approveUrl ?? undefined;
    message.captureUrl = object.captureUrl ?? undefined;
    message.links = object.links?.map((e) => PayPalLink.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalLink(): PayPalLink {
  return { href: "", rel: "", method: "" };
}

export const PayPalLink: MessageFns<PayPalLink> = {
  encode(message: PayPalLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.href !== "") {
      writer.uint32(10).string(message.href);
    }
    if (message.rel !== "") {
      writer.uint32(18).string(message.rel);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.href = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalLink {
    return {
      href: isSet(object.href) ? globalThis.String(object.href) : "",
      rel: isSet(object.rel) ? globalThis.String(object.rel) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
    };
  },

  toJSON(message: PayPalLink): unknown {
    const obj: any = {};
    if (message.href !== "") {
      obj.href = message.href;
    }
    if (message.rel !== "") {
      obj.rel = message.rel;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalLink>, I>>(base?: I): PayPalLink {
    return PayPalLink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalLink>, I>>(object: I): PayPalLink {
    const message = createBasePayPalLink();
    message.href = object.href ?? "";
    message.rel = object.rel ?? "";
    message.method = object.method ?? "";
    return message;
  },
};

function createBaseGetPayPalOrderRequest(): GetPayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const GetPayPalOrderRequest: MessageFns<GetPayPalOrderRequest> = {
  encode(message: GetPayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPayPalOrderRequest {
    return {
      orderId: isSet(object.orderId)
        ? globalThis.String(object.orderId)
        : isSet(object.order_id)
        ? globalThis.String(object.order_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetPayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPayPalOrderRequest>, I>>(base?: I): GetPayPalOrderRequest {
    return GetPayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPayPalOrderRequest>, I>>(object: I): GetPayPalOrderRequest {
    const message = createBaseGetPayPalOrderRequest();
    message.orderId = object.orderId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCapturePayPalOrderRequest(): CapturePayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const CapturePayPalOrderRequest: MessageFns<CapturePayPalOrderRequest> = {
  encode(message: CapturePayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapturePayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapturePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapturePayPalOrderRequest {
    return {
      orderId: isSet(object.orderId)
        ? globalThis.String(object.orderId)
        : isSet(object.order_id)
        ? globalThis.String(object.order_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: CapturePayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CapturePayPalOrderRequest>, I>>(base?: I): CapturePayPalOrderRequest {
    return CapturePayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CapturePayPalOrderRequest>, I>>(object: I): CapturePayPalOrderRequest {
    const message = createBaseCapturePayPalOrderRequest();
    message.orderId = object.orderId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBasePayPalCaptureResponse(): PayPalCaptureResponse {
  return { id: "", status: "", payer: undefined, purchaseUnits: [] };
}

export const PayPalCaptureResponse: MessageFns<PayPalCaptureResponse> = {
  encode(message: PayPalCaptureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.payer !== undefined) {
      PayPalPayer.encode(message.payer, writer.uint32(26).fork()).join();
    }
    for (const v of message.purchaseUnits) {
      PayPalCapturedPurchaseUnit.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCaptureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCaptureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payer = PayPalPayer.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.purchaseUnits.push(PayPalCapturedPurchaseUnit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCaptureResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      payer: isSet(object.payer) ? PayPalPayer.fromJSON(object.payer) : undefined,
      purchaseUnits: globalThis.Array.isArray(object?.purchaseUnits)
        ? object.purchaseUnits.map((e: any) => PayPalCapturedPurchaseUnit.fromJSON(e))
        : globalThis.Array.isArray(object?.purchase_units)
        ? object.purchase_units.map((e: any) => PayPalCapturedPurchaseUnit.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PayPalCaptureResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.payer !== undefined) {
      obj.payer = PayPalPayer.toJSON(message.payer);
    }
    if (message.purchaseUnits?.length) {
      obj.purchaseUnits = message.purchaseUnits.map((e) => PayPalCapturedPurchaseUnit.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCaptureResponse>, I>>(base?: I): PayPalCaptureResponse {
    return PayPalCaptureResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCaptureResponse>, I>>(object: I): PayPalCaptureResponse {
    const message = createBasePayPalCaptureResponse();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.payer = (object.payer !== undefined && object.payer !== null)
      ? PayPalPayer.fromPartial(object.payer)
      : undefined;
    message.purchaseUnits = object.purchaseUnits?.map((e) => PayPalCapturedPurchaseUnit.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalPayer(): PayPalPayer {
  return { emailAddress: undefined, payerId: undefined, givenName: undefined, surname: undefined };
}

export const PayPalPayer: MessageFns<PayPalPayer> = {
  encode(message: PayPalPayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailAddress !== undefined) {
      writer.uint32(10).string(message.emailAddress);
    }
    if (message.payerId !== undefined) {
      writer.uint32(18).string(message.payerId);
    }
    if (message.givenName !== undefined) {
      writer.uint32(26).string(message.givenName);
    }
    if (message.surname !== undefined) {
      writer.uint32(34).string(message.surname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalPayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.givenName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.surname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalPayer {
    return {
      emailAddress: isSet(object.emailAddress)
        ? globalThis.String(object.emailAddress)
        : isSet(object.email_address)
        ? globalThis.String(object.email_address)
        : undefined,
      payerId: isSet(object.payerId)
        ? globalThis.String(object.payerId)
        : isSet(object.payer_id)
        ? globalThis.String(object.payer_id)
        : undefined,
      givenName: isSet(object.givenName)
        ? globalThis.String(object.givenName)
        : isSet(object.given_name)
        ? globalThis.String(object.given_name)
        : undefined,
      surname: isSet(object.surname) ? globalThis.String(object.surname) : undefined,
    };
  },

  toJSON(message: PayPalPayer): unknown {
    const obj: any = {};
    if (message.emailAddress !== undefined) {
      obj.emailAddress = message.emailAddress;
    }
    if (message.payerId !== undefined) {
      obj.payerId = message.payerId;
    }
    if (message.givenName !== undefined) {
      obj.givenName = message.givenName;
    }
    if (message.surname !== undefined) {
      obj.surname = message.surname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalPayer>, I>>(base?: I): PayPalPayer {
    return PayPalPayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalPayer>, I>>(object: I): PayPalPayer {
    const message = createBasePayPalPayer();
    message.emailAddress = object.emailAddress ?? undefined;
    message.payerId = object.payerId ?? undefined;
    message.givenName = object.givenName ?? undefined;
    message.surname = object.surname ?? undefined;
    return message;
  },
};

function createBasePayPalCapturedPurchaseUnit(): PayPalCapturedPurchaseUnit {
  return { referenceId: undefined, captures: [] };
}

export const PayPalCapturedPurchaseUnit: MessageFns<PayPalCapturedPurchaseUnit> = {
  encode(message: PayPalCapturedPurchaseUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    for (const v of message.captures) {
      PayPalCapture.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCapturedPurchaseUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapturedPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.captures.push(PayPalCapture.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCapturedPurchaseUnit {
    return {
      referenceId: isSet(object.referenceId)
        ? globalThis.String(object.referenceId)
        : isSet(object.reference_id)
        ? globalThis.String(object.reference_id)
        : undefined,
      captures: globalThis.Array.isArray(object?.captures)
        ? object.captures.map((e: any) => PayPalCapture.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PayPalCapturedPurchaseUnit): unknown {
    const obj: any = {};
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.captures?.length) {
      obj.captures = message.captures.map((e) => PayPalCapture.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCapturedPurchaseUnit>, I>>(base?: I): PayPalCapturedPurchaseUnit {
    return PayPalCapturedPurchaseUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCapturedPurchaseUnit>, I>>(object: I): PayPalCapturedPurchaseUnit {
    const message = createBasePayPalCapturedPurchaseUnit();
    message.referenceId = object.referenceId ?? undefined;
    message.captures = object.captures?.map((e) => PayPalCapture.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalCapture(): PayPalCapture {
  return { id: "", status: "", amount: undefined };
}

export const PayPalCapture: MessageFns<PayPalCapture> = {
  encode(message: PayPalCapture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.amount !== undefined) {
      PayPalAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCapture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = PayPalAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCapture {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      amount: isSet(object.amount) ? PayPalAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: PayPalCapture): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.amount !== undefined) {
      obj.amount = PayPalAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCapture>, I>>(base?: I): PayPalCapture {
    return PayPalCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCapture>, I>>(object: I): PayPalCapture {
    const message = createBasePayPalCapture();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? PayPalAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBasePayPalAmount(): PayPalAmount {
  return { currencyCode: "", value: "" };
}

export const PayPalAmount: MessageFns<PayPalAmount> = {
  encode(message: PayPalAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalAmount {
    return {
      currencyCode: isSet(object.currencyCode)
        ? globalThis.String(object.currencyCode)
        : isSet(object.currency_code)
        ? globalThis.String(object.currency_code)
        : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PayPalAmount): unknown {
    const obj: any = {};
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalAmount>, I>>(base?: I): PayPalAmount {
    return PayPalAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalAmount>, I>>(object: I): PayPalAmount {
    const message = createBasePayPalAmount();
    message.currencyCode = object.currencyCode ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetupGoCardlessMandateRequest(): SetupGoCardlessMandateRequest {
  return {
    clientId: "",
    societeId: "",
    scheme: "",
    description: undefined,
    successRedirectUrl: "",
    sessionToken: undefined,
  };
}

export const SetupGoCardlessMandateRequest: MessageFns<SetupGoCardlessMandateRequest> = {
  encode(message: SetupGoCardlessMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheme !== "") {
      writer.uint32(26).string(message.scheme);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.successRedirectUrl !== "") {
      writer.uint32(42).string(message.successRedirectUrl);
    }
    if (message.sessionToken !== undefined) {
      writer.uint32(50).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupGoCardlessMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.successRedirectUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupGoCardlessMandateRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      successRedirectUrl: isSet(object.successRedirectUrl)
        ? globalThis.String(object.successRedirectUrl)
        : isSet(object.success_redirect_url)
        ? globalThis.String(object.success_redirect_url)
        : "",
      sessionToken: isSet(object.sessionToken)
        ? globalThis.String(object.sessionToken)
        : isSet(object.session_token)
        ? globalThis.String(object.session_token)
        : undefined,
    };
  },

  toJSON(message: SetupGoCardlessMandateRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.successRedirectUrl !== "") {
      obj.successRedirectUrl = message.successRedirectUrl;
    }
    if (message.sessionToken !== undefined) {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetupGoCardlessMandateRequest>, I>>(base?: I): SetupGoCardlessMandateRequest {
    return SetupGoCardlessMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetupGoCardlessMandateRequest>, I>>(
    object: I,
  ): SetupGoCardlessMandateRequest {
    const message = createBaseSetupGoCardlessMandateRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheme = object.scheme ?? "";
    message.description = object.description ?? undefined;
    message.successRedirectUrl = object.successRedirectUrl ?? "";
    message.sessionToken = object.sessionToken ?? undefined;
    return message;
  },
};

function createBaseGoCardlessMandateResponse(): GoCardlessMandateResponse {
  return {
    id: "",
    clientId: "",
    mandateId: "",
    status: "",
    scheme: "",
    bankName: undefined,
    accountHolderName: undefined,
    accountNumberEnding: undefined,
    redirectUrl: undefined,
  };
}

export const GoCardlessMandateResponse: MessageFns<GoCardlessMandateResponse> = {
  encode(message: GoCardlessMandateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.mandateId !== "") {
      writer.uint32(26).string(message.mandateId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.scheme !== "") {
      writer.uint32(42).string(message.scheme);
    }
    if (message.bankName !== undefined) {
      writer.uint32(50).string(message.bankName);
    }
    if (message.accountHolderName !== undefined) {
      writer.uint32(58).string(message.accountHolderName);
    }
    if (message.accountNumberEnding !== undefined) {
      writer.uint32(66).string(message.accountNumberEnding);
    }
    if (message.redirectUrl !== undefined) {
      writer.uint32(74).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessMandateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessMandateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accountHolderName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.accountNumberEnding = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessMandateResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      bankName: isSet(object.bankName)
        ? globalThis.String(object.bankName)
        : isSet(object.bank_name)
        ? globalThis.String(object.bank_name)
        : undefined,
      accountHolderName: isSet(object.accountHolderName)
        ? globalThis.String(object.accountHolderName)
        : isSet(object.account_holder_name)
        ? globalThis.String(object.account_holder_name)
        : undefined,
      accountNumberEnding: isSet(object.accountNumberEnding)
        ? globalThis.String(object.accountNumberEnding)
        : isSet(object.account_number_ending)
        ? globalThis.String(object.account_number_ending)
        : undefined,
      redirectUrl: isSet(object.redirectUrl)
        ? globalThis.String(object.redirectUrl)
        : isSet(object.redirect_url)
        ? globalThis.String(object.redirect_url)
        : undefined,
    };
  },

  toJSON(message: GoCardlessMandateResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.bankName !== undefined) {
      obj.bankName = message.bankName;
    }
    if (message.accountHolderName !== undefined) {
      obj.accountHolderName = message.accountHolderName;
    }
    if (message.accountNumberEnding !== undefined) {
      obj.accountNumberEnding = message.accountNumberEnding;
    }
    if (message.redirectUrl !== undefined) {
      obj.redirectUrl = message.redirectUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessMandateResponse>, I>>(base?: I): GoCardlessMandateResponse {
    return GoCardlessMandateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessMandateResponse>, I>>(object: I): GoCardlessMandateResponse {
    const message = createBaseGoCardlessMandateResponse();
    message.id = object.id ?? "";
    message.clientId = object.clientId ?? "";
    message.mandateId = object.mandateId ?? "";
    message.status = object.status ?? "";
    message.scheme = object.scheme ?? "";
    message.bankName = object.bankName ?? undefined;
    message.accountHolderName = object.accountHolderName ?? undefined;
    message.accountNumberEnding = object.accountNumberEnding ?? undefined;
    message.redirectUrl = object.redirectUrl ?? undefined;
    return message;
  },
};

function createBaseGetGoCardlessMandateRequest(): GetGoCardlessMandateRequest {
  return { clientId: "", societeId: "" };
}

export const GetGoCardlessMandateRequest: MessageFns<GetGoCardlessMandateRequest> = {
  encode(message: GetGoCardlessMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGoCardlessMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGoCardlessMandateRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetGoCardlessMandateRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGoCardlessMandateRequest>, I>>(base?: I): GetGoCardlessMandateRequest {
    return GetGoCardlessMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGoCardlessMandateRequest>, I>>(object: I): GetGoCardlessMandateRequest {
    const message = createBaseGetGoCardlessMandateRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest(): CreateGoCardlessPaymentRequest {
  return {
    clientId: "",
    societeId: "",
    amount: 0,
    currency: "",
    description: undefined,
    chargeDate: undefined,
    metadata: {},
  };
}

export const CreateGoCardlessPaymentRequest: MessageFns<CreateGoCardlessPaymentRequest> = {
  encode(message: CreateGoCardlessPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateGoCardlessPaymentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = CreateGoCardlessPaymentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessPaymentRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      chargeDate: isSet(object.chargeDate)
        ? globalThis.String(object.chargeDate)
        : isSet(object.charge_date)
        ? globalThis.String(object.charge_date)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateGoCardlessPaymentRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.chargeDate !== undefined) {
      obj.chargeDate = message.chargeDate;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest>, I>>(base?: I): CreateGoCardlessPaymentRequest {
    return CreateGoCardlessPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest>, I>>(
    object: I,
  ): CreateGoCardlessPaymentRequest {
    const message = createBaseCreateGoCardlessPaymentRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.chargeDate = object.chargeDate ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest_MetadataEntry(): CreateGoCardlessPaymentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessPaymentRequest_MetadataEntry: MessageFns<CreateGoCardlessPaymentRequest_MetadataEntry> = {
  encode(
    message: CreateGoCardlessPaymentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessPaymentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateGoCardlessPaymentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateGoCardlessPaymentRequest_MetadataEntry {
    return CreateGoCardlessPaymentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateGoCardlessPaymentRequest_MetadataEntry {
    const message = createBaseCreateGoCardlessPaymentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGoCardlessPaymentResponse(): GoCardlessPaymentResponse {
  return { id: "", paymentId: "", amount: 0, currency: "", status: "", chargeDate: undefined };
}

export const GoCardlessPaymentResponse: MessageFns<GoCardlessPaymentResponse> = {
  encode(message: GoCardlessPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessPaymentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      chargeDate: isSet(object.chargeDate)
        ? globalThis.String(object.chargeDate)
        : isSet(object.charge_date)
        ? globalThis.String(object.charge_date)
        : undefined,
    };
  },

  toJSON(message: GoCardlessPaymentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.chargeDate !== undefined) {
      obj.chargeDate = message.chargeDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessPaymentResponse>, I>>(base?: I): GoCardlessPaymentResponse {
    return GoCardlessPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessPaymentResponse>, I>>(object: I): GoCardlessPaymentResponse {
    const message = createBaseGoCardlessPaymentResponse();
    message.id = object.id ?? "";
    message.paymentId = object.paymentId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.chargeDate = object.chargeDate ?? undefined;
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest(): CreateGoCardlessSubscriptionRequest {
  return {
    clientId: "",
    societeId: "",
    amount: 0,
    currency: "",
    intervalUnit: "",
    interval: 0,
    name: undefined,
    startDate: undefined,
    count: undefined,
    metadata: {},
  };
}

export const CreateGoCardlessSubscriptionRequest: MessageFns<CreateGoCardlessSubscriptionRequest> = {
  encode(message: CreateGoCardlessSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(42).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(48).int32(message.interval);
    }
    if (message.name !== undefined) {
      writer.uint32(58).string(message.name);
    }
    if (message.startDate !== undefined) {
      writer.uint32(66).string(message.startDate);
    }
    if (message.count !== undefined) {
      writer.uint32(72).int32(message.count);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateGoCardlessSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.interval = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateGoCardlessSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessSubscriptionRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      intervalUnit: isSet(object.intervalUnit)
        ? globalThis.String(object.intervalUnit)
        : isSet(object.interval_unit)
        ? globalThis.String(object.interval_unit)
        : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : undefined,
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateGoCardlessSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.intervalUnit !== "") {
      obj.intervalUnit = message.intervalUnit;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest>, I>>(
    base?: I,
  ): CreateGoCardlessSubscriptionRequest {
    return CreateGoCardlessSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest>, I>>(
    object: I,
  ): CreateGoCardlessSubscriptionRequest {
    const message = createBaseCreateGoCardlessSubscriptionRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.intervalUnit = object.intervalUnit ?? "";
    message.interval = object.interval ?? 0;
    message.name = object.name ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.count = object.count ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry(): CreateGoCardlessSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessSubscriptionRequest_MetadataEntry: MessageFns<
  CreateGoCardlessSubscriptionRequest_MetadataEntry
> = {
  encode(
    message: CreateGoCardlessSubscriptionRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateGoCardlessSubscriptionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    return CreateGoCardlessSubscriptionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    const message = createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGoCardlessSubscriptionResponse(): GoCardlessSubscriptionResponse {
  return {
    id: "",
    subscriptionId: "",
    amount: 0,
    currency: "",
    status: "",
    intervalUnit: "",
    interval: 0,
    nextPaymentDate: undefined,
  };
}

export const GoCardlessSubscriptionResponse: MessageFns<GoCardlessSubscriptionResponse> = {
  encode(message: GoCardlessSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(50).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(56).int32(message.interval);
    }
    if (message.nextPaymentDate !== undefined) {
      writer.uint32(66).string(message.nextPaymentDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.interval = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nextPaymentDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessSubscriptionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      intervalUnit: isSet(object.intervalUnit)
        ? globalThis.String(object.intervalUnit)
        : isSet(object.interval_unit)
        ? globalThis.String(object.interval_unit)
        : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      nextPaymentDate: isSet(object.nextPaymentDate)
        ? globalThis.String(object.nextPaymentDate)
        : isSet(object.next_payment_date)
        ? globalThis.String(object.next_payment_date)
        : undefined,
    };
  },

  toJSON(message: GoCardlessSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.intervalUnit !== "") {
      obj.intervalUnit = message.intervalUnit;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.nextPaymentDate !== undefined) {
      obj.nextPaymentDate = message.nextPaymentDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessSubscriptionResponse>, I>>(base?: I): GoCardlessSubscriptionResponse {
    return GoCardlessSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessSubscriptionResponse>, I>>(
    object: I,
  ): GoCardlessSubscriptionResponse {
    const message = createBaseGoCardlessSubscriptionResponse();
    message.id = object.id ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.intervalUnit = object.intervalUnit ?? "";
    message.interval = object.interval ?? 0;
    message.nextPaymentDate = object.nextPaymentDate ?? undefined;
    return message;
  },
};

function createBaseCancelGoCardlessSubscriptionRequest(): CancelGoCardlessSubscriptionRequest {
  return { subscriptionId: "", societeId: "" };
}

export const CancelGoCardlessSubscriptionRequest: MessageFns<CancelGoCardlessSubscriptionRequest> = {
  encode(message: CancelGoCardlessSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelGoCardlessSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelGoCardlessSubscriptionRequest {
    return {
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: CancelGoCardlessSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelGoCardlessSubscriptionRequest>, I>>(
    base?: I,
  ): CancelGoCardlessSubscriptionRequest {
    return CancelGoCardlessSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelGoCardlessSubscriptionRequest>, I>>(
    object: I,
  ): CancelGoCardlessSubscriptionRequest {
    const message = createBaseCancelGoCardlessSubscriptionRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateScheduleRequest(): CreateScheduleRequest {
  return {
    organisationId: "",
    societeId: "",
    contratId: undefined,
    factureId: undefined,
    clientId: undefined,
    amount: 0,
    currency: "",
    dueDate: "",
    description: undefined,
    autoProcess: false,
    metadata: {},
  };
}

export const CreateScheduleRequest: MessageFns<CreateScheduleRequest> = {
  encode(message: CreateScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(26).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(34).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(42).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(48).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(66).string(message.dueDate);
    }
    if (message.description !== undefined) {
      writer.uint32(74).string(message.description);
    }
    if (message.autoProcess !== false) {
      writer.uint32(80).bool(message.autoProcess);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateScheduleRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = CreateScheduleRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.metadata[entry11.key] = entry11.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateScheduleRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : undefined,
      factureId: isSet(object.factureId)
        ? globalThis.String(object.factureId)
        : isSet(object.facture_id)
        ? globalThis.String(object.facture_id)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      dueDate: isSet(object.dueDate)
        ? globalThis.String(object.dueDate)
        : isSet(object.due_date)
        ? globalThis.String(object.due_date)
        : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      autoProcess: isSet(object.autoProcess)
        ? globalThis.Boolean(object.autoProcess)
        : isSet(object.auto_process)
        ? globalThis.Boolean(object.auto_process)
        : false,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateScheduleRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.dueDate !== "") {
      obj.dueDate = message.dueDate;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.autoProcess !== false) {
      obj.autoProcess = message.autoProcess;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateScheduleRequest>, I>>(base?: I): CreateScheduleRequest {
    return CreateScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateScheduleRequest>, I>>(object: I): CreateScheduleRequest {
    const message = createBaseCreateScheduleRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.contratId = object.contratId ?? undefined;
    message.factureId = object.factureId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.dueDate = object.dueDate ?? "";
    message.description = object.description ?? undefined;
    message.autoProcess = object.autoProcess ?? false;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateScheduleRequest_MetadataEntry(): CreateScheduleRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateScheduleRequest_MetadataEntry: MessageFns<CreateScheduleRequest_MetadataEntry> = {
  encode(message: CreateScheduleRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateScheduleRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateScheduleRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateScheduleRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateScheduleRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateScheduleRequest_MetadataEntry {
    return CreateScheduleRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateScheduleRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateScheduleRequest_MetadataEntry {
    const message = createBaseCreateScheduleRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseScheduleResponse(): ScheduleResponse {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    contratId: undefined,
    factureId: undefined,
    clientId: undefined,
    amount: 0,
    currency: "",
    dueDate: "",
    status: "",
    lastAttemptAt: undefined,
    paidAt: undefined,
    retryCount: 0,
    errorMessage: undefined,
  };
}

export const ScheduleResponse: MessageFns<ScheduleResponse> = {
  encode(message: ScheduleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(42).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(50).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(74).string(message.dueDate);
    }
    if (message.status !== "") {
      writer.uint32(82).string(message.status);
    }
    if (message.lastAttemptAt !== undefined) {
      writer.uint32(90).string(message.lastAttemptAt);
    }
    if (message.paidAt !== undefined) {
      writer.uint32(98).string(message.paidAt);
    }
    if (message.retryCount !== 0) {
      writer.uint32(104).int32(message.retryCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(114).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lastAttemptAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.paidAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : undefined,
      factureId: isSet(object.factureId)
        ? globalThis.String(object.factureId)
        : isSet(object.facture_id)
        ? globalThis.String(object.facture_id)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      dueDate: isSet(object.dueDate)
        ? globalThis.String(object.dueDate)
        : isSet(object.due_date)
        ? globalThis.String(object.due_date)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      lastAttemptAt: isSet(object.lastAttemptAt)
        ? globalThis.String(object.lastAttemptAt)
        : isSet(object.last_attempt_at)
        ? globalThis.String(object.last_attempt_at)
        : undefined,
      paidAt: isSet(object.paidAt)
        ? globalThis.String(object.paidAt)
        : isSet(object.paid_at)
        ? globalThis.String(object.paid_at)
        : undefined,
      retryCount: isSet(object.retryCount)
        ? globalThis.Number(object.retryCount)
        : isSet(object.retry_count)
        ? globalThis.Number(object.retry_count)
        : 0,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: ScheduleResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.dueDate !== "") {
      obj.dueDate = message.dueDate;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.lastAttemptAt !== undefined) {
      obj.lastAttemptAt = message.lastAttemptAt;
    }
    if (message.paidAt !== undefined) {
      obj.paidAt = message.paidAt;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleResponse>, I>>(base?: I): ScheduleResponse {
    return ScheduleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleResponse>, I>>(object: I): ScheduleResponse {
    const message = createBaseScheduleResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.contratId = object.contratId ?? undefined;
    message.factureId = object.factureId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.dueDate = object.dueDate ?? "";
    message.status = object.status ?? "";
    message.lastAttemptAt = object.lastAttemptAt ?? undefined;
    message.paidAt = object.paidAt ?? undefined;
    message.retryCount = object.retryCount ?? 0;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseUpdateScheduleRequest(): UpdateScheduleRequest {
  return { id: "", amount: undefined, dueDate: undefined, status: undefined, autoProcess: undefined };
}

export const UpdateScheduleRequest: MessageFns<UpdateScheduleRequest> = {
  encode(message: UpdateScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== undefined) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.dueDate !== undefined) {
      writer.uint32(26).string(message.dueDate);
    }
    if (message.status !== undefined) {
      writer.uint32(34).string(message.status);
    }
    if (message.autoProcess !== undefined) {
      writer.uint32(40).bool(message.autoProcess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
      dueDate: isSet(object.dueDate)
        ? globalThis.String(object.dueDate)
        : isSet(object.due_date)
        ? globalThis.String(object.due_date)
        : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      autoProcess: isSet(object.autoProcess)
        ? globalThis.Boolean(object.autoProcess)
        : isSet(object.auto_process)
        ? globalThis.Boolean(object.auto_process)
        : undefined,
    };
  },

  toJSON(message: UpdateScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.autoProcess !== undefined) {
      obj.autoProcess = message.autoProcess;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateScheduleRequest>, I>>(base?: I): UpdateScheduleRequest {
    return UpdateScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateScheduleRequest>, I>>(object: I): UpdateScheduleRequest {
    const message = createBaseUpdateScheduleRequest();
    message.id = object.id ?? "";
    message.amount = object.amount ?? undefined;
    message.dueDate = object.dueDate ?? undefined;
    message.status = object.status ?? undefined;
    message.autoProcess = object.autoProcess ?? undefined;
    return message;
  },
};

function createBaseGetDueSchedulesRequest(): GetDueSchedulesRequest {
  return { organisationId: "", beforeDate: undefined };
}

export const GetDueSchedulesRequest: MessageFns<GetDueSchedulesRequest> = {
  encode(message: GetDueSchedulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.beforeDate !== undefined) {
      writer.uint32(18).string(message.beforeDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDueSchedulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDueSchedulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDueSchedulesRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      beforeDate: isSet(object.beforeDate)
        ? globalThis.String(object.beforeDate)
        : isSet(object.before_date)
        ? globalThis.String(object.before_date)
        : undefined,
    };
  },

  toJSON(message: GetDueSchedulesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.beforeDate !== undefined) {
      obj.beforeDate = message.beforeDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDueSchedulesRequest>, I>>(base?: I): GetDueSchedulesRequest {
    return GetDueSchedulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDueSchedulesRequest>, I>>(object: I): GetDueSchedulesRequest {
    const message = createBaseGetDueSchedulesRequest();
    message.organisationId = object.organisationId ?? "";
    message.beforeDate = object.beforeDate ?? undefined;
    return message;
  },
};

function createBaseScheduleListResponse(): ScheduleListResponse {
  return { schedules: [], total: 0 };
}

export const ScheduleListResponse: MessageFns<ScheduleListResponse> = {
  encode(message: ScheduleListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schedules) {
      ScheduleResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedules.push(ScheduleResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleListResponse {
    return {
      schedules: globalThis.Array.isArray(object?.schedules)
        ? object.schedules.map((e: any) => ScheduleResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ScheduleListResponse): unknown {
    const obj: any = {};
    if (message.schedules?.length) {
      obj.schedules = message.schedules.map((e) => ScheduleResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleListResponse>, I>>(base?: I): ScheduleListResponse {
    return ScheduleListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleListResponse>, I>>(object: I): ScheduleListResponse {
    const message = createBaseScheduleListResponse();
    message.schedules = object.schedules?.map((e) => ScheduleResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseProcessDuePaymentsRequest(): ProcessDuePaymentsRequest {
  return { organisationId: "", dryRun: undefined };
}

export const ProcessDuePaymentsRequest: MessageFns<ProcessDuePaymentsRequest> = {
  encode(message: ProcessDuePaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.dryRun !== undefined) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDuePaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDuePaymentsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : undefined,
    };
  },

  toJSON(message: ProcessDuePaymentsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.dryRun !== undefined) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDuePaymentsRequest>, I>>(base?: I): ProcessDuePaymentsRequest {
    return ProcessDuePaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDuePaymentsRequest>, I>>(object: I): ProcessDuePaymentsRequest {
    const message = createBaseProcessDuePaymentsRequest();
    message.organisationId = object.organisationId ?? "";
    message.dryRun = object.dryRun ?? undefined;
    return message;
  },
};

function createBaseProcessDuePaymentsResponse(): ProcessDuePaymentsResponse {
  return { processedCount: 0, successCount: 0, failedCount: 0, results: [] };
}

export const ProcessDuePaymentsResponse: MessageFns<ProcessDuePaymentsResponse> = {
  encode(message: ProcessDuePaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processedCount !== 0) {
      writer.uint32(8).int32(message.processedCount);
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(24).int32(message.failedCount);
    }
    for (const v of message.results) {
      ProcessedPayment.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDuePaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processedCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.results.push(ProcessedPayment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDuePaymentsResponse {
    return {
      processedCount: isSet(object.processedCount)
        ? globalThis.Number(object.processedCount)
        : isSet(object.processed_count)
        ? globalThis.Number(object.processed_count)
        : 0,
      successCount: isSet(object.successCount)
        ? globalThis.Number(object.successCount)
        : isSet(object.success_count)
        ? globalThis.Number(object.success_count)
        : 0,
      failedCount: isSet(object.failedCount)
        ? globalThis.Number(object.failedCount)
        : isSet(object.failed_count)
        ? globalThis.Number(object.failed_count)
        : 0,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ProcessedPayment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessDuePaymentsResponse): unknown {
    const obj: any = {};
    if (message.processedCount !== 0) {
      obj.processedCount = Math.round(message.processedCount);
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => ProcessedPayment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDuePaymentsResponse>, I>>(base?: I): ProcessDuePaymentsResponse {
    return ProcessDuePaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDuePaymentsResponse>, I>>(object: I): ProcessDuePaymentsResponse {
    const message = createBaseProcessDuePaymentsResponse();
    message.processedCount = object.processedCount ?? 0;
    message.successCount = object.successCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    message.results = object.results?.map((e) => ProcessedPayment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessedPayment(): ProcessedPayment {
  return { scheduleId: "", success: false, paymentId: undefined, error: undefined };
}

export const ProcessedPayment: MessageFns<ProcessedPayment> = {
  encode(message: ProcessedPayment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduleId !== "") {
      writer.uint32(10).string(message.scheduleId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.paymentId !== undefined) {
      writer.uint32(26).string(message.paymentId);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessedPayment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessedPayment {
    return {
      scheduleId: isSet(object.scheduleId)
        ? globalThis.String(object.scheduleId)
        : isSet(object.schedule_id)
        ? globalThis.String(object.schedule_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: ProcessedPayment): unknown {
    const obj: any = {};
    if (message.scheduleId !== "") {
      obj.scheduleId = message.scheduleId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.paymentId !== undefined) {
      obj.paymentId = message.paymentId;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessedPayment>, I>>(base?: I): ProcessedPayment {
    return ProcessedPayment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessedPayment>, I>>(object: I): ProcessedPayment {
    const message = createBaseProcessedPayment();
    message.scheduleId = object.scheduleId ?? "";
    message.success = object.success ?? false;
    message.paymentId = object.paymentId ?? undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseRenewScheduleRequest(): RenewScheduleRequest {
  return { id: "", newDueDate: "", newAmount: undefined };
}

export const RenewScheduleRequest: MessageFns<RenewScheduleRequest> = {
  encode(message: RenewScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newDueDate !== "") {
      writer.uint32(18).string(message.newDueDate);
    }
    if (message.newAmount !== undefined) {
      writer.uint32(24).int64(message.newAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newDueDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newAmount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      newDueDate: isSet(object.newDueDate)
        ? globalThis.String(object.newDueDate)
        : isSet(object.new_due_date)
        ? globalThis.String(object.new_due_date)
        : "",
      newAmount: isSet(object.newAmount)
        ? globalThis.Number(object.newAmount)
        : isSet(object.new_amount)
        ? globalThis.Number(object.new_amount)
        : undefined,
    };
  },

  toJSON(message: RenewScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.newDueDate !== "") {
      obj.newDueDate = message.newDueDate;
    }
    if (message.newAmount !== undefined) {
      obj.newAmount = Math.round(message.newAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenewScheduleRequest>, I>>(base?: I): RenewScheduleRequest {
    return RenewScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenewScheduleRequest>, I>>(object: I): RenewScheduleRequest {
    const message = createBaseRenewScheduleRequest();
    message.id = object.id ?? "";
    message.newDueDate = object.newDueDate ?? "";
    message.newAmount = object.newAmount ?? undefined;
    return message;
  },
};

function createBaseCreatePaymentIntentRequest(): CreatePaymentIntentRequest {
  return {
    organisationId: "",
    societeId: "",
    scheduleId: undefined,
    pspName: "",
    amount: 0,
    currency: "",
    mandateReference: undefined,
    idempotencyKey: undefined,
    metadata: {},
  };
}

export const CreatePaymentIntentRequest: MessageFns<CreatePaymentIntentRequest> = {
  encode(message: CreatePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(26).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(34).string(message.pspName);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(58).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(66).string(message.idempotencyKey);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pspName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CreatePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentIntentRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scheduleId: isSet(object.scheduleId)
        ? globalThis.String(object.scheduleId)
        : isSet(object.schedule_id)
        ? globalThis.String(object.schedule_id)
        : undefined,
      pspName: isSet(object.pspName)
        ? globalThis.String(object.pspName)
        : isSet(object.psp_name)
        ? globalThis.String(object.psp_name)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      mandateReference: isSet(object.mandateReference)
        ? globalThis.String(object.mandateReference)
        : isSet(object.mandate_reference)
        ? globalThis.String(object.mandate_reference)
        : undefined,
      idempotencyKey: isSet(object.idempotencyKey)
        ? globalThis.String(object.idempotencyKey)
        : isSet(object.idempotency_key)
        ? globalThis.String(object.idempotency_key)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreatePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheduleId !== undefined) {
      obj.scheduleId = message.scheduleId;
    }
    if (message.pspName !== "") {
      obj.pspName = message.pspName;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = message.mandateReference;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentIntentRequest>, I>>(base?: I): CreatePaymentIntentRequest {
    return CreatePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentIntentRequest>, I>>(object: I): CreatePaymentIntentRequest {
    const message = createBaseCreatePaymentIntentRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheduleId = object.scheduleId ?? undefined;
    message.pspName = object.pspName ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.mandateReference = object.mandateReference ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePaymentIntentRequest_MetadataEntry(): CreatePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePaymentIntentRequest_MetadataEntry: MessageFns<CreatePaymentIntentRequest_MetadataEntry> = {
  encode(message: CreatePaymentIntentRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePaymentIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePaymentIntentRequest_MetadataEntry {
    return CreatePaymentIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePaymentIntentRequest_MetadataEntry {
    const message = createBaseCreatePaymentIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePaymentIntentResponse(): PaymentIntentResponse {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    scheduleId: undefined,
    pspName: "",
    pspPaymentId: undefined,
    amount: 0,
    currency: "",
    status: "",
    mandateReference: undefined,
    idempotencyKey: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const PaymentIntentResponse: MessageFns<PaymentIntentResponse> = {
  encode(message: PaymentIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(34).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(42).string(message.pspName);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(50).string(message.pspPaymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(82).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(90).string(message.idempotencyKey);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(98).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(106).string(message.errorMessage);
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(122).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pspName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      scheduleId: isSet(object.scheduleId)
        ? globalThis.String(object.scheduleId)
        : isSet(object.schedule_id)
        ? globalThis.String(object.schedule_id)
        : undefined,
      pspName: isSet(object.pspName)
        ? globalThis.String(object.pspName)
        : isSet(object.psp_name)
        ? globalThis.String(object.psp_name)
        : "",
      pspPaymentId: isSet(object.pspPaymentId)
        ? globalThis.String(object.pspPaymentId)
        : isSet(object.psp_payment_id)
        ? globalThis.String(object.psp_payment_id)
        : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      mandateReference: isSet(object.mandateReference)
        ? globalThis.String(object.mandateReference)
        : isSet(object.mandate_reference)
        ? globalThis.String(object.mandate_reference)
        : undefined,
      idempotencyKey: isSet(object.idempotencyKey)
        ? globalThis.String(object.idempotencyKey)
        : isSet(object.idempotency_key)
        ? globalThis.String(object.idempotency_key)
        : undefined,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : undefined,
    };
  },

  toJSON(message: PaymentIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheduleId !== undefined) {
      obj.scheduleId = message.scheduleId;
    }
    if (message.pspName !== "") {
      obj.pspName = message.pspName;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = message.mandateReference;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentIntentResponse>, I>>(base?: I): PaymentIntentResponse {
    return PaymentIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentIntentResponse>, I>>(object: I): PaymentIntentResponse {
    const message = createBasePaymentIntentResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheduleId = object.scheduleId ?? undefined;
    message.pspName = object.pspName ?? "";
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.mandateReference = object.mandateReference ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseUpdatePaymentIntentRequest(): UpdatePaymentIntentRequest {
  return { id: "", status: undefined, pspPaymentId: undefined, errorCode: undefined, errorMessage: undefined };
}

export const UpdatePaymentIntentRequest: MessageFns<UpdatePaymentIntentRequest> = {
  encode(message: UpdatePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      writer.uint32(18).string(message.status);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(26).string(message.pspPaymentId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePaymentIntentRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      pspPaymentId: isSet(object.pspPaymentId)
        ? globalThis.String(object.pspPaymentId)
        : isSet(object.psp_payment_id)
        ? globalThis.String(object.psp_payment_id)
        : undefined,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: UpdatePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePaymentIntentRequest>, I>>(base?: I): UpdatePaymentIntentRequest {
    return UpdatePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePaymentIntentRequest>, I>>(object: I): UpdatePaymentIntentRequest {
    const message = createBaseUpdatePaymentIntentRequest();
    message.id = object.id ?? "";
    message.status = object.status ?? undefined;
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseCreatePaymentEventRequest(): CreatePaymentEventRequest {
  return { organisationId: "", paymentIntentId: "", eventType: "", rawPayload: "" };
}

export const CreatePaymentEventRequest: MessageFns<CreatePaymentEventRequest> = {
  encode(message: CreatePaymentEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(34).string(message.rawPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentEventRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      rawPayload: isSet(object.rawPayload)
        ? globalThis.String(object.rawPayload)
        : isSet(object.raw_payload)
        ? globalThis.String(object.raw_payload)
        : "",
    };
  },

  toJSON(message: CreatePaymentEventRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentEventRequest>, I>>(base?: I): CreatePaymentEventRequest {
    return CreatePaymentEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentEventRequest>, I>>(object: I): CreatePaymentEventRequest {
    const message = createBaseCreatePaymentEventRequest();
    message.organisationId = object.organisationId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.eventType = object.eventType ?? "";
    message.rawPayload = object.rawPayload ?? "";
    return message;
  },
};

function createBasePaymentEventResponse(): PaymentEventResponse {
  return {
    id: "",
    organisationId: "",
    paymentIntentId: "",
    eventType: "",
    rawPayload: "",
    receivedAt: "",
    processed: false,
    processedAt: undefined,
    errorMessage: undefined,
  };
}

export const PaymentEventResponse: MessageFns<PaymentEventResponse> = {
  encode(message: PaymentEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(26).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(34).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(42).string(message.rawPayload);
    }
    if (message.receivedAt !== "") {
      writer.uint32(50).string(message.receivedAt);
    }
    if (message.processed !== false) {
      writer.uint32(56).bool(message.processed);
    }
    if (message.processedAt !== undefined) {
      writer.uint32(66).string(message.processedAt);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentEventResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      rawPayload: isSet(object.rawPayload)
        ? globalThis.String(object.rawPayload)
        : isSet(object.raw_payload)
        ? globalThis.String(object.raw_payload)
        : "",
      receivedAt: isSet(object.receivedAt)
        ? globalThis.String(object.receivedAt)
        : isSet(object.received_at)
        ? globalThis.String(object.received_at)
        : "",
      processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false,
      processedAt: isSet(object.processedAt)
        ? globalThis.String(object.processedAt)
        : isSet(object.processed_at)
        ? globalThis.String(object.processed_at)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: PaymentEventResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    if (message.receivedAt !== "") {
      obj.receivedAt = message.receivedAt;
    }
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    if (message.processedAt !== undefined) {
      obj.processedAt = message.processedAt;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentEventResponse>, I>>(base?: I): PaymentEventResponse {
    return PaymentEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentEventResponse>, I>>(object: I): PaymentEventResponse {
    const message = createBasePaymentEventResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.eventType = object.eventType ?? "";
    message.rawPayload = object.rawPayload ?? "";
    message.receivedAt = object.receivedAt ?? "";
    message.processed = object.processed ?? false;
    message.processedAt = object.processedAt ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseGetUnprocessedEventsRequest(): GetUnprocessedEventsRequest {
  return { organisationId: "", limit: undefined };
}

export const GetUnprocessedEventsRequest: MessageFns<GetUnprocessedEventsRequest> = {
  encode(message: GetUnprocessedEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnprocessedEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnprocessedEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnprocessedEventsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: GetUnprocessedEventsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUnprocessedEventsRequest>, I>>(base?: I): GetUnprocessedEventsRequest {
    return GetUnprocessedEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUnprocessedEventsRequest>, I>>(object: I): GetUnprocessedEventsRequest {
    const message = createBaseGetUnprocessedEventsRequest();
    message.organisationId = object.organisationId ?? "";
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBasePaymentEventListResponse(): PaymentEventListResponse {
  return { events: [], total: 0 };
}

export const PaymentEventListResponse: MessageFns<PaymentEventListResponse> = {
  encode(message: PaymentEventListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      PaymentEventResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentEventListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(PaymentEventResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentEventListResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => PaymentEventResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: PaymentEventListResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => PaymentEventResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentEventListResponse>, I>>(base?: I): PaymentEventListResponse {
    return PaymentEventListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentEventListResponse>, I>>(object: I): PaymentEventListResponse {
    const message = createBasePaymentEventListResponse();
    message.events = object.events?.map((e) => PaymentEventResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseMarkEventProcessedRequest(): MarkEventProcessedRequest {
  return { id: "", errorMessage: undefined };
}

export const MarkEventProcessedRequest: MessageFns<MarkEventProcessedRequest> = {
  encode(message: MarkEventProcessedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkEventProcessedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkEventProcessedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkEventProcessedRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: MarkEventProcessedRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkEventProcessedRequest>, I>>(base?: I): MarkEventProcessedRequest {
    return MarkEventProcessedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkEventProcessedRequest>, I>>(object: I): MarkEventProcessedRequest {
    const message = createBaseMarkEventProcessedRequest();
    message.id = object.id ?? "";
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseGetPSPAccountsRequest(): GetPSPAccountsRequest {
  return { societeId: "" };
}

export const GetPSPAccountsRequest: MessageFns<GetPSPAccountsRequest> = {
  encode(message: GetPSPAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPSPAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPSPAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPSPAccountsRequest {
    return {
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
    };
  },

  toJSON(message: GetPSPAccountsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPSPAccountsRequest>, I>>(base?: I): GetPSPAccountsRequest {
    return GetPSPAccountsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPSPAccountsRequest>, I>>(object: I): GetPSPAccountsRequest {
    const message = createBaseGetPSPAccountsRequest();
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBasePSPAccountsSummaryResponse(): PSPAccountsSummaryResponse {
  return {
    stripe: undefined,
    paypal: undefined,
    gocardless: undefined,
    emerchantpay: undefined,
    slimpay: undefined,
    multisafepay: undefined,
  };
}

export const PSPAccountsSummaryResponse: MessageFns<PSPAccountsSummaryResponse> = {
  encode(message: PSPAccountsSummaryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stripe !== undefined) {
      PSPAccountInfo.encode(message.stripe, writer.uint32(10).fork()).join();
    }
    if (message.paypal !== undefined) {
      PSPAccountInfo.encode(message.paypal, writer.uint32(18).fork()).join();
    }
    if (message.gocardless !== undefined) {
      PSPAccountInfo.encode(message.gocardless, writer.uint32(26).fork()).join();
    }
    if (message.emerchantpay !== undefined) {
      PSPAccountInfo.encode(message.emerchantpay, writer.uint32(34).fork()).join();
    }
    if (message.slimpay !== undefined) {
      PSPAccountInfo.encode(message.slimpay, writer.uint32(42).fork()).join();
    }
    if (message.multisafepay !== undefined) {
      PSPAccountInfo.encode(message.multisafepay, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PSPAccountsSummaryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountsSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stripe = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paypal = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gocardless = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.emerchantpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.slimpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.multisafepay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PSPAccountsSummaryResponse {
    return {
      stripe: isSet(object.stripe) ? PSPAccountInfo.fromJSON(object.stripe) : undefined,
      paypal: isSet(object.paypal) ? PSPAccountInfo.fromJSON(object.paypal) : undefined,
      gocardless: isSet(object.gocardless) ? PSPAccountInfo.fromJSON(object.gocardless) : undefined,
      emerchantpay: isSet(object.emerchantpay) ? PSPAccountInfo.fromJSON(object.emerchantpay) : undefined,
      slimpay: isSet(object.slimpay) ? PSPAccountInfo.fromJSON(object.slimpay) : undefined,
      multisafepay: isSet(object.multisafepay) ? PSPAccountInfo.fromJSON(object.multisafepay) : undefined,
    };
  },

  toJSON(message: PSPAccountsSummaryResponse): unknown {
    const obj: any = {};
    if (message.stripe !== undefined) {
      obj.stripe = PSPAccountInfo.toJSON(message.stripe);
    }
    if (message.paypal !== undefined) {
      obj.paypal = PSPAccountInfo.toJSON(message.paypal);
    }
    if (message.gocardless !== undefined) {
      obj.gocardless = PSPAccountInfo.toJSON(message.gocardless);
    }
    if (message.emerchantpay !== undefined) {
      obj.emerchantpay = PSPAccountInfo.toJSON(message.emerchantpay);
    }
    if (message.slimpay !== undefined) {
      obj.slimpay = PSPAccountInfo.toJSON(message.slimpay);
    }
    if (message.multisafepay !== undefined) {
      obj.multisafepay = PSPAccountInfo.toJSON(message.multisafepay);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PSPAccountsSummaryResponse>, I>>(base?: I): PSPAccountsSummaryResponse {
    return PSPAccountsSummaryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PSPAccountsSummaryResponse>, I>>(object: I): PSPAccountsSummaryResponse {
    const message = createBasePSPAccountsSummaryResponse();
    message.stripe = (object.stripe !== undefined && object.stripe !== null)
      ? PSPAccountInfo.fromPartial(object.stripe)
      : undefined;
    message.paypal = (object.paypal !== undefined && object.paypal !== null)
      ? PSPAccountInfo.fromPartial(object.paypal)
      : undefined;
    message.gocardless = (object.gocardless !== undefined && object.gocardless !== null)
      ? PSPAccountInfo.fromPartial(object.gocardless)
      : undefined;
    message.emerchantpay = (object.emerchantpay !== undefined && object.emerchantpay !== null)
      ? PSPAccountInfo.fromPartial(object.emerchantpay)
      : undefined;
    message.slimpay = (object.slimpay !== undefined && object.slimpay !== null)
      ? PSPAccountInfo.fromPartial(object.slimpay)
      : undefined;
    message.multisafepay = (object.multisafepay !== undefined && object.multisafepay !== null)
      ? PSPAccountInfo.fromPartial(object.multisafepay)
      : undefined;
    return message;
  },
};

function createBasePSPAccountInfo(): PSPAccountInfo {
  return { id: "", name: "", isActive: false, isLiveMode: false, isConfigured: false };
}

export const PSPAccountInfo: MessageFns<PSPAccountInfo> = {
  encode(message: PSPAccountInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.isLiveMode !== false) {
      writer.uint32(32).bool(message.isLiveMode);
    }
    if (message.isConfigured !== false) {
      writer.uint32(40).bool(message.isConfigured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PSPAccountInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isLiveMode = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isConfigured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PSPAccountInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      isLiveMode: isSet(object.isLiveMode)
        ? globalThis.Boolean(object.isLiveMode)
        : isSet(object.is_live_mode)
        ? globalThis.Boolean(object.is_live_mode)
        : false,
      isConfigured: isSet(object.isConfigured)
        ? globalThis.Boolean(object.isConfigured)
        : isSet(object.is_configured)
        ? globalThis.Boolean(object.is_configured)
        : false,
    };
  },

  toJSON(message: PSPAccountInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isLiveMode !== false) {
      obj.isLiveMode = message.isLiveMode;
    }
    if (message.isConfigured !== false) {
      obj.isConfigured = message.isConfigured;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PSPAccountInfo>, I>>(base?: I): PSPAccountInfo {
    return PSPAccountInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PSPAccountInfo>, I>>(object: I): PSPAccountInfo {
    const message = createBasePSPAccountInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isActive = object.isActive ?? false;
    message.isLiveMode = object.isLiveMode ?? false;
    message.isConfigured = object.isConfigured ?? false;
    return message;
  },
};

function createBaseCreatePortalSessionRequest(): CreatePortalSessionRequest {
  return {
    organisationId: "",
    societeId: "",
    customerId: "",
    contractId: undefined,
    paymentIntentId: undefined,
    allowedActions: [],
    ttlSeconds: undefined,
    maxUses: undefined,
    amountCents: 0,
    currency: undefined,
    description: undefined,
    mandateId: undefined,
    rumMasked: undefined,
    idempotencyKey: undefined,
    metadata: {},
  };
}

export const CreatePortalSessionRequest: MessageFns<CreatePortalSessionRequest> = {
  encode(message: CreatePortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(26).string(message.customerId);
    }
    if (message.contractId !== undefined) {
      writer.uint32(34).string(message.contractId);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(42).string(message.paymentIntentId);
    }
    writer.uint32(50).fork();
    for (const v of message.allowedActions) {
      writer.int32(v);
    }
    writer.join();
    if (message.ttlSeconds !== undefined) {
      writer.uint32(56).int32(message.ttlSeconds);
    }
    if (message.maxUses !== undefined) {
      writer.uint32(64).int32(message.maxUses);
    }
    if (message.amountCents !== 0) {
      writer.uint32(72).int64(message.amountCents);
    }
    if (message.currency !== undefined) {
      writer.uint32(82).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(90).string(message.description);
    }
    if (message.mandateId !== undefined) {
      writer.uint32(98).string(message.mandateId);
    }
    if (message.rumMasked !== undefined) {
      writer.uint32(106).string(message.rumMasked);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(114).string(message.idempotencyKey);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePortalSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.allowedActions.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedActions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ttlSeconds = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxUses = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.rumMasked = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = CreatePortalSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.metadata[entry15.key] = entry15.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePortalSessionRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      contractId: isSet(object.contractId)
        ? globalThis.String(object.contractId)
        : isSet(object.contract_id)
        ? globalThis.String(object.contract_id)
        : undefined,
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : undefined,
      allowedActions: globalThis.Array.isArray(object?.allowedActions)
        ? object.allowedActions.map((e: any) => portalSessionActionFromJSON(e))
        : globalThis.Array.isArray(object?.allowed_actions)
        ? object.allowed_actions.map((e: any) => portalSessionActionFromJSON(e))
        : [],
      ttlSeconds: isSet(object.ttlSeconds)
        ? globalThis.Number(object.ttlSeconds)
        : isSet(object.ttl_seconds)
        ? globalThis.Number(object.ttl_seconds)
        : undefined,
      maxUses: isSet(object.maxUses)
        ? globalThis.Number(object.maxUses)
        : isSet(object.max_uses)
        ? globalThis.Number(object.max_uses)
        : undefined,
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : undefined,
      rumMasked: isSet(object.rumMasked)
        ? globalThis.String(object.rumMasked)
        : isSet(object.rum_masked)
        ? globalThis.String(object.rum_masked)
        : undefined,
      idempotencyKey: isSet(object.idempotencyKey)
        ? globalThis.String(object.idempotencyKey)
        : isSet(object.idempotency_key)
        ? globalThis.String(object.idempotency_key)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreatePortalSessionRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.contractId !== undefined) {
      obj.contractId = message.contractId;
    }
    if (message.paymentIntentId !== undefined) {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.allowedActions?.length) {
      obj.allowedActions = message.allowedActions.map((e) => portalSessionActionToJSON(e));
    }
    if (message.ttlSeconds !== undefined) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    if (message.maxUses !== undefined) {
      obj.maxUses = Math.round(message.maxUses);
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== undefined) {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.mandateId !== undefined) {
      obj.mandateId = message.mandateId;
    }
    if (message.rumMasked !== undefined) {
      obj.rumMasked = message.rumMasked;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePortalSessionRequest>, I>>(base?: I): CreatePortalSessionRequest {
    return CreatePortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePortalSessionRequest>, I>>(object: I): CreatePortalSessionRequest {
    const message = createBaseCreatePortalSessionRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.contractId = object.contractId ?? undefined;
    message.paymentIntentId = object.paymentIntentId ?? undefined;
    message.allowedActions = object.allowedActions?.map((e) => e) || [];
    message.ttlSeconds = object.ttlSeconds ?? undefined;
    message.maxUses = object.maxUses ?? undefined;
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? undefined;
    message.description = object.description ?? undefined;
    message.mandateId = object.mandateId ?? undefined;
    message.rumMasked = object.rumMasked ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePortalSessionRequest_MetadataEntry(): CreatePortalSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePortalSessionRequest_MetadataEntry: MessageFns<CreatePortalSessionRequest_MetadataEntry> = {
  encode(message: CreatePortalSessionRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePortalSessionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePortalSessionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePortalSessionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePortalSessionRequest_MetadataEntry {
    return CreatePortalSessionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePortalSessionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePortalSessionRequest_MetadataEntry {
    const message = createBaseCreatePortalSessionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreatePortalSessionResponse(): CreatePortalSessionResponse {
  return { session: undefined, token: "", portalUrl: "", wasIdempotentHit: false };
}

export const CreatePortalSessionResponse: MessageFns<CreatePortalSessionResponse> = {
  encode(message: CreatePortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.portalUrl !== "") {
      writer.uint32(26).string(message.portalUrl);
    }
    if (message.wasIdempotentHit !== false) {
      writer.uint32(32).bool(message.wasIdempotentHit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.portalUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.wasIdempotentHit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePortalSessionResponse {
    return {
      session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      portalUrl: isSet(object.portalUrl)
        ? globalThis.String(object.portalUrl)
        : isSet(object.portal_url)
        ? globalThis.String(object.portal_url)
        : "",
      wasIdempotentHit: isSet(object.wasIdempotentHit)
        ? globalThis.Boolean(object.wasIdempotentHit)
        : isSet(object.was_idempotent_hit)
        ? globalThis.Boolean(object.was_idempotent_hit)
        : false,
    };
  },

  toJSON(message: CreatePortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.portalUrl !== "") {
      obj.portalUrl = message.portalUrl;
    }
    if (message.wasIdempotentHit !== false) {
      obj.wasIdempotentHit = message.wasIdempotentHit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePortalSessionResponse>, I>>(base?: I): CreatePortalSessionResponse {
    return CreatePortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePortalSessionResponse>, I>>(object: I): CreatePortalSessionResponse {
    const message = createBaseCreatePortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    message.token = object.token ?? "";
    message.portalUrl = object.portalUrl ?? "";
    message.wasIdempotentHit = object.wasIdempotentHit ?? false;
    return message;
  },
};

function createBasePortalPaymentSession(): PortalPaymentSession {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    customerId: "",
    contractId: undefined,
    paymentIntentId: undefined,
    tokenVersion: "",
    status: 0,
    allowedActions: [],
    expiresAt: "",
    maxUses: 0,
    useCount: 0,
    consumedAt: undefined,
    revokedAt: undefined,
    lastAccessedAt: undefined,
    amountCents: 0,
    currency: "",
    description: undefined,
    mandateId: undefined,
    rumMasked: undefined,
    pspState: undefined,
    pspRedirectUrl: undefined,
    pspProvider: undefined,
    pspSessionId: undefined,
    metadata: {},
    createdAt: "",
    updatedAt: "",
  };
}

export const PortalPaymentSession: MessageFns<PortalPaymentSession> = {
  encode(message: PortalPaymentSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(34).string(message.customerId);
    }
    if (message.contractId !== undefined) {
      writer.uint32(42).string(message.contractId);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(50).string(message.paymentIntentId);
    }
    if (message.tokenVersion !== "") {
      writer.uint32(58).string(message.tokenVersion);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    writer.uint32(74).fork();
    for (const v of message.allowedActions) {
      writer.int32(v);
    }
    writer.join();
    if (message.expiresAt !== "") {
      writer.uint32(82).string(message.expiresAt);
    }
    if (message.maxUses !== 0) {
      writer.uint32(88).int32(message.maxUses);
    }
    if (message.useCount !== 0) {
      writer.uint32(96).int32(message.useCount);
    }
    if (message.consumedAt !== undefined) {
      writer.uint32(106).string(message.consumedAt);
    }
    if (message.revokedAt !== undefined) {
      writer.uint32(114).string(message.revokedAt);
    }
    if (message.lastAccessedAt !== undefined) {
      writer.uint32(122).string(message.lastAccessedAt);
    }
    if (message.amountCents !== 0) {
      writer.uint32(128).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(138).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(146).string(message.description);
    }
    if (message.mandateId !== undefined) {
      writer.uint32(154).string(message.mandateId);
    }
    if (message.rumMasked !== undefined) {
      writer.uint32(162).string(message.rumMasked);
    }
    if (message.pspState !== undefined) {
      writer.uint32(170).string(message.pspState);
    }
    if (message.pspRedirectUrl !== undefined) {
      writer.uint32(178).string(message.pspRedirectUrl);
    }
    if (message.pspProvider !== undefined) {
      writer.uint32(184).int32(message.pspProvider);
    }
    if (message.pspSessionId !== undefined) {
      writer.uint32(194).string(message.pspSessionId);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      PortalPaymentSession_MetadataEntry.encode({ key: key as any, value }, writer.uint32(202).fork()).join();
    });
    if (message.createdAt !== "") {
      writer.uint32(210).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(218).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalPaymentSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalPaymentSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenVersion = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.allowedActions.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedActions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxUses = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.useCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.consumedAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.revokedAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.lastAccessedAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.rumMasked = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.pspState = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.pspRedirectUrl = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.pspProvider = reader.int32() as any;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.pspSessionId = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          const entry25 = PortalPaymentSession_MetadataEntry.decode(reader, reader.uint32());
          if (entry25.value !== undefined) {
            message.metadata[entry25.key] = entry25.value;
          }
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalPaymentSession {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : "",
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : "",
      contractId: isSet(object.contractId)
        ? globalThis.String(object.contractId)
        : isSet(object.contract_id)
        ? globalThis.String(object.contract_id)
        : undefined,
      paymentIntentId: isSet(object.paymentIntentId)
        ? globalThis.String(object.paymentIntentId)
        : isSet(object.payment_intent_id)
        ? globalThis.String(object.payment_intent_id)
        : undefined,
      tokenVersion: isSet(object.tokenVersion)
        ? globalThis.String(object.tokenVersion)
        : isSet(object.token_version)
        ? globalThis.String(object.token_version)
        : "",
      status: isSet(object.status) ? portalSessionStatusFromJSON(object.status) : 0,
      allowedActions: globalThis.Array.isArray(object?.allowedActions)
        ? object.allowedActions.map((e: any) => portalSessionActionFromJSON(e))
        : globalThis.Array.isArray(object?.allowed_actions)
        ? object.allowed_actions.map((e: any) => portalSessionActionFromJSON(e))
        : [],
      expiresAt: isSet(object.expiresAt)
        ? globalThis.String(object.expiresAt)
        : isSet(object.expires_at)
        ? globalThis.String(object.expires_at)
        : "",
      maxUses: isSet(object.maxUses)
        ? globalThis.Number(object.maxUses)
        : isSet(object.max_uses)
        ? globalThis.Number(object.max_uses)
        : 0,
      useCount: isSet(object.useCount)
        ? globalThis.Number(object.useCount)
        : isSet(object.use_count)
        ? globalThis.Number(object.use_count)
        : 0,
      consumedAt: isSet(object.consumedAt)
        ? globalThis.String(object.consumedAt)
        : isSet(object.consumed_at)
        ? globalThis.String(object.consumed_at)
        : undefined,
      revokedAt: isSet(object.revokedAt)
        ? globalThis.String(object.revokedAt)
        : isSet(object.revoked_at)
        ? globalThis.String(object.revoked_at)
        : undefined,
      lastAccessedAt: isSet(object.lastAccessedAt)
        ? globalThis.String(object.lastAccessedAt)
        : isSet(object.last_accessed_at)
        ? globalThis.String(object.last_accessed_at)
        : undefined,
      amountCents: isSet(object.amountCents)
        ? globalThis.Number(object.amountCents)
        : isSet(object.amount_cents)
        ? globalThis.Number(object.amount_cents)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      mandateId: isSet(object.mandateId)
        ? globalThis.String(object.mandateId)
        : isSet(object.mandate_id)
        ? globalThis.String(object.mandate_id)
        : undefined,
      rumMasked: isSet(object.rumMasked)
        ? globalThis.String(object.rumMasked)
        : isSet(object.rum_masked)
        ? globalThis.String(object.rum_masked)
        : undefined,
      pspState: isSet(object.pspState)
        ? globalThis.String(object.pspState)
        : isSet(object.psp_state)
        ? globalThis.String(object.psp_state)
        : undefined,
      pspRedirectUrl: isSet(object.pspRedirectUrl)
        ? globalThis.String(object.pspRedirectUrl)
        : isSet(object.psp_redirect_url)
        ? globalThis.String(object.psp_redirect_url)
        : undefined,
      pspProvider: isSet(object.pspProvider)
        ? portalPspProviderFromJSON(object.pspProvider)
        : isSet(object.psp_provider)
        ? portalPspProviderFromJSON(object.psp_provider)
        : undefined,
      pspSessionId: isSet(object.pspSessionId)
        ? globalThis.String(object.pspSessionId)
        : isSet(object.psp_session_id)
        ? globalThis.String(object.psp_session_id)
        : undefined,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: PortalPaymentSession): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.contractId !== undefined) {
      obj.contractId = message.contractId;
    }
    if (message.paymentIntentId !== undefined) {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.tokenVersion !== "") {
      obj.tokenVersion = message.tokenVersion;
    }
    if (message.status !== 0) {
      obj.status = portalSessionStatusToJSON(message.status);
    }
    if (message.allowedActions?.length) {
      obj.allowedActions = message.allowedActions.map((e) => portalSessionActionToJSON(e));
    }
    if (message.expiresAt !== "") {
      obj.expiresAt = message.expiresAt;
    }
    if (message.maxUses !== 0) {
      obj.maxUses = Math.round(message.maxUses);
    }
    if (message.useCount !== 0) {
      obj.useCount = Math.round(message.useCount);
    }
    if (message.consumedAt !== undefined) {
      obj.consumedAt = message.consumedAt;
    }
    if (message.revokedAt !== undefined) {
      obj.revokedAt = message.revokedAt;
    }
    if (message.lastAccessedAt !== undefined) {
      obj.lastAccessedAt = message.lastAccessedAt;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.mandateId !== undefined) {
      obj.mandateId = message.mandateId;
    }
    if (message.rumMasked !== undefined) {
      obj.rumMasked = message.rumMasked;
    }
    if (message.pspState !== undefined) {
      obj.pspState = message.pspState;
    }
    if (message.pspRedirectUrl !== undefined) {
      obj.pspRedirectUrl = message.pspRedirectUrl;
    }
    if (message.pspProvider !== undefined) {
      obj.pspProvider = portalPspProviderToJSON(message.pspProvider);
    }
    if (message.pspSessionId !== undefined) {
      obj.pspSessionId = message.pspSessionId;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalPaymentSession>, I>>(base?: I): PortalPaymentSession {
    return PortalPaymentSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalPaymentSession>, I>>(object: I): PortalPaymentSession {
    const message = createBasePortalPaymentSession();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.contractId = object.contractId ?? undefined;
    message.paymentIntentId = object.paymentIntentId ?? undefined;
    message.tokenVersion = object.tokenVersion ?? "";
    message.status = object.status ?? 0;
    message.allowedActions = object.allowedActions?.map((e) => e) || [];
    message.expiresAt = object.expiresAt ?? "";
    message.maxUses = object.maxUses ?? 0;
    message.useCount = object.useCount ?? 0;
    message.consumedAt = object.consumedAt ?? undefined;
    message.revokedAt = object.revokedAt ?? undefined;
    message.lastAccessedAt = object.lastAccessedAt ?? undefined;
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.mandateId = object.mandateId ?? undefined;
    message.rumMasked = object.rumMasked ?? undefined;
    message.pspState = object.pspState ?? undefined;
    message.pspRedirectUrl = object.pspRedirectUrl ?? undefined;
    message.pspProvider = object.pspProvider ?? undefined;
    message.pspSessionId = object.pspSessionId ?? undefined;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBasePortalPaymentSession_MetadataEntry(): PortalPaymentSession_MetadataEntry {
  return { key: "", value: "" };
}

export const PortalPaymentSession_MetadataEntry: MessageFns<PortalPaymentSession_MetadataEntry> = {
  encode(message: PortalPaymentSession_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalPaymentSession_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalPaymentSession_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalPaymentSession_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PortalPaymentSession_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalPaymentSession_MetadataEntry>, I>>(
    base?: I,
  ): PortalPaymentSession_MetadataEntry {
    return PortalPaymentSession_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalPaymentSession_MetadataEntry>, I>>(
    object: I,
  ): PortalPaymentSession_MetadataEntry {
    const message = createBasePortalPaymentSession_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseValidatePortalTokenRequest(): ValidatePortalTokenRequest {
  return { token: "", ipAddressHash: undefined, userAgentHash: undefined, requestId: undefined };
}

export const ValidatePortalTokenRequest: MessageFns<ValidatePortalTokenRequest> = {
  encode(message: ValidatePortalTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(18).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(26).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePortalTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePortalTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatePortalTokenRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
    };
  },

  toJSON(message: ValidatePortalTokenRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatePortalTokenRequest>, I>>(base?: I): ValidatePortalTokenRequest {
    return ValidatePortalTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatePortalTokenRequest>, I>>(object: I): ValidatePortalTokenRequest {
    const message = createBaseValidatePortalTokenRequest();
    message.token = object.token ?? "";
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    return message;
  },
};

function createBaseValidatePortalTokenResponse(): ValidatePortalTokenResponse {
  return { valid: false, session: undefined, errorCode: undefined, errorMessage: undefined };
}

export const ValidatePortalTokenResponse: MessageFns<ValidatePortalTokenResponse> = {
  encode(message: ValidatePortalTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(18).fork()).join();
    }
    if (message.errorCode !== undefined) {
      writer.uint32(24).int32(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePortalTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePortalTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatePortalTokenResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined,
      errorCode: isSet(object.errorCode)
        ? portalErrorCodeFromJSON(object.errorCode)
        : isSet(object.error_code)
        ? portalErrorCodeFromJSON(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: ValidatePortalTokenResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = portalErrorCodeToJSON(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidatePortalTokenResponse>, I>>(base?: I): ValidatePortalTokenResponse {
    return ValidatePortalTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidatePortalTokenResponse>, I>>(object: I): ValidatePortalTokenResponse {
    const message = createBaseValidatePortalTokenResponse();
    message.valid = object.valid ?? false;
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseAccessPortalSessionRequest(): AccessPortalSessionRequest {
  return { token: "", ipAddressHash: undefined, userAgentHash: undefined, requestId: undefined };
}

export const AccessPortalSessionRequest: MessageFns<AccessPortalSessionRequest> = {
  encode(message: AccessPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(18).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(26).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessPortalSessionRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
    };
  },

  toJSON(message: AccessPortalSessionRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessPortalSessionRequest>, I>>(base?: I): AccessPortalSessionRequest {
    return AccessPortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessPortalSessionRequest>, I>>(object: I): AccessPortalSessionRequest {
    const message = createBaseAccessPortalSessionRequest();
    message.token = object.token ?? "";
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    return message;
  },
};

function createBaseAccessPortalSessionResponse(): AccessPortalSessionResponse {
  return { session: undefined };
}

export const AccessPortalSessionResponse: MessageFns<AccessPortalSessionResponse> = {
  encode(message: AccessPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessPortalSessionResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: AccessPortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessPortalSessionResponse>, I>>(base?: I): AccessPortalSessionResponse {
    return AccessPortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessPortalSessionResponse>, I>>(object: I): AccessPortalSessionResponse {
    const message = createBaseAccessPortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseConsumePortalTokenRequest(): ConsumePortalTokenRequest {
  return { token: "", action: 0, ipAddressHash: undefined, userAgentHash: undefined, requestId: undefined };
}

export const ConsumePortalTokenRequest: MessageFns<ConsumePortalTokenRequest> = {
  encode(message: ConsumePortalTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(26).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(34).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumePortalTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumePortalTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumePortalTokenRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      action: isSet(object.action) ? portalSessionActionFromJSON(object.action) : 0,
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
    };
  },

  toJSON(message: ConsumePortalTokenRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.action !== 0) {
      obj.action = portalSessionActionToJSON(message.action);
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumePortalTokenRequest>, I>>(base?: I): ConsumePortalTokenRequest {
    return ConsumePortalTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumePortalTokenRequest>, I>>(object: I): ConsumePortalTokenRequest {
    const message = createBaseConsumePortalTokenRequest();
    message.token = object.token ?? "";
    message.action = object.action ?? 0;
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    return message;
  },
};

function createBaseConsumePortalTokenResponse(): ConsumePortalTokenResponse {
  return { session: undefined };
}

export const ConsumePortalTokenResponse: MessageFns<ConsumePortalTokenResponse> = {
  encode(message: ConsumePortalTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumePortalTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumePortalTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumePortalTokenResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: ConsumePortalTokenResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumePortalTokenResponse>, I>>(base?: I): ConsumePortalTokenResponse {
    return ConsumePortalTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumePortalTokenResponse>, I>>(object: I): ConsumePortalTokenResponse {
    const message = createBaseConsumePortalTokenResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseCancelPortalSessionRequest(): CancelPortalSessionRequest {
  return { sessionId: "", reason: undefined };
}

export const CancelPortalSessionRequest: MessageFns<CancelPortalSessionRequest> = {
  encode(message: CancelPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.reason !== undefined) {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPortalSessionRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: CancelPortalSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPortalSessionRequest>, I>>(base?: I): CancelPortalSessionRequest {
    return CancelPortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPortalSessionRequest>, I>>(object: I): CancelPortalSessionRequest {
    const message = createBaseCancelPortalSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseCancelPortalSessionResponse(): CancelPortalSessionResponse {
  return { session: undefined };
}

export const CancelPortalSessionResponse: MessageFns<CancelPortalSessionResponse> = {
  encode(message: CancelPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPortalSessionResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: CancelPortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPortalSessionResponse>, I>>(base?: I): CancelPortalSessionResponse {
    return CancelPortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPortalSessionResponse>, I>>(object: I): CancelPortalSessionResponse {
    const message = createBaseCancelPortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdatePortalPspInfoRequest(): UpdatePortalPspInfoRequest {
  return { sessionId: "", pspState: "", pspRedirectUrl: "", pspProvider: 0, pspSessionId: "" };
}

export const UpdatePortalPspInfoRequest: MessageFns<UpdatePortalPspInfoRequest> = {
  encode(message: UpdatePortalPspInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.pspState !== "") {
      writer.uint32(18).string(message.pspState);
    }
    if (message.pspRedirectUrl !== "") {
      writer.uint32(26).string(message.pspRedirectUrl);
    }
    if (message.pspProvider !== 0) {
      writer.uint32(32).int32(message.pspProvider);
    }
    if (message.pspSessionId !== "") {
      writer.uint32(42).string(message.pspSessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePortalPspInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePortalPspInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pspState = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pspRedirectUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pspProvider = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pspSessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePortalPspInfoRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      pspState: isSet(object.pspState)
        ? globalThis.String(object.pspState)
        : isSet(object.psp_state)
        ? globalThis.String(object.psp_state)
        : "",
      pspRedirectUrl: isSet(object.pspRedirectUrl)
        ? globalThis.String(object.pspRedirectUrl)
        : isSet(object.psp_redirect_url)
        ? globalThis.String(object.psp_redirect_url)
        : "",
      pspProvider: isSet(object.pspProvider)
        ? portalPspProviderFromJSON(object.pspProvider)
        : isSet(object.psp_provider)
        ? portalPspProviderFromJSON(object.psp_provider)
        : 0,
      pspSessionId: isSet(object.pspSessionId)
        ? globalThis.String(object.pspSessionId)
        : isSet(object.psp_session_id)
        ? globalThis.String(object.psp_session_id)
        : "",
    };
  },

  toJSON(message: UpdatePortalPspInfoRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.pspState !== "") {
      obj.pspState = message.pspState;
    }
    if (message.pspRedirectUrl !== "") {
      obj.pspRedirectUrl = message.pspRedirectUrl;
    }
    if (message.pspProvider !== 0) {
      obj.pspProvider = portalPspProviderToJSON(message.pspProvider);
    }
    if (message.pspSessionId !== "") {
      obj.pspSessionId = message.pspSessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePortalPspInfoRequest>, I>>(base?: I): UpdatePortalPspInfoRequest {
    return UpdatePortalPspInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePortalPspInfoRequest>, I>>(object: I): UpdatePortalPspInfoRequest {
    const message = createBaseUpdatePortalPspInfoRequest();
    message.sessionId = object.sessionId ?? "";
    message.pspState = object.pspState ?? "";
    message.pspRedirectUrl = object.pspRedirectUrl ?? "";
    message.pspProvider = object.pspProvider ?? 0;
    message.pspSessionId = object.pspSessionId ?? "";
    return message;
  },
};

function createBaseUpdatePortalPspInfoResponse(): UpdatePortalPspInfoResponse {
  return { success: false };
}

export const UpdatePortalPspInfoResponse: MessageFns<UpdatePortalPspInfoResponse> = {
  encode(message: UpdatePortalPspInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePortalPspInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePortalPspInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePortalPspInfoResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UpdatePortalPspInfoResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePortalPspInfoResponse>, I>>(base?: I): UpdatePortalPspInfoResponse {
    return UpdatePortalPspInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePortalPspInfoResponse>, I>>(object: I): UpdatePortalPspInfoResponse {
    const message = createBaseUpdatePortalPspInfoResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseTransitionPortalSessionRequest(): TransitionPortalSessionRequest {
  return { sessionId: "", newStatus: 0, reason: undefined, ipAddressHash: undefined, userAgentHash: undefined };
}

export const TransitionPortalSessionRequest: MessageFns<TransitionPortalSessionRequest> = {
  encode(message: TransitionPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.newStatus !== 0) {
      writer.uint32(16).int32(message.newStatus);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(34).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(42).string(message.userAgentHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionPortalSessionRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      newStatus: isSet(object.newStatus)
        ? portalSessionStatusFromJSON(object.newStatus)
        : isSet(object.new_status)
        ? portalSessionStatusFromJSON(object.new_status)
        : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
    };
  },

  toJSON(message: TransitionPortalSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.newStatus !== 0) {
      obj.newStatus = portalSessionStatusToJSON(message.newStatus);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransitionPortalSessionRequest>, I>>(base?: I): TransitionPortalSessionRequest {
    return TransitionPortalSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransitionPortalSessionRequest>, I>>(
    object: I,
  ): TransitionPortalSessionRequest {
    const message = createBaseTransitionPortalSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.newStatus = object.newStatus ?? 0;
    message.reason = object.reason ?? undefined;
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    return message;
  },
};

function createBaseTransitionPortalSessionResponse(): TransitionPortalSessionResponse {
  return { session: undefined };
}

export const TransitionPortalSessionResponse: MessageFns<TransitionPortalSessionResponse> = {
  encode(message: TransitionPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionPortalSessionResponse {
    return { session: isSet(object.session) ? PortalPaymentSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: TransitionPortalSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = PortalPaymentSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransitionPortalSessionResponse>, I>>(base?: I): TransitionPortalSessionResponse {
    return TransitionPortalSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransitionPortalSessionResponse>, I>>(
    object: I,
  ): TransitionPortalSessionResponse {
    const message = createBaseTransitionPortalSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? PortalPaymentSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBasePortalSessionAuditLog(): PortalSessionAuditLog {
  return {
    id: "",
    portalSessionId: "",
    eventType: 0,
    actorType: 0,
    previousStatus: undefined,
    newStatus: undefined,
    ipAddressHash: undefined,
    userAgentHash: undefined,
    requestId: undefined,
    correlationId: undefined,
    data: {},
    timestamp: "",
  };
}

export const PortalSessionAuditLog: MessageFns<PortalSessionAuditLog> = {
  encode(message: PortalSessionAuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.portalSessionId !== "") {
      writer.uint32(18).string(message.portalSessionId);
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.actorType !== 0) {
      writer.uint32(32).int32(message.actorType);
    }
    if (message.previousStatus !== undefined) {
      writer.uint32(42).string(message.previousStatus);
    }
    if (message.newStatus !== undefined) {
      writer.uint32(50).string(message.newStatus);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(58).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(66).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(74).string(message.requestId);
    }
    if (message.correlationId !== undefined) {
      writer.uint32(82).string(message.correlationId);
    }
    globalThis.Object.entries(message.data).forEach(([key, value]: [string, string]) => {
      PortalSessionAuditLog_DataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.timestamp !== "") {
      writer.uint32(98).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalSessionAuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalSessionAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.portalSessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actorType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.previousStatus = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.newStatus = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = PortalSessionAuditLog_DataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.data[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalSessionAuditLog {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      portalSessionId: isSet(object.portalSessionId)
        ? globalThis.String(object.portalSessionId)
        : isSet(object.portal_session_id)
        ? globalThis.String(object.portal_session_id)
        : "",
      eventType: isSet(object.eventType)
        ? portalAuditEventTypeFromJSON(object.eventType)
        : isSet(object.event_type)
        ? portalAuditEventTypeFromJSON(object.event_type)
        : 0,
      actorType: isSet(object.actorType)
        ? portalAuditActorTypeFromJSON(object.actorType)
        : isSet(object.actor_type)
        ? portalAuditActorTypeFromJSON(object.actor_type)
        : 0,
      previousStatus: isSet(object.previousStatus)
        ? globalThis.String(object.previousStatus)
        : isSet(object.previous_status)
        ? globalThis.String(object.previous_status)
        : undefined,
      newStatus: isSet(object.newStatus)
        ? globalThis.String(object.newStatus)
        : isSet(object.new_status)
        ? globalThis.String(object.new_status)
        : undefined,
      ipAddressHash: isSet(object.ipAddressHash)
        ? globalThis.String(object.ipAddressHash)
        : isSet(object.ip_address_hash)
        ? globalThis.String(object.ip_address_hash)
        : undefined,
      userAgentHash: isSet(object.userAgentHash)
        ? globalThis.String(object.userAgentHash)
        : isSet(object.user_agent_hash)
        ? globalThis.String(object.user_agent_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
      correlationId: isSet(object.correlationId)
        ? globalThis.String(object.correlationId)
        : isSet(object.correlation_id)
        ? globalThis.String(object.correlation_id)
        : undefined,
      data: isObject(object.data)
        ? (globalThis.Object.entries(object.data) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: PortalSessionAuditLog): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.portalSessionId !== "") {
      obj.portalSessionId = message.portalSessionId;
    }
    if (message.eventType !== 0) {
      obj.eventType = portalAuditEventTypeToJSON(message.eventType);
    }
    if (message.actorType !== 0) {
      obj.actorType = portalAuditActorTypeToJSON(message.actorType);
    }
    if (message.previousStatus !== undefined) {
      obj.previousStatus = message.previousStatus;
    }
    if (message.newStatus !== undefined) {
      obj.newStatus = message.newStatus;
    }
    if (message.ipAddressHash !== undefined) {
      obj.ipAddressHash = message.ipAddressHash;
    }
    if (message.userAgentHash !== undefined) {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    if (message.correlationId !== undefined) {
      obj.correlationId = message.correlationId;
    }
    if (message.data) {
      const entries = globalThis.Object.entries(message.data) as [string, string][];
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalSessionAuditLog>, I>>(base?: I): PortalSessionAuditLog {
    return PortalSessionAuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalSessionAuditLog>, I>>(object: I): PortalSessionAuditLog {
    const message = createBasePortalSessionAuditLog();
    message.id = object.id ?? "";
    message.portalSessionId = object.portalSessionId ?? "";
    message.eventType = object.eventType ?? 0;
    message.actorType = object.actorType ?? 0;
    message.previousStatus = object.previousStatus ?? undefined;
    message.newStatus = object.newStatus ?? undefined;
    message.ipAddressHash = object.ipAddressHash ?? undefined;
    message.userAgentHash = object.userAgentHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    message.correlationId = object.correlationId ?? undefined;
    message.data = (globalThis.Object.entries(object.data ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBasePortalSessionAuditLog_DataEntry(): PortalSessionAuditLog_DataEntry {
  return { key: "", value: "" };
}

export const PortalSessionAuditLog_DataEntry: MessageFns<PortalSessionAuditLog_DataEntry> = {
  encode(message: PortalSessionAuditLog_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalSessionAuditLog_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalSessionAuditLog_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalSessionAuditLog_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PortalSessionAuditLog_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalSessionAuditLog_DataEntry>, I>>(base?: I): PortalSessionAuditLog_DataEntry {
    return PortalSessionAuditLog_DataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalSessionAuditLog_DataEntry>, I>>(
    object: I,
  ): PortalSessionAuditLog_DataEntry {
    const message = createBasePortalSessionAuditLog_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListPortalSessionsRequest(): ListPortalSessionsRequest {
  return {
    organisationId: "",
    societeId: undefined,
    customerId: undefined,
    status: undefined,
    fromDate: undefined,
    toDate: undefined,
    page: undefined,
    limit: undefined,
  };
}

export const ListPortalSessionsRequest: MessageFns<ListPortalSessionsRequest> = {
  encode(message: ListPortalSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.customerId !== undefined) {
      writer.uint32(26).string(message.customerId);
    }
    if (message.status !== undefined) {
      writer.uint32(32).int32(message.status);
    }
    if (message.fromDate !== undefined) {
      writer.uint32(42).string(message.fromDate);
    }
    if (message.toDate !== undefined) {
      writer.uint32(50).string(message.toDate);
    }
    if (message.page !== undefined) {
      writer.uint32(56).int32(message.page);
    }
    if (message.limit !== undefined) {
      writer.uint32(64).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortalSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortalSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPortalSessionsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      customerId: isSet(object.customerId)
        ? globalThis.String(object.customerId)
        : isSet(object.customer_id)
        ? globalThis.String(object.customer_id)
        : undefined,
      status: isSet(object.status) ? portalSessionStatusFromJSON(object.status) : undefined,
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: ListPortalSessionsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.status !== undefined) {
      obj.status = portalSessionStatusToJSON(message.status);
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate;
    }
    if (message.page !== undefined) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPortalSessionsRequest>, I>>(base?: I): ListPortalSessionsRequest {
    return ListPortalSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPortalSessionsRequest>, I>>(object: I): ListPortalSessionsRequest {
    const message = createBaseListPortalSessionsRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.customerId = object.customerId ?? undefined;
    message.status = object.status ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.page = object.page ?? undefined;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseListPortalSessionsResponse(): ListPortalSessionsResponse {
  return { sessions: [], total: 0, page: 0, totalPages: 0 };
}

export const ListPortalSessionsResponse: MessageFns<ListPortalSessionsResponse> = {
  encode(message: ListPortalSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      PortalPaymentSession.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortalSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortalSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(PortalPaymentSession.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPortalSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => PortalPaymentSession.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: ListPortalSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => PortalPaymentSession.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPortalSessionsResponse>, I>>(base?: I): ListPortalSessionsResponse {
    return ListPortalSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPortalSessionsResponse>, I>>(object: I): ListPortalSessionsResponse {
    const message = createBaseListPortalSessionsResponse();
    message.sessions = object.sessions?.map((e) => PortalPaymentSession.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetPortalSessionAuditRequest(): GetPortalSessionAuditRequest {
  return { sessionId: "" };
}

export const GetPortalSessionAuditRequest: MessageFns<GetPortalSessionAuditRequest> = {
  encode(message: GetPortalSessionAuditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionAuditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionAuditRequest {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
    };
  },

  toJSON(message: GetPortalSessionAuditRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionAuditRequest>, I>>(base?: I): GetPortalSessionAuditRequest {
    return GetPortalSessionAuditRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionAuditRequest>, I>>(object: I): GetPortalSessionAuditRequest {
    const message = createBaseGetPortalSessionAuditRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseGetPortalSessionAuditResponse(): GetPortalSessionAuditResponse {
  return { logs: [] };
}

export const GetPortalSessionAuditResponse: MessageFns<GetPortalSessionAuditResponse> = {
  encode(message: GetPortalSessionAuditResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      PortalSessionAuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionAuditResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(PortalSessionAuditLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionAuditResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs)
        ? object.logs.map((e: any) => PortalSessionAuditLog.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPortalSessionAuditResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => PortalSessionAuditLog.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionAuditResponse>, I>>(base?: I): GetPortalSessionAuditResponse {
    return GetPortalSessionAuditResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionAuditResponse>, I>>(
    object: I,
  ): GetPortalSessionAuditResponse {
    const message = createBaseGetPortalSessionAuditResponse();
    message.logs = object.logs?.map((e) => PortalSessionAuditLog.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPortalSessionStatsRequest(): GetPortalSessionStatsRequest {
  return { organisationId: "", societeId: undefined, fromDate: "", toDate: "" };
}

export const GetPortalSessionStatsRequest: MessageFns<GetPortalSessionStatsRequest> = {
  encode(message: GetPortalSessionStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.fromDate !== "") {
      writer.uint32(26).string(message.fromDate);
    }
    if (message.toDate !== "") {
      writer.uint32(34).string(message.toDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionStatsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      fromDate: isSet(object.fromDate)
        ? globalThis.String(object.fromDate)
        : isSet(object.from_date)
        ? globalThis.String(object.from_date)
        : "",
      toDate: isSet(object.toDate)
        ? globalThis.String(object.toDate)
        : isSet(object.to_date)
        ? globalThis.String(object.to_date)
        : "",
    };
  },

  toJSON(message: GetPortalSessionStatsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.fromDate !== "") {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== "") {
      obj.toDate = message.toDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionStatsRequest>, I>>(base?: I): GetPortalSessionStatsRequest {
    return GetPortalSessionStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionStatsRequest>, I>>(object: I): GetPortalSessionStatsRequest {
    const message = createBaseGetPortalSessionStatsRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.fromDate = object.fromDate ?? "";
    message.toDate = object.toDate ?? "";
    return message;
  },
};

function createBaseGetPortalSessionStatsResponse(): GetPortalSessionStatsResponse {
  return { totalCreated: 0, totalCompleted: 0, totalFailed: 0, totalExpired: 0, totalCancelled: 0, completionRate: 0 };
}

export const GetPortalSessionStatsResponse: MessageFns<GetPortalSessionStatsResponse> = {
  encode(message: GetPortalSessionStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCreated !== 0) {
      writer.uint32(8).int32(message.totalCreated);
    }
    if (message.totalCompleted !== 0) {
      writer.uint32(16).int32(message.totalCompleted);
    }
    if (message.totalFailed !== 0) {
      writer.uint32(24).int32(message.totalFailed);
    }
    if (message.totalExpired !== 0) {
      writer.uint32(32).int32(message.totalExpired);
    }
    if (message.totalCancelled !== 0) {
      writer.uint32(40).int32(message.totalCancelled);
    }
    if (message.completionRate !== 0) {
      writer.uint32(49).double(message.completionRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCreated = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCompleted = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalFailed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalExpired = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalCancelled = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.completionRate = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortalSessionStatsResponse {
    return {
      totalCreated: isSet(object.totalCreated)
        ? globalThis.Number(object.totalCreated)
        : isSet(object.total_created)
        ? globalThis.Number(object.total_created)
        : 0,
      totalCompleted: isSet(object.totalCompleted)
        ? globalThis.Number(object.totalCompleted)
        : isSet(object.total_completed)
        ? globalThis.Number(object.total_completed)
        : 0,
      totalFailed: isSet(object.totalFailed)
        ? globalThis.Number(object.totalFailed)
        : isSet(object.total_failed)
        ? globalThis.Number(object.total_failed)
        : 0,
      totalExpired: isSet(object.totalExpired)
        ? globalThis.Number(object.totalExpired)
        : isSet(object.total_expired)
        ? globalThis.Number(object.total_expired)
        : 0,
      totalCancelled: isSet(object.totalCancelled)
        ? globalThis.Number(object.totalCancelled)
        : isSet(object.total_cancelled)
        ? globalThis.Number(object.total_cancelled)
        : 0,
      completionRate: isSet(object.completionRate)
        ? globalThis.Number(object.completionRate)
        : isSet(object.completion_rate)
        ? globalThis.Number(object.completion_rate)
        : 0,
    };
  },

  toJSON(message: GetPortalSessionStatsResponse): unknown {
    const obj: any = {};
    if (message.totalCreated !== 0) {
      obj.totalCreated = Math.round(message.totalCreated);
    }
    if (message.totalCompleted !== 0) {
      obj.totalCompleted = Math.round(message.totalCompleted);
    }
    if (message.totalFailed !== 0) {
      obj.totalFailed = Math.round(message.totalFailed);
    }
    if (message.totalExpired !== 0) {
      obj.totalExpired = Math.round(message.totalExpired);
    }
    if (message.totalCancelled !== 0) {
      obj.totalCancelled = Math.round(message.totalCancelled);
    }
    if (message.completionRate !== 0) {
      obj.completionRate = message.completionRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortalSessionStatsResponse>, I>>(base?: I): GetPortalSessionStatsResponse {
    return GetPortalSessionStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortalSessionStatsResponse>, I>>(
    object: I,
  ): GetPortalSessionStatsResponse {
    const message = createBaseGetPortalSessionStatsResponse();
    message.totalCreated = object.totalCreated ?? 0;
    message.totalCompleted = object.totalCompleted ?? 0;
    message.totalFailed = object.totalFailed ?? 0;
    message.totalExpired = object.totalExpired ?? 0;
    message.totalCancelled = object.totalCancelled ?? 0;
    message.completionRate = object.completionRate ?? 0;
    return message;
  },
};

function createBasePortalRequestContext(): PortalRequestContext {
  return { ipHash: undefined, uaHash: undefined, requestId: undefined, correlationId: undefined };
}

export const PortalRequestContext: MessageFns<PortalRequestContext> = {
  encode(message: PortalRequestContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipHash !== undefined) {
      writer.uint32(10).string(message.ipHash);
    }
    if (message.uaHash !== undefined) {
      writer.uint32(18).string(message.uaHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(26).string(message.requestId);
    }
    if (message.correlationId !== undefined) {
      writer.uint32(34).string(message.correlationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalRequestContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalRequestContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uaHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortalRequestContext {
    return {
      ipHash: isSet(object.ipHash)
        ? globalThis.String(object.ipHash)
        : isSet(object.ip_hash)
        ? globalThis.String(object.ip_hash)
        : undefined,
      uaHash: isSet(object.uaHash)
        ? globalThis.String(object.uaHash)
        : isSet(object.ua_hash)
        ? globalThis.String(object.ua_hash)
        : undefined,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : undefined,
      correlationId: isSet(object.correlationId)
        ? globalThis.String(object.correlationId)
        : isSet(object.correlation_id)
        ? globalThis.String(object.correlation_id)
        : undefined,
    };
  },

  toJSON(message: PortalRequestContext): unknown {
    const obj: any = {};
    if (message.ipHash !== undefined) {
      obj.ipHash = message.ipHash;
    }
    if (message.uaHash !== undefined) {
      obj.uaHash = message.uaHash;
    }
    if (message.requestId !== undefined) {
      obj.requestId = message.requestId;
    }
    if (message.correlationId !== undefined) {
      obj.correlationId = message.correlationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortalRequestContext>, I>>(base?: I): PortalRequestContext {
    return PortalRequestContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortalRequestContext>, I>>(object: I): PortalRequestContext {
    const message = createBasePortalRequestContext();
    message.ipHash = object.ipHash ?? undefined;
    message.uaHash = object.uaHash ?? undefined;
    message.requestId = object.requestId ?? undefined;
    message.correlationId = object.correlationId ?? undefined;
    return message;
  },
};

function createBaseGoCardlessConfig(): GoCardlessConfig {
  return { accessToken: "", baseUrl: "" };
}

export const GoCardlessConfig: MessageFns<GoCardlessConfig> = {
  encode(message: GoCardlessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessConfig {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      baseUrl: isSet(object.baseUrl)
        ? globalThis.String(object.baseUrl)
        : isSet(object.base_url)
        ? globalThis.String(object.base_url)
        : "",
    };
  },

  toJSON(message: GoCardlessConfig): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessConfig>, I>>(base?: I): GoCardlessConfig {
    return GoCardlessConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessConfig>, I>>(object: I): GoCardlessConfig {
    const message = createBaseGoCardlessConfig();
    message.accessToken = object.accessToken ?? "";
    message.baseUrl = object.baseUrl ?? "";
    return message;
  },
};

function createBaseSlimpayToken(): SlimpayToken {
  return { accessToken: "", expiresAt: 0 };
}

export const SlimpayToken: MessageFns<SlimpayToken> = {
  encode(message: SlimpayToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlimpayToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlimpayToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlimpayToken {
    return {
      accessToken: isSet(object.accessToken)
        ? globalThis.String(object.accessToken)
        : isSet(object.access_token)
        ? globalThis.String(object.access_token)
        : "",
      expiresAt: isSet(object.expiresAt)
        ? globalThis.Number(object.expiresAt)
        : isSet(object.expires_at)
        ? globalThis.Number(object.expires_at)
        : 0,
    };
  },

  toJSON(message: SlimpayToken): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlimpayToken>, I>>(base?: I): SlimpayToken {
    return SlimpayToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlimpayToken>, I>>(object: I): SlimpayToken {
    const message = createBaseSlimpayToken();
    message.accessToken = object.accessToken ?? "";
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: {
    path: "/payment.PaymentService/CreateStripeCheckoutSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCheckoutSessionRequest): Buffer =>
      Buffer.from(CreateStripeCheckoutSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeCheckoutSessionRequest =>
      CreateStripeCheckoutSessionRequest.decode(value),
    responseSerialize: (value: StripeCheckoutSessionResponse): Buffer =>
      Buffer.from(StripeCheckoutSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCheckoutSessionResponse => StripeCheckoutSessionResponse.decode(value),
  },
  createStripePaymentIntent: {
    path: "/payment.PaymentService/CreateStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripePaymentIntentRequest): Buffer =>
      Buffer.from(CreateStripePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripePaymentIntentRequest =>
      CreateStripePaymentIntentRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  getStripePaymentIntent: {
    path: "/payment.PaymentService/GetStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  cancelStripePaymentIntent: {
    path: "/payment.PaymentService/CancelStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  /** Customers */
  createStripeCustomer: {
    path: "/payment.PaymentService/CreateStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCustomerRequest): Buffer =>
      Buffer.from(CreateStripeCustomerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeCustomerRequest => CreateStripeCustomerRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse): Buffer =>
      Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCustomerResponse => StripeCustomerResponse.decode(value),
  },
  getStripeCustomer: {
    path: "/payment.PaymentService/GetStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse): Buffer =>
      Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCustomerResponse => StripeCustomerResponse.decode(value),
  },
  /** Subscriptions */
  createStripeSubscription: {
    path: "/payment.PaymentService/CreateStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSubscriptionRequest): Buffer =>
      Buffer.from(CreateStripeSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeSubscriptionRequest =>
      CreateStripeSubscriptionRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  getStripeSubscription: {
    path: "/payment.PaymentService/GetStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  cancelStripeSubscription: {
    path: "/payment.PaymentService/CancelStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  /** Refunds */
  createStripeRefund: {
    path: "/payment.PaymentService/CreateStripeRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeRefundRequest): Buffer =>
      Buffer.from(CreateStripeRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeRefundRequest => CreateStripeRefundRequest.decode(value),
    responseSerialize: (value: StripeRefundResponse): Buffer =>
      Buffer.from(StripeRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeRefundResponse => StripeRefundResponse.decode(value),
  },
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: {
    path: "/payment.PaymentService/CreateStripeSetupIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSetupIntentRequest): Buffer =>
      Buffer.from(CreateStripeSetupIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeSetupIntentRequest => CreateStripeSetupIntentRequest.decode(value),
    responseSerialize: (value: StripeSetupIntentResponse): Buffer =>
      Buffer.from(StripeSetupIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSetupIntentResponse => StripeSetupIntentResponse.decode(value),
  },
  /** Billing Portal */
  createStripeBillingPortalSession: {
    path: "/payment.PaymentService/CreateStripeBillingPortalSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeBillingPortalRequest): Buffer =>
      Buffer.from(CreateStripeBillingPortalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeBillingPortalRequest =>
      CreateStripeBillingPortalRequest.decode(value),
    responseSerialize: (value: StripeBillingPortalResponse): Buffer =>
      Buffer.from(StripeBillingPortalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeBillingPortalResponse => StripeBillingPortalResponse.decode(value),
  },
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: {
    path: "/payment.PaymentService/CreatePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePayPalOrderRequest): Buffer =>
      Buffer.from(CreatePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePayPalOrderRequest => CreatePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  getPayPalOrder: {
    path: "/payment.PaymentService/GetPayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest): Buffer =>
      Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPayPalOrderRequest => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  capturePayPalOrder: {
    path: "/payment.PaymentService/CapturePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CapturePayPalOrderRequest): Buffer =>
      Buffer.from(CapturePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CapturePayPalOrderRequest => CapturePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalCaptureResponse): Buffer =>
      Buffer.from(PayPalCaptureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalCaptureResponse => PayPalCaptureResponse.decode(value),
  },
  authorizePayPalOrder: {
    path: "/payment.PaymentService/AuthorizePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest): Buffer =>
      Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPayPalOrderRequest => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: {
    path: "/payment.PaymentService/SetupGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetupGoCardlessMandateRequest): Buffer =>
      Buffer.from(SetupGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SetupGoCardlessMandateRequest => SetupGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  getGoCardlessMandate: {
    path: "/payment.PaymentService/GetGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest): Buffer =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGoCardlessMandateRequest => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  cancelGoCardlessMandate: {
    path: "/payment.PaymentService/CancelGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest): Buffer =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGoCardlessMandateRequest => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  createGoCardlessPayment: {
    path: "/payment.PaymentService/CreateGoCardlessPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessPaymentRequest): Buffer =>
      Buffer.from(CreateGoCardlessPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGoCardlessPaymentRequest => CreateGoCardlessPaymentRequest.decode(value),
    responseSerialize: (value: GoCardlessPaymentResponse): Buffer =>
      Buffer.from(GoCardlessPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessPaymentResponse => GoCardlessPaymentResponse.decode(value),
  },
  createGoCardlessSubscription: {
    path: "/payment.PaymentService/CreateGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessSubscriptionRequest): Buffer =>
      Buffer.from(CreateGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGoCardlessSubscriptionRequest =>
      CreateGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse): Buffer =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessSubscriptionResponse =>
      GoCardlessSubscriptionResponse.decode(value),
  },
  cancelGoCardlessSubscription: {
    path: "/payment.PaymentService/CancelGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelGoCardlessSubscriptionRequest): Buffer =>
      Buffer.from(CancelGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelGoCardlessSubscriptionRequest =>
      CancelGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse): Buffer =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessSubscriptionResponse =>
      GoCardlessSubscriptionResponse.decode(value),
  },
  /** ==================== SCHEDULES ==================== */
  createSchedule: {
    path: "/payment.PaymentService/CreateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateScheduleRequest): Buffer =>
      Buffer.from(CreateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateScheduleRequest => CreateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  getSchedule: {
    path: "/payment.PaymentService/GetSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  updateSchedule: {
    path: "/payment.PaymentService/UpdateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateScheduleRequest): Buffer =>
      Buffer.from(UpdateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateScheduleRequest => UpdateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  deleteSchedule: {
    path: "/payment.PaymentService/DeleteSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getDueSchedules: {
    path: "/payment.PaymentService/GetDueSchedules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDueSchedulesRequest): Buffer =>
      Buffer.from(GetDueSchedulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDueSchedulesRequest => GetDueSchedulesRequest.decode(value),
    responseSerialize: (value: ScheduleListResponse): Buffer =>
      Buffer.from(ScheduleListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleListResponse => ScheduleListResponse.decode(value),
  },
  processDuePayments: {
    path: "/payment.PaymentService/ProcessDuePayments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDuePaymentsRequest): Buffer =>
      Buffer.from(ProcessDuePaymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessDuePaymentsRequest => ProcessDuePaymentsRequest.decode(value),
    responseSerialize: (value: ProcessDuePaymentsResponse): Buffer =>
      Buffer.from(ProcessDuePaymentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessDuePaymentsResponse => ProcessDuePaymentsResponse.decode(value),
  },
  renewSchedule: {
    path: "/payment.PaymentService/RenewSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenewScheduleRequest): Buffer => Buffer.from(RenewScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RenewScheduleRequest => RenewScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: {
    path: "/payment.PaymentService/CreatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentIntentRequest): Buffer =>
      Buffer.from(CreatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePaymentIntentRequest => CreatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  getPaymentIntent: {
    path: "/payment.PaymentService/GetPaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  updatePaymentIntent: {
    path: "/payment.PaymentService/UpdatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePaymentIntentRequest): Buffer =>
      Buffer.from(UpdatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePaymentIntentRequest => UpdatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  deletePaymentIntent: {
    path: "/payment.PaymentService/DeletePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: {
    path: "/payment.PaymentService/CreatePaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentEventRequest): Buffer =>
      Buffer.from(CreatePaymentEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePaymentEventRequest => CreatePaymentEventRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  getPaymentEvent: {
    path: "/payment.PaymentService/GetPaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  getUnprocessedEvents: {
    path: "/payment.PaymentService/GetUnprocessedEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUnprocessedEventsRequest): Buffer =>
      Buffer.from(GetUnprocessedEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUnprocessedEventsRequest => GetUnprocessedEventsRequest.decode(value),
    responseSerialize: (value: PaymentEventListResponse): Buffer =>
      Buffer.from(PaymentEventListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventListResponse => PaymentEventListResponse.decode(value),
  },
  markEventProcessed: {
    path: "/payment.PaymentService/MarkEventProcessed",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkEventProcessedRequest): Buffer =>
      Buffer.from(MarkEventProcessedRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarkEventProcessedRequest => MarkEventProcessedRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: {
    path: "/payment.PaymentService/GetPSPAccountsSummary",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPSPAccountsRequest): Buffer =>
      Buffer.from(GetPSPAccountsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPSPAccountsRequest => GetPSPAccountsRequest.decode(value),
    responseSerialize: (value: PSPAccountsSummaryResponse): Buffer =>
      Buffer.from(PSPAccountsSummaryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PSPAccountsSummaryResponse => PSPAccountsSummaryResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: handleUnaryCall<CreateStripeCheckoutSessionRequest, StripeCheckoutSessionResponse>;
  createStripePaymentIntent: handleUnaryCall<CreateStripePaymentIntentRequest, StripePaymentIntentResponse>;
  getStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  cancelStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  /** Customers */
  createStripeCustomer: handleUnaryCall<CreateStripeCustomerRequest, StripeCustomerResponse>;
  getStripeCustomer: handleUnaryCall<GetByIdRequest, StripeCustomerResponse>;
  /** Subscriptions */
  createStripeSubscription: handleUnaryCall<CreateStripeSubscriptionRequest, StripeSubscriptionResponse>;
  getStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  cancelStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  /** Refunds */
  createStripeRefund: handleUnaryCall<CreateStripeRefundRequest, StripeRefundResponse>;
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: handleUnaryCall<CreateStripeSetupIntentRequest, StripeSetupIntentResponse>;
  /** Billing Portal */
  createStripeBillingPortalSession: handleUnaryCall<CreateStripeBillingPortalRequest, StripeBillingPortalResponse>;
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: handleUnaryCall<CreatePayPalOrderRequest, PayPalOrderResponse>;
  getPayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  capturePayPalOrder: handleUnaryCall<CapturePayPalOrderRequest, PayPalCaptureResponse>;
  authorizePayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: handleUnaryCall<SetupGoCardlessMandateRequest, GoCardlessMandateResponse>;
  getGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  cancelGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  createGoCardlessPayment: handleUnaryCall<CreateGoCardlessPaymentRequest, GoCardlessPaymentResponse>;
  createGoCardlessSubscription: handleUnaryCall<CreateGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  cancelGoCardlessSubscription: handleUnaryCall<CancelGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  /** ==================== SCHEDULES ==================== */
  createSchedule: handleUnaryCall<CreateScheduleRequest, ScheduleResponse>;
  getSchedule: handleUnaryCall<GetByIdRequest, ScheduleResponse>;
  updateSchedule: handleUnaryCall<UpdateScheduleRequest, ScheduleResponse>;
  deleteSchedule: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  getDueSchedules: handleUnaryCall<GetDueSchedulesRequest, ScheduleListResponse>;
  processDuePayments: handleUnaryCall<ProcessDuePaymentsRequest, ProcessDuePaymentsResponse>;
  renewSchedule: handleUnaryCall<RenewScheduleRequest, ScheduleResponse>;
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: handleUnaryCall<CreatePaymentIntentRequest, PaymentIntentResponse>;
  getPaymentIntent: handleUnaryCall<GetByIdRequest, PaymentIntentResponse>;
  updatePaymentIntent: handleUnaryCall<UpdatePaymentIntentRequest, PaymentIntentResponse>;
  deletePaymentIntent: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: handleUnaryCall<CreatePaymentEventRequest, PaymentEventResponse>;
  getPaymentEvent: handleUnaryCall<GetByIdRequest, PaymentEventResponse>;
  getUnprocessedEvents: handleUnaryCall<GetUnprocessedEventsRequest, PaymentEventListResponse>;
  markEventProcessed: handleUnaryCall<MarkEventProcessedRequest, PaymentEventResponse>;
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: handleUnaryCall<GetPSPAccountsRequest, PSPAccountsSummaryResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
