// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: retry/am04_retry.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../google/protobuf/timestamp";

/** Rejection reason codes (SEPA return reason codes) */
export enum RejectionReasonCode {
  REJECTION_REASON_CODE_UNSPECIFIED = 0,
  /** AM04_ACCOUNT_CLOSED - AM04 - Account closed/invalid - RETRYABLE */
  AM04_ACCOUNT_CLOSED = 1,
  /** AC04_ACCOUNT_CLOSED - Other retryable codes */
  AC04_ACCOUNT_CLOSED = 2,
  /** AC06_ACCOUNT_BLOCKED - Account blocked */
  AC06_ACCOUNT_BLOCKED = 3,
  /** AG01_TRANSACTION_FORBIDDEN - Transaction forbidden */
  AG01_TRANSACTION_FORBIDDEN = 4,
  /** AG02_INVALID_FORMAT - Invalid bank operation code */
  AG02_INVALID_FORMAT = 5,
  /** BE04_MISSING_CREDITOR_ADDRESS - Missing creditor address */
  BE04_MISSING_CREDITOR_ADDRESS = 6,
  /** FF01_INVALID_FILE_FORMAT - Invalid file format */
  FF01_INVALID_FILE_FORMAT = 7,
  /** MD01_NO_MANDATE - No mandate */
  MD01_NO_MANDATE = 8,
  /** MD02_MISSING_MANDATORY_INFO - Missing mandatory infos */
  MD02_MISSING_MANDATORY_INFO = 9,
  /** MD06_REFUND_REQUEST - Refund request by end customer */
  MD06_REFUND_REQUEST = 10,
  /** MD07_END_CUSTOMER_DECEASED - End customer deceased */
  MD07_END_CUSTOMER_DECEASED = 11,
  /** MS02_NOT_SPECIFIED_REASON - Reason not specified by customer */
  MS02_NOT_SPECIFIED_REASON = 12,
  /** MS03_AGENT_REASON - Reason not specified by agent */
  MS03_AGENT_REASON = 13,
  /** RC01_INVALID_BIC - Bank identifier incorrect */
  RC01_INVALID_BIC = 14,
  /** RR01_MISSING_DEBTOR_ACCOUNT - Missing debtor account/ID */
  RR01_MISSING_DEBTOR_ACCOUNT = 15,
  /** RR02_MISSING_DEBTOR_NAME - Missing debtor name/address */
  RR02_MISSING_DEBTOR_NAME = 16,
  /** RR03_MISSING_CREDITOR_NAME - Missing creditor name/address */
  RR03_MISSING_CREDITOR_NAME = 17,
  /** RR04_REGULATORY_REASON - Regulatory reason */
  RR04_REGULATORY_REASON = 18,
  /** SL01_SPECIFIC_SERVICE_PROVIDER - Due to specific service offered */
  SL01_SPECIFIC_SERVICE_PROVIDER = 19,
  /** TM01_CUT_OFF_TIME - File received after cut-off time */
  TM01_CUT_OFF_TIME = 20,
  /** AC01_IBAN_INVALID - Non-retryable codes */
  AC01_IBAN_INVALID = 50,
  /** AC13_DEBTOR_ACCOUNT_TYPE - Invalid debtor account type - NOT RETRYABLE */
  AC13_DEBTOR_ACCOUNT_TYPE = 51,
  /** CNOR_CREDITOR_NOT_ON_WHITELIST - Creditor bank not registered - NOT RETRYABLE */
  CNOR_CREDITOR_NOT_ON_WHITELIST = 52,
  /** DNOR_DEBTOR_NOT_ON_WHITELIST - Debtor bank not registered - NOT RETRYABLE */
  DNOR_DEBTOR_NOT_ON_WHITELIST = 53,
  /** FF05_DUPLICATE_ENTRY - Duplicate - NOT RETRYABLE */
  FF05_DUPLICATE_ENTRY = 54,
  /** FOCR_FOLLOWING_CANCELLATION - Following cancellation request - NOT RETRYABLE */
  FOCR_FOLLOWING_CANCELLATION = 55,
  UNRECOGNIZED = -1,
}

export function rejectionReasonCodeFromJSON(object: any): RejectionReasonCode {
  switch (object) {
    case 0:
    case "REJECTION_REASON_CODE_UNSPECIFIED":
      return RejectionReasonCode.REJECTION_REASON_CODE_UNSPECIFIED;
    case 1:
    case "AM04_ACCOUNT_CLOSED":
      return RejectionReasonCode.AM04_ACCOUNT_CLOSED;
    case 2:
    case "AC04_ACCOUNT_CLOSED":
      return RejectionReasonCode.AC04_ACCOUNT_CLOSED;
    case 3:
    case "AC06_ACCOUNT_BLOCKED":
      return RejectionReasonCode.AC06_ACCOUNT_BLOCKED;
    case 4:
    case "AG01_TRANSACTION_FORBIDDEN":
      return RejectionReasonCode.AG01_TRANSACTION_FORBIDDEN;
    case 5:
    case "AG02_INVALID_FORMAT":
      return RejectionReasonCode.AG02_INVALID_FORMAT;
    case 6:
    case "BE04_MISSING_CREDITOR_ADDRESS":
      return RejectionReasonCode.BE04_MISSING_CREDITOR_ADDRESS;
    case 7:
    case "FF01_INVALID_FILE_FORMAT":
      return RejectionReasonCode.FF01_INVALID_FILE_FORMAT;
    case 8:
    case "MD01_NO_MANDATE":
      return RejectionReasonCode.MD01_NO_MANDATE;
    case 9:
    case "MD02_MISSING_MANDATORY_INFO":
      return RejectionReasonCode.MD02_MISSING_MANDATORY_INFO;
    case 10:
    case "MD06_REFUND_REQUEST":
      return RejectionReasonCode.MD06_REFUND_REQUEST;
    case 11:
    case "MD07_END_CUSTOMER_DECEASED":
      return RejectionReasonCode.MD07_END_CUSTOMER_DECEASED;
    case 12:
    case "MS02_NOT_SPECIFIED_REASON":
      return RejectionReasonCode.MS02_NOT_SPECIFIED_REASON;
    case 13:
    case "MS03_AGENT_REASON":
      return RejectionReasonCode.MS03_AGENT_REASON;
    case 14:
    case "RC01_INVALID_BIC":
      return RejectionReasonCode.RC01_INVALID_BIC;
    case 15:
    case "RR01_MISSING_DEBTOR_ACCOUNT":
      return RejectionReasonCode.RR01_MISSING_DEBTOR_ACCOUNT;
    case 16:
    case "RR02_MISSING_DEBTOR_NAME":
      return RejectionReasonCode.RR02_MISSING_DEBTOR_NAME;
    case 17:
    case "RR03_MISSING_CREDITOR_NAME":
      return RejectionReasonCode.RR03_MISSING_CREDITOR_NAME;
    case 18:
    case "RR04_REGULATORY_REASON":
      return RejectionReasonCode.RR04_REGULATORY_REASON;
    case 19:
    case "SL01_SPECIFIC_SERVICE_PROVIDER":
      return RejectionReasonCode.SL01_SPECIFIC_SERVICE_PROVIDER;
    case 20:
    case "TM01_CUT_OFF_TIME":
      return RejectionReasonCode.TM01_CUT_OFF_TIME;
    case 50:
    case "AC01_IBAN_INVALID":
      return RejectionReasonCode.AC01_IBAN_INVALID;
    case 51:
    case "AC13_DEBTOR_ACCOUNT_TYPE":
      return RejectionReasonCode.AC13_DEBTOR_ACCOUNT_TYPE;
    case 52:
    case "CNOR_CREDITOR_NOT_ON_WHITELIST":
      return RejectionReasonCode.CNOR_CREDITOR_NOT_ON_WHITELIST;
    case 53:
    case "DNOR_DEBTOR_NOT_ON_WHITELIST":
      return RejectionReasonCode.DNOR_DEBTOR_NOT_ON_WHITELIST;
    case 54:
    case "FF05_DUPLICATE_ENTRY":
      return RejectionReasonCode.FF05_DUPLICATE_ENTRY;
    case 55:
    case "FOCR_FOLLOWING_CANCELLATION":
      return RejectionReasonCode.FOCR_FOLLOWING_CANCELLATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RejectionReasonCode.UNRECOGNIZED;
  }
}

export function rejectionReasonCodeToJSON(object: RejectionReasonCode): string {
  switch (object) {
    case RejectionReasonCode.REJECTION_REASON_CODE_UNSPECIFIED:
      return "REJECTION_REASON_CODE_UNSPECIFIED";
    case RejectionReasonCode.AM04_ACCOUNT_CLOSED:
      return "AM04_ACCOUNT_CLOSED";
    case RejectionReasonCode.AC04_ACCOUNT_CLOSED:
      return "AC04_ACCOUNT_CLOSED";
    case RejectionReasonCode.AC06_ACCOUNT_BLOCKED:
      return "AC06_ACCOUNT_BLOCKED";
    case RejectionReasonCode.AG01_TRANSACTION_FORBIDDEN:
      return "AG01_TRANSACTION_FORBIDDEN";
    case RejectionReasonCode.AG02_INVALID_FORMAT:
      return "AG02_INVALID_FORMAT";
    case RejectionReasonCode.BE04_MISSING_CREDITOR_ADDRESS:
      return "BE04_MISSING_CREDITOR_ADDRESS";
    case RejectionReasonCode.FF01_INVALID_FILE_FORMAT:
      return "FF01_INVALID_FILE_FORMAT";
    case RejectionReasonCode.MD01_NO_MANDATE:
      return "MD01_NO_MANDATE";
    case RejectionReasonCode.MD02_MISSING_MANDATORY_INFO:
      return "MD02_MISSING_MANDATORY_INFO";
    case RejectionReasonCode.MD06_REFUND_REQUEST:
      return "MD06_REFUND_REQUEST";
    case RejectionReasonCode.MD07_END_CUSTOMER_DECEASED:
      return "MD07_END_CUSTOMER_DECEASED";
    case RejectionReasonCode.MS02_NOT_SPECIFIED_REASON:
      return "MS02_NOT_SPECIFIED_REASON";
    case RejectionReasonCode.MS03_AGENT_REASON:
      return "MS03_AGENT_REASON";
    case RejectionReasonCode.RC01_INVALID_BIC:
      return "RC01_INVALID_BIC";
    case RejectionReasonCode.RR01_MISSING_DEBTOR_ACCOUNT:
      return "RR01_MISSING_DEBTOR_ACCOUNT";
    case RejectionReasonCode.RR02_MISSING_DEBTOR_NAME:
      return "RR02_MISSING_DEBTOR_NAME";
    case RejectionReasonCode.RR03_MISSING_CREDITOR_NAME:
      return "RR03_MISSING_CREDITOR_NAME";
    case RejectionReasonCode.RR04_REGULATORY_REASON:
      return "RR04_REGULATORY_REASON";
    case RejectionReasonCode.SL01_SPECIFIC_SERVICE_PROVIDER:
      return "SL01_SPECIFIC_SERVICE_PROVIDER";
    case RejectionReasonCode.TM01_CUT_OFF_TIME:
      return "TM01_CUT_OFF_TIME";
    case RejectionReasonCode.AC01_IBAN_INVALID:
      return "AC01_IBAN_INVALID";
    case RejectionReasonCode.AC13_DEBTOR_ACCOUNT_TYPE:
      return "AC13_DEBTOR_ACCOUNT_TYPE";
    case RejectionReasonCode.CNOR_CREDITOR_NOT_ON_WHITELIST:
      return "CNOR_CREDITOR_NOT_ON_WHITELIST";
    case RejectionReasonCode.DNOR_DEBTOR_NOT_ON_WHITELIST:
      return "DNOR_DEBTOR_NOT_ON_WHITELIST";
    case RejectionReasonCode.FF05_DUPLICATE_ENTRY:
      return "FF05_DUPLICATE_ENTRY";
    case RejectionReasonCode.FOCR_FOLLOWING_CANCELLATION:
      return "FOCR_FOLLOWING_CANCELLATION";
    case RejectionReasonCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Retry eligibility decision */
export enum RetryEligibility {
  RETRY_ELIGIBILITY_UNSPECIFIED = 0,
  /** ELIGIBLE - Can retry */
  ELIGIBLE = 1,
  /** NOT_ELIGIBLE_REASON_CODE - Reason code is non-retryable */
  NOT_ELIGIBLE_REASON_CODE = 2,
  /** NOT_ELIGIBLE_MAX_ATTEMPTS - Max attempts reached */
  NOT_ELIGIBLE_MAX_ATTEMPTS = 3,
  /** NOT_ELIGIBLE_PAYMENT_SETTLED - Payment already settled elsewhere */
  NOT_ELIGIBLE_PAYMENT_SETTLED = 4,
  /** NOT_ELIGIBLE_CONTRACT_CANCELLED - Contract cancelled */
  NOT_ELIGIBLE_CONTRACT_CANCELLED = 5,
  /** NOT_ELIGIBLE_MANDATE_REVOKED - Mandate revoked */
  NOT_ELIGIBLE_MANDATE_REVOKED = 6,
  /** NOT_ELIGIBLE_CLIENT_BLOCKED - Client blocked/blacklisted */
  NOT_ELIGIBLE_CLIENT_BLOCKED = 7,
  /** NOT_ELIGIBLE_MANUAL_CANCEL - Manually cancelled by admin */
  NOT_ELIGIBLE_MANUAL_CANCEL = 8,
  UNRECOGNIZED = -1,
}

export function retryEligibilityFromJSON(object: any): RetryEligibility {
  switch (object) {
    case 0:
    case "RETRY_ELIGIBILITY_UNSPECIFIED":
      return RetryEligibility.RETRY_ELIGIBILITY_UNSPECIFIED;
    case 1:
    case "ELIGIBLE":
      return RetryEligibility.ELIGIBLE;
    case 2:
    case "NOT_ELIGIBLE_REASON_CODE":
      return RetryEligibility.NOT_ELIGIBLE_REASON_CODE;
    case 3:
    case "NOT_ELIGIBLE_MAX_ATTEMPTS":
      return RetryEligibility.NOT_ELIGIBLE_MAX_ATTEMPTS;
    case 4:
    case "NOT_ELIGIBLE_PAYMENT_SETTLED":
      return RetryEligibility.NOT_ELIGIBLE_PAYMENT_SETTLED;
    case 5:
    case "NOT_ELIGIBLE_CONTRACT_CANCELLED":
      return RetryEligibility.NOT_ELIGIBLE_CONTRACT_CANCELLED;
    case 6:
    case "NOT_ELIGIBLE_MANDATE_REVOKED":
      return RetryEligibility.NOT_ELIGIBLE_MANDATE_REVOKED;
    case 7:
    case "NOT_ELIGIBLE_CLIENT_BLOCKED":
      return RetryEligibility.NOT_ELIGIBLE_CLIENT_BLOCKED;
    case 8:
    case "NOT_ELIGIBLE_MANUAL_CANCEL":
      return RetryEligibility.NOT_ELIGIBLE_MANUAL_CANCEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RetryEligibility.UNRECOGNIZED;
  }
}

export function retryEligibilityToJSON(object: RetryEligibility): string {
  switch (object) {
    case RetryEligibility.RETRY_ELIGIBILITY_UNSPECIFIED:
      return "RETRY_ELIGIBILITY_UNSPECIFIED";
    case RetryEligibility.ELIGIBLE:
      return "ELIGIBLE";
    case RetryEligibility.NOT_ELIGIBLE_REASON_CODE:
      return "NOT_ELIGIBLE_REASON_CODE";
    case RetryEligibility.NOT_ELIGIBLE_MAX_ATTEMPTS:
      return "NOT_ELIGIBLE_MAX_ATTEMPTS";
    case RetryEligibility.NOT_ELIGIBLE_PAYMENT_SETTLED:
      return "NOT_ELIGIBLE_PAYMENT_SETTLED";
    case RetryEligibility.NOT_ELIGIBLE_CONTRACT_CANCELLED:
      return "NOT_ELIGIBLE_CONTRACT_CANCELLED";
    case RetryEligibility.NOT_ELIGIBLE_MANDATE_REVOKED:
      return "NOT_ELIGIBLE_MANDATE_REVOKED";
    case RetryEligibility.NOT_ELIGIBLE_CLIENT_BLOCKED:
      return "NOT_ELIGIBLE_CLIENT_BLOCKED";
    case RetryEligibility.NOT_ELIGIBLE_MANUAL_CANCEL:
      return "NOT_ELIGIBLE_MANUAL_CANCEL";
    case RetryEligibility.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Retry attempt status */
export enum RetryAttemptStatus {
  RETRY_ATTEMPT_STATUS_UNSPECIFIED = 0,
  /** SCHEDULED - Planned for future date */
  SCHEDULED = 1,
  /** IN_PROGRESS - Currently being processed */
  IN_PROGRESS = 2,
  /** SUBMITTED - Submitted to PSP, awaiting confirmation */
  SUBMITTED = 3,
  /** SUCCEEDED - Payment successful */
  SUCCEEDED = 4,
  /** FAILED - Payment failed (may trigger next retry) */
  FAILED = 5,
  /** CANCELLED - Manually cancelled */
  CANCELLED = 6,
  /** SKIPPED - Skipped due to condition (e.g., payment settled) */
  SKIPPED = 7,
  UNRECOGNIZED = -1,
}

export function retryAttemptStatusFromJSON(object: any): RetryAttemptStatus {
  switch (object) {
    case 0:
    case "RETRY_ATTEMPT_STATUS_UNSPECIFIED":
      return RetryAttemptStatus.RETRY_ATTEMPT_STATUS_UNSPECIFIED;
    case 1:
    case "SCHEDULED":
      return RetryAttemptStatus.SCHEDULED;
    case 2:
    case "IN_PROGRESS":
      return RetryAttemptStatus.IN_PROGRESS;
    case 3:
    case "SUBMITTED":
      return RetryAttemptStatus.SUBMITTED;
    case 4:
    case "SUCCEEDED":
      return RetryAttemptStatus.SUCCEEDED;
    case 5:
    case "FAILED":
      return RetryAttemptStatus.FAILED;
    case 6:
    case "CANCELLED":
      return RetryAttemptStatus.CANCELLED;
    case 7:
    case "SKIPPED":
      return RetryAttemptStatus.SKIPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RetryAttemptStatus.UNRECOGNIZED;
  }
}

export function retryAttemptStatusToJSON(object: RetryAttemptStatus): string {
  switch (object) {
    case RetryAttemptStatus.RETRY_ATTEMPT_STATUS_UNSPECIFIED:
      return "RETRY_ATTEMPT_STATUS_UNSPECIFIED";
    case RetryAttemptStatus.SCHEDULED:
      return "SCHEDULED";
    case RetryAttemptStatus.IN_PROGRESS:
      return "IN_PROGRESS";
    case RetryAttemptStatus.SUBMITTED:
      return "SUBMITTED";
    case RetryAttemptStatus.SUCCEEDED:
      return "SUCCEEDED";
    case RetryAttemptStatus.FAILED:
      return "FAILED";
    case RetryAttemptStatus.CANCELLED:
      return "CANCELLED";
    case RetryAttemptStatus.SKIPPED:
      return "SKIPPED";
    case RetryAttemptStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Retry job status (scheduler batch) */
export enum RetryJobStatus {
  RETRY_JOB_STATUS_UNSPECIFIED = 0,
  /** JOB_PENDING - Waiting to be picked up */
  JOB_PENDING = 1,
  /** JOB_RUNNING - Currently executing */
  JOB_RUNNING = 2,
  /** JOB_COMPLETED - Finished successfully */
  JOB_COMPLETED = 3,
  /** JOB_FAILED - Failed with errors */
  JOB_FAILED = 4,
  /** JOB_PARTIAL - Completed with some failures */
  JOB_PARTIAL = 5,
  UNRECOGNIZED = -1,
}

export function retryJobStatusFromJSON(object: any): RetryJobStatus {
  switch (object) {
    case 0:
    case "RETRY_JOB_STATUS_UNSPECIFIED":
      return RetryJobStatus.RETRY_JOB_STATUS_UNSPECIFIED;
    case 1:
    case "JOB_PENDING":
      return RetryJobStatus.JOB_PENDING;
    case 2:
    case "JOB_RUNNING":
      return RetryJobStatus.JOB_RUNNING;
    case 3:
    case "JOB_COMPLETED":
      return RetryJobStatus.JOB_COMPLETED;
    case 4:
    case "JOB_FAILED":
      return RetryJobStatus.JOB_FAILED;
    case 5:
    case "JOB_PARTIAL":
      return RetryJobStatus.JOB_PARTIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RetryJobStatus.UNRECOGNIZED;
  }
}

export function retryJobStatusToJSON(object: RetryJobStatus): string {
  switch (object) {
    case RetryJobStatus.RETRY_JOB_STATUS_UNSPECIFIED:
      return "RETRY_JOB_STATUS_UNSPECIFIED";
    case RetryJobStatus.JOB_PENDING:
      return "JOB_PENDING";
    case RetryJobStatus.JOB_RUNNING:
      return "JOB_RUNNING";
    case RetryJobStatus.JOB_COMPLETED:
      return "JOB_COMPLETED";
    case RetryJobStatus.JOB_FAILED:
      return "JOB_FAILED";
    case RetryJobStatus.JOB_PARTIAL:
      return "JOB_PARTIAL";
    case RetryJobStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reminder channel */
export enum ReminderChannel {
  REMINDER_CHANNEL_UNSPECIFIED = 0,
  EMAIL = 1,
  SMS = 2,
  /** PHONE_CALL - Task for call center */
  PHONE_CALL = 3,
  PUSH_NOTIFICATION = 4,
  POSTAL_MAIL = 5,
  UNRECOGNIZED = -1,
}

export function reminderChannelFromJSON(object: any): ReminderChannel {
  switch (object) {
    case 0:
    case "REMINDER_CHANNEL_UNSPECIFIED":
      return ReminderChannel.REMINDER_CHANNEL_UNSPECIFIED;
    case 1:
    case "EMAIL":
      return ReminderChannel.EMAIL;
    case 2:
    case "SMS":
      return ReminderChannel.SMS;
    case 3:
    case "PHONE_CALL":
      return ReminderChannel.PHONE_CALL;
    case 4:
    case "PUSH_NOTIFICATION":
      return ReminderChannel.PUSH_NOTIFICATION;
    case 5:
    case "POSTAL_MAIL":
      return ReminderChannel.POSTAL_MAIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReminderChannel.UNRECOGNIZED;
  }
}

export function reminderChannelToJSON(object: ReminderChannel): string {
  switch (object) {
    case ReminderChannel.REMINDER_CHANNEL_UNSPECIFIED:
      return "REMINDER_CHANNEL_UNSPECIFIED";
    case ReminderChannel.EMAIL:
      return "EMAIL";
    case ReminderChannel.SMS:
      return "SMS";
    case ReminderChannel.PHONE_CALL:
      return "PHONE_CALL";
    case ReminderChannel.PUSH_NOTIFICATION:
      return "PUSH_NOTIFICATION";
    case ReminderChannel.POSTAL_MAIL:
      return "POSTAL_MAIL";
    case ReminderChannel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reminder status */
export enum ReminderStatus {
  REMINDER_STATUS_UNSPECIFIED = 0,
  /** REMINDER_PENDING - Queued for sending */
  REMINDER_PENDING = 1,
  /** REMINDER_SENT - Sent to provider */
  REMINDER_SENT = 2,
  /** REMINDER_DELIVERED - Confirmed delivered */
  REMINDER_DELIVERED = 3,
  /** REMINDER_FAILED - Delivery failed */
  REMINDER_FAILED = 4,
  /** REMINDER_CANCELLED - Cancelled before sending */
  REMINDER_CANCELLED = 5,
  /** REMINDER_BOUNCED - Bounced (email) */
  REMINDER_BOUNCED = 6,
  /** REMINDER_OPENED - Opened (email tracking) */
  REMINDER_OPENED = 7,
  /** REMINDER_CLICKED - Link clicked (email tracking) */
  REMINDER_CLICKED = 8,
  UNRECOGNIZED = -1,
}

export function reminderStatusFromJSON(object: any): ReminderStatus {
  switch (object) {
    case 0:
    case "REMINDER_STATUS_UNSPECIFIED":
      return ReminderStatus.REMINDER_STATUS_UNSPECIFIED;
    case 1:
    case "REMINDER_PENDING":
      return ReminderStatus.REMINDER_PENDING;
    case 2:
    case "REMINDER_SENT":
      return ReminderStatus.REMINDER_SENT;
    case 3:
    case "REMINDER_DELIVERED":
      return ReminderStatus.REMINDER_DELIVERED;
    case 4:
    case "REMINDER_FAILED":
      return ReminderStatus.REMINDER_FAILED;
    case 5:
    case "REMINDER_CANCELLED":
      return ReminderStatus.REMINDER_CANCELLED;
    case 6:
    case "REMINDER_BOUNCED":
      return ReminderStatus.REMINDER_BOUNCED;
    case 7:
    case "REMINDER_OPENED":
      return ReminderStatus.REMINDER_OPENED;
    case 8:
    case "REMINDER_CLICKED":
      return ReminderStatus.REMINDER_CLICKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReminderStatus.UNRECOGNIZED;
  }
}

export function reminderStatusToJSON(object: ReminderStatus): string {
  switch (object) {
    case ReminderStatus.REMINDER_STATUS_UNSPECIFIED:
      return "REMINDER_STATUS_UNSPECIFIED";
    case ReminderStatus.REMINDER_PENDING:
      return "REMINDER_PENDING";
    case ReminderStatus.REMINDER_SENT:
      return "REMINDER_SENT";
    case ReminderStatus.REMINDER_DELIVERED:
      return "REMINDER_DELIVERED";
    case ReminderStatus.REMINDER_FAILED:
      return "REMINDER_FAILED";
    case ReminderStatus.REMINDER_CANCELLED:
      return "REMINDER_CANCELLED";
    case ReminderStatus.REMINDER_BOUNCED:
      return "REMINDER_BOUNCED";
    case ReminderStatus.REMINDER_OPENED:
      return "REMINDER_OPENED";
    case ReminderStatus.REMINDER_CLICKED:
      return "REMINDER_CLICKED";
    case ReminderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reminder trigger type */
export enum ReminderTrigger {
  REMINDER_TRIGGER_UNSPECIFIED = 0,
  /** ON_AM04_RECEIVED - When AM04 rejection received */
  ON_AM04_RECEIVED = 1,
  /** BEFORE_RETRY - X days before scheduled retry */
  BEFORE_RETRY = 2,
  /** AFTER_RETRY_FAILED - After a retry attempt failed */
  AFTER_RETRY_FAILED = 3,
  /** AFTER_ALL_RETRIES_EXHAUSTED - All retries failed */
  AFTER_ALL_RETRIES_EXHAUSTED = 4,
  /** MANUAL - Manually triggered by admin */
  MANUAL = 5,
  UNRECOGNIZED = -1,
}

export function reminderTriggerFromJSON(object: any): ReminderTrigger {
  switch (object) {
    case 0:
    case "REMINDER_TRIGGER_UNSPECIFIED":
      return ReminderTrigger.REMINDER_TRIGGER_UNSPECIFIED;
    case 1:
    case "ON_AM04_RECEIVED":
      return ReminderTrigger.ON_AM04_RECEIVED;
    case 2:
    case "BEFORE_RETRY":
      return ReminderTrigger.BEFORE_RETRY;
    case 3:
    case "AFTER_RETRY_FAILED":
      return ReminderTrigger.AFTER_RETRY_FAILED;
    case 4:
    case "AFTER_ALL_RETRIES_EXHAUSTED":
      return ReminderTrigger.AFTER_ALL_RETRIES_EXHAUSTED;
    case 5:
    case "MANUAL":
      return ReminderTrigger.MANUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReminderTrigger.UNRECOGNIZED;
  }
}

export function reminderTriggerToJSON(object: ReminderTrigger): string {
  switch (object) {
    case ReminderTrigger.REMINDER_TRIGGER_UNSPECIFIED:
      return "REMINDER_TRIGGER_UNSPECIFIED";
    case ReminderTrigger.ON_AM04_RECEIVED:
      return "ON_AM04_RECEIVED";
    case ReminderTrigger.BEFORE_RETRY:
      return "BEFORE_RETRY";
    case ReminderTrigger.AFTER_RETRY_FAILED:
      return "AFTER_RETRY_FAILED";
    case ReminderTrigger.AFTER_ALL_RETRIES_EXHAUSTED:
      return "AFTER_ALL_RETRIES_EXHAUSTED";
    case ReminderTrigger.MANUAL:
      return "MANUAL";
    case ReminderTrigger.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Policy defining retry behavior for a given context */
export interface RetryPolicy {
  id: string;
  organisationId: string;
  /** Scope (optional, for policy inheritance) */
  societeId?:
    | string
    | undefined;
  /** If set, applies to this product */
  productId?:
    | string
    | undefined;
  /** If set, applies to this channel */
  channelId?:
    | string
    | undefined;
  /** Policy name and description */
  name: string;
  description: string;
  /** Retry schedule (days after rejection) */
  retryDelaysDays: number[];
  /** Limits */
  maxAttempts: number;
  /** Maximum days from first rejection (default: 30) */
  maxTotalDays: number;
  /** Conditions */
  retryOnAm04: boolean;
  /** Additional retryable codes */
  retryableCodes: RejectionReasonCode[];
  /** Explicit non-retryable codes */
  nonRetryableCodes: RejectionReasonCode[];
  /** Stop conditions */
  stopOnPaymentSettled: boolean;
  /** Stop if contract cancelled */
  stopOnContractCancelled: boolean;
  /** Stop if mandate revoked */
  stopOnMandateRevoked: boolean;
  /** Backoff strategy (for future extensibility) */
  backoffStrategy: string;
  /** Active status */
  isActive: boolean;
  /** Default policy for organisation */
  isDefault: boolean;
  /** Priority (higher = more specific) */
  priority: number;
  /** Audit */
  createdAt: string;
  updatedAt: string;
  createdBy: string;
  updatedBy: string;
}

/** A retry schedule for a specific rejected payment */
export interface RetrySchedule {
  id: string;
  organisationId: string;
  societeId: string;
  /** Source payment reference */
  originalPaymentId: string;
  /** Reference to payment schedule */
  scheduleId: string;
  /** Invoice if applicable */
  factureId?:
    | string
    | undefined;
  /** Contract if applicable */
  contratId?:
    | string
    | undefined;
  /** Client reference */
  clientId: string;
  /** Rejection info */
  rejectionCode: RejectionReasonCode;
  /** Raw code from PSP */
  rejectionRawCode: string;
  rejectionMessage: string;
  rejectionDate?:
    | Date
    | undefined;
  /** Policy applied */
  retryPolicyId: string;
  /** Amount */
  amountCents: number;
  currency: string;
  /** Eligibility */
  eligibility: RetryEligibility;
  eligibilityReason: string;
  /** Current state */
  currentAttempt: number;
  maxAttempts: number;
  nextRetryDate?:
    | Date
    | undefined;
  /** Final outcome */
  isResolved: boolean;
  /** Why it was resolved */
  resolutionReason?: string | undefined;
  resolvedAt?:
    | Date
    | undefined;
  /** Idempotency */
  idempotencyKey: string;
  /** Audit */
  createdAt: string;
  updatedAt: string;
  metadata: { [key: string]: string };
}

export interface RetrySchedule_MetadataEntry {
  key: string;
  value: string;
}

/** Individual retry attempt */
export interface RetryAttempt {
  id: string;
  retryScheduleId: string;
  /** Attempt info */
  attemptNumber: number;
  plannedDate?: Date | undefined;
  executedAt?:
    | Date
    | undefined;
  /** Status */
  status: RetryAttemptStatus;
  /** Execution details */
  paymentIntentId?:
    | string
    | undefined;
  /** PSP payment reference */
  pspPaymentId?:
    | string
    | undefined;
  /** Raw PSP response (JSON) */
  pspResponse?:
    | string
    | undefined;
  /** Result */
  errorCode?: string | undefined;
  errorMessage?:
    | string
    | undefined;
  /** If failed with new code */
  newRejectionCode?:
    | RejectionReasonCode
    | undefined;
  /** Retry job reference */
  retryJobId?:
    | string
    | undefined;
  /** Idempotency */
  idempotencyKey: string;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

/** Batch job for scheduler execution */
export interface RetryJob {
  id: string;
  organisationId: string;
  /** Job parameters */
  targetDate?:
    | Date
    | undefined;
  /** Timezone for cutoff (e.g., "Europe/Paris") */
  timezone: string;
  /** Cutoff time (e.g., "10:00:00") */
  cutoffTime: string;
  /** Execution */
  scheduledAt?: Date | undefined;
  startedAt?: Date | undefined;
  completedAt?:
    | Date
    | undefined;
  /** Status */
  status: RetryJobStatus;
  /** Results */
  totalAttempts: number;
  successfulAttempts: number;
  failedAttempts: number;
  skippedAttempts: number;
  /** Error tracking */
  errorMessage?: string | undefined;
  failedScheduleIds: string[];
  /** Idempotency */
  idempotencyKey: string;
  /** Trigger */
  triggeredBy: string;
  isManual: boolean;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

/** Policy defining reminder behavior */
export interface ReminderPolicy {
  id: string;
  organisationId: string;
  /** Scope */
  societeId?:
    | string
    | undefined;
  /** Policy name */
  name: string;
  description: string;
  /** Trigger rules */
  triggerRules: ReminderTriggerRule[];
  /** Anti-spam / rate limiting */
  cooldownHours: number;
  /** Max reminders per day per client */
  maxRemindersPerDay: number;
  /** Max reminders per week per client */
  maxRemindersPerWeek: number;
  /** Time windows (hours in 24h format) */
  allowedStartHour: number;
  /** e.g., 19 (7:00 PM) */
  allowedEndHour: number;
  /** 0=Sunday, 1=Monday, ..., 6=Saturday */
  allowedDaysOfWeek: number[];
  /** Opt-out handling */
  respectOptOut: boolean;
  /** Active status */
  isActive: boolean;
  isDefault: boolean;
  priority: number;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

/** Trigger rule within a reminder policy */
export interface ReminderTriggerRule {
  id: string;
  trigger: ReminderTrigger;
  channel: ReminderChannel;
  /** Email/SMS template reference */
  templateId: string;
  /** Timing */
  delayHours: number;
  /** For BEFORE_RETRY trigger */
  daysBeforeRetry?:
    | number
    | undefined;
  /** Priority */
  order: number;
  /** Conditions */
  onlyIfNoResponse: boolean;
  /** Only on first AM04, not subsequent */
  onlyFirstRejection: boolean;
}

/** Individual reminder instance */
export interface Reminder {
  id: string;
  organisationId: string;
  societeId: string;
  /** References */
  retryScheduleId: string;
  /** If triggered by specific attempt */
  retryAttemptId?: string | undefined;
  clientId: string;
  /** Policy */
  reminderPolicyId: string;
  triggerRuleId: string;
  /** Channel and content */
  channel: ReminderChannel;
  templateId: string;
  templateVariables: { [key: string]: string };
  /** Trigger */
  trigger: ReminderTrigger;
  /** Scheduling */
  plannedAt?: Date | undefined;
  sentAt?: Date | undefined;
  deliveredAt?:
    | Date
    | undefined;
  /** Status */
  status: ReminderStatus;
  /** Delivery details */
  providerName?:
    | string
    | undefined;
  /** Provider's tracking ID */
  providerMessageId?:
    | string
    | undefined;
  /** Raw status from provider */
  deliveryStatusRaw?:
    | string
    | undefined;
  /** Error handling */
  errorCode?: string | undefined;
  errorMessage?:
    | string
    | undefined;
  /** Delivery retry count */
  retryCount: number;
  /** Idempotency */
  idempotencyKey: string;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

export interface Reminder_TemplateVariablesEntry {
  key: string;
  value: string;
}

/** Append-only audit log for all retry/reminder actions */
export interface RetryAuditLog {
  id: string;
  organisationId: string;
  /** What changed */
  entityType: string;
  entityId: string;
  /** "CREATED", "UPDATED", "STATUS_CHANGED", etc. */
  action: string;
  /** Change details */
  oldValue?:
    | string
    | undefined;
  /** JSON of new state */
  newValue: string;
  /** Comma-separated field names */
  changedFields?:
    | string
    | undefined;
  /** Context */
  retryScheduleId?: string | undefined;
  retryAttemptId?: string | undefined;
  reminderId?: string | undefined;
  paymentId?:
    | string
    | undefined;
  /** Actor */
  actorType: string;
  /** User ID if applicable */
  actorId?: string | undefined;
  actorIp: string;
  /** Timestamp (immutable) */
  timestamp?:
    | Date
    | undefined;
  /** Additional context */
  metadata: { [key: string]: string };
}

export interface RetryAuditLog_MetadataEntry {
  key: string;
  value: string;
}

/** Event: Payment rejected (input event) */
export interface PaymentRejectedEvent {
  eventId: string;
  organisationId: string;
  societeId: string;
  /** Payment info */
  paymentId: string;
  scheduleId: string;
  factureId?: string | undefined;
  contratId?: string | undefined;
  clientId: string;
  /** Rejection details */
  reasonCode: string;
  reasonMessage: string;
  /** Amount */
  amountCents: number;
  currency: string;
  /** PSP info */
  pspName: string;
  pspPaymentId?:
    | string
    | undefined;
  /** JSON */
  pspRawResponse?:
    | string
    | undefined;
  /** Timestamps */
  rejectedAt?: Date | undefined;
  eventTimestamp?:
    | Date
    | undefined;
  /** Idempotency */
  idempotencyKey: string;
}

/** Event: Retry scheduled */
export interface RetryScheduledEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  plannedDate?: Date | undefined;
  clientId: string;
  amountCents: number;
  currency: string;
  eventTimestamp?: Date | undefined;
}

/** Event: Retry executed */
export interface RetryExecutedEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  status: RetryAttemptStatus;
  paymentIntentId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  executedAt?: Date | undefined;
  eventTimestamp?: Date | undefined;
}

/** Event: Retry succeeded */
export interface RetrySucceededEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  paymentIntentId: string;
  amountCents: number;
  currency: string;
  succeededAt?: Date | undefined;
  eventTimestamp?: Date | undefined;
}

/** Event: Retry failed */
export interface RetryFailedEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  errorCode: string;
  errorMessage: string;
  newRejectionCode?: RejectionReasonCode | undefined;
  hasMoreAttempts: boolean;
  nextRetryDate?: Date | undefined;
  failedAt?: Date | undefined;
  eventTimestamp?: Date | undefined;
}

/** Event: Retry cancelled */
export interface RetryCancelledEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId?: string | undefined;
  cancellationReason: string;
  /** User ID or "SYSTEM" */
  cancelledBy: string;
  cancelledAt?: Date | undefined;
  eventTimestamp?: Date | undefined;
}

/** Event: Reminder planned */
export interface ReminderPlannedEvent {
  eventId: string;
  reminderId: string;
  retryScheduleId: string;
  channel: ReminderChannel;
  trigger: ReminderTrigger;
  plannedAt?: Date | undefined;
  clientId: string;
  eventTimestamp?: Date | undefined;
}

/** Event: Reminder sent */
export interface ReminderSentEvent {
  eventId: string;
  reminderId: string;
  channel: ReminderChannel;
  providerName: string;
  providerMessageId?: string | undefined;
  sentAt?: Date | undefined;
  eventTimestamp?: Date | undefined;
}

/** Event: Reminder failed */
export interface ReminderFailedEvent {
  eventId: string;
  reminderId: string;
  channel: ReminderChannel;
  errorCode: string;
  errorMessage: string;
  retryCount: number;
  willRetry: boolean;
  failedAt?: Date | undefined;
  eventTimestamp?: Date | undefined;
}

/** Event: Reminder cancelled */
export interface ReminderCancelledEvent {
  eventId: string;
  reminderId: string;
  cancellationReason: string;
  cancelledBy: string;
  cancelledAt?: Date | undefined;
  eventTimestamp?: Date | undefined;
}

/** Typed error responses */
export interface RetryError {
  code: string;
  message: string;
  details: { [key: string]: string };
}

export interface RetryError_DetailsEntry {
  key: string;
  value: string;
}

function createBaseRetryPolicy(): RetryPolicy {
  return {
    id: "",
    organisationId: "",
    societeId: undefined,
    productId: undefined,
    channelId: undefined,
    name: "",
    description: "",
    retryDelaysDays: [],
    maxAttempts: 0,
    maxTotalDays: 0,
    retryOnAm04: false,
    retryableCodes: [],
    nonRetryableCodes: [],
    stopOnPaymentSettled: false,
    stopOnContractCancelled: false,
    stopOnMandateRevoked: false,
    backoffStrategy: "",
    isActive: false,
    isDefault: false,
    priority: 0,
    createdAt: "",
    updatedAt: "",
    createdBy: "",
    updatedBy: "",
  };
}

export const RetryPolicy = {
  encode(message: RetryPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(26).string(message.societeId);
    }
    if (message.productId !== undefined) {
      writer.uint32(34).string(message.productId);
    }
    if (message.channelId !== undefined) {
      writer.uint32(42).string(message.channelId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    writer.uint32(66).fork();
    for (const v of message.retryDelaysDays) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.maxAttempts !== 0) {
      writer.uint32(72).int32(message.maxAttempts);
    }
    if (message.maxTotalDays !== 0) {
      writer.uint32(80).int32(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== false) {
      writer.uint32(88).bool(message.retryOnAm04);
    }
    writer.uint32(98).fork();
    for (const v of message.retryableCodes) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(106).fork();
    for (const v of message.nonRetryableCodes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.stopOnPaymentSettled !== false) {
      writer.uint32(112).bool(message.stopOnPaymentSettled);
    }
    if (message.stopOnContractCancelled !== false) {
      writer.uint32(120).bool(message.stopOnContractCancelled);
    }
    if (message.stopOnMandateRevoked !== false) {
      writer.uint32(128).bool(message.stopOnMandateRevoked);
    }
    if (message.backoffStrategy !== "") {
      writer.uint32(138).string(message.backoffStrategy);
    }
    if (message.isActive !== false) {
      writer.uint32(144).bool(message.isActive);
    }
    if (message.isDefault !== false) {
      writer.uint32(152).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(160).int32(message.priority);
    }
    if (message.createdAt !== "") {
      writer.uint32(170).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(178).string(message.updatedAt);
    }
    if (message.createdBy !== "") {
      writer.uint32(186).string(message.createdBy);
    }
    if (message.updatedBy !== "") {
      writer.uint32(194).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 8:
          if (tag === 64) {
            message.retryDelaysDays.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryDelaysDays.push(reader.int32());
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxTotalDays = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.retryOnAm04 = reader.bool();
          continue;
        case 12:
          if (tag === 96) {
            message.retryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 13:
          if (tag === 104) {
            message.nonRetryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nonRetryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.stopOnPaymentSettled = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.stopOnContractCancelled = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.stopOnMandateRevoked = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.backoffStrategy = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : undefined,
      productId: isSet(object.productId) ? globalThis.String(object.productId) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      retryDelaysDays: globalThis.Array.isArray(object?.retryDelaysDays)
        ? object.retryDelaysDays.map((e: any) => globalThis.Number(e))
        : [],
      maxAttempts: isSet(object.maxAttempts) ? globalThis.Number(object.maxAttempts) : 0,
      maxTotalDays: isSet(object.maxTotalDays) ? globalThis.Number(object.maxTotalDays) : 0,
      retryOnAm04: isSet(object.retryOnAm04) ? globalThis.Boolean(object.retryOnAm04) : false,
      retryableCodes: globalThis.Array.isArray(object?.retryableCodes)
        ? object.retryableCodes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : [],
      nonRetryableCodes: globalThis.Array.isArray(object?.nonRetryableCodes)
        ? object.nonRetryableCodes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : [],
      stopOnPaymentSettled: isSet(object.stopOnPaymentSettled)
        ? globalThis.Boolean(object.stopOnPaymentSettled)
        : false,
      stopOnContractCancelled: isSet(object.stopOnContractCancelled)
        ? globalThis.Boolean(object.stopOnContractCancelled)
        : false,
      stopOnMandateRevoked: isSet(object.stopOnMandateRevoked)
        ? globalThis.Boolean(object.stopOnMandateRevoked)
        : false,
      backoffStrategy: isSet(object.backoffStrategy) ? globalThis.String(object.backoffStrategy) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: RetryPolicy): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.productId !== undefined) {
      obj.productId = message.productId;
    }
    if (message.channelId !== undefined) {
      obj.channelId = message.channelId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.retryDelaysDays?.length) {
      obj.retryDelaysDays = message.retryDelaysDays.map((e) => Math.round(e));
    }
    if (message.maxAttempts !== 0) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.maxTotalDays !== 0) {
      obj.maxTotalDays = Math.round(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== false) {
      obj.retryOnAm04 = message.retryOnAm04;
    }
    if (message.retryableCodes?.length) {
      obj.retryableCodes = message.retryableCodes.map((e) => rejectionReasonCodeToJSON(e));
    }
    if (message.nonRetryableCodes?.length) {
      obj.nonRetryableCodes = message.nonRetryableCodes.map((e) => rejectionReasonCodeToJSON(e));
    }
    if (message.stopOnPaymentSettled !== false) {
      obj.stopOnPaymentSettled = message.stopOnPaymentSettled;
    }
    if (message.stopOnContractCancelled !== false) {
      obj.stopOnContractCancelled = message.stopOnContractCancelled;
    }
    if (message.stopOnMandateRevoked !== false) {
      obj.stopOnMandateRevoked = message.stopOnMandateRevoked;
    }
    if (message.backoffStrategy !== "") {
      obj.backoffStrategy = message.backoffStrategy;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy>, I>>(base?: I): RetryPolicy {
    return RetryPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy>, I>>(object: I): RetryPolicy {
    const message = createBaseRetryPolicy();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.productId = object.productId ?? undefined;
    message.channelId = object.channelId ?? undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.retryDelaysDays = object.retryDelaysDays?.map((e) => e) || [];
    message.maxAttempts = object.maxAttempts ?? 0;
    message.maxTotalDays = object.maxTotalDays ?? 0;
    message.retryOnAm04 = object.retryOnAm04 ?? false;
    message.retryableCodes = object.retryableCodes?.map((e) => e) || [];
    message.nonRetryableCodes = object.nonRetryableCodes?.map((e) => e) || [];
    message.stopOnPaymentSettled = object.stopOnPaymentSettled ?? false;
    message.stopOnContractCancelled = object.stopOnContractCancelled ?? false;
    message.stopOnMandateRevoked = object.stopOnMandateRevoked ?? false;
    message.backoffStrategy = object.backoffStrategy ?? "";
    message.isActive = object.isActive ?? false;
    message.isDefault = object.isDefault ?? false;
    message.priority = object.priority ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.createdBy = object.createdBy ?? "";
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseRetrySchedule(): RetrySchedule {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    originalPaymentId: "",
    scheduleId: "",
    factureId: undefined,
    contratId: undefined,
    clientId: "",
    rejectionCode: 0,
    rejectionRawCode: "",
    rejectionMessage: "",
    rejectionDate: undefined,
    retryPolicyId: "",
    amountCents: 0,
    currency: "",
    eligibility: 0,
    eligibilityReason: "",
    currentAttempt: 0,
    maxAttempts: 0,
    nextRetryDate: undefined,
    isResolved: false,
    resolutionReason: undefined,
    resolvedAt: undefined,
    idempotencyKey: "",
    createdAt: "",
    updatedAt: "",
    metadata: {},
  };
}

export const RetrySchedule = {
  encode(message: RetrySchedule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.originalPaymentId !== "") {
      writer.uint32(34).string(message.originalPaymentId);
    }
    if (message.scheduleId !== "") {
      writer.uint32(42).string(message.scheduleId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(50).string(message.factureId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(58).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(66).string(message.clientId);
    }
    if (message.rejectionCode !== 0) {
      writer.uint32(72).int32(message.rejectionCode);
    }
    if (message.rejectionRawCode !== "") {
      writer.uint32(82).string(message.rejectionRawCode);
    }
    if (message.rejectionMessage !== "") {
      writer.uint32(90).string(message.rejectionMessage);
    }
    if (message.rejectionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.rejectionDate), writer.uint32(98).fork()).ldelim();
    }
    if (message.retryPolicyId !== "") {
      writer.uint32(106).string(message.retryPolicyId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(112).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(122).string(message.currency);
    }
    if (message.eligibility !== 0) {
      writer.uint32(128).int32(message.eligibility);
    }
    if (message.eligibilityReason !== "") {
      writer.uint32(138).string(message.eligibilityReason);
    }
    if (message.currentAttempt !== 0) {
      writer.uint32(144).int32(message.currentAttempt);
    }
    if (message.maxAttempts !== 0) {
      writer.uint32(152).int32(message.maxAttempts);
    }
    if (message.nextRetryDate !== undefined) {
      Timestamp.encode(toTimestamp(message.nextRetryDate), writer.uint32(162).fork()).ldelim();
    }
    if (message.isResolved !== false) {
      writer.uint32(168).bool(message.isResolved);
    }
    if (message.resolutionReason !== undefined) {
      writer.uint32(178).string(message.resolutionReason);
    }
    if (message.resolvedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.resolvedAt), writer.uint32(186).fork()).ldelim();
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(194).string(message.idempotencyKey);
    }
    if (message.createdAt !== "") {
      writer.uint32(202).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(210).string(message.updatedAt);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      RetrySchedule_MetadataEntry.encode({ key: key as any, value }, writer.uint32(218).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetrySchedule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.originalPaymentId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.factureId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contratId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.rejectionCode = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.rejectionRawCode = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.rejectionMessage = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.rejectionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.retryPolicyId = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.amountCents = longToNumber(reader.int64() as Long);
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.eligibilityReason = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.currentAttempt = reader.int32();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.nextRetryDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.isResolved = reader.bool();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.resolutionReason = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.resolvedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          const entry27 = RetrySchedule_MetadataEntry.decode(reader, reader.uint32());
          if (entry27.value !== undefined) {
            message.metadata[entry27.key] = entry27.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrySchedule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      originalPaymentId: isSet(object.originalPaymentId) ? globalThis.String(object.originalPaymentId) : "",
      scheduleId: isSet(object.scheduleId) ? globalThis.String(object.scheduleId) : "",
      factureId: isSet(object.factureId) ? globalThis.String(object.factureId) : undefined,
      contratId: isSet(object.contratId) ? globalThis.String(object.contratId) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      rejectionCode: isSet(object.rejectionCode) ? rejectionReasonCodeFromJSON(object.rejectionCode) : 0,
      rejectionRawCode: isSet(object.rejectionRawCode) ? globalThis.String(object.rejectionRawCode) : "",
      rejectionMessage: isSet(object.rejectionMessage) ? globalThis.String(object.rejectionMessage) : "",
      rejectionDate: isSet(object.rejectionDate) ? fromJsonTimestamp(object.rejectionDate) : undefined,
      retryPolicyId: isSet(object.retryPolicyId) ? globalThis.String(object.retryPolicyId) : "",
      amountCents: isSet(object.amountCents) ? globalThis.Number(object.amountCents) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      eligibility: isSet(object.eligibility) ? retryEligibilityFromJSON(object.eligibility) : 0,
      eligibilityReason: isSet(object.eligibilityReason) ? globalThis.String(object.eligibilityReason) : "",
      currentAttempt: isSet(object.currentAttempt) ? globalThis.Number(object.currentAttempt) : 0,
      maxAttempts: isSet(object.maxAttempts) ? globalThis.Number(object.maxAttempts) : 0,
      nextRetryDate: isSet(object.nextRetryDate) ? fromJsonTimestamp(object.nextRetryDate) : undefined,
      isResolved: isSet(object.isResolved) ? globalThis.Boolean(object.isResolved) : false,
      resolutionReason: isSet(object.resolutionReason) ? globalThis.String(object.resolutionReason) : undefined,
      resolvedAt: isSet(object.resolvedAt) ? fromJsonTimestamp(object.resolvedAt) : undefined,
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RetrySchedule): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.originalPaymentId !== "") {
      obj.originalPaymentId = message.originalPaymentId;
    }
    if (message.scheduleId !== "") {
      obj.scheduleId = message.scheduleId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.rejectionCode !== 0) {
      obj.rejectionCode = rejectionReasonCodeToJSON(message.rejectionCode);
    }
    if (message.rejectionRawCode !== "") {
      obj.rejectionRawCode = message.rejectionRawCode;
    }
    if (message.rejectionMessage !== "") {
      obj.rejectionMessage = message.rejectionMessage;
    }
    if (message.rejectionDate !== undefined) {
      obj.rejectionDate = message.rejectionDate.toISOString();
    }
    if (message.retryPolicyId !== "") {
      obj.retryPolicyId = message.retryPolicyId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.eligibility !== 0) {
      obj.eligibility = retryEligibilityToJSON(message.eligibility);
    }
    if (message.eligibilityReason !== "") {
      obj.eligibilityReason = message.eligibilityReason;
    }
    if (message.currentAttempt !== 0) {
      obj.currentAttempt = Math.round(message.currentAttempt);
    }
    if (message.maxAttempts !== 0) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.nextRetryDate !== undefined) {
      obj.nextRetryDate = message.nextRetryDate.toISOString();
    }
    if (message.isResolved !== false) {
      obj.isResolved = message.isResolved;
    }
    if (message.resolutionReason !== undefined) {
      obj.resolutionReason = message.resolutionReason;
    }
    if (message.resolvedAt !== undefined) {
      obj.resolvedAt = message.resolvedAt.toISOString();
    }
    if (message.idempotencyKey !== "") {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetrySchedule>, I>>(base?: I): RetrySchedule {
    return RetrySchedule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetrySchedule>, I>>(object: I): RetrySchedule {
    const message = createBaseRetrySchedule();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.originalPaymentId = object.originalPaymentId ?? "";
    message.scheduleId = object.scheduleId ?? "";
    message.factureId = object.factureId ?? undefined;
    message.contratId = object.contratId ?? undefined;
    message.clientId = object.clientId ?? "";
    message.rejectionCode = object.rejectionCode ?? 0;
    message.rejectionRawCode = object.rejectionRawCode ?? "";
    message.rejectionMessage = object.rejectionMessage ?? "";
    message.rejectionDate = object.rejectionDate ?? undefined;
    message.retryPolicyId = object.retryPolicyId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.eligibility = object.eligibility ?? 0;
    message.eligibilityReason = object.eligibilityReason ?? "";
    message.currentAttempt = object.currentAttempt ?? 0;
    message.maxAttempts = object.maxAttempts ?? 0;
    message.nextRetryDate = object.nextRetryDate ?? undefined;
    message.isResolved = object.isResolved ?? false;
    message.resolutionReason = object.resolutionReason ?? undefined;
    message.resolvedAt = object.resolvedAt ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRetrySchedule_MetadataEntry(): RetrySchedule_MetadataEntry {
  return { key: "", value: "" };
}

export const RetrySchedule_MetadataEntry = {
  encode(message: RetrySchedule_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetrySchedule_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrySchedule_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrySchedule_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RetrySchedule_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetrySchedule_MetadataEntry>, I>>(base?: I): RetrySchedule_MetadataEntry {
    return RetrySchedule_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetrySchedule_MetadataEntry>, I>>(object: I): RetrySchedule_MetadataEntry {
    const message = createBaseRetrySchedule_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRetryAttempt(): RetryAttempt {
  return {
    id: "",
    retryScheduleId: "",
    attemptNumber: 0,
    plannedDate: undefined,
    executedAt: undefined,
    status: 0,
    paymentIntentId: undefined,
    pspPaymentId: undefined,
    pspResponse: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    newRejectionCode: undefined,
    retryJobId: undefined,
    idempotencyKey: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const RetryAttempt = {
  encode(message: RetryAttempt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(24).int32(message.attemptNumber);
    }
    if (message.plannedDate !== undefined) {
      Timestamp.encode(toTimestamp(message.plannedDate), writer.uint32(34).fork()).ldelim();
    }
    if (message.executedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.executedAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(58).string(message.paymentIntentId);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(66).string(message.pspPaymentId);
    }
    if (message.pspResponse !== undefined) {
      writer.uint32(74).string(message.pspResponse);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(82).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(90).string(message.errorMessage);
    }
    if (message.newRejectionCode !== undefined) {
      writer.uint32(96).int32(message.newRejectionCode);
    }
    if (message.retryJobId !== undefined) {
      writer.uint32(106).string(message.retryJobId);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(114).string(message.idempotencyKey);
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryAttempt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAttempt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.plannedDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.executedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pspResponse = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.newRejectionCode = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.retryJobId = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryAttempt {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      attemptNumber: isSet(object.attemptNumber) ? globalThis.Number(object.attemptNumber) : 0,
      plannedDate: isSet(object.plannedDate) ? fromJsonTimestamp(object.plannedDate) : undefined,
      executedAt: isSet(object.executedAt) ? fromJsonTimestamp(object.executedAt) : undefined,
      status: isSet(object.status) ? retryAttemptStatusFromJSON(object.status) : 0,
      paymentIntentId: isSet(object.paymentIntentId) ? globalThis.String(object.paymentIntentId) : undefined,
      pspPaymentId: isSet(object.pspPaymentId) ? globalThis.String(object.pspPaymentId) : undefined,
      pspResponse: isSet(object.pspResponse) ? globalThis.String(object.pspResponse) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      newRejectionCode: isSet(object.newRejectionCode)
        ? rejectionReasonCodeFromJSON(object.newRejectionCode)
        : undefined,
      retryJobId: isSet(object.retryJobId) ? globalThis.String(object.retryJobId) : undefined,
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: RetryAttempt): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.attemptNumber !== 0) {
      obj.attemptNumber = Math.round(message.attemptNumber);
    }
    if (message.plannedDate !== undefined) {
      obj.plannedDate = message.plannedDate.toISOString();
    }
    if (message.executedAt !== undefined) {
      obj.executedAt = message.executedAt.toISOString();
    }
    if (message.status !== 0) {
      obj.status = retryAttemptStatusToJSON(message.status);
    }
    if (message.paymentIntentId !== undefined) {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.pspResponse !== undefined) {
      obj.pspResponse = message.pspResponse;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.newRejectionCode !== undefined) {
      obj.newRejectionCode = rejectionReasonCodeToJSON(message.newRejectionCode);
    }
    if (message.retryJobId !== undefined) {
      obj.retryJobId = message.retryJobId;
    }
    if (message.idempotencyKey !== "") {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryAttempt>, I>>(base?: I): RetryAttempt {
    return RetryAttempt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryAttempt>, I>>(object: I): RetryAttempt {
    const message = createBaseRetryAttempt();
    message.id = object.id ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.attemptNumber = object.attemptNumber ?? 0;
    message.plannedDate = object.plannedDate ?? undefined;
    message.executedAt = object.executedAt ?? undefined;
    message.status = object.status ?? 0;
    message.paymentIntentId = object.paymentIntentId ?? undefined;
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.pspResponse = object.pspResponse ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.newRejectionCode = object.newRejectionCode ?? undefined;
    message.retryJobId = object.retryJobId ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseRetryJob(): RetryJob {
  return {
    id: "",
    organisationId: "",
    targetDate: undefined,
    timezone: "",
    cutoffTime: "",
    scheduledAt: undefined,
    startedAt: undefined,
    completedAt: undefined,
    status: 0,
    totalAttempts: 0,
    successfulAttempts: 0,
    failedAttempts: 0,
    skippedAttempts: 0,
    errorMessage: undefined,
    failedScheduleIds: [],
    idempotencyKey: "",
    triggeredBy: "",
    isManual: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const RetryJob = {
  encode(message: RetryJob, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.targetDate !== undefined) {
      Timestamp.encode(toTimestamp(message.targetDate), writer.uint32(26).fork()).ldelim();
    }
    if (message.timezone !== "") {
      writer.uint32(34).string(message.timezone);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(42).string(message.cutoffTime);
    }
    if (message.scheduledAt !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduledAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    if (message.totalAttempts !== 0) {
      writer.uint32(80).int32(message.totalAttempts);
    }
    if (message.successfulAttempts !== 0) {
      writer.uint32(88).int32(message.successfulAttempts);
    }
    if (message.failedAttempts !== 0) {
      writer.uint32(96).int32(message.failedAttempts);
    }
    if (message.skippedAttempts !== 0) {
      writer.uint32(104).int32(message.skippedAttempts);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(114).string(message.errorMessage);
    }
    for (const v of message.failedScheduleIds) {
      writer.uint32(122).string(v!);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(130).string(message.idempotencyKey);
    }
    if (message.triggeredBy !== "") {
      writer.uint32(138).string(message.triggeredBy);
    }
    if (message.isManual !== false) {
      writer.uint32(144).bool(message.isManual);
    }
    if (message.createdAt !== "") {
      writer.uint32(154).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(162).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryJob {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timezone = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.scheduledAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.totalAttempts = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.successfulAttempts = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.failedAttempts = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.skippedAttempts = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.failedScheduleIds.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.triggeredBy = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.isManual = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryJob {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      targetDate: isSet(object.targetDate) ? fromJsonTimestamp(object.targetDate) : undefined,
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
      cutoffTime: isSet(object.cutoffTime) ? globalThis.String(object.cutoffTime) : "",
      scheduledAt: isSet(object.scheduledAt) ? fromJsonTimestamp(object.scheduledAt) : undefined,
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      completedAt: isSet(object.completedAt) ? fromJsonTimestamp(object.completedAt) : undefined,
      status: isSet(object.status) ? retryJobStatusFromJSON(object.status) : 0,
      totalAttempts: isSet(object.totalAttempts) ? globalThis.Number(object.totalAttempts) : 0,
      successfulAttempts: isSet(object.successfulAttempts) ? globalThis.Number(object.successfulAttempts) : 0,
      failedAttempts: isSet(object.failedAttempts) ? globalThis.Number(object.failedAttempts) : 0,
      skippedAttempts: isSet(object.skippedAttempts) ? globalThis.Number(object.skippedAttempts) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      failedScheduleIds: globalThis.Array.isArray(object?.failedScheduleIds)
        ? object.failedScheduleIds.map((e: any) => globalThis.String(e))
        : [],
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : "",
      triggeredBy: isSet(object.triggeredBy) ? globalThis.String(object.triggeredBy) : "",
      isManual: isSet(object.isManual) ? globalThis.Boolean(object.isManual) : false,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: RetryJob): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.targetDate !== undefined) {
      obj.targetDate = message.targetDate.toISOString();
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    if (message.cutoffTime !== "") {
      obj.cutoffTime = message.cutoffTime;
    }
    if (message.scheduledAt !== undefined) {
      obj.scheduledAt = message.scheduledAt.toISOString();
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.status !== 0) {
      obj.status = retryJobStatusToJSON(message.status);
    }
    if (message.totalAttempts !== 0) {
      obj.totalAttempts = Math.round(message.totalAttempts);
    }
    if (message.successfulAttempts !== 0) {
      obj.successfulAttempts = Math.round(message.successfulAttempts);
    }
    if (message.failedAttempts !== 0) {
      obj.failedAttempts = Math.round(message.failedAttempts);
    }
    if (message.skippedAttempts !== 0) {
      obj.skippedAttempts = Math.round(message.skippedAttempts);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.failedScheduleIds?.length) {
      obj.failedScheduleIds = message.failedScheduleIds;
    }
    if (message.idempotencyKey !== "") {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.triggeredBy !== "") {
      obj.triggeredBy = message.triggeredBy;
    }
    if (message.isManual !== false) {
      obj.isManual = message.isManual;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryJob>, I>>(base?: I): RetryJob {
    return RetryJob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryJob>, I>>(object: I): RetryJob {
    const message = createBaseRetryJob();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.targetDate = object.targetDate ?? undefined;
    message.timezone = object.timezone ?? "";
    message.cutoffTime = object.cutoffTime ?? "";
    message.scheduledAt = object.scheduledAt ?? undefined;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.status = object.status ?? 0;
    message.totalAttempts = object.totalAttempts ?? 0;
    message.successfulAttempts = object.successfulAttempts ?? 0;
    message.failedAttempts = object.failedAttempts ?? 0;
    message.skippedAttempts = object.skippedAttempts ?? 0;
    message.errorMessage = object.errorMessage ?? undefined;
    message.failedScheduleIds = object.failedScheduleIds?.map((e) => e) || [];
    message.idempotencyKey = object.idempotencyKey ?? "";
    message.triggeredBy = object.triggeredBy ?? "";
    message.isManual = object.isManual ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseReminderPolicy(): ReminderPolicy {
  return {
    id: "",
    organisationId: "",
    societeId: undefined,
    name: "",
    description: "",
    triggerRules: [],
    cooldownHours: 0,
    maxRemindersPerDay: 0,
    maxRemindersPerWeek: 0,
    allowedStartHour: 0,
    allowedEndHour: 0,
    allowedDaysOfWeek: [],
    respectOptOut: false,
    isActive: false,
    isDefault: false,
    priority: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const ReminderPolicy = {
  encode(message: ReminderPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(26).string(message.societeId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.triggerRules) {
      ReminderTriggerRule.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.cooldownHours !== 0) {
      writer.uint32(56).int32(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== 0) {
      writer.uint32(64).int32(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== 0) {
      writer.uint32(72).int32(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== 0) {
      writer.uint32(80).int32(message.allowedStartHour);
    }
    if (message.allowedEndHour !== 0) {
      writer.uint32(88).int32(message.allowedEndHour);
    }
    writer.uint32(98).fork();
    for (const v of message.allowedDaysOfWeek) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.respectOptOut !== false) {
      writer.uint32(104).bool(message.respectOptOut);
    }
    if (message.isActive !== false) {
      writer.uint32(112).bool(message.isActive);
    }
    if (message.isDefault !== false) {
      writer.uint32(120).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(128).int32(message.priority);
    }
    if (message.createdAt !== "") {
      writer.uint32(138).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(146).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReminderPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.triggerRules.push(ReminderTriggerRule.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.cooldownHours = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.maxRemindersPerDay = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.maxRemindersPerWeek = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.allowedStartHour = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.allowedEndHour = reader.int32();
          continue;
        case 12:
          if (tag === 96) {
            message.allowedDaysOfWeek.push(reader.int32());

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedDaysOfWeek.push(reader.int32());
            }

            continue;
          }

          break;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.respectOptOut = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderPolicy {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      triggerRules: globalThis.Array.isArray(object?.triggerRules)
        ? object.triggerRules.map((e: any) => ReminderTriggerRule.fromJSON(e))
        : [],
      cooldownHours: isSet(object.cooldownHours) ? globalThis.Number(object.cooldownHours) : 0,
      maxRemindersPerDay: isSet(object.maxRemindersPerDay) ? globalThis.Number(object.maxRemindersPerDay) : 0,
      maxRemindersPerWeek: isSet(object.maxRemindersPerWeek) ? globalThis.Number(object.maxRemindersPerWeek) : 0,
      allowedStartHour: isSet(object.allowedStartHour) ? globalThis.Number(object.allowedStartHour) : 0,
      allowedEndHour: isSet(object.allowedEndHour) ? globalThis.Number(object.allowedEndHour) : 0,
      allowedDaysOfWeek: globalThis.Array.isArray(object?.allowedDaysOfWeek)
        ? object.allowedDaysOfWeek.map((e: any) => globalThis.Number(e))
        : [],
      respectOptOut: isSet(object.respectOptOut) ? globalThis.Boolean(object.respectOptOut) : false,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: ReminderPolicy): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.triggerRules?.length) {
      obj.triggerRules = message.triggerRules.map((e) => ReminderTriggerRule.toJSON(e));
    }
    if (message.cooldownHours !== 0) {
      obj.cooldownHours = Math.round(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== 0) {
      obj.maxRemindersPerDay = Math.round(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== 0) {
      obj.maxRemindersPerWeek = Math.round(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== 0) {
      obj.allowedStartHour = Math.round(message.allowedStartHour);
    }
    if (message.allowedEndHour !== 0) {
      obj.allowedEndHour = Math.round(message.allowedEndHour);
    }
    if (message.allowedDaysOfWeek?.length) {
      obj.allowedDaysOfWeek = message.allowedDaysOfWeek.map((e) => Math.round(e));
    }
    if (message.respectOptOut !== false) {
      obj.respectOptOut = message.respectOptOut;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderPolicy>, I>>(base?: I): ReminderPolicy {
    return ReminderPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderPolicy>, I>>(object: I): ReminderPolicy {
    const message = createBaseReminderPolicy();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.triggerRules = object.triggerRules?.map((e) => ReminderTriggerRule.fromPartial(e)) || [];
    message.cooldownHours = object.cooldownHours ?? 0;
    message.maxRemindersPerDay = object.maxRemindersPerDay ?? 0;
    message.maxRemindersPerWeek = object.maxRemindersPerWeek ?? 0;
    message.allowedStartHour = object.allowedStartHour ?? 0;
    message.allowedEndHour = object.allowedEndHour ?? 0;
    message.allowedDaysOfWeek = object.allowedDaysOfWeek?.map((e) => e) || [];
    message.respectOptOut = object.respectOptOut ?? false;
    message.isActive = object.isActive ?? false;
    message.isDefault = object.isDefault ?? false;
    message.priority = object.priority ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseReminderTriggerRule(): ReminderTriggerRule {
  return {
    id: "",
    trigger: 0,
    channel: 0,
    templateId: "",
    delayHours: 0,
    daysBeforeRetry: undefined,
    order: 0,
    onlyIfNoResponse: false,
    onlyFirstRejection: false,
  };
}

export const ReminderTriggerRule = {
  encode(message: ReminderTriggerRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.trigger !== 0) {
      writer.uint32(16).int32(message.trigger);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.templateId !== "") {
      writer.uint32(34).string(message.templateId);
    }
    if (message.delayHours !== 0) {
      writer.uint32(40).int32(message.delayHours);
    }
    if (message.daysBeforeRetry !== undefined) {
      writer.uint32(48).int32(message.daysBeforeRetry);
    }
    if (message.order !== 0) {
      writer.uint32(56).int32(message.order);
    }
    if (message.onlyIfNoResponse !== false) {
      writer.uint32(64).bool(message.onlyIfNoResponse);
    }
    if (message.onlyFirstRejection !== false) {
      writer.uint32(72).bool(message.onlyFirstRejection);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReminderTriggerRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderTriggerRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trigger = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.templateId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.delayHours = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.daysBeforeRetry = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.order = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.onlyIfNoResponse = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.onlyFirstRejection = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderTriggerRule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      trigger: isSet(object.trigger) ? reminderTriggerFromJSON(object.trigger) : 0,
      channel: isSet(object.channel) ? reminderChannelFromJSON(object.channel) : 0,
      templateId: isSet(object.templateId) ? globalThis.String(object.templateId) : "",
      delayHours: isSet(object.delayHours) ? globalThis.Number(object.delayHours) : 0,
      daysBeforeRetry: isSet(object.daysBeforeRetry) ? globalThis.Number(object.daysBeforeRetry) : undefined,
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      onlyIfNoResponse: isSet(object.onlyIfNoResponse) ? globalThis.Boolean(object.onlyIfNoResponse) : false,
      onlyFirstRejection: isSet(object.onlyFirstRejection) ? globalThis.Boolean(object.onlyFirstRejection) : false,
    };
  },

  toJSON(message: ReminderTriggerRule): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.trigger !== 0) {
      obj.trigger = reminderTriggerToJSON(message.trigger);
    }
    if (message.channel !== 0) {
      obj.channel = reminderChannelToJSON(message.channel);
    }
    if (message.templateId !== "") {
      obj.templateId = message.templateId;
    }
    if (message.delayHours !== 0) {
      obj.delayHours = Math.round(message.delayHours);
    }
    if (message.daysBeforeRetry !== undefined) {
      obj.daysBeforeRetry = Math.round(message.daysBeforeRetry);
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.onlyIfNoResponse !== false) {
      obj.onlyIfNoResponse = message.onlyIfNoResponse;
    }
    if (message.onlyFirstRejection !== false) {
      obj.onlyFirstRejection = message.onlyFirstRejection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderTriggerRule>, I>>(base?: I): ReminderTriggerRule {
    return ReminderTriggerRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderTriggerRule>, I>>(object: I): ReminderTriggerRule {
    const message = createBaseReminderTriggerRule();
    message.id = object.id ?? "";
    message.trigger = object.trigger ?? 0;
    message.channel = object.channel ?? 0;
    message.templateId = object.templateId ?? "";
    message.delayHours = object.delayHours ?? 0;
    message.daysBeforeRetry = object.daysBeforeRetry ?? undefined;
    message.order = object.order ?? 0;
    message.onlyIfNoResponse = object.onlyIfNoResponse ?? false;
    message.onlyFirstRejection = object.onlyFirstRejection ?? false;
    return message;
  },
};

function createBaseReminder(): Reminder {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    retryScheduleId: "",
    retryAttemptId: undefined,
    clientId: "",
    reminderPolicyId: "",
    triggerRuleId: "",
    channel: 0,
    templateId: "",
    templateVariables: {},
    trigger: 0,
    plannedAt: undefined,
    sentAt: undefined,
    deliveredAt: undefined,
    status: 0,
    providerName: undefined,
    providerMessageId: undefined,
    deliveryStatusRaw: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    retryCount: 0,
    idempotencyKey: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Reminder = {
  encode(message: Reminder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(34).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== undefined) {
      writer.uint32(42).string(message.retryAttemptId);
    }
    if (message.clientId !== "") {
      writer.uint32(50).string(message.clientId);
    }
    if (message.reminderPolicyId !== "") {
      writer.uint32(58).string(message.reminderPolicyId);
    }
    if (message.triggerRuleId !== "") {
      writer.uint32(66).string(message.triggerRuleId);
    }
    if (message.channel !== 0) {
      writer.uint32(72).int32(message.channel);
    }
    if (message.templateId !== "") {
      writer.uint32(82).string(message.templateId);
    }
    Object.entries(message.templateVariables).forEach(([key, value]) => {
      Reminder_TemplateVariablesEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).ldelim();
    });
    if (message.trigger !== 0) {
      writer.uint32(96).int32(message.trigger);
    }
    if (message.plannedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.plannedAt), writer.uint32(106).fork()).ldelim();
    }
    if (message.sentAt !== undefined) {
      Timestamp.encode(toTimestamp(message.sentAt), writer.uint32(114).fork()).ldelim();
    }
    if (message.deliveredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.deliveredAt), writer.uint32(122).fork()).ldelim();
    }
    if (message.status !== 0) {
      writer.uint32(128).int32(message.status);
    }
    if (message.providerName !== undefined) {
      writer.uint32(138).string(message.providerName);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(146).string(message.providerMessageId);
    }
    if (message.deliveryStatusRaw !== undefined) {
      writer.uint32(154).string(message.deliveryStatusRaw);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(162).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(170).string(message.errorMessage);
    }
    if (message.retryCount !== 0) {
      writer.uint32(176).int32(message.retryCount);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(186).string(message.idempotencyKey);
    }
    if (message.createdAt !== "") {
      writer.uint32(194).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(202).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Reminder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.reminderPolicyId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.triggerRuleId = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.templateId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = Reminder_TemplateVariablesEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.templateVariables[entry11.key] = entry11.value;
          }
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.trigger = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.plannedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.sentAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.deliveredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.providerName = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.deliveryStatusRaw = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reminder {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      retryAttemptId: isSet(object.retryAttemptId) ? globalThis.String(object.retryAttemptId) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      reminderPolicyId: isSet(object.reminderPolicyId) ? globalThis.String(object.reminderPolicyId) : "",
      triggerRuleId: isSet(object.triggerRuleId) ? globalThis.String(object.triggerRuleId) : "",
      channel: isSet(object.channel) ? reminderChannelFromJSON(object.channel) : 0,
      templateId: isSet(object.templateId) ? globalThis.String(object.templateId) : "",
      templateVariables: isObject(object.templateVariables)
        ? Object.entries(object.templateVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      trigger: isSet(object.trigger) ? reminderTriggerFromJSON(object.trigger) : 0,
      plannedAt: isSet(object.plannedAt) ? fromJsonTimestamp(object.plannedAt) : undefined,
      sentAt: isSet(object.sentAt) ? fromJsonTimestamp(object.sentAt) : undefined,
      deliveredAt: isSet(object.deliveredAt) ? fromJsonTimestamp(object.deliveredAt) : undefined,
      status: isSet(object.status) ? reminderStatusFromJSON(object.status) : 0,
      providerName: isSet(object.providerName) ? globalThis.String(object.providerName) : undefined,
      providerMessageId: isSet(object.providerMessageId) ? globalThis.String(object.providerMessageId) : undefined,
      deliveryStatusRaw: isSet(object.deliveryStatusRaw) ? globalThis.String(object.deliveryStatusRaw) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
    };
  },

  toJSON(message: Reminder): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== undefined) {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.reminderPolicyId !== "") {
      obj.reminderPolicyId = message.reminderPolicyId;
    }
    if (message.triggerRuleId !== "") {
      obj.triggerRuleId = message.triggerRuleId;
    }
    if (message.channel !== 0) {
      obj.channel = reminderChannelToJSON(message.channel);
    }
    if (message.templateId !== "") {
      obj.templateId = message.templateId;
    }
    if (message.templateVariables) {
      const entries = Object.entries(message.templateVariables);
      if (entries.length > 0) {
        obj.templateVariables = {};
        entries.forEach(([k, v]) => {
          obj.templateVariables[k] = v;
        });
      }
    }
    if (message.trigger !== 0) {
      obj.trigger = reminderTriggerToJSON(message.trigger);
    }
    if (message.plannedAt !== undefined) {
      obj.plannedAt = message.plannedAt.toISOString();
    }
    if (message.sentAt !== undefined) {
      obj.sentAt = message.sentAt.toISOString();
    }
    if (message.deliveredAt !== undefined) {
      obj.deliveredAt = message.deliveredAt.toISOString();
    }
    if (message.status !== 0) {
      obj.status = reminderStatusToJSON(message.status);
    }
    if (message.providerName !== undefined) {
      obj.providerName = message.providerName;
    }
    if (message.providerMessageId !== undefined) {
      obj.providerMessageId = message.providerMessageId;
    }
    if (message.deliveryStatusRaw !== undefined) {
      obj.deliveryStatusRaw = message.deliveryStatusRaw;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.idempotencyKey !== "") {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reminder>, I>>(base?: I): Reminder {
    return Reminder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reminder>, I>>(object: I): Reminder {
    const message = createBaseReminder();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.retryAttemptId = object.retryAttemptId ?? undefined;
    message.clientId = object.clientId ?? "";
    message.reminderPolicyId = object.reminderPolicyId ?? "";
    message.triggerRuleId = object.triggerRuleId ?? "";
    message.channel = object.channel ?? 0;
    message.templateId = object.templateId ?? "";
    message.templateVariables = Object.entries(object.templateVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.trigger = object.trigger ?? 0;
    message.plannedAt = object.plannedAt ?? undefined;
    message.sentAt = object.sentAt ?? undefined;
    message.deliveredAt = object.deliveredAt ?? undefined;
    message.status = object.status ?? 0;
    message.providerName = object.providerName ?? undefined;
    message.providerMessageId = object.providerMessageId ?? undefined;
    message.deliveryStatusRaw = object.deliveryStatusRaw ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.retryCount = object.retryCount ?? 0;
    message.idempotencyKey = object.idempotencyKey ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseReminder_TemplateVariablesEntry(): Reminder_TemplateVariablesEntry {
  return { key: "", value: "" };
}

export const Reminder_TemplateVariablesEntry = {
  encode(message: Reminder_TemplateVariablesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Reminder_TemplateVariablesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminder_TemplateVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reminder_TemplateVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Reminder_TemplateVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reminder_TemplateVariablesEntry>, I>>(base?: I): Reminder_TemplateVariablesEntry {
    return Reminder_TemplateVariablesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reminder_TemplateVariablesEntry>, I>>(
    object: I,
  ): Reminder_TemplateVariablesEntry {
    const message = createBaseReminder_TemplateVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRetryAuditLog(): RetryAuditLog {
  return {
    id: "",
    organisationId: "",
    entityType: "",
    entityId: "",
    action: "",
    oldValue: undefined,
    newValue: "",
    changedFields: undefined,
    retryScheduleId: undefined,
    retryAttemptId: undefined,
    reminderId: undefined,
    paymentId: undefined,
    actorType: "",
    actorId: undefined,
    actorIp: "",
    timestamp: undefined,
    metadata: {},
  };
}

export const RetryAuditLog = {
  encode(message: RetryAuditLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.oldValue !== undefined) {
      writer.uint32(50).string(message.oldValue);
    }
    if (message.newValue !== "") {
      writer.uint32(58).string(message.newValue);
    }
    if (message.changedFields !== undefined) {
      writer.uint32(66).string(message.changedFields);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(74).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== undefined) {
      writer.uint32(82).string(message.retryAttemptId);
    }
    if (message.reminderId !== undefined) {
      writer.uint32(90).string(message.reminderId);
    }
    if (message.paymentId !== undefined) {
      writer.uint32(98).string(message.paymentId);
    }
    if (message.actorType !== "") {
      writer.uint32(106).string(message.actorType);
    }
    if (message.actorId !== undefined) {
      writer.uint32(114).string(message.actorId);
    }
    if (message.actorIp !== "") {
      writer.uint32(122).string(message.actorIp);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(130).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      RetryAuditLog_MetadataEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryAuditLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oldValue = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.newValue = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.changedFields = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.actorIp = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = RetryAuditLog_MetadataEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.metadata[entry17.key] = entry17.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryAuditLog {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      oldValue: isSet(object.oldValue) ? globalThis.String(object.oldValue) : undefined,
      newValue: isSet(object.newValue) ? globalThis.String(object.newValue) : "",
      changedFields: isSet(object.changedFields) ? globalThis.String(object.changedFields) : undefined,
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : undefined,
      retryAttemptId: isSet(object.retryAttemptId) ? globalThis.String(object.retryAttemptId) : undefined,
      reminderId: isSet(object.reminderId) ? globalThis.String(object.reminderId) : undefined,
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : undefined,
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : undefined,
      actorIp: isSet(object.actorIp) ? globalThis.String(object.actorIp) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RetryAuditLog): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.oldValue !== undefined) {
      obj.oldValue = message.oldValue;
    }
    if (message.newValue !== "") {
      obj.newValue = message.newValue;
    }
    if (message.changedFields !== undefined) {
      obj.changedFields = message.changedFields;
    }
    if (message.retryScheduleId !== undefined) {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== undefined) {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.reminderId !== undefined) {
      obj.reminderId = message.reminderId;
    }
    if (message.paymentId !== undefined) {
      obj.paymentId = message.paymentId;
    }
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== undefined) {
      obj.actorId = message.actorId;
    }
    if (message.actorIp !== "") {
      obj.actorIp = message.actorIp;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryAuditLog>, I>>(base?: I): RetryAuditLog {
    return RetryAuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryAuditLog>, I>>(object: I): RetryAuditLog {
    const message = createBaseRetryAuditLog();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.entityType = object.entityType ?? "";
    message.entityId = object.entityId ?? "";
    message.action = object.action ?? "";
    message.oldValue = object.oldValue ?? undefined;
    message.newValue = object.newValue ?? "";
    message.changedFields = object.changedFields ?? undefined;
    message.retryScheduleId = object.retryScheduleId ?? undefined;
    message.retryAttemptId = object.retryAttemptId ?? undefined;
    message.reminderId = object.reminderId ?? undefined;
    message.paymentId = object.paymentId ?? undefined;
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? undefined;
    message.actorIp = object.actorIp ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRetryAuditLog_MetadataEntry(): RetryAuditLog_MetadataEntry {
  return { key: "", value: "" };
}

export const RetryAuditLog_MetadataEntry = {
  encode(message: RetryAuditLog_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryAuditLog_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAuditLog_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryAuditLog_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RetryAuditLog_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryAuditLog_MetadataEntry>, I>>(base?: I): RetryAuditLog_MetadataEntry {
    return RetryAuditLog_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryAuditLog_MetadataEntry>, I>>(object: I): RetryAuditLog_MetadataEntry {
    const message = createBaseRetryAuditLog_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePaymentRejectedEvent(): PaymentRejectedEvent {
  return {
    eventId: "",
    organisationId: "",
    societeId: "",
    paymentId: "",
    scheduleId: "",
    factureId: undefined,
    contratId: undefined,
    clientId: "",
    reasonCode: "",
    reasonMessage: "",
    amountCents: 0,
    currency: "",
    pspName: "",
    pspPaymentId: undefined,
    pspRawResponse: undefined,
    rejectedAt: undefined,
    eventTimestamp: undefined,
    idempotencyKey: "",
  };
}

export const PaymentRejectedEvent = {
  encode(message: PaymentRejectedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.paymentId !== "") {
      writer.uint32(34).string(message.paymentId);
    }
    if (message.scheduleId !== "") {
      writer.uint32(42).string(message.scheduleId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(50).string(message.factureId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(58).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(66).string(message.clientId);
    }
    if (message.reasonCode !== "") {
      writer.uint32(74).string(message.reasonCode);
    }
    if (message.reasonMessage !== "") {
      writer.uint32(82).string(message.reasonMessage);
    }
    if (message.amountCents !== 0) {
      writer.uint32(88).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(98).string(message.currency);
    }
    if (message.pspName !== "") {
      writer.uint32(106).string(message.pspName);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(114).string(message.pspPaymentId);
    }
    if (message.pspRawResponse !== undefined) {
      writer.uint32(122).string(message.pspRawResponse);
    }
    if (message.rejectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.rejectedAt), writer.uint32(130).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(138).fork()).ldelim();
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(146).string(message.idempotencyKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentRejectedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentRejectedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.factureId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contratId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.reasonCode = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.reasonMessage = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.amountCents = longToNumber(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.pspName = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.pspRawResponse = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.rejectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentRejectedEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      scheduleId: isSet(object.scheduleId) ? globalThis.String(object.scheduleId) : "",
      factureId: isSet(object.factureId) ? globalThis.String(object.factureId) : undefined,
      contratId: isSet(object.contratId) ? globalThis.String(object.contratId) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      reasonCode: isSet(object.reasonCode) ? globalThis.String(object.reasonCode) : "",
      reasonMessage: isSet(object.reasonMessage) ? globalThis.String(object.reasonMessage) : "",
      amountCents: isSet(object.amountCents) ? globalThis.Number(object.amountCents) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      pspName: isSet(object.pspName) ? globalThis.String(object.pspName) : "",
      pspPaymentId: isSet(object.pspPaymentId) ? globalThis.String(object.pspPaymentId) : undefined,
      pspRawResponse: isSet(object.pspRawResponse) ? globalThis.String(object.pspRawResponse) : undefined,
      rejectedAt: isSet(object.rejectedAt) ? fromJsonTimestamp(object.rejectedAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : "",
    };
  },

  toJSON(message: PaymentRejectedEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.scheduleId !== "") {
      obj.scheduleId = message.scheduleId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.reasonCode !== "") {
      obj.reasonCode = message.reasonCode;
    }
    if (message.reasonMessage !== "") {
      obj.reasonMessage = message.reasonMessage;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.pspName !== "") {
      obj.pspName = message.pspName;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.pspRawResponse !== undefined) {
      obj.pspRawResponse = message.pspRawResponse;
    }
    if (message.rejectedAt !== undefined) {
      obj.rejectedAt = message.rejectedAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    if (message.idempotencyKey !== "") {
      obj.idempotencyKey = message.idempotencyKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentRejectedEvent>, I>>(base?: I): PaymentRejectedEvent {
    return PaymentRejectedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentRejectedEvent>, I>>(object: I): PaymentRejectedEvent {
    const message = createBasePaymentRejectedEvent();
    message.eventId = object.eventId ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.paymentId = object.paymentId ?? "";
    message.scheduleId = object.scheduleId ?? "";
    message.factureId = object.factureId ?? undefined;
    message.contratId = object.contratId ?? undefined;
    message.clientId = object.clientId ?? "";
    message.reasonCode = object.reasonCode ?? "";
    message.reasonMessage = object.reasonMessage ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.pspName = object.pspName ?? "";
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.pspRawResponse = object.pspRawResponse ?? undefined;
    message.rejectedAt = object.rejectedAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? "";
    return message;
  },
};

function createBaseRetryScheduledEvent(): RetryScheduledEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: "",
    attemptNumber: 0,
    plannedDate: undefined,
    clientId: "",
    amountCents: 0,
    currency: "",
    eventTimestamp: undefined,
  };
}

export const RetryScheduledEvent = {
  encode(message: RetryScheduledEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.plannedDate !== undefined) {
      Timestamp.encode(toTimestamp(message.plannedDate), writer.uint32(42).fork()).ldelim();
    }
    if (message.clientId !== "") {
      writer.uint32(50).string(message.clientId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(56).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryScheduledEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryScheduledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.plannedDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amountCents = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryScheduledEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      retryAttemptId: isSet(object.retryAttemptId) ? globalThis.String(object.retryAttemptId) : "",
      attemptNumber: isSet(object.attemptNumber) ? globalThis.Number(object.attemptNumber) : 0,
      plannedDate: isSet(object.plannedDate) ? fromJsonTimestamp(object.plannedDate) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      amountCents: isSet(object.amountCents) ? globalThis.Number(object.amountCents) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: RetryScheduledEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== "") {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.attemptNumber !== 0) {
      obj.attemptNumber = Math.round(message.attemptNumber);
    }
    if (message.plannedDate !== undefined) {
      obj.plannedDate = message.plannedDate.toISOString();
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryScheduledEvent>, I>>(base?: I): RetryScheduledEvent {
    return RetryScheduledEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryScheduledEvent>, I>>(object: I): RetryScheduledEvent {
    const message = createBaseRetryScheduledEvent();
    message.eventId = object.eventId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.retryAttemptId = object.retryAttemptId ?? "";
    message.attemptNumber = object.attemptNumber ?? 0;
    message.plannedDate = object.plannedDate ?? undefined;
    message.clientId = object.clientId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseRetryExecutedEvent(): RetryExecutedEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: "",
    attemptNumber: 0,
    status: 0,
    paymentIntentId: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    executedAt: undefined,
    eventTimestamp: undefined,
  };
}

export const RetryExecutedEvent = {
  encode(message: RetryExecutedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(50).string(message.paymentIntentId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(58).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(66).string(message.errorMessage);
    }
    if (message.executedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.executedAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryExecutedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryExecutedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.executedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryExecutedEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      retryAttemptId: isSet(object.retryAttemptId) ? globalThis.String(object.retryAttemptId) : "",
      attemptNumber: isSet(object.attemptNumber) ? globalThis.Number(object.attemptNumber) : 0,
      status: isSet(object.status) ? retryAttemptStatusFromJSON(object.status) : 0,
      paymentIntentId: isSet(object.paymentIntentId) ? globalThis.String(object.paymentIntentId) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      executedAt: isSet(object.executedAt) ? fromJsonTimestamp(object.executedAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: RetryExecutedEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== "") {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.attemptNumber !== 0) {
      obj.attemptNumber = Math.round(message.attemptNumber);
    }
    if (message.status !== 0) {
      obj.status = retryAttemptStatusToJSON(message.status);
    }
    if (message.paymentIntentId !== undefined) {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.executedAt !== undefined) {
      obj.executedAt = message.executedAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryExecutedEvent>, I>>(base?: I): RetryExecutedEvent {
    return RetryExecutedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryExecutedEvent>, I>>(object: I): RetryExecutedEvent {
    const message = createBaseRetryExecutedEvent();
    message.eventId = object.eventId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.retryAttemptId = object.retryAttemptId ?? "";
    message.attemptNumber = object.attemptNumber ?? 0;
    message.status = object.status ?? 0;
    message.paymentIntentId = object.paymentIntentId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.executedAt = object.executedAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseRetrySucceededEvent(): RetrySucceededEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: "",
    attemptNumber: 0,
    paymentIntentId: "",
    amountCents: 0,
    currency: "",
    succeededAt: undefined,
    eventTimestamp: undefined,
  };
}

export const RetrySucceededEvent = {
  encode(message: RetrySucceededEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(42).string(message.paymentIntentId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(48).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.succeededAt !== undefined) {
      Timestamp.encode(toTimestamp(message.succeededAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetrySucceededEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrySucceededEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.amountCents = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.succeededAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrySucceededEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      retryAttemptId: isSet(object.retryAttemptId) ? globalThis.String(object.retryAttemptId) : "",
      attemptNumber: isSet(object.attemptNumber) ? globalThis.Number(object.attemptNumber) : 0,
      paymentIntentId: isSet(object.paymentIntentId) ? globalThis.String(object.paymentIntentId) : "",
      amountCents: isSet(object.amountCents) ? globalThis.Number(object.amountCents) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      succeededAt: isSet(object.succeededAt) ? fromJsonTimestamp(object.succeededAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: RetrySucceededEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== "") {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.attemptNumber !== 0) {
      obj.attemptNumber = Math.round(message.attemptNumber);
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.succeededAt !== undefined) {
      obj.succeededAt = message.succeededAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetrySucceededEvent>, I>>(base?: I): RetrySucceededEvent {
    return RetrySucceededEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetrySucceededEvent>, I>>(object: I): RetrySucceededEvent {
    const message = createBaseRetrySucceededEvent();
    message.eventId = object.eventId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.retryAttemptId = object.retryAttemptId ?? "";
    message.attemptNumber = object.attemptNumber ?? 0;
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.currency = object.currency ?? "";
    message.succeededAt = object.succeededAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseRetryFailedEvent(): RetryFailedEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: "",
    attemptNumber: 0,
    errorCode: "",
    errorMessage: "",
    newRejectionCode: undefined,
    hasMoreAttempts: false,
    nextRetryDate: undefined,
    failedAt: undefined,
    eventTimestamp: undefined,
  };
}

export const RetryFailedEvent = {
  encode(message: RetryFailedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.errorCode !== "") {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(50).string(message.errorMessage);
    }
    if (message.newRejectionCode !== undefined) {
      writer.uint32(56).int32(message.newRejectionCode);
    }
    if (message.hasMoreAttempts !== false) {
      writer.uint32(64).bool(message.hasMoreAttempts);
    }
    if (message.nextRetryDate !== undefined) {
      Timestamp.encode(toTimestamp(message.nextRetryDate), writer.uint32(74).fork()).ldelim();
    }
    if (message.failedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.failedAt), writer.uint32(82).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryFailedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryFailedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.newRejectionCode = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.hasMoreAttempts = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.nextRetryDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.failedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryFailedEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      retryAttemptId: isSet(object.retryAttemptId) ? globalThis.String(object.retryAttemptId) : "",
      attemptNumber: isSet(object.attemptNumber) ? globalThis.Number(object.attemptNumber) : 0,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      newRejectionCode: isSet(object.newRejectionCode)
        ? rejectionReasonCodeFromJSON(object.newRejectionCode)
        : undefined,
      hasMoreAttempts: isSet(object.hasMoreAttempts) ? globalThis.Boolean(object.hasMoreAttempts) : false,
      nextRetryDate: isSet(object.nextRetryDate) ? fromJsonTimestamp(object.nextRetryDate) : undefined,
      failedAt: isSet(object.failedAt) ? fromJsonTimestamp(object.failedAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: RetryFailedEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== "") {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.attemptNumber !== 0) {
      obj.attemptNumber = Math.round(message.attemptNumber);
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.newRejectionCode !== undefined) {
      obj.newRejectionCode = rejectionReasonCodeToJSON(message.newRejectionCode);
    }
    if (message.hasMoreAttempts !== false) {
      obj.hasMoreAttempts = message.hasMoreAttempts;
    }
    if (message.nextRetryDate !== undefined) {
      obj.nextRetryDate = message.nextRetryDate.toISOString();
    }
    if (message.failedAt !== undefined) {
      obj.failedAt = message.failedAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryFailedEvent>, I>>(base?: I): RetryFailedEvent {
    return RetryFailedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryFailedEvent>, I>>(object: I): RetryFailedEvent {
    const message = createBaseRetryFailedEvent();
    message.eventId = object.eventId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.retryAttemptId = object.retryAttemptId ?? "";
    message.attemptNumber = object.attemptNumber ?? 0;
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.newRejectionCode = object.newRejectionCode ?? undefined;
    message.hasMoreAttempts = object.hasMoreAttempts ?? false;
    message.nextRetryDate = object.nextRetryDate ?? undefined;
    message.failedAt = object.failedAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseRetryCancelledEvent(): RetryCancelledEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: undefined,
    cancellationReason: "",
    cancelledBy: "",
    cancelledAt: undefined,
    eventTimestamp: undefined,
  };
}

export const RetryCancelledEvent = {
  encode(message: RetryCancelledEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== undefined) {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.cancellationReason !== "") {
      writer.uint32(34).string(message.cancellationReason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(42).string(message.cancelledBy);
    }
    if (message.cancelledAt !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelledAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryCancelledEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryCancelledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cancellationReason = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cancelledAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryCancelledEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      retryAttemptId: isSet(object.retryAttemptId) ? globalThis.String(object.retryAttemptId) : undefined,
      cancellationReason: isSet(object.cancellationReason) ? globalThis.String(object.cancellationReason) : "",
      cancelledBy: isSet(object.cancelledBy) ? globalThis.String(object.cancelledBy) : "",
      cancelledAt: isSet(object.cancelledAt) ? fromJsonTimestamp(object.cancelledAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: RetryCancelledEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== undefined) {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.cancellationReason !== "") {
      obj.cancellationReason = message.cancellationReason;
    }
    if (message.cancelledBy !== "") {
      obj.cancelledBy = message.cancelledBy;
    }
    if (message.cancelledAt !== undefined) {
      obj.cancelledAt = message.cancelledAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryCancelledEvent>, I>>(base?: I): RetryCancelledEvent {
    return RetryCancelledEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryCancelledEvent>, I>>(object: I): RetryCancelledEvent {
    const message = createBaseRetryCancelledEvent();
    message.eventId = object.eventId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.retryAttemptId = object.retryAttemptId ?? undefined;
    message.cancellationReason = object.cancellationReason ?? "";
    message.cancelledBy = object.cancelledBy ?? "";
    message.cancelledAt = object.cancelledAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseReminderPlannedEvent(): ReminderPlannedEvent {
  return {
    eventId: "",
    reminderId: "",
    retryScheduleId: "",
    channel: 0,
    trigger: 0,
    plannedAt: undefined,
    clientId: "",
    eventTimestamp: undefined,
  };
}

export const ReminderPlannedEvent = {
  encode(message: ReminderPlannedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(26).string(message.retryScheduleId);
    }
    if (message.channel !== 0) {
      writer.uint32(32).int32(message.channel);
    }
    if (message.trigger !== 0) {
      writer.uint32(40).int32(message.trigger);
    }
    if (message.plannedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.plannedAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.clientId !== "") {
      writer.uint32(58).string(message.clientId);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReminderPlannedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderPlannedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.trigger = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.plannedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderPlannedEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      reminderId: isSet(object.reminderId) ? globalThis.String(object.reminderId) : "",
      retryScheduleId: isSet(object.retryScheduleId) ? globalThis.String(object.retryScheduleId) : "",
      channel: isSet(object.channel) ? reminderChannelFromJSON(object.channel) : 0,
      trigger: isSet(object.trigger) ? reminderTriggerFromJSON(object.trigger) : 0,
      plannedAt: isSet(object.plannedAt) ? fromJsonTimestamp(object.plannedAt) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: ReminderPlannedEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.reminderId !== "") {
      obj.reminderId = message.reminderId;
    }
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.channel !== 0) {
      obj.channel = reminderChannelToJSON(message.channel);
    }
    if (message.trigger !== 0) {
      obj.trigger = reminderTriggerToJSON(message.trigger);
    }
    if (message.plannedAt !== undefined) {
      obj.plannedAt = message.plannedAt.toISOString();
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderPlannedEvent>, I>>(base?: I): ReminderPlannedEvent {
    return ReminderPlannedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderPlannedEvent>, I>>(object: I): ReminderPlannedEvent {
    const message = createBaseReminderPlannedEvent();
    message.eventId = object.eventId ?? "";
    message.reminderId = object.reminderId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.channel = object.channel ?? 0;
    message.trigger = object.trigger ?? 0;
    message.plannedAt = object.plannedAt ?? undefined;
    message.clientId = object.clientId ?? "";
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseReminderSentEvent(): ReminderSentEvent {
  return {
    eventId: "",
    reminderId: "",
    channel: 0,
    providerName: "",
    providerMessageId: undefined,
    sentAt: undefined,
    eventTimestamp: undefined,
  };
}

export const ReminderSentEvent = {
  encode(message: ReminderSentEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.providerName !== "") {
      writer.uint32(34).string(message.providerName);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(42).string(message.providerMessageId);
    }
    if (message.sentAt !== undefined) {
      Timestamp.encode(toTimestamp(message.sentAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReminderSentEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderSentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.providerName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sentAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderSentEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      reminderId: isSet(object.reminderId) ? globalThis.String(object.reminderId) : "",
      channel: isSet(object.channel) ? reminderChannelFromJSON(object.channel) : 0,
      providerName: isSet(object.providerName) ? globalThis.String(object.providerName) : "",
      providerMessageId: isSet(object.providerMessageId) ? globalThis.String(object.providerMessageId) : undefined,
      sentAt: isSet(object.sentAt) ? fromJsonTimestamp(object.sentAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: ReminderSentEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.reminderId !== "") {
      obj.reminderId = message.reminderId;
    }
    if (message.channel !== 0) {
      obj.channel = reminderChannelToJSON(message.channel);
    }
    if (message.providerName !== "") {
      obj.providerName = message.providerName;
    }
    if (message.providerMessageId !== undefined) {
      obj.providerMessageId = message.providerMessageId;
    }
    if (message.sentAt !== undefined) {
      obj.sentAt = message.sentAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderSentEvent>, I>>(base?: I): ReminderSentEvent {
    return ReminderSentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderSentEvent>, I>>(object: I): ReminderSentEvent {
    const message = createBaseReminderSentEvent();
    message.eventId = object.eventId ?? "";
    message.reminderId = object.reminderId ?? "";
    message.channel = object.channel ?? 0;
    message.providerName = object.providerName ?? "";
    message.providerMessageId = object.providerMessageId ?? undefined;
    message.sentAt = object.sentAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseReminderFailedEvent(): ReminderFailedEvent {
  return {
    eventId: "",
    reminderId: "",
    channel: 0,
    errorCode: "",
    errorMessage: "",
    retryCount: 0,
    willRetry: false,
    failedAt: undefined,
    eventTimestamp: undefined,
  };
}

export const ReminderFailedEvent = {
  encode(message: ReminderFailedEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    if (message.retryCount !== 0) {
      writer.uint32(48).int32(message.retryCount);
    }
    if (message.willRetry !== false) {
      writer.uint32(56).bool(message.willRetry);
    }
    if (message.failedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.failedAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReminderFailedEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderFailedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.willRetry = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.failedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderFailedEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      reminderId: isSet(object.reminderId) ? globalThis.String(object.reminderId) : "",
      channel: isSet(object.channel) ? reminderChannelFromJSON(object.channel) : 0,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      willRetry: isSet(object.willRetry) ? globalThis.Boolean(object.willRetry) : false,
      failedAt: isSet(object.failedAt) ? fromJsonTimestamp(object.failedAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: ReminderFailedEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.reminderId !== "") {
      obj.reminderId = message.reminderId;
    }
    if (message.channel !== 0) {
      obj.channel = reminderChannelToJSON(message.channel);
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.willRetry !== false) {
      obj.willRetry = message.willRetry;
    }
    if (message.failedAt !== undefined) {
      obj.failedAt = message.failedAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderFailedEvent>, I>>(base?: I): ReminderFailedEvent {
    return ReminderFailedEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderFailedEvent>, I>>(object: I): ReminderFailedEvent {
    const message = createBaseReminderFailedEvent();
    message.eventId = object.eventId ?? "";
    message.reminderId = object.reminderId ?? "";
    message.channel = object.channel ?? 0;
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.retryCount = object.retryCount ?? 0;
    message.willRetry = object.willRetry ?? false;
    message.failedAt = object.failedAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseReminderCancelledEvent(): ReminderCancelledEvent {
  return {
    eventId: "",
    reminderId: "",
    cancellationReason: "",
    cancelledBy: "",
    cancelledAt: undefined,
    eventTimestamp: undefined,
  };
}

export const ReminderCancelledEvent = {
  encode(message: ReminderCancelledEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.cancellationReason !== "") {
      writer.uint32(26).string(message.cancellationReason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(34).string(message.cancelledBy);
    }
    if (message.cancelledAt !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelledAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTimestamp), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReminderCancelledEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderCancelledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cancellationReason = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cancelledAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.eventTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderCancelledEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      reminderId: isSet(object.reminderId) ? globalThis.String(object.reminderId) : "",
      cancellationReason: isSet(object.cancellationReason) ? globalThis.String(object.cancellationReason) : "",
      cancelledBy: isSet(object.cancelledBy) ? globalThis.String(object.cancelledBy) : "",
      cancelledAt: isSet(object.cancelledAt) ? fromJsonTimestamp(object.cancelledAt) : undefined,
      eventTimestamp: isSet(object.eventTimestamp) ? fromJsonTimestamp(object.eventTimestamp) : undefined,
    };
  },

  toJSON(message: ReminderCancelledEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.reminderId !== "") {
      obj.reminderId = message.reminderId;
    }
    if (message.cancellationReason !== "") {
      obj.cancellationReason = message.cancellationReason;
    }
    if (message.cancelledBy !== "") {
      obj.cancelledBy = message.cancelledBy;
    }
    if (message.cancelledAt !== undefined) {
      obj.cancelledAt = message.cancelledAt.toISOString();
    }
    if (message.eventTimestamp !== undefined) {
      obj.eventTimestamp = message.eventTimestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderCancelledEvent>, I>>(base?: I): ReminderCancelledEvent {
    return ReminderCancelledEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderCancelledEvent>, I>>(object: I): ReminderCancelledEvent {
    const message = createBaseReminderCancelledEvent();
    message.eventId = object.eventId ?? "";
    message.reminderId = object.reminderId ?? "";
    message.cancellationReason = object.cancellationReason ?? "";
    message.cancelledBy = object.cancelledBy ?? "";
    message.cancelledAt = object.cancelledAt ?? undefined;
    message.eventTimestamp = object.eventTimestamp ?? undefined;
    return message;
  },
};

function createBaseRetryError(): RetryError {
  return { code: "", message: "", details: {} };
}

export const RetryError = {
  encode(message: RetryError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      RetryError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = RetryError_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryError {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RetryError): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryError>, I>>(base?: I): RetryError {
    return RetryError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryError>, I>>(object: I): RetryError {
    const message = createBaseRetryError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRetryError_DetailsEntry(): RetryError_DetailsEntry {
  return { key: "", value: "" };
}

export const RetryError_DetailsEntry = {
  encode(message: RetryError_DetailsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RetryError_DetailsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryError_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RetryError_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryError_DetailsEntry>, I>>(base?: I): RetryError_DetailsEntry {
    return RetryError_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryError_DetailsEntry>, I>>(object: I): RetryError_DetailsEntry {
    const message = createBaseRetryError_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
