// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: retry/am04_retry_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { Timestamp } from "../google/protobuf/timestamp";
import {
  PaymentRejectedEvent,
  RejectionReasonCode,
  rejectionReasonCodeFromJSON,
  rejectionReasonCodeToJSON,
  Reminder,
  ReminderChannel,
  reminderChannelFromJSON,
  reminderChannelToJSON,
  ReminderPolicy,
  ReminderStatus,
  reminderStatusFromJSON,
  reminderStatusToJSON,
  ReminderTriggerRule,
  RetryAttempt,
  RetryAuditLog,
  RetryEligibility,
  retryEligibilityFromJSON,
  retryEligibilityToJSON,
  RetryJob,
  RetryJobStatus,
  retryJobStatusFromJSON,
  retryJobStatusToJSON,
  RetryPolicy,
  RetrySchedule,
} from "./am04_retry";

export const protobufPackage = "retry";

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface PaginationRequest {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResponse {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface GetRetryPolicyRequest {
  id: string;
}

export interface RetryPolicyResponse {
  policy: RetryPolicy | undefined;
}

export interface ListRetryPoliciesRequest {
  organisationId: string;
  societeId?: string | undefined;
  activeOnly?: boolean | undefined;
  pagination: PaginationRequest | undefined;
}

export interface ListRetryPoliciesResponse {
  policies: RetryPolicy[];
  pagination: PaginationResponse | undefined;
}

export interface CreateRetryPolicyRequest {
  organisationId: string;
  societeId?: string | undefined;
  productId?: string | undefined;
  channelId?: string | undefined;
  name: string;
  description: string;
  retryDelaysDays: number[];
  maxAttempts: number;
  maxTotalDays: number;
  retryOnAm04: boolean;
  retryableCodes: RejectionReasonCode[];
  nonRetryableCodes: RejectionReasonCode[];
  stopOnPaymentSettled: boolean;
  stopOnContractCancelled: boolean;
  stopOnMandateRevoked: boolean;
  backoffStrategy: string;
  isDefault: boolean;
  priority: number;
}

export interface UpdateRetryPolicyRequest {
  id: string;
  name?: string | undefined;
  description?: string | undefined;
  retryDelaysDays: number[];
  maxAttempts?: number | undefined;
  maxTotalDays?: number | undefined;
  retryOnAm04?: boolean | undefined;
  retryableCodes: RejectionReasonCode[];
  nonRetryableCodes: RejectionReasonCode[];
  stopOnPaymentSettled?: boolean | undefined;
  stopOnContractCancelled?: boolean | undefined;
  stopOnMandateRevoked?: boolean | undefined;
  backoffStrategy?: string | undefined;
  isActive?: boolean | undefined;
  isDefault?: boolean | undefined;
  priority?: number | undefined;
}

export interface DeleteRetryPolicyRequest {
  id: string;
}

export interface GetRetryScheduleRequest {
  id: string;
}

export interface RetryScheduleResponse {
  schedule: RetrySchedule | undefined;
  attempts: RetryAttempt[];
  reminders: Reminder[];
}

export interface ListRetrySchedulesRequest {
  organisationId: string;
  societeId?: string | undefined;
  clientId?: string | undefined;
  contratId?: string | undefined;
  eligibility?: RetryEligibility | undefined;
  isResolved?: boolean | undefined;
  fromDate?: Date | undefined;
  toDate?: Date | undefined;
  pagination: PaginationRequest | undefined;
}

export interface ListRetrySchedulesResponse {
  schedules: RetrySchedule[];
  pagination: PaginationResponse | undefined;
}

export interface CancelRetryScheduleRequest {
  id: string;
  reason: string;
  cancelledBy: string;
}

export interface ReplanRetryScheduleRequest {
  id: string;
  newRetryDate: Date | undefined;
  reason: string;
  replannedBy: string;
}

export interface GetRetryAttemptRequest {
  id: string;
}

export interface RetryAttemptResponse {
  attempt: RetryAttempt | undefined;
}

export interface ListRetryAttemptsRequest {
  retryScheduleId: string;
  pagination: PaginationRequest | undefined;
}

export interface ListRetryAttemptsResponse {
  attempts: RetryAttempt[];
  pagination: PaginationResponse | undefined;
}

export interface RunNowRequest {
  organisationId: string;
  retryScheduleId?: string | undefined;
  triggeredBy: string;
  dryRun: boolean;
}

export interface RunNowResponse {
  jobId: string;
  status: RetryJobStatus;
  message: string;
  scheduledCount: number;
}

export interface GetRetryJobStatusRequest {
  jobId: string;
}

export interface RetryJobResponse {
  job: RetryJob | undefined;
}

export interface ListRetryJobsRequest {
  organisationId: string;
  status?: RetryJobStatus | undefined;
  fromDate?: Date | undefined;
  toDate?: Date | undefined;
  pagination: PaginationRequest | undefined;
}

export interface ListRetryJobsResponse {
  jobs: RetryJob[];
  pagination: PaginationResponse | undefined;
}

export interface GetRetryMetricsRequest {
  organisationId: string;
  societeId?: string | undefined;
  fromDate: Date | undefined;
  toDate: Date | undefined;
}

export interface RetryMetricsResponse {
  totalRejections: number;
  am04Rejections: number;
  otherRejections: number;
  totalRetrySchedules: number;
  eligibleForRetry: number;
  notEligible: number;
  totalRetryAttempts: number;
  successfulRetries: number;
  failedRetries: number;
  pendingRetries: number;
  successRate: number;
  am04Rate: number;
  totalAmountRecoveredCents: number;
  totalAmountPendingCents: number;
  rejectionCodeBreakdown: RejectionCodeMetric[];
  dailyMetrics: DailyRetryMetric[];
}

export interface RejectionCodeMetric {
  code: RejectionReasonCode;
  codeRaw: string;
  count: number;
  percentage: number;
}

export interface DailyRetryMetric {
  date: string;
  rejections: number;
  retriesScheduled: number;
  retriesExecuted: number;
  retriesSucceeded: number;
  retriesFailed: number;
}

export interface GetAuditLogsRequest {
  organisationId: string;
  entityType?: string | undefined;
  entityId?: string | undefined;
  action?: string | undefined;
  fromDate?: Date | undefined;
  toDate?: Date | undefined;
  pagination: PaginationRequest | undefined;
}

export interface AuditLogsResponse {
  logs: RetryAuditLog[];
  pagination: PaginationResponse | undefined;
}

export interface ProcessDueRetriesRequest {
  organisationId: string;
  targetDate: Date | undefined;
  timezone: string;
  cutoffTime: string;
  dryRun: boolean;
}

export interface ProcessDueRetriesResponse {
  jobId: string;
  status: RetryJobStatus;
  totalProcessed: number;
  successful: number;
  failed: number;
  skipped: number;
  results: ProcessedRetryResult[];
}

export interface ProcessedRetryResult {
  retryScheduleId: string;
  retryAttemptId: string;
  success: boolean;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface CheckEligibilityRequest {
  paymentId: string;
  rejectionCode: string;
  organisationId: string;
  societeId?: string | undefined;
  contratId?: string | undefined;
  clientId?: string | undefined;
}

export interface CheckEligibilityResponse {
  eligibility: RetryEligibility;
  reason: string;
  applicablePolicyId?: string | undefined;
  firstRetryDate?: Date | undefined;
}

export interface HandleRejectionResponse {
  processed: boolean;
  retryScheduleId?: string | undefined;
  eligibility: RetryEligibility;
  message: string;
  reminderIds: string[];
}

export interface GetReminderPolicyRequest {
  id: string;
}

export interface ReminderPolicyResponse {
  policy: ReminderPolicy | undefined;
}

export interface ListReminderPoliciesRequest {
  organisationId: string;
  societeId?: string | undefined;
  activeOnly?: boolean | undefined;
  pagination: PaginationRequest | undefined;
}

export interface ListReminderPoliciesResponse {
  policies: ReminderPolicy[];
  pagination: PaginationResponse | undefined;
}

export interface CreateReminderPolicyRequest {
  organisationId: string;
  societeId?: string | undefined;
  name: string;
  description: string;
  triggerRules: ReminderTriggerRule[];
  cooldownHours: number;
  maxRemindersPerDay: number;
  maxRemindersPerWeek: number;
  allowedStartHour: number;
  allowedEndHour: number;
  allowedDaysOfWeek: number[];
  respectOptOut: boolean;
  isDefault: boolean;
  priority: number;
}

export interface UpdateReminderPolicyRequest {
  id: string;
  name?: string | undefined;
  description?: string | undefined;
  triggerRules: ReminderTriggerRule[];
  cooldownHours?: number | undefined;
  maxRemindersPerDay?: number | undefined;
  maxRemindersPerWeek?: number | undefined;
  allowedStartHour?: number | undefined;
  allowedEndHour?: number | undefined;
  allowedDaysOfWeek: number[];
  respectOptOut?: boolean | undefined;
  isActive?: boolean | undefined;
  isDefault?: boolean | undefined;
  priority?: number | undefined;
}

export interface DeleteReminderPolicyRequest {
  id: string;
}

export interface GetReminderRequest {
  id: string;
}

export interface ReminderResponse {
  reminder: Reminder | undefined;
}

export interface ListRemindersRequest {
  organisationId: string;
  retryScheduleId?: string | undefined;
  clientId?: string | undefined;
  channel?: ReminderChannel | undefined;
  status?: ReminderStatus | undefined;
  fromDate?: Date | undefined;
  toDate?: Date | undefined;
  pagination: PaginationRequest | undefined;
}

export interface ListRemindersResponse {
  reminders: Reminder[];
  pagination: PaginationResponse | undefined;
}

export interface CancelReminderRequest {
  id: string;
  reason: string;
  cancelledBy: string;
}

export interface SendReminderRequest {
  id: string;
  force: boolean;
}

export interface SendReminderResponse {
  success: boolean;
  message: string;
  providerMessageId?: string | undefined;
  errorCode?: string | undefined;
}

export interface ProcessDueRemindersRequest {
  organisationId: string;
  targetTime: Date | undefined;
  timezone: string;
  dryRun: boolean;
}

export interface ProcessDueRemindersResponse {
  totalProcessed: number;
  sent: number;
  failed: number;
  skipped: number;
  results: ProcessedReminderResult[];
}

export interface ProcessedReminderResult {
  reminderId: string;
  success: boolean;
  channel: ReminderChannel;
  providerMessageId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  skipReason?: string | undefined;
}

export interface UpdateDeliveryStatusRequest {
  reminderId: string;
  status: ReminderStatus;
  providerMessageId?: string | undefined;
  deliveryStatusRaw?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      sortBy: isSet(object.sortBy)
        ? globalThis.String(object.sortBy)
        : isSet(object.sort_by)
        ? globalThis.String(object.sort_by)
        : "",
      sortOrder: isSet(object.sortOrder)
        ? globalThis.String(object.sortOrder)
        : isSet(object.sort_order)
        ? globalThis.String(object.sort_order)
        : "",
    };
  },

  toJSON(message: PaginationRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationRequest>, I>>(base?: I): PaginationRequest {
    return PaginationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationRequest>, I>>(object: I): PaginationRequest {
    const message = createBasePaginationRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResponse {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: PaginationResponse): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResponse>, I>>(base?: I): PaginationResponse {
    return PaginationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResponse>, I>>(object: I): PaginationResponse {
    const message = createBasePaginationResponse();
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetRetryPolicyRequest(): GetRetryPolicyRequest {
  return { id: "" };
}

export const GetRetryPolicyRequest: MessageFns<GetRetryPolicyRequest> = {
  encode(message: GetRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRetryPolicyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetRetryPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRetryPolicyRequest>, I>>(base?: I): GetRetryPolicyRequest {
    return GetRetryPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRetryPolicyRequest>, I>>(object: I): GetRetryPolicyRequest {
    const message = createBaseGetRetryPolicyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRetryPolicyResponse(): RetryPolicyResponse {
  return { policy: undefined };
}

export const RetryPolicyResponse: MessageFns<RetryPolicyResponse> = {
  encode(message: RetryPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      RetryPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicyResponse {
    return { policy: isSet(object.policy) ? RetryPolicy.fromJSON(object.policy) : undefined };
  },

  toJSON(message: RetryPolicyResponse): unknown {
    const obj: any = {};
    if (message.policy !== undefined) {
      obj.policy = RetryPolicy.toJSON(message.policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicyResponse>, I>>(base?: I): RetryPolicyResponse {
    return RetryPolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicyResponse>, I>>(object: I): RetryPolicyResponse {
    const message = createBaseRetryPolicyResponse();
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? RetryPolicy.fromPartial(object.policy)
      : undefined;
    return message;
  },
};

function createBaseListRetryPoliciesRequest(): ListRetryPoliciesRequest {
  return { organisationId: "", societeId: undefined, activeOnly: undefined, pagination: undefined };
}

export const ListRetryPoliciesRequest: MessageFns<ListRetryPoliciesRequest> = {
  encode(message: ListRetryPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.activeOnly !== undefined) {
      writer.uint32(24).bool(message.activeOnly);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetryPoliciesRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      activeOnly: isSet(object.activeOnly)
        ? globalThis.Boolean(object.activeOnly)
        : isSet(object.active_only)
        ? globalThis.Boolean(object.active_only)
        : undefined,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetryPoliciesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.activeOnly !== undefined) {
      obj.activeOnly = message.activeOnly;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetryPoliciesRequest>, I>>(base?: I): ListRetryPoliciesRequest {
    return ListRetryPoliciesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetryPoliciesRequest>, I>>(object: I): ListRetryPoliciesRequest {
    const message = createBaseListRetryPoliciesRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.activeOnly = object.activeOnly ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRetryPoliciesResponse(): ListRetryPoliciesResponse {
  return { policies: [], pagination: undefined };
}

export const ListRetryPoliciesResponse: MessageFns<ListRetryPoliciesResponse> = {
  encode(message: ListRetryPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policies) {
      RetryPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policies.push(RetryPolicy.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetryPoliciesResponse {
    return {
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => RetryPolicy.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetryPoliciesResponse): unknown {
    const obj: any = {};
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => RetryPolicy.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetryPoliciesResponse>, I>>(base?: I): ListRetryPoliciesResponse {
    return ListRetryPoliciesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetryPoliciesResponse>, I>>(object: I): ListRetryPoliciesResponse {
    const message = createBaseListRetryPoliciesResponse();
    message.policies = object.policies?.map((e) => RetryPolicy.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseCreateRetryPolicyRequest(): CreateRetryPolicyRequest {
  return {
    organisationId: "",
    societeId: undefined,
    productId: undefined,
    channelId: undefined,
    name: "",
    description: "",
    retryDelaysDays: [],
    maxAttempts: 0,
    maxTotalDays: 0,
    retryOnAm04: false,
    retryableCodes: [],
    nonRetryableCodes: [],
    stopOnPaymentSettled: false,
    stopOnContractCancelled: false,
    stopOnMandateRevoked: false,
    backoffStrategy: "",
    isDefault: false,
    priority: 0,
  };
}

export const CreateRetryPolicyRequest: MessageFns<CreateRetryPolicyRequest> = {
  encode(message: CreateRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.productId !== undefined) {
      writer.uint32(26).string(message.productId);
    }
    if (message.channelId !== undefined) {
      writer.uint32(34).string(message.channelId);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    writer.uint32(58).fork();
    for (const v of message.retryDelaysDays) {
      writer.int32(v);
    }
    writer.join();
    if (message.maxAttempts !== 0) {
      writer.uint32(64).int32(message.maxAttempts);
    }
    if (message.maxTotalDays !== 0) {
      writer.uint32(72).int32(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== false) {
      writer.uint32(80).bool(message.retryOnAm04);
    }
    writer.uint32(90).fork();
    for (const v of message.retryableCodes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(98).fork();
    for (const v of message.nonRetryableCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.stopOnPaymentSettled !== false) {
      writer.uint32(104).bool(message.stopOnPaymentSettled);
    }
    if (message.stopOnContractCancelled !== false) {
      writer.uint32(112).bool(message.stopOnContractCancelled);
    }
    if (message.stopOnMandateRevoked !== false) {
      writer.uint32(120).bool(message.stopOnMandateRevoked);
    }
    if (message.backoffStrategy !== "") {
      writer.uint32(130).string(message.backoffStrategy);
    }
    if (message.isDefault !== false) {
      writer.uint32(136).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(144).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.retryDelaysDays.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryDelaysDays.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxTotalDays = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.retryOnAm04 = reader.bool();
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.retryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag === 96) {
            message.nonRetryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nonRetryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.stopOnPaymentSettled = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.stopOnContractCancelled = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.stopOnMandateRevoked = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.backoffStrategy = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRetryPolicyRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      productId: isSet(object.productId)
        ? globalThis.String(object.productId)
        : isSet(object.product_id)
        ? globalThis.String(object.product_id)
        : undefined,
      channelId: isSet(object.channelId)
        ? globalThis.String(object.channelId)
        : isSet(object.channel_id)
        ? globalThis.String(object.channel_id)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      retryDelaysDays: globalThis.Array.isArray(object?.retryDelaysDays)
        ? object.retryDelaysDays.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.retry_delays_days)
        ? object.retry_delays_days.map((e: any) => globalThis.Number(e))
        : [],
      maxAttempts: isSet(object.maxAttempts)
        ? globalThis.Number(object.maxAttempts)
        : isSet(object.max_attempts)
        ? globalThis.Number(object.max_attempts)
        : 0,
      maxTotalDays: isSet(object.maxTotalDays)
        ? globalThis.Number(object.maxTotalDays)
        : isSet(object.max_total_days)
        ? globalThis.Number(object.max_total_days)
        : 0,
      retryOnAm04: isSet(object.retryOnAm04)
        ? globalThis.Boolean(object.retryOnAm04)
        : isSet(object.retry_on_am04)
        ? globalThis.Boolean(object.retry_on_am04)
        : false,
      retryableCodes: globalThis.Array.isArray(object?.retryableCodes)
        ? object.retryableCodes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : globalThis.Array.isArray(object?.retryable_codes)
        ? object.retryable_codes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : [],
      nonRetryableCodes: globalThis.Array.isArray(object?.nonRetryableCodes)
        ? object.nonRetryableCodes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : globalThis.Array.isArray(object?.non_retryable_codes)
        ? object.non_retryable_codes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : [],
      stopOnPaymentSettled: isSet(object.stopOnPaymentSettled)
        ? globalThis.Boolean(object.stopOnPaymentSettled)
        : isSet(object.stop_on_payment_settled)
        ? globalThis.Boolean(object.stop_on_payment_settled)
        : false,
      stopOnContractCancelled: isSet(object.stopOnContractCancelled)
        ? globalThis.Boolean(object.stopOnContractCancelled)
        : isSet(object.stop_on_contract_cancelled)
        ? globalThis.Boolean(object.stop_on_contract_cancelled)
        : false,
      stopOnMandateRevoked: isSet(object.stopOnMandateRevoked)
        ? globalThis.Boolean(object.stopOnMandateRevoked)
        : isSet(object.stop_on_mandate_revoked)
        ? globalThis.Boolean(object.stop_on_mandate_revoked)
        : false,
      backoffStrategy: isSet(object.backoffStrategy)
        ? globalThis.String(object.backoffStrategy)
        : isSet(object.backoff_strategy)
        ? globalThis.String(object.backoff_strategy)
        : "",
      isDefault: isSet(object.isDefault)
        ? globalThis.Boolean(object.isDefault)
        : isSet(object.is_default)
        ? globalThis.Boolean(object.is_default)
        : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: CreateRetryPolicyRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.productId !== undefined) {
      obj.productId = message.productId;
    }
    if (message.channelId !== undefined) {
      obj.channelId = message.channelId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.retryDelaysDays?.length) {
      obj.retryDelaysDays = message.retryDelaysDays.map((e) => Math.round(e));
    }
    if (message.maxAttempts !== 0) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.maxTotalDays !== 0) {
      obj.maxTotalDays = Math.round(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== false) {
      obj.retryOnAm04 = message.retryOnAm04;
    }
    if (message.retryableCodes?.length) {
      obj.retryableCodes = message.retryableCodes.map((e) => rejectionReasonCodeToJSON(e));
    }
    if (message.nonRetryableCodes?.length) {
      obj.nonRetryableCodes = message.nonRetryableCodes.map((e) => rejectionReasonCodeToJSON(e));
    }
    if (message.stopOnPaymentSettled !== false) {
      obj.stopOnPaymentSettled = message.stopOnPaymentSettled;
    }
    if (message.stopOnContractCancelled !== false) {
      obj.stopOnContractCancelled = message.stopOnContractCancelled;
    }
    if (message.stopOnMandateRevoked !== false) {
      obj.stopOnMandateRevoked = message.stopOnMandateRevoked;
    }
    if (message.backoffStrategy !== "") {
      obj.backoffStrategy = message.backoffStrategy;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRetryPolicyRequest>, I>>(base?: I): CreateRetryPolicyRequest {
    return CreateRetryPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRetryPolicyRequest>, I>>(object: I): CreateRetryPolicyRequest {
    const message = createBaseCreateRetryPolicyRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.productId = object.productId ?? undefined;
    message.channelId = object.channelId ?? undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.retryDelaysDays = object.retryDelaysDays?.map((e) => e) || [];
    message.maxAttempts = object.maxAttempts ?? 0;
    message.maxTotalDays = object.maxTotalDays ?? 0;
    message.retryOnAm04 = object.retryOnAm04 ?? false;
    message.retryableCodes = object.retryableCodes?.map((e) => e) || [];
    message.nonRetryableCodes = object.nonRetryableCodes?.map((e) => e) || [];
    message.stopOnPaymentSettled = object.stopOnPaymentSettled ?? false;
    message.stopOnContractCancelled = object.stopOnContractCancelled ?? false;
    message.stopOnMandateRevoked = object.stopOnMandateRevoked ?? false;
    message.backoffStrategy = object.backoffStrategy ?? "";
    message.isDefault = object.isDefault ?? false;
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseUpdateRetryPolicyRequest(): UpdateRetryPolicyRequest {
  return {
    id: "",
    name: undefined,
    description: undefined,
    retryDelaysDays: [],
    maxAttempts: undefined,
    maxTotalDays: undefined,
    retryOnAm04: undefined,
    retryableCodes: [],
    nonRetryableCodes: [],
    stopOnPaymentSettled: undefined,
    stopOnContractCancelled: undefined,
    stopOnMandateRevoked: undefined,
    backoffStrategy: undefined,
    isActive: undefined,
    isDefault: undefined,
    priority: undefined,
  };
}

export const UpdateRetryPolicyRequest: MessageFns<UpdateRetryPolicyRequest> = {
  encode(message: UpdateRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    writer.uint32(34).fork();
    for (const v of message.retryDelaysDays) {
      writer.int32(v);
    }
    writer.join();
    if (message.maxAttempts !== undefined) {
      writer.uint32(40).int32(message.maxAttempts);
    }
    if (message.maxTotalDays !== undefined) {
      writer.uint32(48).int32(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== undefined) {
      writer.uint32(56).bool(message.retryOnAm04);
    }
    writer.uint32(66).fork();
    for (const v of message.retryableCodes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(74).fork();
    for (const v of message.nonRetryableCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.stopOnPaymentSettled !== undefined) {
      writer.uint32(80).bool(message.stopOnPaymentSettled);
    }
    if (message.stopOnContractCancelled !== undefined) {
      writer.uint32(88).bool(message.stopOnContractCancelled);
    }
    if (message.stopOnMandateRevoked !== undefined) {
      writer.uint32(96).bool(message.stopOnMandateRevoked);
    }
    if (message.backoffStrategy !== undefined) {
      writer.uint32(106).string(message.backoffStrategy);
    }
    if (message.isActive !== undefined) {
      writer.uint32(112).bool(message.isActive);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(120).bool(message.isDefault);
    }
    if (message.priority !== undefined) {
      writer.uint32(128).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.retryDelaysDays.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryDelaysDays.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxTotalDays = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.retryOnAm04 = reader.bool();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.retryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag === 72) {
            message.nonRetryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nonRetryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.stopOnPaymentSettled = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.stopOnContractCancelled = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.stopOnMandateRevoked = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.backoffStrategy = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRetryPolicyRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      retryDelaysDays: globalThis.Array.isArray(object?.retryDelaysDays)
        ? object.retryDelaysDays.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.retry_delays_days)
        ? object.retry_delays_days.map((e: any) => globalThis.Number(e))
        : [],
      maxAttempts: isSet(object.maxAttempts)
        ? globalThis.Number(object.maxAttempts)
        : isSet(object.max_attempts)
        ? globalThis.Number(object.max_attempts)
        : undefined,
      maxTotalDays: isSet(object.maxTotalDays)
        ? globalThis.Number(object.maxTotalDays)
        : isSet(object.max_total_days)
        ? globalThis.Number(object.max_total_days)
        : undefined,
      retryOnAm04: isSet(object.retryOnAm04)
        ? globalThis.Boolean(object.retryOnAm04)
        : isSet(object.retry_on_am04)
        ? globalThis.Boolean(object.retry_on_am04)
        : undefined,
      retryableCodes: globalThis.Array.isArray(object?.retryableCodes)
        ? object.retryableCodes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : globalThis.Array.isArray(object?.retryable_codes)
        ? object.retryable_codes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : [],
      nonRetryableCodes: globalThis.Array.isArray(object?.nonRetryableCodes)
        ? object.nonRetryableCodes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : globalThis.Array.isArray(object?.non_retryable_codes)
        ? object.non_retryable_codes.map((e: any) => rejectionReasonCodeFromJSON(e))
        : [],
      stopOnPaymentSettled: isSet(object.stopOnPaymentSettled)
        ? globalThis.Boolean(object.stopOnPaymentSettled)
        : isSet(object.stop_on_payment_settled)
        ? globalThis.Boolean(object.stop_on_payment_settled)
        : undefined,
      stopOnContractCancelled: isSet(object.stopOnContractCancelled)
        ? globalThis.Boolean(object.stopOnContractCancelled)
        : isSet(object.stop_on_contract_cancelled)
        ? globalThis.Boolean(object.stop_on_contract_cancelled)
        : undefined,
      stopOnMandateRevoked: isSet(object.stopOnMandateRevoked)
        ? globalThis.Boolean(object.stopOnMandateRevoked)
        : isSet(object.stop_on_mandate_revoked)
        ? globalThis.Boolean(object.stop_on_mandate_revoked)
        : undefined,
      backoffStrategy: isSet(object.backoffStrategy)
        ? globalThis.String(object.backoffStrategy)
        : isSet(object.backoff_strategy)
        ? globalThis.String(object.backoff_strategy)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
      isDefault: isSet(object.isDefault)
        ? globalThis.Boolean(object.isDefault)
        : isSet(object.is_default)
        ? globalThis.Boolean(object.is_default)
        : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : undefined,
    };
  },

  toJSON(message: UpdateRetryPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.retryDelaysDays?.length) {
      obj.retryDelaysDays = message.retryDelaysDays.map((e) => Math.round(e));
    }
    if (message.maxAttempts !== undefined) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.maxTotalDays !== undefined) {
      obj.maxTotalDays = Math.round(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== undefined) {
      obj.retryOnAm04 = message.retryOnAm04;
    }
    if (message.retryableCodes?.length) {
      obj.retryableCodes = message.retryableCodes.map((e) => rejectionReasonCodeToJSON(e));
    }
    if (message.nonRetryableCodes?.length) {
      obj.nonRetryableCodes = message.nonRetryableCodes.map((e) => rejectionReasonCodeToJSON(e));
    }
    if (message.stopOnPaymentSettled !== undefined) {
      obj.stopOnPaymentSettled = message.stopOnPaymentSettled;
    }
    if (message.stopOnContractCancelled !== undefined) {
      obj.stopOnContractCancelled = message.stopOnContractCancelled;
    }
    if (message.stopOnMandateRevoked !== undefined) {
      obj.stopOnMandateRevoked = message.stopOnMandateRevoked;
    }
    if (message.backoffStrategy !== undefined) {
      obj.backoffStrategy = message.backoffStrategy;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    if (message.isDefault !== undefined) {
      obj.isDefault = message.isDefault;
    }
    if (message.priority !== undefined) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRetryPolicyRequest>, I>>(base?: I): UpdateRetryPolicyRequest {
    return UpdateRetryPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRetryPolicyRequest>, I>>(object: I): UpdateRetryPolicyRequest {
    const message = createBaseUpdateRetryPolicyRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.retryDelaysDays = object.retryDelaysDays?.map((e) => e) || [];
    message.maxAttempts = object.maxAttempts ?? undefined;
    message.maxTotalDays = object.maxTotalDays ?? undefined;
    message.retryOnAm04 = object.retryOnAm04 ?? undefined;
    message.retryableCodes = object.retryableCodes?.map((e) => e) || [];
    message.nonRetryableCodes = object.nonRetryableCodes?.map((e) => e) || [];
    message.stopOnPaymentSettled = object.stopOnPaymentSettled ?? undefined;
    message.stopOnContractCancelled = object.stopOnContractCancelled ?? undefined;
    message.stopOnMandateRevoked = object.stopOnMandateRevoked ?? undefined;
    message.backoffStrategy = object.backoffStrategy ?? undefined;
    message.isActive = object.isActive ?? undefined;
    message.isDefault = object.isDefault ?? undefined;
    message.priority = object.priority ?? undefined;
    return message;
  },
};

function createBaseDeleteRetryPolicyRequest(): DeleteRetryPolicyRequest {
  return { id: "" };
}

export const DeleteRetryPolicyRequest: MessageFns<DeleteRetryPolicyRequest> = {
  encode(message: DeleteRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRetryPolicyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteRetryPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRetryPolicyRequest>, I>>(base?: I): DeleteRetryPolicyRequest {
    return DeleteRetryPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRetryPolicyRequest>, I>>(object: I): DeleteRetryPolicyRequest {
    const message = createBaseDeleteRetryPolicyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetRetryScheduleRequest(): GetRetryScheduleRequest {
  return { id: "" };
}

export const GetRetryScheduleRequest: MessageFns<GetRetryScheduleRequest> = {
  encode(message: GetRetryScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRetryScheduleRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetRetryScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRetryScheduleRequest>, I>>(base?: I): GetRetryScheduleRequest {
    return GetRetryScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRetryScheduleRequest>, I>>(object: I): GetRetryScheduleRequest {
    const message = createBaseGetRetryScheduleRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRetryScheduleResponse(): RetryScheduleResponse {
  return { schedule: undefined, attempts: [], reminders: [] };
}

export const RetryScheduleResponse: MessageFns<RetryScheduleResponse> = {
  encode(message: RetryScheduleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schedule !== undefined) {
      RetrySchedule.encode(message.schedule, writer.uint32(10).fork()).join();
    }
    for (const v of message.attempts) {
      RetryAttempt.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.reminders) {
      Reminder.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryScheduleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedule = RetrySchedule.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attempts.push(RetryAttempt.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reminders.push(Reminder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryScheduleResponse {
    return {
      schedule: isSet(object.schedule) ? RetrySchedule.fromJSON(object.schedule) : undefined,
      attempts: globalThis.Array.isArray(object?.attempts)
        ? object.attempts.map((e: any) => RetryAttempt.fromJSON(e))
        : [],
      reminders: globalThis.Array.isArray(object?.reminders)
        ? object.reminders.map((e: any) => Reminder.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RetryScheduleResponse): unknown {
    const obj: any = {};
    if (message.schedule !== undefined) {
      obj.schedule = RetrySchedule.toJSON(message.schedule);
    }
    if (message.attempts?.length) {
      obj.attempts = message.attempts.map((e) => RetryAttempt.toJSON(e));
    }
    if (message.reminders?.length) {
      obj.reminders = message.reminders.map((e) => Reminder.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryScheduleResponse>, I>>(base?: I): RetryScheduleResponse {
    return RetryScheduleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryScheduleResponse>, I>>(object: I): RetryScheduleResponse {
    const message = createBaseRetryScheduleResponse();
    message.schedule = (object.schedule !== undefined && object.schedule !== null)
      ? RetrySchedule.fromPartial(object.schedule)
      : undefined;
    message.attempts = object.attempts?.map((e) => RetryAttempt.fromPartial(e)) || [];
    message.reminders = object.reminders?.map((e) => Reminder.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRetrySchedulesRequest(): ListRetrySchedulesRequest {
  return {
    organisationId: "",
    societeId: undefined,
    clientId: undefined,
    contratId: undefined,
    eligibility: undefined,
    isResolved: undefined,
    fromDate: undefined,
    toDate: undefined,
    pagination: undefined,
  };
}

export const ListRetrySchedulesRequest: MessageFns<ListRetrySchedulesRequest> = {
  encode(message: ListRetrySchedulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(26).string(message.clientId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.eligibility !== undefined) {
      writer.uint32(40).int32(message.eligibility);
    }
    if (message.isResolved !== undefined) {
      writer.uint32(48).bool(message.isResolved);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(toTimestamp(message.fromDate), writer.uint32(58).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(toTimestamp(message.toDate), writer.uint32(66).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetrySchedulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetrySchedulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isResolved = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fromDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.toDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetrySchedulesRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : undefined,
      eligibility: isSet(object.eligibility) ? retryEligibilityFromJSON(object.eligibility) : undefined,
      isResolved: isSet(object.isResolved)
        ? globalThis.Boolean(object.isResolved)
        : isSet(object.is_resolved)
        ? globalThis.Boolean(object.is_resolved)
        : undefined,
      fromDate: isSet(object.fromDate)
        ? fromJsonTimestamp(object.fromDate)
        : isSet(object.from_date)
        ? fromJsonTimestamp(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? fromJsonTimestamp(object.toDate)
        : isSet(object.to_date)
        ? fromJsonTimestamp(object.to_date)
        : undefined,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetrySchedulesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.eligibility !== undefined) {
      obj.eligibility = retryEligibilityToJSON(message.eligibility);
    }
    if (message.isResolved !== undefined) {
      obj.isResolved = message.isResolved;
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate.toISOString();
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate.toISOString();
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetrySchedulesRequest>, I>>(base?: I): ListRetrySchedulesRequest {
    return ListRetrySchedulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetrySchedulesRequest>, I>>(object: I): ListRetrySchedulesRequest {
    const message = createBaseListRetrySchedulesRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.contratId = object.contratId ?? undefined;
    message.eligibility = object.eligibility ?? undefined;
    message.isResolved = object.isResolved ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRetrySchedulesResponse(): ListRetrySchedulesResponse {
  return { schedules: [], pagination: undefined };
}

export const ListRetrySchedulesResponse: MessageFns<ListRetrySchedulesResponse> = {
  encode(message: ListRetrySchedulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schedules) {
      RetrySchedule.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetrySchedulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetrySchedulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedules.push(RetrySchedule.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetrySchedulesResponse {
    return {
      schedules: globalThis.Array.isArray(object?.schedules)
        ? object.schedules.map((e: any) => RetrySchedule.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetrySchedulesResponse): unknown {
    const obj: any = {};
    if (message.schedules?.length) {
      obj.schedules = message.schedules.map((e) => RetrySchedule.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetrySchedulesResponse>, I>>(base?: I): ListRetrySchedulesResponse {
    return ListRetrySchedulesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetrySchedulesResponse>, I>>(object: I): ListRetrySchedulesResponse {
    const message = createBaseListRetrySchedulesResponse();
    message.schedules = object.schedules?.map((e) => RetrySchedule.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseCancelRetryScheduleRequest(): CancelRetryScheduleRequest {
  return { id: "", reason: "", cancelledBy: "" };
}

export const CancelRetryScheduleRequest: MessageFns<CancelRetryScheduleRequest> = {
  encode(message: CancelRetryScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(26).string(message.cancelledBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRetryScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRetryScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelRetryScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      cancelledBy: isSet(object.cancelledBy)
        ? globalThis.String(object.cancelledBy)
        : isSet(object.cancelled_by)
        ? globalThis.String(object.cancelled_by)
        : "",
    };
  },

  toJSON(message: CancelRetryScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.cancelledBy !== "") {
      obj.cancelledBy = message.cancelledBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelRetryScheduleRequest>, I>>(base?: I): CancelRetryScheduleRequest {
    return CancelRetryScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelRetryScheduleRequest>, I>>(object: I): CancelRetryScheduleRequest {
    const message = createBaseCancelRetryScheduleRequest();
    message.id = object.id ?? "";
    message.reason = object.reason ?? "";
    message.cancelledBy = object.cancelledBy ?? "";
    return message;
  },
};

function createBaseReplanRetryScheduleRequest(): ReplanRetryScheduleRequest {
  return { id: "", newRetryDate: undefined, reason: "", replannedBy: "" };
}

export const ReplanRetryScheduleRequest: MessageFns<ReplanRetryScheduleRequest> = {
  encode(message: ReplanRetryScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newRetryDate !== undefined) {
      Timestamp.encode(toTimestamp(message.newRetryDate), writer.uint32(18).fork()).join();
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.replannedBy !== "") {
      writer.uint32(34).string(message.replannedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplanRetryScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplanRetryScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newRetryDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.replannedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplanRetryScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      newRetryDate: isSet(object.newRetryDate)
        ? fromJsonTimestamp(object.newRetryDate)
        : isSet(object.new_retry_date)
        ? fromJsonTimestamp(object.new_retry_date)
        : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      replannedBy: isSet(object.replannedBy)
        ? globalThis.String(object.replannedBy)
        : isSet(object.replanned_by)
        ? globalThis.String(object.replanned_by)
        : "",
    };
  },

  toJSON(message: ReplanRetryScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.newRetryDate !== undefined) {
      obj.newRetryDate = message.newRetryDate.toISOString();
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.replannedBy !== "") {
      obj.replannedBy = message.replannedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReplanRetryScheduleRequest>, I>>(base?: I): ReplanRetryScheduleRequest {
    return ReplanRetryScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplanRetryScheduleRequest>, I>>(object: I): ReplanRetryScheduleRequest {
    const message = createBaseReplanRetryScheduleRequest();
    message.id = object.id ?? "";
    message.newRetryDate = object.newRetryDate ?? undefined;
    message.reason = object.reason ?? "";
    message.replannedBy = object.replannedBy ?? "";
    return message;
  },
};

function createBaseGetRetryAttemptRequest(): GetRetryAttemptRequest {
  return { id: "" };
}

export const GetRetryAttemptRequest: MessageFns<GetRetryAttemptRequest> = {
  encode(message: GetRetryAttemptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryAttemptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryAttemptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRetryAttemptRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetRetryAttemptRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRetryAttemptRequest>, I>>(base?: I): GetRetryAttemptRequest {
    return GetRetryAttemptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRetryAttemptRequest>, I>>(object: I): GetRetryAttemptRequest {
    const message = createBaseGetRetryAttemptRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseRetryAttemptResponse(): RetryAttemptResponse {
  return { attempt: undefined };
}

export const RetryAttemptResponse: MessageFns<RetryAttemptResponse> = {
  encode(message: RetryAttemptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attempt !== undefined) {
      RetryAttempt.encode(message.attempt, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryAttemptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAttemptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attempt = RetryAttempt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryAttemptResponse {
    return { attempt: isSet(object.attempt) ? RetryAttempt.fromJSON(object.attempt) : undefined };
  },

  toJSON(message: RetryAttemptResponse): unknown {
    const obj: any = {};
    if (message.attempt !== undefined) {
      obj.attempt = RetryAttempt.toJSON(message.attempt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryAttemptResponse>, I>>(base?: I): RetryAttemptResponse {
    return RetryAttemptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryAttemptResponse>, I>>(object: I): RetryAttemptResponse {
    const message = createBaseRetryAttemptResponse();
    message.attempt = (object.attempt !== undefined && object.attempt !== null)
      ? RetryAttempt.fromPartial(object.attempt)
      : undefined;
    return message;
  },
};

function createBaseListRetryAttemptsRequest(): ListRetryAttemptsRequest {
  return { retryScheduleId: "", pagination: undefined };
}

export const ListRetryAttemptsRequest: MessageFns<ListRetryAttemptsRequest> = {
  encode(message: ListRetryAttemptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryScheduleId !== "") {
      writer.uint32(10).string(message.retryScheduleId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryAttemptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryAttemptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetryAttemptsRequest {
    return {
      retryScheduleId: isSet(object.retryScheduleId)
        ? globalThis.String(object.retryScheduleId)
        : isSet(object.retry_schedule_id)
        ? globalThis.String(object.retry_schedule_id)
        : "",
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetryAttemptsRequest): unknown {
    const obj: any = {};
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetryAttemptsRequest>, I>>(base?: I): ListRetryAttemptsRequest {
    return ListRetryAttemptsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetryAttemptsRequest>, I>>(object: I): ListRetryAttemptsRequest {
    const message = createBaseListRetryAttemptsRequest();
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRetryAttemptsResponse(): ListRetryAttemptsResponse {
  return { attempts: [], pagination: undefined };
}

export const ListRetryAttemptsResponse: MessageFns<ListRetryAttemptsResponse> = {
  encode(message: ListRetryAttemptsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attempts) {
      RetryAttempt.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryAttemptsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryAttemptsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attempts.push(RetryAttempt.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetryAttemptsResponse {
    return {
      attempts: globalThis.Array.isArray(object?.attempts)
        ? object.attempts.map((e: any) => RetryAttempt.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetryAttemptsResponse): unknown {
    const obj: any = {};
    if (message.attempts?.length) {
      obj.attempts = message.attempts.map((e) => RetryAttempt.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetryAttemptsResponse>, I>>(base?: I): ListRetryAttemptsResponse {
    return ListRetryAttemptsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetryAttemptsResponse>, I>>(object: I): ListRetryAttemptsResponse {
    const message = createBaseListRetryAttemptsResponse();
    message.attempts = object.attempts?.map((e) => RetryAttempt.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseRunNowRequest(): RunNowRequest {
  return { organisationId: "", retryScheduleId: undefined, triggeredBy: "", dryRun: false };
}

export const RunNowRequest: MessageFns<RunNowRequest> = {
  encode(message: RunNowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.triggeredBy !== "") {
      writer.uint32(26).string(message.triggeredBy);
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunNowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunNowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.triggeredBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunNowRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      retryScheduleId: isSet(object.retryScheduleId)
        ? globalThis.String(object.retryScheduleId)
        : isSet(object.retry_schedule_id)
        ? globalThis.String(object.retry_schedule_id)
        : undefined,
      triggeredBy: isSet(object.triggeredBy)
        ? globalThis.String(object.triggeredBy)
        : isSet(object.triggered_by)
        ? globalThis.String(object.triggered_by)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
    };
  },

  toJSON(message: RunNowRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.retryScheduleId !== undefined) {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.triggeredBy !== "") {
      obj.triggeredBy = message.triggeredBy;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunNowRequest>, I>>(base?: I): RunNowRequest {
    return RunNowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunNowRequest>, I>>(object: I): RunNowRequest {
    const message = createBaseRunNowRequest();
    message.organisationId = object.organisationId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? undefined;
    message.triggeredBy = object.triggeredBy ?? "";
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseRunNowResponse(): RunNowResponse {
  return { jobId: "", status: 0, message: "", scheduledCount: 0 };
}

export const RunNowResponse: MessageFns<RunNowResponse> = {
  encode(message: RunNowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.scheduledCount !== 0) {
      writer.uint32(32).int32(message.scheduledCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunNowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunNowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scheduledCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunNowResponse {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      status: isSet(object.status) ? retryJobStatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      scheduledCount: isSet(object.scheduledCount)
        ? globalThis.Number(object.scheduledCount)
        : isSet(object.scheduled_count)
        ? globalThis.Number(object.scheduled_count)
        : 0,
    };
  },

  toJSON(message: RunNowResponse): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.status !== 0) {
      obj.status = retryJobStatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.scheduledCount !== 0) {
      obj.scheduledCount = Math.round(message.scheduledCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunNowResponse>, I>>(base?: I): RunNowResponse {
    return RunNowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunNowResponse>, I>>(object: I): RunNowResponse {
    const message = createBaseRunNowResponse();
    message.jobId = object.jobId ?? "";
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.scheduledCount = object.scheduledCount ?? 0;
    return message;
  },
};

function createBaseGetRetryJobStatusRequest(): GetRetryJobStatusRequest {
  return { jobId: "" };
}

export const GetRetryJobStatusRequest: MessageFns<GetRetryJobStatusRequest> = {
  encode(message: GetRetryJobStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryJobStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryJobStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRetryJobStatusRequest {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
    };
  },

  toJSON(message: GetRetryJobStatusRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRetryJobStatusRequest>, I>>(base?: I): GetRetryJobStatusRequest {
    return GetRetryJobStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRetryJobStatusRequest>, I>>(object: I): GetRetryJobStatusRequest {
    const message = createBaseGetRetryJobStatusRequest();
    message.jobId = object.jobId ?? "";
    return message;
  },
};

function createBaseRetryJobResponse(): RetryJobResponse {
  return { job: undefined };
}

export const RetryJobResponse: MessageFns<RetryJobResponse> = {
  encode(message: RetryJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      RetryJob.encode(message.job, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = RetryJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryJobResponse {
    return { job: isSet(object.job) ? RetryJob.fromJSON(object.job) : undefined };
  },

  toJSON(message: RetryJobResponse): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = RetryJob.toJSON(message.job);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryJobResponse>, I>>(base?: I): RetryJobResponse {
    return RetryJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryJobResponse>, I>>(object: I): RetryJobResponse {
    const message = createBaseRetryJobResponse();
    message.job = (object.job !== undefined && object.job !== null) ? RetryJob.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseListRetryJobsRequest(): ListRetryJobsRequest {
  return { organisationId: "", status: undefined, fromDate: undefined, toDate: undefined, pagination: undefined };
}

export const ListRetryJobsRequest: MessageFns<ListRetryJobsRequest> = {
  encode(message: ListRetryJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.status !== undefined) {
      writer.uint32(16).int32(message.status);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(toTimestamp(message.fromDate), writer.uint32(26).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(toTimestamp(message.toDate), writer.uint32(34).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetryJobsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      status: isSet(object.status) ? retryJobStatusFromJSON(object.status) : undefined,
      fromDate: isSet(object.fromDate)
        ? fromJsonTimestamp(object.fromDate)
        : isSet(object.from_date)
        ? fromJsonTimestamp(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? fromJsonTimestamp(object.toDate)
        : isSet(object.to_date)
        ? fromJsonTimestamp(object.to_date)
        : undefined,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetryJobsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.status !== undefined) {
      obj.status = retryJobStatusToJSON(message.status);
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate.toISOString();
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate.toISOString();
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetryJobsRequest>, I>>(base?: I): ListRetryJobsRequest {
    return ListRetryJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetryJobsRequest>, I>>(object: I): ListRetryJobsRequest {
    const message = createBaseListRetryJobsRequest();
    message.organisationId = object.organisationId ?? "";
    message.status = object.status ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRetryJobsResponse(): ListRetryJobsResponse {
  return { jobs: [], pagination: undefined };
}

export const ListRetryJobsResponse: MessageFns<ListRetryJobsResponse> = {
  encode(message: ListRetryJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      RetryJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(RetryJob.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetryJobsResponse {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => RetryJob.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRetryJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => RetryJob.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetryJobsResponse>, I>>(base?: I): ListRetryJobsResponse {
    return ListRetryJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetryJobsResponse>, I>>(object: I): ListRetryJobsResponse {
    const message = createBaseListRetryJobsResponse();
    message.jobs = object.jobs?.map((e) => RetryJob.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetRetryMetricsRequest(): GetRetryMetricsRequest {
  return { organisationId: "", societeId: undefined, fromDate: undefined, toDate: undefined };
}

export const GetRetryMetricsRequest: MessageFns<GetRetryMetricsRequest> = {
  encode(message: GetRetryMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(toTimestamp(message.fromDate), writer.uint32(26).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(toTimestamp(message.toDate), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRetryMetricsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      fromDate: isSet(object.fromDate)
        ? fromJsonTimestamp(object.fromDate)
        : isSet(object.from_date)
        ? fromJsonTimestamp(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? fromJsonTimestamp(object.toDate)
        : isSet(object.to_date)
        ? fromJsonTimestamp(object.to_date)
        : undefined,
    };
  },

  toJSON(message: GetRetryMetricsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate.toISOString();
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRetryMetricsRequest>, I>>(base?: I): GetRetryMetricsRequest {
    return GetRetryMetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRetryMetricsRequest>, I>>(object: I): GetRetryMetricsRequest {
    const message = createBaseGetRetryMetricsRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    return message;
  },
};

function createBaseRetryMetricsResponse(): RetryMetricsResponse {
  return {
    totalRejections: 0,
    am04Rejections: 0,
    otherRejections: 0,
    totalRetrySchedules: 0,
    eligibleForRetry: 0,
    notEligible: 0,
    totalRetryAttempts: 0,
    successfulRetries: 0,
    failedRetries: 0,
    pendingRetries: 0,
    successRate: 0,
    am04Rate: 0,
    totalAmountRecoveredCents: 0,
    totalAmountPendingCents: 0,
    rejectionCodeBreakdown: [],
    dailyMetrics: [],
  };
}

export const RetryMetricsResponse: MessageFns<RetryMetricsResponse> = {
  encode(message: RetryMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalRejections !== 0) {
      writer.uint32(8).int32(message.totalRejections);
    }
    if (message.am04Rejections !== 0) {
      writer.uint32(16).int32(message.am04Rejections);
    }
    if (message.otherRejections !== 0) {
      writer.uint32(24).int32(message.otherRejections);
    }
    if (message.totalRetrySchedules !== 0) {
      writer.uint32(32).int32(message.totalRetrySchedules);
    }
    if (message.eligibleForRetry !== 0) {
      writer.uint32(40).int32(message.eligibleForRetry);
    }
    if (message.notEligible !== 0) {
      writer.uint32(48).int32(message.notEligible);
    }
    if (message.totalRetryAttempts !== 0) {
      writer.uint32(56).int32(message.totalRetryAttempts);
    }
    if (message.successfulRetries !== 0) {
      writer.uint32(64).int32(message.successfulRetries);
    }
    if (message.failedRetries !== 0) {
      writer.uint32(72).int32(message.failedRetries);
    }
    if (message.pendingRetries !== 0) {
      writer.uint32(80).int32(message.pendingRetries);
    }
    if (message.successRate !== 0) {
      writer.uint32(89).double(message.successRate);
    }
    if (message.am04Rate !== 0) {
      writer.uint32(97).double(message.am04Rate);
    }
    if (message.totalAmountRecoveredCents !== 0) {
      writer.uint32(104).int64(message.totalAmountRecoveredCents);
    }
    if (message.totalAmountPendingCents !== 0) {
      writer.uint32(112).int64(message.totalAmountPendingCents);
    }
    for (const v of message.rejectionCodeBreakdown) {
      RejectionCodeMetric.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.dailyMetrics) {
      DailyRetryMetric.encode(v!, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalRejections = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.am04Rejections = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.otherRejections = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalRetrySchedules = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.eligibleForRetry = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.notEligible = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalRetryAttempts = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.successfulRetries = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.failedRetries = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.pendingRetries = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.successRate = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.am04Rate = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.totalAmountRecoveredCents = longToNumber(reader.int64());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.totalAmountPendingCents = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.rejectionCodeBreakdown.push(RejectionCodeMetric.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dailyMetrics.push(DailyRetryMetric.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryMetricsResponse {
    return {
      totalRejections: isSet(object.totalRejections)
        ? globalThis.Number(object.totalRejections)
        : isSet(object.total_rejections)
        ? globalThis.Number(object.total_rejections)
        : 0,
      am04Rejections: isSet(object.am04Rejections)
        ? globalThis.Number(object.am04Rejections)
        : isSet(object.am04_rejections)
        ? globalThis.Number(object.am04_rejections)
        : 0,
      otherRejections: isSet(object.otherRejections)
        ? globalThis.Number(object.otherRejections)
        : isSet(object.other_rejections)
        ? globalThis.Number(object.other_rejections)
        : 0,
      totalRetrySchedules: isSet(object.totalRetrySchedules)
        ? globalThis.Number(object.totalRetrySchedules)
        : isSet(object.total_retry_schedules)
        ? globalThis.Number(object.total_retry_schedules)
        : 0,
      eligibleForRetry: isSet(object.eligibleForRetry)
        ? globalThis.Number(object.eligibleForRetry)
        : isSet(object.eligible_for_retry)
        ? globalThis.Number(object.eligible_for_retry)
        : 0,
      notEligible: isSet(object.notEligible)
        ? globalThis.Number(object.notEligible)
        : isSet(object.not_eligible)
        ? globalThis.Number(object.not_eligible)
        : 0,
      totalRetryAttempts: isSet(object.totalRetryAttempts)
        ? globalThis.Number(object.totalRetryAttempts)
        : isSet(object.total_retry_attempts)
        ? globalThis.Number(object.total_retry_attempts)
        : 0,
      successfulRetries: isSet(object.successfulRetries)
        ? globalThis.Number(object.successfulRetries)
        : isSet(object.successful_retries)
        ? globalThis.Number(object.successful_retries)
        : 0,
      failedRetries: isSet(object.failedRetries)
        ? globalThis.Number(object.failedRetries)
        : isSet(object.failed_retries)
        ? globalThis.Number(object.failed_retries)
        : 0,
      pendingRetries: isSet(object.pendingRetries)
        ? globalThis.Number(object.pendingRetries)
        : isSet(object.pending_retries)
        ? globalThis.Number(object.pending_retries)
        : 0,
      successRate: isSet(object.successRate)
        ? globalThis.Number(object.successRate)
        : isSet(object.success_rate)
        ? globalThis.Number(object.success_rate)
        : 0,
      am04Rate: isSet(object.am04Rate)
        ? globalThis.Number(object.am04Rate)
        : isSet(object.am04_rate)
        ? globalThis.Number(object.am04_rate)
        : 0,
      totalAmountRecoveredCents: isSet(object.totalAmountRecoveredCents)
        ? globalThis.Number(object.totalAmountRecoveredCents)
        : isSet(object.total_amount_recovered_cents)
        ? globalThis.Number(object.total_amount_recovered_cents)
        : 0,
      totalAmountPendingCents: isSet(object.totalAmountPendingCents)
        ? globalThis.Number(object.totalAmountPendingCents)
        : isSet(object.total_amount_pending_cents)
        ? globalThis.Number(object.total_amount_pending_cents)
        : 0,
      rejectionCodeBreakdown: globalThis.Array.isArray(object?.rejectionCodeBreakdown)
        ? object.rejectionCodeBreakdown.map((e: any) => RejectionCodeMetric.fromJSON(e))
        : globalThis.Array.isArray(object?.rejection_code_breakdown)
        ? object.rejection_code_breakdown.map((e: any) => RejectionCodeMetric.fromJSON(e))
        : [],
      dailyMetrics: globalThis.Array.isArray(object?.dailyMetrics)
        ? object.dailyMetrics.map((e: any) => DailyRetryMetric.fromJSON(e))
        : globalThis.Array.isArray(object?.daily_metrics)
        ? object.daily_metrics.map((e: any) => DailyRetryMetric.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RetryMetricsResponse): unknown {
    const obj: any = {};
    if (message.totalRejections !== 0) {
      obj.totalRejections = Math.round(message.totalRejections);
    }
    if (message.am04Rejections !== 0) {
      obj.am04Rejections = Math.round(message.am04Rejections);
    }
    if (message.otherRejections !== 0) {
      obj.otherRejections = Math.round(message.otherRejections);
    }
    if (message.totalRetrySchedules !== 0) {
      obj.totalRetrySchedules = Math.round(message.totalRetrySchedules);
    }
    if (message.eligibleForRetry !== 0) {
      obj.eligibleForRetry = Math.round(message.eligibleForRetry);
    }
    if (message.notEligible !== 0) {
      obj.notEligible = Math.round(message.notEligible);
    }
    if (message.totalRetryAttempts !== 0) {
      obj.totalRetryAttempts = Math.round(message.totalRetryAttempts);
    }
    if (message.successfulRetries !== 0) {
      obj.successfulRetries = Math.round(message.successfulRetries);
    }
    if (message.failedRetries !== 0) {
      obj.failedRetries = Math.round(message.failedRetries);
    }
    if (message.pendingRetries !== 0) {
      obj.pendingRetries = Math.round(message.pendingRetries);
    }
    if (message.successRate !== 0) {
      obj.successRate = message.successRate;
    }
    if (message.am04Rate !== 0) {
      obj.am04Rate = message.am04Rate;
    }
    if (message.totalAmountRecoveredCents !== 0) {
      obj.totalAmountRecoveredCents = Math.round(message.totalAmountRecoveredCents);
    }
    if (message.totalAmountPendingCents !== 0) {
      obj.totalAmountPendingCents = Math.round(message.totalAmountPendingCents);
    }
    if (message.rejectionCodeBreakdown?.length) {
      obj.rejectionCodeBreakdown = message.rejectionCodeBreakdown.map((e) => RejectionCodeMetric.toJSON(e));
    }
    if (message.dailyMetrics?.length) {
      obj.dailyMetrics = message.dailyMetrics.map((e) => DailyRetryMetric.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryMetricsResponse>, I>>(base?: I): RetryMetricsResponse {
    return RetryMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryMetricsResponse>, I>>(object: I): RetryMetricsResponse {
    const message = createBaseRetryMetricsResponse();
    message.totalRejections = object.totalRejections ?? 0;
    message.am04Rejections = object.am04Rejections ?? 0;
    message.otherRejections = object.otherRejections ?? 0;
    message.totalRetrySchedules = object.totalRetrySchedules ?? 0;
    message.eligibleForRetry = object.eligibleForRetry ?? 0;
    message.notEligible = object.notEligible ?? 0;
    message.totalRetryAttempts = object.totalRetryAttempts ?? 0;
    message.successfulRetries = object.successfulRetries ?? 0;
    message.failedRetries = object.failedRetries ?? 0;
    message.pendingRetries = object.pendingRetries ?? 0;
    message.successRate = object.successRate ?? 0;
    message.am04Rate = object.am04Rate ?? 0;
    message.totalAmountRecoveredCents = object.totalAmountRecoveredCents ?? 0;
    message.totalAmountPendingCents = object.totalAmountPendingCents ?? 0;
    message.rejectionCodeBreakdown = object.rejectionCodeBreakdown?.map((e) => RejectionCodeMetric.fromPartial(e)) ||
      [];
    message.dailyMetrics = object.dailyMetrics?.map((e) => DailyRetryMetric.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRejectionCodeMetric(): RejectionCodeMetric {
  return { code: 0, codeRaw: "", count: 0, percentage: 0 };
}

export const RejectionCodeMetric: MessageFns<RejectionCodeMetric> = {
  encode(message: RejectionCodeMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.codeRaw !== "") {
      writer.uint32(18).string(message.codeRaw);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.percentage !== 0) {
      writer.uint32(33).double(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectionCodeMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectionCodeMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codeRaw = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.percentage = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectionCodeMetric {
    return {
      code: isSet(object.code) ? rejectionReasonCodeFromJSON(object.code) : 0,
      codeRaw: isSet(object.codeRaw)
        ? globalThis.String(object.codeRaw)
        : isSet(object.code_raw)
        ? globalThis.String(object.code_raw)
        : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
    };
  },

  toJSON(message: RejectionCodeMetric): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = rejectionReasonCodeToJSON(message.code);
    }
    if (message.codeRaw !== "") {
      obj.codeRaw = message.codeRaw;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.percentage !== 0) {
      obj.percentage = message.percentage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RejectionCodeMetric>, I>>(base?: I): RejectionCodeMetric {
    return RejectionCodeMetric.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RejectionCodeMetric>, I>>(object: I): RejectionCodeMetric {
    const message = createBaseRejectionCodeMetric();
    message.code = object.code ?? 0;
    message.codeRaw = object.codeRaw ?? "";
    message.count = object.count ?? 0;
    message.percentage = object.percentage ?? 0;
    return message;
  },
};

function createBaseDailyRetryMetric(): DailyRetryMetric {
  return { date: "", rejections: 0, retriesScheduled: 0, retriesExecuted: 0, retriesSucceeded: 0, retriesFailed: 0 };
}

export const DailyRetryMetric: MessageFns<DailyRetryMetric> = {
  encode(message: DailyRetryMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.rejections !== 0) {
      writer.uint32(16).int32(message.rejections);
    }
    if (message.retriesScheduled !== 0) {
      writer.uint32(24).int32(message.retriesScheduled);
    }
    if (message.retriesExecuted !== 0) {
      writer.uint32(32).int32(message.retriesExecuted);
    }
    if (message.retriesSucceeded !== 0) {
      writer.uint32(40).int32(message.retriesSucceeded);
    }
    if (message.retriesFailed !== 0) {
      writer.uint32(48).int32(message.retriesFailed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyRetryMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyRetryMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rejections = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.retriesScheduled = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.retriesExecuted = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.retriesSucceeded = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.retriesFailed = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyRetryMetric {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      rejections: isSet(object.rejections) ? globalThis.Number(object.rejections) : 0,
      retriesScheduled: isSet(object.retriesScheduled)
        ? globalThis.Number(object.retriesScheduled)
        : isSet(object.retries_scheduled)
        ? globalThis.Number(object.retries_scheduled)
        : 0,
      retriesExecuted: isSet(object.retriesExecuted)
        ? globalThis.Number(object.retriesExecuted)
        : isSet(object.retries_executed)
        ? globalThis.Number(object.retries_executed)
        : 0,
      retriesSucceeded: isSet(object.retriesSucceeded)
        ? globalThis.Number(object.retriesSucceeded)
        : isSet(object.retries_succeeded)
        ? globalThis.Number(object.retries_succeeded)
        : 0,
      retriesFailed: isSet(object.retriesFailed)
        ? globalThis.Number(object.retriesFailed)
        : isSet(object.retries_failed)
        ? globalThis.Number(object.retries_failed)
        : 0,
    };
  },

  toJSON(message: DailyRetryMetric): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.rejections !== 0) {
      obj.rejections = Math.round(message.rejections);
    }
    if (message.retriesScheduled !== 0) {
      obj.retriesScheduled = Math.round(message.retriesScheduled);
    }
    if (message.retriesExecuted !== 0) {
      obj.retriesExecuted = Math.round(message.retriesExecuted);
    }
    if (message.retriesSucceeded !== 0) {
      obj.retriesSucceeded = Math.round(message.retriesSucceeded);
    }
    if (message.retriesFailed !== 0) {
      obj.retriesFailed = Math.round(message.retriesFailed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DailyRetryMetric>, I>>(base?: I): DailyRetryMetric {
    return DailyRetryMetric.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DailyRetryMetric>, I>>(object: I): DailyRetryMetric {
    const message = createBaseDailyRetryMetric();
    message.date = object.date ?? "";
    message.rejections = object.rejections ?? 0;
    message.retriesScheduled = object.retriesScheduled ?? 0;
    message.retriesExecuted = object.retriesExecuted ?? 0;
    message.retriesSucceeded = object.retriesSucceeded ?? 0;
    message.retriesFailed = object.retriesFailed ?? 0;
    return message;
  },
};

function createBaseGetAuditLogsRequest(): GetAuditLogsRequest {
  return {
    organisationId: "",
    entityType: undefined,
    entityId: undefined,
    action: undefined,
    fromDate: undefined,
    toDate: undefined,
    pagination: undefined,
  };
}

export const GetAuditLogsRequest: MessageFns<GetAuditLogsRequest> = {
  encode(message: GetAuditLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.entityType !== undefined) {
      writer.uint32(18).string(message.entityType);
    }
    if (message.entityId !== undefined) {
      writer.uint32(26).string(message.entityId);
    }
    if (message.action !== undefined) {
      writer.uint32(34).string(message.action);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(toTimestamp(message.fromDate), writer.uint32(42).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(toTimestamp(message.toDate), writer.uint32(50).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditLogsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      entityType: isSet(object.entityType)
        ? globalThis.String(object.entityType)
        : isSet(object.entity_type)
        ? globalThis.String(object.entity_type)
        : undefined,
      entityId: isSet(object.entityId)
        ? globalThis.String(object.entityId)
        : isSet(object.entity_id)
        ? globalThis.String(object.entity_id)
        : undefined,
      action: isSet(object.action) ? globalThis.String(object.action) : undefined,
      fromDate: isSet(object.fromDate)
        ? fromJsonTimestamp(object.fromDate)
        : isSet(object.from_date)
        ? fromJsonTimestamp(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? fromJsonTimestamp(object.toDate)
        : isSet(object.to_date)
        ? fromJsonTimestamp(object.to_date)
        : undefined,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetAuditLogsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.entityType !== undefined) {
      obj.entityType = message.entityType;
    }
    if (message.entityId !== undefined) {
      obj.entityId = message.entityId;
    }
    if (message.action !== undefined) {
      obj.action = message.action;
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate.toISOString();
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate.toISOString();
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuditLogsRequest>, I>>(base?: I): GetAuditLogsRequest {
    return GetAuditLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuditLogsRequest>, I>>(object: I): GetAuditLogsRequest {
    const message = createBaseGetAuditLogsRequest();
    message.organisationId = object.organisationId ?? "";
    message.entityType = object.entityType ?? undefined;
    message.entityId = object.entityId ?? undefined;
    message.action = object.action ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseAuditLogsResponse(): AuditLogsResponse {
  return { logs: [], pagination: undefined };
}

export const AuditLogsResponse: MessageFns<AuditLogsResponse> = {
  encode(message: AuditLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      RetryAuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(RetryAuditLog.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLogsResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => RetryAuditLog.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: AuditLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => RetryAuditLog.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLogsResponse>, I>>(base?: I): AuditLogsResponse {
    return AuditLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLogsResponse>, I>>(object: I): AuditLogsResponse {
    const message = createBaseAuditLogsResponse();
    message.logs = object.logs?.map((e) => RetryAuditLog.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseProcessDueRetriesRequest(): ProcessDueRetriesRequest {
  return { organisationId: "", targetDate: undefined, timezone: "", cutoffTime: "", dryRun: false };
}

export const ProcessDueRetriesRequest: MessageFns<ProcessDueRetriesRequest> = {
  encode(message: ProcessDueRetriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.targetDate !== undefined) {
      Timestamp.encode(toTimestamp(message.targetDate), writer.uint32(18).fork()).join();
    }
    if (message.timezone !== "") {
      writer.uint32(26).string(message.timezone);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(34).string(message.cutoffTime);
    }
    if (message.dryRun !== false) {
      writer.uint32(40).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRetriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRetriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDueRetriesRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      targetDate: isSet(object.targetDate)
        ? fromJsonTimestamp(object.targetDate)
        : isSet(object.target_date)
        ? fromJsonTimestamp(object.target_date)
        : undefined,
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
      cutoffTime: isSet(object.cutoffTime)
        ? globalThis.String(object.cutoffTime)
        : isSet(object.cutoff_time)
        ? globalThis.String(object.cutoff_time)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
    };
  },

  toJSON(message: ProcessDueRetriesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.targetDate !== undefined) {
      obj.targetDate = message.targetDate.toISOString();
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    if (message.cutoffTime !== "") {
      obj.cutoffTime = message.cutoffTime;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDueRetriesRequest>, I>>(base?: I): ProcessDueRetriesRequest {
    return ProcessDueRetriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDueRetriesRequest>, I>>(object: I): ProcessDueRetriesRequest {
    const message = createBaseProcessDueRetriesRequest();
    message.organisationId = object.organisationId ?? "";
    message.targetDate = object.targetDate ?? undefined;
    message.timezone = object.timezone ?? "";
    message.cutoffTime = object.cutoffTime ?? "";
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseProcessDueRetriesResponse(): ProcessDueRetriesResponse {
  return { jobId: "", status: 0, totalProcessed: 0, successful: 0, failed: 0, skipped: 0, results: [] };
}

export const ProcessDueRetriesResponse: MessageFns<ProcessDueRetriesResponse> = {
  encode(message: ProcessDueRetriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.totalProcessed !== 0) {
      writer.uint32(24).int32(message.totalProcessed);
    }
    if (message.successful !== 0) {
      writer.uint32(32).int32(message.successful);
    }
    if (message.failed !== 0) {
      writer.uint32(40).int32(message.failed);
    }
    if (message.skipped !== 0) {
      writer.uint32(48).int32(message.skipped);
    }
    for (const v of message.results) {
      ProcessedRetryResult.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRetriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRetriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalProcessed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.successful = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.failed = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.skipped = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.results.push(ProcessedRetryResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDueRetriesResponse {
    return {
      jobId: isSet(object.jobId)
        ? globalThis.String(object.jobId)
        : isSet(object.job_id)
        ? globalThis.String(object.job_id)
        : "",
      status: isSet(object.status) ? retryJobStatusFromJSON(object.status) : 0,
      totalProcessed: isSet(object.totalProcessed)
        ? globalThis.Number(object.totalProcessed)
        : isSet(object.total_processed)
        ? globalThis.Number(object.total_processed)
        : 0,
      successful: isSet(object.successful) ? globalThis.Number(object.successful) : 0,
      failed: isSet(object.failed) ? globalThis.Number(object.failed) : 0,
      skipped: isSet(object.skipped) ? globalThis.Number(object.skipped) : 0,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ProcessedRetryResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessDueRetriesResponse): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.status !== 0) {
      obj.status = retryJobStatusToJSON(message.status);
    }
    if (message.totalProcessed !== 0) {
      obj.totalProcessed = Math.round(message.totalProcessed);
    }
    if (message.successful !== 0) {
      obj.successful = Math.round(message.successful);
    }
    if (message.failed !== 0) {
      obj.failed = Math.round(message.failed);
    }
    if (message.skipped !== 0) {
      obj.skipped = Math.round(message.skipped);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => ProcessedRetryResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDueRetriesResponse>, I>>(base?: I): ProcessDueRetriesResponse {
    return ProcessDueRetriesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDueRetriesResponse>, I>>(object: I): ProcessDueRetriesResponse {
    const message = createBaseProcessDueRetriesResponse();
    message.jobId = object.jobId ?? "";
    message.status = object.status ?? 0;
    message.totalProcessed = object.totalProcessed ?? 0;
    message.successful = object.successful ?? 0;
    message.failed = object.failed ?? 0;
    message.skipped = object.skipped ?? 0;
    message.results = object.results?.map((e) => ProcessedRetryResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessedRetryResult(): ProcessedRetryResult {
  return { retryScheduleId: "", retryAttemptId: "", success: false, errorCode: undefined, errorMessage: undefined };
}

export const ProcessedRetryResult: MessageFns<ProcessedRetryResult> = {
  encode(message: ProcessedRetryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryScheduleId !== "") {
      writer.uint32(10).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(18).string(message.retryAttemptId);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessedRetryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedRetryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessedRetryResult {
    return {
      retryScheduleId: isSet(object.retryScheduleId)
        ? globalThis.String(object.retryScheduleId)
        : isSet(object.retry_schedule_id)
        ? globalThis.String(object.retry_schedule_id)
        : "",
      retryAttemptId: isSet(object.retryAttemptId)
        ? globalThis.String(object.retryAttemptId)
        : isSet(object.retry_attempt_id)
        ? globalThis.String(object.retry_attempt_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: ProcessedRetryResult): unknown {
    const obj: any = {};
    if (message.retryScheduleId !== "") {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.retryAttemptId !== "") {
      obj.retryAttemptId = message.retryAttemptId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessedRetryResult>, I>>(base?: I): ProcessedRetryResult {
    return ProcessedRetryResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessedRetryResult>, I>>(object: I): ProcessedRetryResult {
    const message = createBaseProcessedRetryResult();
    message.retryScheduleId = object.retryScheduleId ?? "";
    message.retryAttemptId = object.retryAttemptId ?? "";
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseCheckEligibilityRequest(): CheckEligibilityRequest {
  return {
    paymentId: "",
    rejectionCode: "",
    organisationId: "",
    societeId: undefined,
    contratId: undefined,
    clientId: undefined,
  };
}

export const CheckEligibilityRequest: MessageFns<CheckEligibilityRequest> = {
  encode(message: CheckEligibilityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.rejectionCode !== "") {
      writer.uint32(18).string(message.rejectionCode);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(34).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(42).string(message.contratId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(50).string(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckEligibilityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckEligibilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rejectionCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckEligibilityRequest {
    return {
      paymentId: isSet(object.paymentId)
        ? globalThis.String(object.paymentId)
        : isSet(object.payment_id)
        ? globalThis.String(object.payment_id)
        : "",
      rejectionCode: isSet(object.rejectionCode)
        ? globalThis.String(object.rejectionCode)
        : isSet(object.rejection_code)
        ? globalThis.String(object.rejection_code)
        : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
    };
  },

  toJSON(message: CheckEligibilityRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.rejectionCode !== "") {
      obj.rejectionCode = message.rejectionCode;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckEligibilityRequest>, I>>(base?: I): CheckEligibilityRequest {
    return CheckEligibilityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckEligibilityRequest>, I>>(object: I): CheckEligibilityRequest {
    const message = createBaseCheckEligibilityRequest();
    message.paymentId = object.paymentId ?? "";
    message.rejectionCode = object.rejectionCode ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.contratId = object.contratId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    return message;
  },
};

function createBaseCheckEligibilityResponse(): CheckEligibilityResponse {
  return { eligibility: 0, reason: "", applicablePolicyId: undefined, firstRetryDate: undefined };
}

export const CheckEligibilityResponse: MessageFns<CheckEligibilityResponse> = {
  encode(message: CheckEligibilityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eligibility !== 0) {
      writer.uint32(8).int32(message.eligibility);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.applicablePolicyId !== undefined) {
      writer.uint32(26).string(message.applicablePolicyId);
    }
    if (message.firstRetryDate !== undefined) {
      Timestamp.encode(toTimestamp(message.firstRetryDate), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckEligibilityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckEligibilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.applicablePolicyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstRetryDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckEligibilityResponse {
    return {
      eligibility: isSet(object.eligibility) ? retryEligibilityFromJSON(object.eligibility) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      applicablePolicyId: isSet(object.applicablePolicyId)
        ? globalThis.String(object.applicablePolicyId)
        : isSet(object.applicable_policy_id)
        ? globalThis.String(object.applicable_policy_id)
        : undefined,
      firstRetryDate: isSet(object.firstRetryDate)
        ? fromJsonTimestamp(object.firstRetryDate)
        : isSet(object.first_retry_date)
        ? fromJsonTimestamp(object.first_retry_date)
        : undefined,
    };
  },

  toJSON(message: CheckEligibilityResponse): unknown {
    const obj: any = {};
    if (message.eligibility !== 0) {
      obj.eligibility = retryEligibilityToJSON(message.eligibility);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.applicablePolicyId !== undefined) {
      obj.applicablePolicyId = message.applicablePolicyId;
    }
    if (message.firstRetryDate !== undefined) {
      obj.firstRetryDate = message.firstRetryDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckEligibilityResponse>, I>>(base?: I): CheckEligibilityResponse {
    return CheckEligibilityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckEligibilityResponse>, I>>(object: I): CheckEligibilityResponse {
    const message = createBaseCheckEligibilityResponse();
    message.eligibility = object.eligibility ?? 0;
    message.reason = object.reason ?? "";
    message.applicablePolicyId = object.applicablePolicyId ?? undefined;
    message.firstRetryDate = object.firstRetryDate ?? undefined;
    return message;
  },
};

function createBaseHandleRejectionResponse(): HandleRejectionResponse {
  return { processed: false, retryScheduleId: undefined, eligibility: 0, message: "", reminderIds: [] };
}

export const HandleRejectionResponse: MessageFns<HandleRejectionResponse> = {
  encode(message: HandleRejectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processed !== false) {
      writer.uint32(8).bool(message.processed);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.eligibility !== 0) {
      writer.uint32(24).int32(message.eligibility);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    for (const v of message.reminderIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandleRejectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandleRejectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reminderIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandleRejectionResponse {
    return {
      processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false,
      retryScheduleId: isSet(object.retryScheduleId)
        ? globalThis.String(object.retryScheduleId)
        : isSet(object.retry_schedule_id)
        ? globalThis.String(object.retry_schedule_id)
        : undefined,
      eligibility: isSet(object.eligibility) ? retryEligibilityFromJSON(object.eligibility) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      reminderIds: globalThis.Array.isArray(object?.reminderIds)
        ? object.reminderIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.reminder_ids)
        ? object.reminder_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: HandleRejectionResponse): unknown {
    const obj: any = {};
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    if (message.retryScheduleId !== undefined) {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.eligibility !== 0) {
      obj.eligibility = retryEligibilityToJSON(message.eligibility);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.reminderIds?.length) {
      obj.reminderIds = message.reminderIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandleRejectionResponse>, I>>(base?: I): HandleRejectionResponse {
    return HandleRejectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandleRejectionResponse>, I>>(object: I): HandleRejectionResponse {
    const message = createBaseHandleRejectionResponse();
    message.processed = object.processed ?? false;
    message.retryScheduleId = object.retryScheduleId ?? undefined;
    message.eligibility = object.eligibility ?? 0;
    message.message = object.message ?? "";
    message.reminderIds = object.reminderIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetReminderPolicyRequest(): GetReminderPolicyRequest {
  return { id: "" };
}

export const GetReminderPolicyRequest: MessageFns<GetReminderPolicyRequest> = {
  encode(message: GetReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReminderPolicyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetReminderPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReminderPolicyRequest>, I>>(base?: I): GetReminderPolicyRequest {
    return GetReminderPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReminderPolicyRequest>, I>>(object: I): GetReminderPolicyRequest {
    const message = createBaseGetReminderPolicyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseReminderPolicyResponse(): ReminderPolicyResponse {
  return { policy: undefined };
}

export const ReminderPolicyResponse: MessageFns<ReminderPolicyResponse> = {
  encode(message: ReminderPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      ReminderPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = ReminderPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderPolicyResponse {
    return { policy: isSet(object.policy) ? ReminderPolicy.fromJSON(object.policy) : undefined };
  },

  toJSON(message: ReminderPolicyResponse): unknown {
    const obj: any = {};
    if (message.policy !== undefined) {
      obj.policy = ReminderPolicy.toJSON(message.policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderPolicyResponse>, I>>(base?: I): ReminderPolicyResponse {
    return ReminderPolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderPolicyResponse>, I>>(object: I): ReminderPolicyResponse {
    const message = createBaseReminderPolicyResponse();
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? ReminderPolicy.fromPartial(object.policy)
      : undefined;
    return message;
  },
};

function createBaseListReminderPoliciesRequest(): ListReminderPoliciesRequest {
  return { organisationId: "", societeId: undefined, activeOnly: undefined, pagination: undefined };
}

export const ListReminderPoliciesRequest: MessageFns<ListReminderPoliciesRequest> = {
  encode(message: ListReminderPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.activeOnly !== undefined) {
      writer.uint32(24).bool(message.activeOnly);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReminderPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReminderPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReminderPoliciesRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      activeOnly: isSet(object.activeOnly)
        ? globalThis.Boolean(object.activeOnly)
        : isSet(object.active_only)
        ? globalThis.Boolean(object.active_only)
        : undefined,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListReminderPoliciesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.activeOnly !== undefined) {
      obj.activeOnly = message.activeOnly;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListReminderPoliciesRequest>, I>>(base?: I): ListReminderPoliciesRequest {
    return ListReminderPoliciesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListReminderPoliciesRequest>, I>>(object: I): ListReminderPoliciesRequest {
    const message = createBaseListReminderPoliciesRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.activeOnly = object.activeOnly ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListReminderPoliciesResponse(): ListReminderPoliciesResponse {
  return { policies: [], pagination: undefined };
}

export const ListReminderPoliciesResponse: MessageFns<ListReminderPoliciesResponse> = {
  encode(message: ListReminderPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policies) {
      ReminderPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReminderPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReminderPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policies.push(ReminderPolicy.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReminderPoliciesResponse {
    return {
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => ReminderPolicy.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListReminderPoliciesResponse): unknown {
    const obj: any = {};
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => ReminderPolicy.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListReminderPoliciesResponse>, I>>(base?: I): ListReminderPoliciesResponse {
    return ListReminderPoliciesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListReminderPoliciesResponse>, I>>(object: I): ListReminderPoliciesResponse {
    const message = createBaseListReminderPoliciesResponse();
    message.policies = object.policies?.map((e) => ReminderPolicy.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseCreateReminderPolicyRequest(): CreateReminderPolicyRequest {
  return {
    organisationId: "",
    societeId: undefined,
    name: "",
    description: "",
    triggerRules: [],
    cooldownHours: 0,
    maxRemindersPerDay: 0,
    maxRemindersPerWeek: 0,
    allowedStartHour: 0,
    allowedEndHour: 0,
    allowedDaysOfWeek: [],
    respectOptOut: false,
    isDefault: false,
    priority: 0,
  };
}

export const CreateReminderPolicyRequest: MessageFns<CreateReminderPolicyRequest> = {
  encode(message: CreateReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.triggerRules) {
      ReminderTriggerRule.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.cooldownHours !== 0) {
      writer.uint32(48).int32(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== 0) {
      writer.uint32(56).int32(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== 0) {
      writer.uint32(64).int32(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== 0) {
      writer.uint32(72).int32(message.allowedStartHour);
    }
    if (message.allowedEndHour !== 0) {
      writer.uint32(80).int32(message.allowedEndHour);
    }
    writer.uint32(90).fork();
    for (const v of message.allowedDaysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    if (message.respectOptOut !== false) {
      writer.uint32(96).bool(message.respectOptOut);
    }
    if (message.isDefault !== false) {
      writer.uint32(104).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(112).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.triggerRules.push(ReminderTriggerRule.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cooldownHours = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxRemindersPerDay = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxRemindersPerWeek = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowedStartHour = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowedEndHour = reader.int32();
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.allowedDaysOfWeek.push(reader.int32());

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedDaysOfWeek.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.respectOptOut = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReminderPolicyRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      societeId: isSet(object.societeId)
        ? globalThis.String(object.societeId)
        : isSet(object.societe_id)
        ? globalThis.String(object.societe_id)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      triggerRules: globalThis.Array.isArray(object?.triggerRules)
        ? object.triggerRules.map((e: any) => ReminderTriggerRule.fromJSON(e))
        : globalThis.Array.isArray(object?.trigger_rules)
        ? object.trigger_rules.map((e: any) => ReminderTriggerRule.fromJSON(e))
        : [],
      cooldownHours: isSet(object.cooldownHours)
        ? globalThis.Number(object.cooldownHours)
        : isSet(object.cooldown_hours)
        ? globalThis.Number(object.cooldown_hours)
        : 0,
      maxRemindersPerDay: isSet(object.maxRemindersPerDay)
        ? globalThis.Number(object.maxRemindersPerDay)
        : isSet(object.max_reminders_per_day)
        ? globalThis.Number(object.max_reminders_per_day)
        : 0,
      maxRemindersPerWeek: isSet(object.maxRemindersPerWeek)
        ? globalThis.Number(object.maxRemindersPerWeek)
        : isSet(object.max_reminders_per_week)
        ? globalThis.Number(object.max_reminders_per_week)
        : 0,
      allowedStartHour: isSet(object.allowedStartHour)
        ? globalThis.Number(object.allowedStartHour)
        : isSet(object.allowed_start_hour)
        ? globalThis.Number(object.allowed_start_hour)
        : 0,
      allowedEndHour: isSet(object.allowedEndHour)
        ? globalThis.Number(object.allowedEndHour)
        : isSet(object.allowed_end_hour)
        ? globalThis.Number(object.allowed_end_hour)
        : 0,
      allowedDaysOfWeek: globalThis.Array.isArray(object?.allowedDaysOfWeek)
        ? object.allowedDaysOfWeek.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.allowed_days_of_week)
        ? object.allowed_days_of_week.map((e: any) => globalThis.Number(e))
        : [],
      respectOptOut: isSet(object.respectOptOut)
        ? globalThis.Boolean(object.respectOptOut)
        : isSet(object.respect_opt_out)
        ? globalThis.Boolean(object.respect_opt_out)
        : false,
      isDefault: isSet(object.isDefault)
        ? globalThis.Boolean(object.isDefault)
        : isSet(object.is_default)
        ? globalThis.Boolean(object.is_default)
        : false,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: CreateReminderPolicyRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== undefined) {
      obj.societeId = message.societeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.triggerRules?.length) {
      obj.triggerRules = message.triggerRules.map((e) => ReminderTriggerRule.toJSON(e));
    }
    if (message.cooldownHours !== 0) {
      obj.cooldownHours = Math.round(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== 0) {
      obj.maxRemindersPerDay = Math.round(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== 0) {
      obj.maxRemindersPerWeek = Math.round(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== 0) {
      obj.allowedStartHour = Math.round(message.allowedStartHour);
    }
    if (message.allowedEndHour !== 0) {
      obj.allowedEndHour = Math.round(message.allowedEndHour);
    }
    if (message.allowedDaysOfWeek?.length) {
      obj.allowedDaysOfWeek = message.allowedDaysOfWeek.map((e) => Math.round(e));
    }
    if (message.respectOptOut !== false) {
      obj.respectOptOut = message.respectOptOut;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateReminderPolicyRequest>, I>>(base?: I): CreateReminderPolicyRequest {
    return CreateReminderPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateReminderPolicyRequest>, I>>(object: I): CreateReminderPolicyRequest {
    const message = createBaseCreateReminderPolicyRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.triggerRules = object.triggerRules?.map((e) => ReminderTriggerRule.fromPartial(e)) || [];
    message.cooldownHours = object.cooldownHours ?? 0;
    message.maxRemindersPerDay = object.maxRemindersPerDay ?? 0;
    message.maxRemindersPerWeek = object.maxRemindersPerWeek ?? 0;
    message.allowedStartHour = object.allowedStartHour ?? 0;
    message.allowedEndHour = object.allowedEndHour ?? 0;
    message.allowedDaysOfWeek = object.allowedDaysOfWeek?.map((e) => e) || [];
    message.respectOptOut = object.respectOptOut ?? false;
    message.isDefault = object.isDefault ?? false;
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseUpdateReminderPolicyRequest(): UpdateReminderPolicyRequest {
  return {
    id: "",
    name: undefined,
    description: undefined,
    triggerRules: [],
    cooldownHours: undefined,
    maxRemindersPerDay: undefined,
    maxRemindersPerWeek: undefined,
    allowedStartHour: undefined,
    allowedEndHour: undefined,
    allowedDaysOfWeek: [],
    respectOptOut: undefined,
    isActive: undefined,
    isDefault: undefined,
    priority: undefined,
  };
}

export const UpdateReminderPolicyRequest: MessageFns<UpdateReminderPolicyRequest> = {
  encode(message: UpdateReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.triggerRules) {
      ReminderTriggerRule.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.cooldownHours !== undefined) {
      writer.uint32(40).int32(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== undefined) {
      writer.uint32(48).int32(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== undefined) {
      writer.uint32(56).int32(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== undefined) {
      writer.uint32(64).int32(message.allowedStartHour);
    }
    if (message.allowedEndHour !== undefined) {
      writer.uint32(72).int32(message.allowedEndHour);
    }
    writer.uint32(82).fork();
    for (const v of message.allowedDaysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    if (message.respectOptOut !== undefined) {
      writer.uint32(88).bool(message.respectOptOut);
    }
    if (message.isActive !== undefined) {
      writer.uint32(96).bool(message.isActive);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(104).bool(message.isDefault);
    }
    if (message.priority !== undefined) {
      writer.uint32(112).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.triggerRules.push(ReminderTriggerRule.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cooldownHours = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxRemindersPerDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxRemindersPerWeek = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.allowedStartHour = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowedEndHour = reader.int32();
          continue;
        }
        case 10: {
          if (tag === 80) {
            message.allowedDaysOfWeek.push(reader.int32());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedDaysOfWeek.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.respectOptOut = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateReminderPolicyRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      triggerRules: globalThis.Array.isArray(object?.triggerRules)
        ? object.triggerRules.map((e: any) => ReminderTriggerRule.fromJSON(e))
        : globalThis.Array.isArray(object?.trigger_rules)
        ? object.trigger_rules.map((e: any) => ReminderTriggerRule.fromJSON(e))
        : [],
      cooldownHours: isSet(object.cooldownHours)
        ? globalThis.Number(object.cooldownHours)
        : isSet(object.cooldown_hours)
        ? globalThis.Number(object.cooldown_hours)
        : undefined,
      maxRemindersPerDay: isSet(object.maxRemindersPerDay)
        ? globalThis.Number(object.maxRemindersPerDay)
        : isSet(object.max_reminders_per_day)
        ? globalThis.Number(object.max_reminders_per_day)
        : undefined,
      maxRemindersPerWeek: isSet(object.maxRemindersPerWeek)
        ? globalThis.Number(object.maxRemindersPerWeek)
        : isSet(object.max_reminders_per_week)
        ? globalThis.Number(object.max_reminders_per_week)
        : undefined,
      allowedStartHour: isSet(object.allowedStartHour)
        ? globalThis.Number(object.allowedStartHour)
        : isSet(object.allowed_start_hour)
        ? globalThis.Number(object.allowed_start_hour)
        : undefined,
      allowedEndHour: isSet(object.allowedEndHour)
        ? globalThis.Number(object.allowedEndHour)
        : isSet(object.allowed_end_hour)
        ? globalThis.Number(object.allowed_end_hour)
        : undefined,
      allowedDaysOfWeek: globalThis.Array.isArray(object?.allowedDaysOfWeek)
        ? object.allowedDaysOfWeek.map((e: any) => globalThis.Number(e))
        : globalThis.Array.isArray(object?.allowed_days_of_week)
        ? object.allowed_days_of_week.map((e: any) => globalThis.Number(e))
        : [],
      respectOptOut: isSet(object.respectOptOut)
        ? globalThis.Boolean(object.respectOptOut)
        : isSet(object.respect_opt_out)
        ? globalThis.Boolean(object.respect_opt_out)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
      isDefault: isSet(object.isDefault)
        ? globalThis.Boolean(object.isDefault)
        : isSet(object.is_default)
        ? globalThis.Boolean(object.is_default)
        : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : undefined,
    };
  },

  toJSON(message: UpdateReminderPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.triggerRules?.length) {
      obj.triggerRules = message.triggerRules.map((e) => ReminderTriggerRule.toJSON(e));
    }
    if (message.cooldownHours !== undefined) {
      obj.cooldownHours = Math.round(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== undefined) {
      obj.maxRemindersPerDay = Math.round(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== undefined) {
      obj.maxRemindersPerWeek = Math.round(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== undefined) {
      obj.allowedStartHour = Math.round(message.allowedStartHour);
    }
    if (message.allowedEndHour !== undefined) {
      obj.allowedEndHour = Math.round(message.allowedEndHour);
    }
    if (message.allowedDaysOfWeek?.length) {
      obj.allowedDaysOfWeek = message.allowedDaysOfWeek.map((e) => Math.round(e));
    }
    if (message.respectOptOut !== undefined) {
      obj.respectOptOut = message.respectOptOut;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    if (message.isDefault !== undefined) {
      obj.isDefault = message.isDefault;
    }
    if (message.priority !== undefined) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateReminderPolicyRequest>, I>>(base?: I): UpdateReminderPolicyRequest {
    return UpdateReminderPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateReminderPolicyRequest>, I>>(object: I): UpdateReminderPolicyRequest {
    const message = createBaseUpdateReminderPolicyRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.triggerRules = object.triggerRules?.map((e) => ReminderTriggerRule.fromPartial(e)) || [];
    message.cooldownHours = object.cooldownHours ?? undefined;
    message.maxRemindersPerDay = object.maxRemindersPerDay ?? undefined;
    message.maxRemindersPerWeek = object.maxRemindersPerWeek ?? undefined;
    message.allowedStartHour = object.allowedStartHour ?? undefined;
    message.allowedEndHour = object.allowedEndHour ?? undefined;
    message.allowedDaysOfWeek = object.allowedDaysOfWeek?.map((e) => e) || [];
    message.respectOptOut = object.respectOptOut ?? undefined;
    message.isActive = object.isActive ?? undefined;
    message.isDefault = object.isDefault ?? undefined;
    message.priority = object.priority ?? undefined;
    return message;
  },
};

function createBaseDeleteReminderPolicyRequest(): DeleteReminderPolicyRequest {
  return { id: "" };
}

export const DeleteReminderPolicyRequest: MessageFns<DeleteReminderPolicyRequest> = {
  encode(message: DeleteReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteReminderPolicyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteReminderPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteReminderPolicyRequest>, I>>(base?: I): DeleteReminderPolicyRequest {
    return DeleteReminderPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteReminderPolicyRequest>, I>>(object: I): DeleteReminderPolicyRequest {
    const message = createBaseDeleteReminderPolicyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetReminderRequest(): GetReminderRequest {
  return { id: "" };
}

export const GetReminderRequest: MessageFns<GetReminderRequest> = {
  encode(message: GetReminderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReminderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReminderRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetReminderRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReminderRequest>, I>>(base?: I): GetReminderRequest {
    return GetReminderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReminderRequest>, I>>(object: I): GetReminderRequest {
    const message = createBaseGetReminderRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseReminderResponse(): ReminderResponse {
  return { reminder: undefined };
}

export const ReminderResponse: MessageFns<ReminderResponse> = {
  encode(message: ReminderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reminder !== undefined) {
      Reminder.encode(message.reminder, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminder = Reminder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReminderResponse {
    return { reminder: isSet(object.reminder) ? Reminder.fromJSON(object.reminder) : undefined };
  },

  toJSON(message: ReminderResponse): unknown {
    const obj: any = {};
    if (message.reminder !== undefined) {
      obj.reminder = Reminder.toJSON(message.reminder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReminderResponse>, I>>(base?: I): ReminderResponse {
    return ReminderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReminderResponse>, I>>(object: I): ReminderResponse {
    const message = createBaseReminderResponse();
    message.reminder = (object.reminder !== undefined && object.reminder !== null)
      ? Reminder.fromPartial(object.reminder)
      : undefined;
    return message;
  },
};

function createBaseListRemindersRequest(): ListRemindersRequest {
  return {
    organisationId: "",
    retryScheduleId: undefined,
    clientId: undefined,
    channel: undefined,
    status: undefined,
    fromDate: undefined,
    toDate: undefined,
    pagination: undefined,
  };
}

export const ListRemindersRequest: MessageFns<ListRemindersRequest> = {
  encode(message: ListRemindersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(26).string(message.clientId);
    }
    if (message.channel !== undefined) {
      writer.uint32(32).int32(message.channel);
    }
    if (message.status !== undefined) {
      writer.uint32(40).int32(message.status);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(toTimestamp(message.fromDate), writer.uint32(50).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(toTimestamp(message.toDate), writer.uint32(58).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRemindersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRemindersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fromDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.toDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRemindersRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      retryScheduleId: isSet(object.retryScheduleId)
        ? globalThis.String(object.retryScheduleId)
        : isSet(object.retry_schedule_id)
        ? globalThis.String(object.retry_schedule_id)
        : undefined,
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      channel: isSet(object.channel) ? reminderChannelFromJSON(object.channel) : undefined,
      status: isSet(object.status) ? reminderStatusFromJSON(object.status) : undefined,
      fromDate: isSet(object.fromDate)
        ? fromJsonTimestamp(object.fromDate)
        : isSet(object.from_date)
        ? fromJsonTimestamp(object.from_date)
        : undefined,
      toDate: isSet(object.toDate)
        ? fromJsonTimestamp(object.toDate)
        : isSet(object.to_date)
        ? fromJsonTimestamp(object.to_date)
        : undefined,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRemindersRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.retryScheduleId !== undefined) {
      obj.retryScheduleId = message.retryScheduleId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.channel !== undefined) {
      obj.channel = reminderChannelToJSON(message.channel);
    }
    if (message.status !== undefined) {
      obj.status = reminderStatusToJSON(message.status);
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate.toISOString();
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate.toISOString();
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRemindersRequest>, I>>(base?: I): ListRemindersRequest {
    return ListRemindersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRemindersRequest>, I>>(object: I): ListRemindersRequest {
    const message = createBaseListRemindersRequest();
    message.organisationId = object.organisationId ?? "";
    message.retryScheduleId = object.retryScheduleId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.channel = object.channel ?? undefined;
    message.status = object.status ?? undefined;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRemindersResponse(): ListRemindersResponse {
  return { reminders: [], pagination: undefined };
}

export const ListRemindersResponse: MessageFns<ListRemindersResponse> = {
  encode(message: ListRemindersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reminders) {
      Reminder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRemindersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRemindersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminders.push(Reminder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRemindersResponse {
    return {
      reminders: globalThis.Array.isArray(object?.reminders)
        ? object.reminders.map((e: any) => Reminder.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRemindersResponse): unknown {
    const obj: any = {};
    if (message.reminders?.length) {
      obj.reminders = message.reminders.map((e) => Reminder.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRemindersResponse>, I>>(base?: I): ListRemindersResponse {
    return ListRemindersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRemindersResponse>, I>>(object: I): ListRemindersResponse {
    const message = createBaseListRemindersResponse();
    message.reminders = object.reminders?.map((e) => Reminder.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseCancelReminderRequest(): CancelReminderRequest {
  return { id: "", reason: "", cancelledBy: "" };
}

export const CancelReminderRequest: MessageFns<CancelReminderRequest> = {
  encode(message: CancelReminderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(26).string(message.cancelledBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelReminderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelReminderRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      cancelledBy: isSet(object.cancelledBy)
        ? globalThis.String(object.cancelledBy)
        : isSet(object.cancelled_by)
        ? globalThis.String(object.cancelled_by)
        : "",
    };
  },

  toJSON(message: CancelReminderRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.cancelledBy !== "") {
      obj.cancelledBy = message.cancelledBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelReminderRequest>, I>>(base?: I): CancelReminderRequest {
    return CancelReminderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelReminderRequest>, I>>(object: I): CancelReminderRequest {
    const message = createBaseCancelReminderRequest();
    message.id = object.id ?? "";
    message.reason = object.reason ?? "";
    message.cancelledBy = object.cancelledBy ?? "";
    return message;
  },
};

function createBaseSendReminderRequest(): SendReminderRequest {
  return { id: "", force: false };
}

export const SendReminderRequest: MessageFns<SendReminderRequest> = {
  encode(message: SendReminderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendReminderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendReminderRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: SendReminderRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendReminderRequest>, I>>(base?: I): SendReminderRequest {
    return SendReminderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendReminderRequest>, I>>(object: I): SendReminderRequest {
    const message = createBaseSendReminderRequest();
    message.id = object.id ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseSendReminderResponse(): SendReminderResponse {
  return { success: false, message: "", providerMessageId: undefined, errorCode: undefined };
}

export const SendReminderResponse: MessageFns<SendReminderResponse> = {
  encode(message: SendReminderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(26).string(message.providerMessageId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendReminderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendReminderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendReminderResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      providerMessageId: isSet(object.providerMessageId)
        ? globalThis.String(object.providerMessageId)
        : isSet(object.provider_message_id)
        ? globalThis.String(object.provider_message_id)
        : undefined,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
    };
  },

  toJSON(message: SendReminderResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.providerMessageId !== undefined) {
      obj.providerMessageId = message.providerMessageId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendReminderResponse>, I>>(base?: I): SendReminderResponse {
    return SendReminderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendReminderResponse>, I>>(object: I): SendReminderResponse {
    const message = createBaseSendReminderResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.providerMessageId = object.providerMessageId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    return message;
  },
};

function createBaseProcessDueRemindersRequest(): ProcessDueRemindersRequest {
  return { organisationId: "", targetTime: undefined, timezone: "", dryRun: false };
}

export const ProcessDueRemindersRequest: MessageFns<ProcessDueRemindersRequest> = {
  encode(message: ProcessDueRemindersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.targetTime !== undefined) {
      Timestamp.encode(toTimestamp(message.targetTime), writer.uint32(18).fork()).join();
    }
    if (message.timezone !== "") {
      writer.uint32(26).string(message.timezone);
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRemindersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRemindersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDueRemindersRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      targetTime: isSet(object.targetTime)
        ? fromJsonTimestamp(object.targetTime)
        : isSet(object.target_time)
        ? fromJsonTimestamp(object.target_time)
        : undefined,
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
    };
  },

  toJSON(message: ProcessDueRemindersRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.targetTime !== undefined) {
      obj.targetTime = message.targetTime.toISOString();
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDueRemindersRequest>, I>>(base?: I): ProcessDueRemindersRequest {
    return ProcessDueRemindersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDueRemindersRequest>, I>>(object: I): ProcessDueRemindersRequest {
    const message = createBaseProcessDueRemindersRequest();
    message.organisationId = object.organisationId ?? "";
    message.targetTime = object.targetTime ?? undefined;
    message.timezone = object.timezone ?? "";
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseProcessDueRemindersResponse(): ProcessDueRemindersResponse {
  return { totalProcessed: 0, sent: 0, failed: 0, skipped: 0, results: [] };
}

export const ProcessDueRemindersResponse: MessageFns<ProcessDueRemindersResponse> = {
  encode(message: ProcessDueRemindersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalProcessed !== 0) {
      writer.uint32(8).int32(message.totalProcessed);
    }
    if (message.sent !== 0) {
      writer.uint32(16).int32(message.sent);
    }
    if (message.failed !== 0) {
      writer.uint32(24).int32(message.failed);
    }
    if (message.skipped !== 0) {
      writer.uint32(32).int32(message.skipped);
    }
    for (const v of message.results) {
      ProcessedReminderResult.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRemindersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRemindersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalProcessed = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skipped = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.results.push(ProcessedReminderResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDueRemindersResponse {
    return {
      totalProcessed: isSet(object.totalProcessed)
        ? globalThis.Number(object.totalProcessed)
        : isSet(object.total_processed)
        ? globalThis.Number(object.total_processed)
        : 0,
      sent: isSet(object.sent) ? globalThis.Number(object.sent) : 0,
      failed: isSet(object.failed) ? globalThis.Number(object.failed) : 0,
      skipped: isSet(object.skipped) ? globalThis.Number(object.skipped) : 0,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ProcessedReminderResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessDueRemindersResponse): unknown {
    const obj: any = {};
    if (message.totalProcessed !== 0) {
      obj.totalProcessed = Math.round(message.totalProcessed);
    }
    if (message.sent !== 0) {
      obj.sent = Math.round(message.sent);
    }
    if (message.failed !== 0) {
      obj.failed = Math.round(message.failed);
    }
    if (message.skipped !== 0) {
      obj.skipped = Math.round(message.skipped);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => ProcessedReminderResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDueRemindersResponse>, I>>(base?: I): ProcessDueRemindersResponse {
    return ProcessDueRemindersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDueRemindersResponse>, I>>(object: I): ProcessDueRemindersResponse {
    const message = createBaseProcessDueRemindersResponse();
    message.totalProcessed = object.totalProcessed ?? 0;
    message.sent = object.sent ?? 0;
    message.failed = object.failed ?? 0;
    message.skipped = object.skipped ?? 0;
    message.results = object.results?.map((e) => ProcessedReminderResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessedReminderResult(): ProcessedReminderResult {
  return {
    reminderId: "",
    success: false,
    channel: 0,
    providerMessageId: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    skipReason: undefined,
  };
}

export const ProcessedReminderResult: MessageFns<ProcessedReminderResult> = {
  encode(message: ProcessedReminderResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reminderId !== "") {
      writer.uint32(10).string(message.reminderId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(34).string(message.providerMessageId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(50).string(message.errorMessage);
    }
    if (message.skipReason !== undefined) {
      writer.uint32(58).string(message.skipReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessedReminderResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedReminderResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.skipReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessedReminderResult {
    return {
      reminderId: isSet(object.reminderId)
        ? globalThis.String(object.reminderId)
        : isSet(object.reminder_id)
        ? globalThis.String(object.reminder_id)
        : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      channel: isSet(object.channel) ? reminderChannelFromJSON(object.channel) : 0,
      providerMessageId: isSet(object.providerMessageId)
        ? globalThis.String(object.providerMessageId)
        : isSet(object.provider_message_id)
        ? globalThis.String(object.provider_message_id)
        : undefined,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
      skipReason: isSet(object.skipReason)
        ? globalThis.String(object.skipReason)
        : isSet(object.skip_reason)
        ? globalThis.String(object.skip_reason)
        : undefined,
    };
  },

  toJSON(message: ProcessedReminderResult): unknown {
    const obj: any = {};
    if (message.reminderId !== "") {
      obj.reminderId = message.reminderId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.channel !== 0) {
      obj.channel = reminderChannelToJSON(message.channel);
    }
    if (message.providerMessageId !== undefined) {
      obj.providerMessageId = message.providerMessageId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.skipReason !== undefined) {
      obj.skipReason = message.skipReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessedReminderResult>, I>>(base?: I): ProcessedReminderResult {
    return ProcessedReminderResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessedReminderResult>, I>>(object: I): ProcessedReminderResult {
    const message = createBaseProcessedReminderResult();
    message.reminderId = object.reminderId ?? "";
    message.success = object.success ?? false;
    message.channel = object.channel ?? 0;
    message.providerMessageId = object.providerMessageId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.skipReason = object.skipReason ?? undefined;
    return message;
  },
};

function createBaseUpdateDeliveryStatusRequest(): UpdateDeliveryStatusRequest {
  return {
    reminderId: "",
    status: 0,
    providerMessageId: undefined,
    deliveryStatusRaw: undefined,
    errorCode: undefined,
    errorMessage: undefined,
  };
}

export const UpdateDeliveryStatusRequest: MessageFns<UpdateDeliveryStatusRequest> = {
  encode(message: UpdateDeliveryStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reminderId !== "") {
      writer.uint32(10).string(message.reminderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(26).string(message.providerMessageId);
    }
    if (message.deliveryStatusRaw !== undefined) {
      writer.uint32(34).string(message.deliveryStatusRaw);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(50).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeliveryStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeliveryStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deliveryStatusRaw = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDeliveryStatusRequest {
    return {
      reminderId: isSet(object.reminderId)
        ? globalThis.String(object.reminderId)
        : isSet(object.reminder_id)
        ? globalThis.String(object.reminder_id)
        : "",
      status: isSet(object.status) ? reminderStatusFromJSON(object.status) : 0,
      providerMessageId: isSet(object.providerMessageId)
        ? globalThis.String(object.providerMessageId)
        : isSet(object.provider_message_id)
        ? globalThis.String(object.provider_message_id)
        : undefined,
      deliveryStatusRaw: isSet(object.deliveryStatusRaw)
        ? globalThis.String(object.deliveryStatusRaw)
        : isSet(object.delivery_status_raw)
        ? globalThis.String(object.delivery_status_raw)
        : undefined,
      errorCode: isSet(object.errorCode)
        ? globalThis.String(object.errorCode)
        : isSet(object.error_code)
        ? globalThis.String(object.error_code)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: UpdateDeliveryStatusRequest): unknown {
    const obj: any = {};
    if (message.reminderId !== "") {
      obj.reminderId = message.reminderId;
    }
    if (message.status !== 0) {
      obj.status = reminderStatusToJSON(message.status);
    }
    if (message.providerMessageId !== undefined) {
      obj.providerMessageId = message.providerMessageId;
    }
    if (message.deliveryStatusRaw !== undefined) {
      obj.deliveryStatusRaw = message.deliveryStatusRaw;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateDeliveryStatusRequest>, I>>(base?: I): UpdateDeliveryStatusRequest {
    return UpdateDeliveryStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateDeliveryStatusRequest>, I>>(object: I): UpdateDeliveryStatusRequest {
    const message = createBaseUpdateDeliveryStatusRequest();
    message.reminderId = object.reminderId ?? "";
    message.status = object.status ?? 0;
    message.providerMessageId = object.providerMessageId ?? undefined;
    message.deliveryStatusRaw = object.deliveryStatusRaw ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

export type RetryAdminServiceService = typeof RetryAdminServiceService;
export const RetryAdminServiceService = {
  getRetryPolicy: {
    path: "/retry.RetryAdminService/GetRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryPolicyRequest): Buffer =>
      Buffer.from(GetRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryPolicyRequest => GetRetryPolicyRequest.decode(value),
    responseSerialize: (value: RetryPolicyResponse): Buffer => Buffer.from(RetryPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryPolicyResponse => RetryPolicyResponse.decode(value),
  },
  listRetryPolicies: {
    path: "/retry.RetryAdminService/ListRetryPolicies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetryPoliciesRequest): Buffer =>
      Buffer.from(ListRetryPoliciesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetryPoliciesRequest => ListRetryPoliciesRequest.decode(value),
    responseSerialize: (value: ListRetryPoliciesResponse): Buffer =>
      Buffer.from(ListRetryPoliciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetryPoliciesResponse => ListRetryPoliciesResponse.decode(value),
  },
  createRetryPolicy: {
    path: "/retry.RetryAdminService/CreateRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRetryPolicyRequest): Buffer =>
      Buffer.from(CreateRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateRetryPolicyRequest => CreateRetryPolicyRequest.decode(value),
    responseSerialize: (value: RetryPolicyResponse): Buffer => Buffer.from(RetryPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryPolicyResponse => RetryPolicyResponse.decode(value),
  },
  updateRetryPolicy: {
    path: "/retry.RetryAdminService/UpdateRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateRetryPolicyRequest): Buffer =>
      Buffer.from(UpdateRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateRetryPolicyRequest => UpdateRetryPolicyRequest.decode(value),
    responseSerialize: (value: RetryPolicyResponse): Buffer => Buffer.from(RetryPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryPolicyResponse => RetryPolicyResponse.decode(value),
  },
  deleteRetryPolicy: {
    path: "/retry.RetryAdminService/DeleteRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRetryPolicyRequest): Buffer =>
      Buffer.from(DeleteRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRetryPolicyRequest => DeleteRetryPolicyRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getRetrySchedule: {
    path: "/retry.RetryAdminService/GetRetrySchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryScheduleRequest): Buffer =>
      Buffer.from(GetRetryScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryScheduleRequest => GetRetryScheduleRequest.decode(value),
    responseSerialize: (value: RetryScheduleResponse): Buffer =>
      Buffer.from(RetryScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryScheduleResponse => RetryScheduleResponse.decode(value),
  },
  listRetrySchedules: {
    path: "/retry.RetryAdminService/ListRetrySchedules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetrySchedulesRequest): Buffer =>
      Buffer.from(ListRetrySchedulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetrySchedulesRequest => ListRetrySchedulesRequest.decode(value),
    responseSerialize: (value: ListRetrySchedulesResponse): Buffer =>
      Buffer.from(ListRetrySchedulesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetrySchedulesResponse => ListRetrySchedulesResponse.decode(value),
  },
  cancelRetrySchedule: {
    path: "/retry.RetryAdminService/CancelRetrySchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelRetryScheduleRequest): Buffer =>
      Buffer.from(CancelRetryScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelRetryScheduleRequest => CancelRetryScheduleRequest.decode(value),
    responseSerialize: (value: RetryScheduleResponse): Buffer =>
      Buffer.from(RetryScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryScheduleResponse => RetryScheduleResponse.decode(value),
  },
  replanRetrySchedule: {
    path: "/retry.RetryAdminService/ReplanRetrySchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReplanRetryScheduleRequest): Buffer =>
      Buffer.from(ReplanRetryScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReplanRetryScheduleRequest => ReplanRetryScheduleRequest.decode(value),
    responseSerialize: (value: RetryScheduleResponse): Buffer =>
      Buffer.from(RetryScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryScheduleResponse => RetryScheduleResponse.decode(value),
  },
  getRetryAttempt: {
    path: "/retry.RetryAdminService/GetRetryAttempt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryAttemptRequest): Buffer =>
      Buffer.from(GetRetryAttemptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryAttemptRequest => GetRetryAttemptRequest.decode(value),
    responseSerialize: (value: RetryAttemptResponse): Buffer =>
      Buffer.from(RetryAttemptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryAttemptResponse => RetryAttemptResponse.decode(value),
  },
  listRetryAttempts: {
    path: "/retry.RetryAdminService/ListRetryAttempts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetryAttemptsRequest): Buffer =>
      Buffer.from(ListRetryAttemptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetryAttemptsRequest => ListRetryAttemptsRequest.decode(value),
    responseSerialize: (value: ListRetryAttemptsResponse): Buffer =>
      Buffer.from(ListRetryAttemptsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetryAttemptsResponse => ListRetryAttemptsResponse.decode(value),
  },
  runNow: {
    path: "/retry.RetryAdminService/RunNow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RunNowRequest): Buffer => Buffer.from(RunNowRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunNowRequest => RunNowRequest.decode(value),
    responseSerialize: (value: RunNowResponse): Buffer => Buffer.from(RunNowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunNowResponse => RunNowResponse.decode(value),
  },
  getRetryJobStatus: {
    path: "/retry.RetryAdminService/GetRetryJobStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryJobStatusRequest): Buffer =>
      Buffer.from(GetRetryJobStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryJobStatusRequest => GetRetryJobStatusRequest.decode(value),
    responseSerialize: (value: RetryJobResponse): Buffer => Buffer.from(RetryJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryJobResponse => RetryJobResponse.decode(value),
  },
  listRetryJobs: {
    path: "/retry.RetryAdminService/ListRetryJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetryJobsRequest): Buffer => Buffer.from(ListRetryJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetryJobsRequest => ListRetryJobsRequest.decode(value),
    responseSerialize: (value: ListRetryJobsResponse): Buffer =>
      Buffer.from(ListRetryJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetryJobsResponse => ListRetryJobsResponse.decode(value),
  },
  getRetryMetrics: {
    path: "/retry.RetryAdminService/GetRetryMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryMetricsRequest): Buffer =>
      Buffer.from(GetRetryMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryMetricsRequest => GetRetryMetricsRequest.decode(value),
    responseSerialize: (value: RetryMetricsResponse): Buffer =>
      Buffer.from(RetryMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryMetricsResponse => RetryMetricsResponse.decode(value),
  },
  getAuditLogs: {
    path: "/retry.RetryAdminService/GetAuditLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditLogsRequest): Buffer => Buffer.from(GetAuditLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuditLogsRequest => GetAuditLogsRequest.decode(value),
    responseSerialize: (value: AuditLogsResponse): Buffer => Buffer.from(AuditLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuditLogsResponse => AuditLogsResponse.decode(value),
  },
} as const;

export interface RetryAdminServiceServer extends UntypedServiceImplementation {
  getRetryPolicy: handleUnaryCall<GetRetryPolicyRequest, RetryPolicyResponse>;
  listRetryPolicies: handleUnaryCall<ListRetryPoliciesRequest, ListRetryPoliciesResponse>;
  createRetryPolicy: handleUnaryCall<CreateRetryPolicyRequest, RetryPolicyResponse>;
  updateRetryPolicy: handleUnaryCall<UpdateRetryPolicyRequest, RetryPolicyResponse>;
  deleteRetryPolicy: handleUnaryCall<DeleteRetryPolicyRequest, DeleteResponse>;
  getRetrySchedule: handleUnaryCall<GetRetryScheduleRequest, RetryScheduleResponse>;
  listRetrySchedules: handleUnaryCall<ListRetrySchedulesRequest, ListRetrySchedulesResponse>;
  cancelRetrySchedule: handleUnaryCall<CancelRetryScheduleRequest, RetryScheduleResponse>;
  replanRetrySchedule: handleUnaryCall<ReplanRetryScheduleRequest, RetryScheduleResponse>;
  getRetryAttempt: handleUnaryCall<GetRetryAttemptRequest, RetryAttemptResponse>;
  listRetryAttempts: handleUnaryCall<ListRetryAttemptsRequest, ListRetryAttemptsResponse>;
  runNow: handleUnaryCall<RunNowRequest, RunNowResponse>;
  getRetryJobStatus: handleUnaryCall<GetRetryJobStatusRequest, RetryJobResponse>;
  listRetryJobs: handleUnaryCall<ListRetryJobsRequest, ListRetryJobsResponse>;
  getRetryMetrics: handleUnaryCall<GetRetryMetricsRequest, RetryMetricsResponse>;
  getAuditLogs: handleUnaryCall<GetAuditLogsRequest, AuditLogsResponse>;
}

export type RetrySchedulerServiceService = typeof RetrySchedulerServiceService;
export const RetrySchedulerServiceService = {
  processDueRetries: {
    path: "/retry.RetrySchedulerService/ProcessDueRetries",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDueRetriesRequest): Buffer =>
      Buffer.from(ProcessDueRetriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessDueRetriesRequest => ProcessDueRetriesRequest.decode(value),
    responseSerialize: (value: ProcessDueRetriesResponse): Buffer =>
      Buffer.from(ProcessDueRetriesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessDueRetriesResponse => ProcessDueRetriesResponse.decode(value),
  },
  checkEligibility: {
    path: "/retry.RetrySchedulerService/CheckEligibility",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckEligibilityRequest): Buffer =>
      Buffer.from(CheckEligibilityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckEligibilityRequest => CheckEligibilityRequest.decode(value),
    responseSerialize: (value: CheckEligibilityResponse): Buffer =>
      Buffer.from(CheckEligibilityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckEligibilityResponse => CheckEligibilityResponse.decode(value),
  },
  handlePaymentRejected: {
    path: "/retry.RetrySchedulerService/HandlePaymentRejected",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentRejectedEvent): Buffer => Buffer.from(PaymentRejectedEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): PaymentRejectedEvent => PaymentRejectedEvent.decode(value),
    responseSerialize: (value: HandleRejectionResponse): Buffer =>
      Buffer.from(HandleRejectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HandleRejectionResponse => HandleRejectionResponse.decode(value),
  },
} as const;

export interface RetrySchedulerServiceServer extends UntypedServiceImplementation {
  processDueRetries: handleUnaryCall<ProcessDueRetriesRequest, ProcessDueRetriesResponse>;
  checkEligibility: handleUnaryCall<CheckEligibilityRequest, CheckEligibilityResponse>;
  handlePaymentRejected: handleUnaryCall<PaymentRejectedEvent, HandleRejectionResponse>;
}

export type ReminderServiceService = typeof ReminderServiceService;
export const ReminderServiceService = {
  getReminderPolicy: {
    path: "/retry.ReminderService/GetReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReminderPolicyRequest): Buffer =>
      Buffer.from(GetReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReminderPolicyRequest => GetReminderPolicyRequest.decode(value),
    responseSerialize: (value: ReminderPolicyResponse): Buffer =>
      Buffer.from(ReminderPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderPolicyResponse => ReminderPolicyResponse.decode(value),
  },
  listReminderPolicies: {
    path: "/retry.ReminderService/ListReminderPolicies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListReminderPoliciesRequest): Buffer =>
      Buffer.from(ListReminderPoliciesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListReminderPoliciesRequest => ListReminderPoliciesRequest.decode(value),
    responseSerialize: (value: ListReminderPoliciesResponse): Buffer =>
      Buffer.from(ListReminderPoliciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListReminderPoliciesResponse => ListReminderPoliciesResponse.decode(value),
  },
  createReminderPolicy: {
    path: "/retry.ReminderService/CreateReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateReminderPolicyRequest): Buffer =>
      Buffer.from(CreateReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateReminderPolicyRequest => CreateReminderPolicyRequest.decode(value),
    responseSerialize: (value: ReminderPolicyResponse): Buffer =>
      Buffer.from(ReminderPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderPolicyResponse => ReminderPolicyResponse.decode(value),
  },
  updateReminderPolicy: {
    path: "/retry.ReminderService/UpdateReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateReminderPolicyRequest): Buffer =>
      Buffer.from(UpdateReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateReminderPolicyRequest => UpdateReminderPolicyRequest.decode(value),
    responseSerialize: (value: ReminderPolicyResponse): Buffer =>
      Buffer.from(ReminderPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderPolicyResponse => ReminderPolicyResponse.decode(value),
  },
  deleteReminderPolicy: {
    path: "/retry.ReminderService/DeleteReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteReminderPolicyRequest): Buffer =>
      Buffer.from(DeleteReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteReminderPolicyRequest => DeleteReminderPolicyRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getReminder: {
    path: "/retry.ReminderService/GetReminder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReminderRequest): Buffer => Buffer.from(GetReminderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReminderRequest => GetReminderRequest.decode(value),
    responseSerialize: (value: ReminderResponse): Buffer => Buffer.from(ReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderResponse => ReminderResponse.decode(value),
  },
  listReminders: {
    path: "/retry.ReminderService/ListReminders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRemindersRequest): Buffer => Buffer.from(ListRemindersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRemindersRequest => ListRemindersRequest.decode(value),
    responseSerialize: (value: ListRemindersResponse): Buffer =>
      Buffer.from(ListRemindersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRemindersResponse => ListRemindersResponse.decode(value),
  },
  cancelReminder: {
    path: "/retry.ReminderService/CancelReminder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelReminderRequest): Buffer =>
      Buffer.from(CancelReminderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelReminderRequest => CancelReminderRequest.decode(value),
    responseSerialize: (value: ReminderResponse): Buffer => Buffer.from(ReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderResponse => ReminderResponse.decode(value),
  },
  sendReminder: {
    path: "/retry.ReminderService/SendReminder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendReminderRequest): Buffer => Buffer.from(SendReminderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendReminderRequest => SendReminderRequest.decode(value),
    responseSerialize: (value: SendReminderResponse): Buffer =>
      Buffer.from(SendReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SendReminderResponse => SendReminderResponse.decode(value),
  },
  processDueReminders: {
    path: "/retry.ReminderService/ProcessDueReminders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDueRemindersRequest): Buffer =>
      Buffer.from(ProcessDueRemindersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessDueRemindersRequest => ProcessDueRemindersRequest.decode(value),
    responseSerialize: (value: ProcessDueRemindersResponse): Buffer =>
      Buffer.from(ProcessDueRemindersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessDueRemindersResponse => ProcessDueRemindersResponse.decode(value),
  },
  updateDeliveryStatus: {
    path: "/retry.ReminderService/UpdateDeliveryStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateDeliveryStatusRequest): Buffer =>
      Buffer.from(UpdateDeliveryStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateDeliveryStatusRequest => UpdateDeliveryStatusRequest.decode(value),
    responseSerialize: (value: ReminderResponse): Buffer => Buffer.from(ReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderResponse => ReminderResponse.decode(value),
  },
} as const;

export interface ReminderServiceServer extends UntypedServiceImplementation {
  getReminderPolicy: handleUnaryCall<GetReminderPolicyRequest, ReminderPolicyResponse>;
  listReminderPolicies: handleUnaryCall<ListReminderPoliciesRequest, ListReminderPoliciesResponse>;
  createReminderPolicy: handleUnaryCall<CreateReminderPolicyRequest, ReminderPolicyResponse>;
  updateReminderPolicy: handleUnaryCall<UpdateReminderPolicyRequest, ReminderPolicyResponse>;
  deleteReminderPolicy: handleUnaryCall<DeleteReminderPolicyRequest, DeleteResponse>;
  getReminder: handleUnaryCall<GetReminderRequest, ReminderResponse>;
  listReminders: handleUnaryCall<ListRemindersRequest, ListRemindersResponse>;
  cancelReminder: handleUnaryCall<CancelReminderRequest, ReminderResponse>;
  sendReminder: handleUnaryCall<SendReminderRequest, SendReminderResponse>;
  processDueReminders: handleUnaryCall<ProcessDueRemindersRequest, ProcessDueRemindersResponse>;
  updateDeliveryStatus: handleUnaryCall<UpdateDeliveryStatusRequest, ReminderResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
