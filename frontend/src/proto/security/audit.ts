// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: security/audit.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  ClientReadableStream,
  type ClientUnaryCall,
  handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../google/protobuf/timestamp";

/** Audit result for logged actions */
export enum AuditResult {
  AUDIT_RESULT_UNSPECIFIED = 0,
  /** AUDIT_RESULT_ALLOWED - Action was allowed and executed */
  AUDIT_RESULT_ALLOWED = 1,
  /** AUDIT_RESULT_DENIED - Action was denied (authorization failed) */
  AUDIT_RESULT_DENIED = 2,
  /** AUDIT_RESULT_FAILED - Action failed (execution error) */
  AUDIT_RESULT_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function auditResultFromJSON(object: any): AuditResult {
  switch (object) {
    case 0:
    case "AUDIT_RESULT_UNSPECIFIED":
      return AuditResult.AUDIT_RESULT_UNSPECIFIED;
    case 1:
    case "AUDIT_RESULT_ALLOWED":
      return AuditResult.AUDIT_RESULT_ALLOWED;
    case 2:
    case "AUDIT_RESULT_DENIED":
      return AuditResult.AUDIT_RESULT_DENIED;
    case 3:
    case "AUDIT_RESULT_FAILED":
      return AuditResult.AUDIT_RESULT_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuditResult.UNRECOGNIZED;
  }
}

export function auditResultToJSON(object: AuditResult): string {
  switch (object) {
    case AuditResult.AUDIT_RESULT_UNSPECIFIED:
      return "AUDIT_RESULT_UNSPECIFIED";
    case AuditResult.AUDIT_RESULT_ALLOWED:
      return "AUDIT_RESULT_ALLOWED";
    case AuditResult.AUDIT_RESULT_DENIED:
      return "AUDIT_RESULT_DENIED";
    case AuditResult.AUDIT_RESULT_FAILED:
      return "AUDIT_RESULT_FAILED";
    case AuditResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of actor performing the action */
export enum ActorType {
  ACTOR_TYPE_UNSPECIFIED = 0,
  /** ACTOR_TYPE_USER - Human user */
  ACTOR_TYPE_USER = 1,
  /** ACTOR_TYPE_SERVICE - Service account or microservice */
  ACTOR_TYPE_SERVICE = 2,
  /** ACTOR_TYPE_SYSTEM - System/automated process */
  ACTOR_TYPE_SYSTEM = 3,
  /** ACTOR_TYPE_WEBHOOK - External webhook */
  ACTOR_TYPE_WEBHOOK = 4,
  UNRECOGNIZED = -1,
}

export function actorTypeFromJSON(object: any): ActorType {
  switch (object) {
    case 0:
    case "ACTOR_TYPE_UNSPECIFIED":
      return ActorType.ACTOR_TYPE_UNSPECIFIED;
    case 1:
    case "ACTOR_TYPE_USER":
      return ActorType.ACTOR_TYPE_USER;
    case 2:
    case "ACTOR_TYPE_SERVICE":
      return ActorType.ACTOR_TYPE_SERVICE;
    case 3:
    case "ACTOR_TYPE_SYSTEM":
      return ActorType.ACTOR_TYPE_SYSTEM;
    case 4:
    case "ACTOR_TYPE_WEBHOOK":
      return ActorType.ACTOR_TYPE_WEBHOOK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActorType.UNRECOGNIZED;
  }
}

export function actorTypeToJSON(object: ActorType): string {
  switch (object) {
    case ActorType.ACTOR_TYPE_UNSPECIFIED:
      return "ACTOR_TYPE_UNSPECIFIED";
    case ActorType.ACTOR_TYPE_USER:
      return "ACTOR_TYPE_USER";
    case ActorType.ACTOR_TYPE_SERVICE:
      return "ACTOR_TYPE_SERVICE";
    case ActorType.ACTOR_TYPE_SYSTEM:
      return "ACTOR_TYPE_SYSTEM";
    case ActorType.ACTOR_TYPE_WEBHOOK:
      return "ACTOR_TYPE_WEBHOOK";
    case ActorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExportFormat {
  EXPORT_FORMAT_UNSPECIFIED = 0,
  EXPORT_FORMAT_JSON = 1,
  EXPORT_FORMAT_CSV = 2,
  EXPORT_FORMAT_PARQUET = 3,
  UNRECOGNIZED = -1,
}

export function exportFormatFromJSON(object: any): ExportFormat {
  switch (object) {
    case 0:
    case "EXPORT_FORMAT_UNSPECIFIED":
      return ExportFormat.EXPORT_FORMAT_UNSPECIFIED;
    case 1:
    case "EXPORT_FORMAT_JSON":
      return ExportFormat.EXPORT_FORMAT_JSON;
    case 2:
    case "EXPORT_FORMAT_CSV":
      return ExportFormat.EXPORT_FORMAT_CSV;
    case 3:
    case "EXPORT_FORMAT_PARQUET":
      return ExportFormat.EXPORT_FORMAT_PARQUET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportFormat.UNRECOGNIZED;
  }
}

export function exportFormatToJSON(object: ExportFormat): string {
  switch (object) {
    case ExportFormat.EXPORT_FORMAT_UNSPECIFIED:
      return "EXPORT_FORMAT_UNSPECIFIED";
    case ExportFormat.EXPORT_FORMAT_JSON:
      return "EXPORT_FORMAT_JSON";
    case ExportFormat.EXPORT_FORMAT_CSV:
      return "EXPORT_FORMAT_CSV";
    case ExportFormat.EXPORT_FORMAT_PARQUET:
      return "EXPORT_FORMAT_PARQUET";
    case ExportFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about who performed the action */
export interface AuditActor {
  /** Type of actor */
  actorType: ActorType;
  /** User ID (if actor_type = USER) */
  userId: string;
  /** Keycloak subject ID (for correlation with IdP) */
  keycloakSub: string;
  /** Service name (if actor_type = SERVICE) */
  serviceName: string;
  /** Organisation/tenant context */
  organisationId: string;
  /** Break-glass session ID (if action performed under break-glass) */
  breakglassSessionId: string;
  /** User email (for display, may be redacted) */
  userEmail: string;
  /** IP address hash (SHA256 for privacy) */
  ipHash: string;
  /** User agent hash (SHA256 for privacy) */
  userAgentHash: string;
}

/** Information about the target of the action */
export interface AuditTarget {
  /** Type of target resource (e.g., "payment_intent", "user", "mandate") */
  targetType: string;
  /** ID of the target resource */
  targetId: string;
  /** Additional non-sensitive metadata about the target */
  targetMeta: { [key: string]: string };
}

export interface AuditTarget_TargetMetaEntry {
  key: string;
  value: string;
}

/** A single audit log entry */
export interface AuditLogEntry {
  /** Unique identifier (UUID) */
  id: string;
  /** When the action occurred */
  occurredAt?:
    | Date
    | undefined;
  /** Trace ID for distributed tracing */
  requestId: string;
  /** Business correlation ID (e.g., payment flow ID) */
  correlationId: string;
  /** Who performed the action */
  actor?:
    | AuditActor
    | undefined;
  /** Action label (e.g., "payment.refund.create") */
  action: string;
  /** Permission that was evaluated */
  permission: string;
  /** Result of the action */
  result: AuditResult;
  /** Error message (if result = FAILED or DENIED) */
  errorMessage: string;
  /** What was the action performed on */
  target?:
    | AuditTarget
    | undefined;
  /** State before the action (JSON, encrypted if sensitive) */
  beforeJson: string;
  /** State after the action (JSON, encrypted if sensitive) */
  afterJson: string;
  /** Hash of the previous entry in the chain */
  prevHash: string;
  /** Hash of this entry (SHA256 of prev_hash + canonical entry) */
  entryHash: string;
  /** Additional non-sensitive metadata */
  meta: { [key: string]: string };
}

export interface AuditLogEntry_MetaEntry {
  key: string;
  value: string;
}

export interface WriteAuditRequest {
  /** The audit entry to write (id, prev_hash, entry_hash computed server-side) */
  entry?: AuditLogEntry | undefined;
}

export interface WriteAuditResponse {
  /** Whether the write succeeded */
  success: boolean;
  /** The computed entry hash (for verification) */
  persistedEntryHash: string;
  /** The assigned entry ID */
  entryId: string;
}

/** Batch write for high-throughput scenarios */
export interface BatchWriteAuditRequest {
  /** Entries to write (ordered, hashes computed server-side) */
  entries: AuditLogEntry[];
}

export interface BatchWriteAuditResponse {
  /** Number of entries successfully written */
  successCount: number;
  /** Number of entries that failed */
  failureCount: number;
  /** IDs of failed entries */
  failedEntryIds: string[];
  /** Hash of the last successfully written entry */
  lastEntryHash: string;
}

export interface ListAuditRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range */
  from?: Date | undefined;
  to?:
    | Date
    | undefined;
  /** Filters */
  actions: string[];
  actorUserIds: string[];
  results: AuditResult[];
  targetType: string;
  targetId: string;
  correlationId: string;
  requestId: string;
  /** Pagination */
  page: number;
  limit: number;
  /** Sort order (default: occurred_at DESC) */
  sortBy: string;
  sortOrder: string;
}

export interface ListAuditResponse {
  /** Audit entries matching the query */
  entries: AuditLogEntry[];
  /** Pagination info */
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface GetAuditEntryRequest {
  id: string;
  organisationId: string;
}

export interface GetAuditEntryResponse {
  entry?: AuditLogEntry | undefined;
}

export interface ExportAuditRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range (required for export) */
  from?: Date | undefined;
  to?:
    | Date
    | undefined;
  /** Output format */
  format: ExportFormat;
  /** Include hash chain proof data */
  includeChainProof: boolean;
  /** Filters (same as ListAuditRequest) */
  actions: string[];
  actorUserIds: string[];
}

export interface ExportAuditChunk {
  /** Chunk of export data */
  data: Uint8Array;
  /** Watermark ID (tracks who exported this data) */
  watermarkId: string;
  /** Chunk index (for reassembly) */
  chunkIndex: number;
  /** Total chunks */
  totalChunks: number;
  /** Is this the last chunk? */
  isLast: boolean;
}

export interface VerifyChainRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range to verify */
  from?: Date | undefined;
  to?:
    | Date
    | undefined;
  /** Optional: specific stream (default: "default") */
  stream: string;
}

export interface VerifyChainResponse {
  /** Whether the chain is valid */
  valid: boolean;
  /** First hash in the verified range */
  firstHash: string;
  /** Last hash in the verified range */
  lastHash: string;
  /** Number of entries verified */
  entriesChecked: number;
  /** If invalid: ID of first corrupted entry */
  corruptedEntryId: string;
  /** If invalid: description of the issue */
  corruptionDetails: string;
}

export interface GetChainHeadRequest {
  organisationId: string;
  stream: string;
}

export interface GetChainHeadResponse {
  organisationId: string;
  stream: string;
  lastEntryHash: string;
  entryCount: number;
  lastUpdatedAt?: Date | undefined;
}

export interface CreateCheckpointRequest {
  organisationId: string;
  stream: string;
  /** If true, checkpoint is signed with KMS key */
  signCheckpoint: boolean;
}

export interface CreateCheckpointResponse {
  checkpointId: string;
  checkpointHash: string;
  signature: string;
  createdAt?: Date | undefined;
  entryCount: number;
}

export interface VerifyCheckpointRequest {
  checkpointId: string;
}

export interface VerifyCheckpointResponse {
  valid: boolean;
  checkpointHash: string;
  signatureValid: boolean;
  checkpointCreatedAt?: Date | undefined;
}

function createBaseAuditActor(): AuditActor {
  return {
    actorType: 0,
    userId: "",
    keycloakSub: "",
    serviceName: "",
    organisationId: "",
    breakglassSessionId: "",
    userEmail: "",
    ipHash: "",
    userAgentHash: "",
  };
}

export const AuditActor = {
  encode(message: AuditActor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== 0) {
      writer.uint32(8).int32(message.actorType);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(26).string(message.keycloakSub);
    }
    if (message.serviceName !== "") {
      writer.uint32(34).string(message.serviceName);
    }
    if (message.organisationId !== "") {
      writer.uint32(42).string(message.organisationId);
    }
    if (message.breakglassSessionId !== "") {
      writer.uint32(50).string(message.breakglassSessionId);
    }
    if (message.userEmail !== "") {
      writer.uint32(58).string(message.userEmail);
    }
    if (message.ipHash !== "") {
      writer.uint32(66).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(74).string(message.userAgentHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuditActor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditActor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.actorType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.breakglassSessionId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditActor {
    return {
      actorType: isSet(object.actorType) ? actorTypeFromJSON(object.actorType) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      keycloakSub: isSet(object.keycloakSub) ? globalThis.String(object.keycloakSub) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      breakglassSessionId: isSet(object.breakglassSessionId) ? globalThis.String(object.breakglassSessionId) : "",
      userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "",
      ipHash: isSet(object.ipHash) ? globalThis.String(object.ipHash) : "",
      userAgentHash: isSet(object.userAgentHash) ? globalThis.String(object.userAgentHash) : "",
    };
  },

  toJSON(message: AuditActor): unknown {
    const obj: any = {};
    if (message.actorType !== 0) {
      obj.actorType = actorTypeToJSON(message.actorType);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.keycloakSub !== "") {
      obj.keycloakSub = message.keycloakSub;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.breakglassSessionId !== "") {
      obj.breakglassSessionId = message.breakglassSessionId;
    }
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    if (message.ipHash !== "") {
      obj.ipHash = message.ipHash;
    }
    if (message.userAgentHash !== "") {
      obj.userAgentHash = message.userAgentHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditActor>, I>>(base?: I): AuditActor {
    return AuditActor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditActor>, I>>(object: I): AuditActor {
    const message = createBaseAuditActor();
    message.actorType = object.actorType ?? 0;
    message.userId = object.userId ?? "";
    message.keycloakSub = object.keycloakSub ?? "";
    message.serviceName = object.serviceName ?? "";
    message.organisationId = object.organisationId ?? "";
    message.breakglassSessionId = object.breakglassSessionId ?? "";
    message.userEmail = object.userEmail ?? "";
    message.ipHash = object.ipHash ?? "";
    message.userAgentHash = object.userAgentHash ?? "";
    return message;
  },
};

function createBaseAuditTarget(): AuditTarget {
  return { targetType: "", targetId: "", targetMeta: {} };
}

export const AuditTarget = {
  encode(message: AuditTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.targetType !== "") {
      writer.uint32(10).string(message.targetType);
    }
    if (message.targetId !== "") {
      writer.uint32(18).string(message.targetId);
    }
    Object.entries(message.targetMeta).forEach(([key, value]) => {
      AuditTarget_TargetMetaEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuditTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = AuditTarget_TargetMetaEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.targetMeta[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditTarget {
    return {
      targetType: isSet(object.targetType) ? globalThis.String(object.targetType) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      targetMeta: isObject(object.targetMeta)
        ? Object.entries(object.targetMeta).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AuditTarget): unknown {
    const obj: any = {};
    if (message.targetType !== "") {
      obj.targetType = message.targetType;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.targetMeta) {
      const entries = Object.entries(message.targetMeta);
      if (entries.length > 0) {
        obj.targetMeta = {};
        entries.forEach(([k, v]) => {
          obj.targetMeta[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditTarget>, I>>(base?: I): AuditTarget {
    return AuditTarget.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditTarget>, I>>(object: I): AuditTarget {
    const message = createBaseAuditTarget();
    message.targetType = object.targetType ?? "";
    message.targetId = object.targetId ?? "";
    message.targetMeta = Object.entries(object.targetMeta ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAuditTarget_TargetMetaEntry(): AuditTarget_TargetMetaEntry {
  return { key: "", value: "" };
}

export const AuditTarget_TargetMetaEntry = {
  encode(message: AuditTarget_TargetMetaEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuditTarget_TargetMetaEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditTarget_TargetMetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditTarget_TargetMetaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AuditTarget_TargetMetaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditTarget_TargetMetaEntry>, I>>(base?: I): AuditTarget_TargetMetaEntry {
    return AuditTarget_TargetMetaEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditTarget_TargetMetaEntry>, I>>(object: I): AuditTarget_TargetMetaEntry {
    const message = createBaseAuditTarget_TargetMetaEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAuditLogEntry(): AuditLogEntry {
  return {
    id: "",
    occurredAt: undefined,
    requestId: "",
    correlationId: "",
    actor: undefined,
    action: "",
    permission: "",
    result: 0,
    errorMessage: "",
    target: undefined,
    beforeJson: "",
    afterJson: "",
    prevHash: "",
    entryHash: "",
    meta: {},
  };
}

export const AuditLogEntry = {
  encode(message: AuditLogEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.occurredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.occurredAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.correlationId !== "") {
      writer.uint32(34).string(message.correlationId);
    }
    if (message.actor !== undefined) {
      AuditActor.encode(message.actor, writer.uint32(42).fork()).ldelim();
    }
    if (message.action !== "") {
      writer.uint32(50).string(message.action);
    }
    if (message.permission !== "") {
      writer.uint32(58).string(message.permission);
    }
    if (message.result !== 0) {
      writer.uint32(64).int32(message.result);
    }
    if (message.errorMessage !== "") {
      writer.uint32(74).string(message.errorMessage);
    }
    if (message.target !== undefined) {
      AuditTarget.encode(message.target, writer.uint32(82).fork()).ldelim();
    }
    if (message.beforeJson !== "") {
      writer.uint32(90).string(message.beforeJson);
    }
    if (message.afterJson !== "") {
      writer.uint32(98).string(message.afterJson);
    }
    if (message.prevHash !== "") {
      writer.uint32(106).string(message.prevHash);
    }
    if (message.entryHash !== "") {
      writer.uint32(114).string(message.entryHash);
    }
    Object.entries(message.meta).forEach(([key, value]) => {
      AuditLogEntry_MetaEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuditLogEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.occurredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actor = AuditActor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.action = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.permission = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.target = AuditTarget.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.beforeJson = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.afterJson = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.prevHash = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.entryHash = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = AuditLogEntry_MetaEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.meta[entry15.key] = entry15.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLogEntry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      occurredAt: isSet(object.occurredAt) ? fromJsonTimestamp(object.occurredAt) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      actor: isSet(object.actor) ? AuditActor.fromJSON(object.actor) : undefined,
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      permission: isSet(object.permission) ? globalThis.String(object.permission) : "",
      result: isSet(object.result) ? auditResultFromJSON(object.result) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      target: isSet(object.target) ? AuditTarget.fromJSON(object.target) : undefined,
      beforeJson: isSet(object.beforeJson) ? globalThis.String(object.beforeJson) : "",
      afterJson: isSet(object.afterJson) ? globalThis.String(object.afterJson) : "",
      prevHash: isSet(object.prevHash) ? globalThis.String(object.prevHash) : "",
      entryHash: isSet(object.entryHash) ? globalThis.String(object.entryHash) : "",
      meta: isObject(object.meta)
        ? Object.entries(object.meta).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AuditLogEntry): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.occurredAt !== undefined) {
      obj.occurredAt = message.occurredAt.toISOString();
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.actor !== undefined) {
      obj.actor = AuditActor.toJSON(message.actor);
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.permission !== "") {
      obj.permission = message.permission;
    }
    if (message.result !== 0) {
      obj.result = auditResultToJSON(message.result);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.target !== undefined) {
      obj.target = AuditTarget.toJSON(message.target);
    }
    if (message.beforeJson !== "") {
      obj.beforeJson = message.beforeJson;
    }
    if (message.afterJson !== "") {
      obj.afterJson = message.afterJson;
    }
    if (message.prevHash !== "") {
      obj.prevHash = message.prevHash;
    }
    if (message.entryHash !== "") {
      obj.entryHash = message.entryHash;
    }
    if (message.meta) {
      const entries = Object.entries(message.meta);
      if (entries.length > 0) {
        obj.meta = {};
        entries.forEach(([k, v]) => {
          obj.meta[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLogEntry>, I>>(base?: I): AuditLogEntry {
    return AuditLogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLogEntry>, I>>(object: I): AuditLogEntry {
    const message = createBaseAuditLogEntry();
    message.id = object.id ?? "";
    message.occurredAt = object.occurredAt ?? undefined;
    message.requestId = object.requestId ?? "";
    message.correlationId = object.correlationId ?? "";
    message.actor = (object.actor !== undefined && object.actor !== null)
      ? AuditActor.fromPartial(object.actor)
      : undefined;
    message.action = object.action ?? "";
    message.permission = object.permission ?? "";
    message.result = object.result ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.target = (object.target !== undefined && object.target !== null)
      ? AuditTarget.fromPartial(object.target)
      : undefined;
    message.beforeJson = object.beforeJson ?? "";
    message.afterJson = object.afterJson ?? "";
    message.prevHash = object.prevHash ?? "";
    message.entryHash = object.entryHash ?? "";
    message.meta = Object.entries(object.meta ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAuditLogEntry_MetaEntry(): AuditLogEntry_MetaEntry {
  return { key: "", value: "" };
}

export const AuditLogEntry_MetaEntry = {
  encode(message: AuditLogEntry_MetaEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuditLogEntry_MetaEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEntry_MetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLogEntry_MetaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AuditLogEntry_MetaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLogEntry_MetaEntry>, I>>(base?: I): AuditLogEntry_MetaEntry {
    return AuditLogEntry_MetaEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLogEntry_MetaEntry>, I>>(object: I): AuditLogEntry_MetaEntry {
    const message = createBaseAuditLogEntry_MetaEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWriteAuditRequest(): WriteAuditRequest {
  return { entry: undefined };
}

export const WriteAuditRequest = {
  encode(message: WriteAuditRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entry !== undefined) {
      AuditLogEntry.encode(message.entry, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WriteAuditRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entry = AuditLogEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteAuditRequest {
    return { entry: isSet(object.entry) ? AuditLogEntry.fromJSON(object.entry) : undefined };
  },

  toJSON(message: WriteAuditRequest): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = AuditLogEntry.toJSON(message.entry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteAuditRequest>, I>>(base?: I): WriteAuditRequest {
    return WriteAuditRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteAuditRequest>, I>>(object: I): WriteAuditRequest {
    const message = createBaseWriteAuditRequest();
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? AuditLogEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseWriteAuditResponse(): WriteAuditResponse {
  return { success: false, persistedEntryHash: "", entryId: "" };
}

export const WriteAuditResponse = {
  encode(message: WriteAuditResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.persistedEntryHash !== "") {
      writer.uint32(18).string(message.persistedEntryHash);
    }
    if (message.entryId !== "") {
      writer.uint32(26).string(message.entryId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WriteAuditResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.persistedEntryHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteAuditResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      persistedEntryHash: isSet(object.persistedEntryHash) ? globalThis.String(object.persistedEntryHash) : "",
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
    };
  },

  toJSON(message: WriteAuditResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.persistedEntryHash !== "") {
      obj.persistedEntryHash = message.persistedEntryHash;
    }
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteAuditResponse>, I>>(base?: I): WriteAuditResponse {
    return WriteAuditResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteAuditResponse>, I>>(object: I): WriteAuditResponse {
    const message = createBaseWriteAuditResponse();
    message.success = object.success ?? false;
    message.persistedEntryHash = object.persistedEntryHash ?? "";
    message.entryId = object.entryId ?? "";
    return message;
  },
};

function createBaseBatchWriteAuditRequest(): BatchWriteAuditRequest {
  return { entries: [] };
}

export const BatchWriteAuditRequest = {
  encode(message: BatchWriteAuditRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entries) {
      AuditLogEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchWriteAuditRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchWriteAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchWriteAuditRequest {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => AuditLogEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchWriteAuditRequest): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => AuditLogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchWriteAuditRequest>, I>>(base?: I): BatchWriteAuditRequest {
    return BatchWriteAuditRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchWriteAuditRequest>, I>>(object: I): BatchWriteAuditRequest {
    const message = createBaseBatchWriteAuditRequest();
    message.entries = object.entries?.map((e) => AuditLogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchWriteAuditResponse(): BatchWriteAuditResponse {
  return { successCount: 0, failureCount: 0, failedEntryIds: [], lastEntryHash: "" };
}

export const BatchWriteAuditResponse = {
  encode(message: BatchWriteAuditResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.successCount !== 0) {
      writer.uint32(8).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(16).int32(message.failureCount);
    }
    for (const v of message.failedEntryIds) {
      writer.uint32(26).string(v!);
    }
    if (message.lastEntryHash !== "") {
      writer.uint32(34).string(message.lastEntryHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchWriteAuditResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchWriteAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failedEntryIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastEntryHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchWriteAuditResponse {
    return {
      successCount: isSet(object.successCount) ? globalThis.Number(object.successCount) : 0,
      failureCount: isSet(object.failureCount) ? globalThis.Number(object.failureCount) : 0,
      failedEntryIds: globalThis.Array.isArray(object?.failedEntryIds)
        ? object.failedEntryIds.map((e: any) => globalThis.String(e))
        : [],
      lastEntryHash: isSet(object.lastEntryHash) ? globalThis.String(object.lastEntryHash) : "",
    };
  },

  toJSON(message: BatchWriteAuditResponse): unknown {
    const obj: any = {};
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failureCount !== 0) {
      obj.failureCount = Math.round(message.failureCount);
    }
    if (message.failedEntryIds?.length) {
      obj.failedEntryIds = message.failedEntryIds;
    }
    if (message.lastEntryHash !== "") {
      obj.lastEntryHash = message.lastEntryHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchWriteAuditResponse>, I>>(base?: I): BatchWriteAuditResponse {
    return BatchWriteAuditResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchWriteAuditResponse>, I>>(object: I): BatchWriteAuditResponse {
    const message = createBaseBatchWriteAuditResponse();
    message.successCount = object.successCount ?? 0;
    message.failureCount = object.failureCount ?? 0;
    message.failedEntryIds = object.failedEntryIds?.map((e) => e) || [];
    message.lastEntryHash = object.lastEntryHash ?? "";
    return message;
  },
};

function createBaseListAuditRequest(): ListAuditRequest {
  return {
    organisationId: "",
    from: undefined,
    to: undefined,
    actions: [],
    actorUserIds: [],
    results: [],
    targetType: "",
    targetId: "",
    correlationId: "",
    requestId: "",
    page: 0,
    limit: 0,
    sortBy: "",
    sortOrder: "",
  };
}

export const ListAuditRequest = {
  encode(message: ListAuditRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.actions) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.actorUserIds) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.results) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.targetType !== "") {
      writer.uint32(58).string(message.targetType);
    }
    if (message.targetId !== "") {
      writer.uint32(66).string(message.targetId);
    }
    if (message.correlationId !== "") {
      writer.uint32(74).string(message.correlationId);
    }
    if (message.requestId !== "") {
      writer.uint32(82).string(message.requestId);
    }
    if (message.page !== 0) {
      writer.uint32(88).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(96).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(106).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(114).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAuditRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.actorUserIds.push(reader.string());
          continue;
        case 6:
          if (tag === 48) {
            message.results.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.results.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
      actorUserIds: globalThis.Array.isArray(object?.actorUserIds)
        ? object.actorUserIds.map((e: any) => globalThis.String(e))
        : [],
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => auditResultFromJSON(e)) : [],
      targetType: isSet(object.targetType) ? globalThis.String(object.targetType) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      sortBy: isSet(object.sortBy) ? globalThis.String(object.sortBy) : "",
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
    };
  },

  toJSON(message: ListAuditRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.actorUserIds?.length) {
      obj.actorUserIds = message.actorUserIds;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => auditResultToJSON(e));
    }
    if (message.targetType !== "") {
      obj.targetType = message.targetType;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditRequest>, I>>(base?: I): ListAuditRequest {
    return ListAuditRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditRequest>, I>>(object: I): ListAuditRequest {
    const message = createBaseListAuditRequest();
    message.organisationId = object.organisationId ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.actions = object.actions?.map((e) => e) || [];
    message.actorUserIds = object.actorUserIds?.map((e) => e) || [];
    message.results = object.results?.map((e) => e) || [];
    message.targetType = object.targetType ?? "";
    message.targetId = object.targetId ?? "";
    message.correlationId = object.correlationId ?? "";
    message.requestId = object.requestId ?? "";
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBaseListAuditResponse(): ListAuditResponse {
  return { entries: [], total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const ListAuditResponse = {
  encode(message: ListAuditResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.entries) {
      AuditLogEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(40).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAuditResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditResponse {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => AuditLogEntry.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListAuditResponse): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => AuditLogEntry.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditResponse>, I>>(base?: I): ListAuditResponse {
    return ListAuditResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditResponse>, I>>(object: I): ListAuditResponse {
    const message = createBaseListAuditResponse();
    message.entries = object.entries?.map((e) => AuditLogEntry.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetAuditEntryRequest(): GetAuditEntryRequest {
  return { id: "", organisationId: "" };
}

export const GetAuditEntryRequest = {
  encode(message: GetAuditEntryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAuditEntryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditEntryRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
    };
  },

  toJSON(message: GetAuditEntryRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuditEntryRequest>, I>>(base?: I): GetAuditEntryRequest {
    return GetAuditEntryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuditEntryRequest>, I>>(object: I): GetAuditEntryRequest {
    const message = createBaseGetAuditEntryRequest();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    return message;
  },
};

function createBaseGetAuditEntryResponse(): GetAuditEntryResponse {
  return { entry: undefined };
}

export const GetAuditEntryResponse = {
  encode(message: GetAuditEntryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entry !== undefined) {
      AuditLogEntry.encode(message.entry, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAuditEntryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditEntryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entry = AuditLogEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditEntryResponse {
    return { entry: isSet(object.entry) ? AuditLogEntry.fromJSON(object.entry) : undefined };
  },

  toJSON(message: GetAuditEntryResponse): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = AuditLogEntry.toJSON(message.entry);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAuditEntryResponse>, I>>(base?: I): GetAuditEntryResponse {
    return GetAuditEntryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAuditEntryResponse>, I>>(object: I): GetAuditEntryResponse {
    const message = createBaseGetAuditEntryResponse();
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? AuditLogEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseExportAuditRequest(): ExportAuditRequest {
  return {
    organisationId: "",
    from: undefined,
    to: undefined,
    format: 0,
    includeChainProof: false,
    actions: [],
    actorUserIds: [],
  };
}

export const ExportAuditRequest = {
  encode(message: ExportAuditRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).ldelim();
    }
    if (message.format !== 0) {
      writer.uint32(32).int32(message.format);
    }
    if (message.includeChainProof !== false) {
      writer.uint32(40).bool(message.includeChainProof);
    }
    for (const v of message.actions) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.actorUserIds) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAuditRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includeChainProof = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.actorUserIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAuditRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      format: isSet(object.format) ? exportFormatFromJSON(object.format) : 0,
      includeChainProof: isSet(object.includeChainProof) ? globalThis.Boolean(object.includeChainProof) : false,
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
      actorUserIds: globalThis.Array.isArray(object?.actorUserIds)
        ? object.actorUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ExportAuditRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.format !== 0) {
      obj.format = exportFormatToJSON(message.format);
    }
    if (message.includeChainProof !== false) {
      obj.includeChainProof = message.includeChainProof;
    }
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.actorUserIds?.length) {
      obj.actorUserIds = message.actorUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportAuditRequest>, I>>(base?: I): ExportAuditRequest {
    return ExportAuditRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportAuditRequest>, I>>(object: I): ExportAuditRequest {
    const message = createBaseExportAuditRequest();
    message.organisationId = object.organisationId ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.format = object.format ?? 0;
    message.includeChainProof = object.includeChainProof ?? false;
    message.actions = object.actions?.map((e) => e) || [];
    message.actorUserIds = object.actorUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseExportAuditChunk(): ExportAuditChunk {
  return { data: new Uint8Array(0), watermarkId: "", chunkIndex: 0, totalChunks: 0, isLast: false };
}

export const ExportAuditChunk = {
  encode(message: ExportAuditChunk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.watermarkId !== "") {
      writer.uint32(18).string(message.watermarkId);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(24).int32(message.chunkIndex);
    }
    if (message.totalChunks !== 0) {
      writer.uint32(32).int32(message.totalChunks);
    }
    if (message.isLast !== false) {
      writer.uint32(40).bool(message.isLast);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAuditChunk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAuditChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.watermarkId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalChunks = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isLast = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAuditChunk {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      watermarkId: isSet(object.watermarkId) ? globalThis.String(object.watermarkId) : "",
      chunkIndex: isSet(object.chunkIndex) ? globalThis.Number(object.chunkIndex) : 0,
      totalChunks: isSet(object.totalChunks) ? globalThis.Number(object.totalChunks) : 0,
      isLast: isSet(object.isLast) ? globalThis.Boolean(object.isLast) : false,
    };
  },

  toJSON(message: ExportAuditChunk): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.watermarkId !== "") {
      obj.watermarkId = message.watermarkId;
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.totalChunks !== 0) {
      obj.totalChunks = Math.round(message.totalChunks);
    }
    if (message.isLast !== false) {
      obj.isLast = message.isLast;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExportAuditChunk>, I>>(base?: I): ExportAuditChunk {
    return ExportAuditChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExportAuditChunk>, I>>(object: I): ExportAuditChunk {
    const message = createBaseExportAuditChunk();
    message.data = object.data ?? new Uint8Array(0);
    message.watermarkId = object.watermarkId ?? "";
    message.chunkIndex = object.chunkIndex ?? 0;
    message.totalChunks = object.totalChunks ?? 0;
    message.isLast = object.isLast ?? false;
    return message;
  },
};

function createBaseVerifyChainRequest(): VerifyChainRequest {
  return { organisationId: "", from: undefined, to: undefined, stream: "" };
}

export const VerifyChainRequest = {
  encode(message: VerifyChainRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).ldelim();
    }
    if (message.stream !== "") {
      writer.uint32(34).string(message.stream);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VerifyChainRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyChainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stream = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyChainRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
    };
  },

  toJSON(message: VerifyChainRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyChainRequest>, I>>(base?: I): VerifyChainRequest {
    return VerifyChainRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyChainRequest>, I>>(object: I): VerifyChainRequest {
    const message = createBaseVerifyChainRequest();
    message.organisationId = object.organisationId ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.stream = object.stream ?? "";
    return message;
  },
};

function createBaseVerifyChainResponse(): VerifyChainResponse {
  return { valid: false, firstHash: "", lastHash: "", entriesChecked: 0, corruptedEntryId: "", corruptionDetails: "" };
}

export const VerifyChainResponse = {
  encode(message: VerifyChainResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.firstHash !== "") {
      writer.uint32(18).string(message.firstHash);
    }
    if (message.lastHash !== "") {
      writer.uint32(26).string(message.lastHash);
    }
    if (message.entriesChecked !== 0) {
      writer.uint32(32).int64(message.entriesChecked);
    }
    if (message.corruptedEntryId !== "") {
      writer.uint32(42).string(message.corruptedEntryId);
    }
    if (message.corruptionDetails !== "") {
      writer.uint32(50).string(message.corruptionDetails);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VerifyChainResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.firstHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastHash = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entriesChecked = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.corruptedEntryId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.corruptionDetails = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyChainResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      firstHash: isSet(object.firstHash) ? globalThis.String(object.firstHash) : "",
      lastHash: isSet(object.lastHash) ? globalThis.String(object.lastHash) : "",
      entriesChecked: isSet(object.entriesChecked) ? globalThis.Number(object.entriesChecked) : 0,
      corruptedEntryId: isSet(object.corruptedEntryId) ? globalThis.String(object.corruptedEntryId) : "",
      corruptionDetails: isSet(object.corruptionDetails) ? globalThis.String(object.corruptionDetails) : "",
    };
  },

  toJSON(message: VerifyChainResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.firstHash !== "") {
      obj.firstHash = message.firstHash;
    }
    if (message.lastHash !== "") {
      obj.lastHash = message.lastHash;
    }
    if (message.entriesChecked !== 0) {
      obj.entriesChecked = Math.round(message.entriesChecked);
    }
    if (message.corruptedEntryId !== "") {
      obj.corruptedEntryId = message.corruptedEntryId;
    }
    if (message.corruptionDetails !== "") {
      obj.corruptionDetails = message.corruptionDetails;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyChainResponse>, I>>(base?: I): VerifyChainResponse {
    return VerifyChainResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyChainResponse>, I>>(object: I): VerifyChainResponse {
    const message = createBaseVerifyChainResponse();
    message.valid = object.valid ?? false;
    message.firstHash = object.firstHash ?? "";
    message.lastHash = object.lastHash ?? "";
    message.entriesChecked = object.entriesChecked ?? 0;
    message.corruptedEntryId = object.corruptedEntryId ?? "";
    message.corruptionDetails = object.corruptionDetails ?? "";
    return message;
  },
};

function createBaseGetChainHeadRequest(): GetChainHeadRequest {
  return { organisationId: "", stream: "" };
}

export const GetChainHeadRequest = {
  encode(message: GetChainHeadRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChainHeadRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainHeadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainHeadRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
    };
  },

  toJSON(message: GetChainHeadRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainHeadRequest>, I>>(base?: I): GetChainHeadRequest {
    return GetChainHeadRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainHeadRequest>, I>>(object: I): GetChainHeadRequest {
    const message = createBaseGetChainHeadRequest();
    message.organisationId = object.organisationId ?? "";
    message.stream = object.stream ?? "";
    return message;
  },
};

function createBaseGetChainHeadResponse(): GetChainHeadResponse {
  return { organisationId: "", stream: "", lastEntryHash: "", entryCount: 0, lastUpdatedAt: undefined };
}

export const GetChainHeadResponse = {
  encode(message: GetChainHeadResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    if (message.lastEntryHash !== "") {
      writer.uint32(26).string(message.lastEntryHash);
    }
    if (message.entryCount !== 0) {
      writer.uint32(32).int64(message.entryCount);
    }
    if (message.lastUpdatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdatedAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChainHeadResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainHeadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastEntryHash = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entryCount = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastUpdatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainHeadResponse {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      lastEntryHash: isSet(object.lastEntryHash) ? globalThis.String(object.lastEntryHash) : "",
      entryCount: isSet(object.entryCount) ? globalThis.Number(object.entryCount) : 0,
      lastUpdatedAt: isSet(object.lastUpdatedAt) ? fromJsonTimestamp(object.lastUpdatedAt) : undefined,
    };
  },

  toJSON(message: GetChainHeadResponse): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.lastEntryHash !== "") {
      obj.lastEntryHash = message.lastEntryHash;
    }
    if (message.entryCount !== 0) {
      obj.entryCount = Math.round(message.entryCount);
    }
    if (message.lastUpdatedAt !== undefined) {
      obj.lastUpdatedAt = message.lastUpdatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainHeadResponse>, I>>(base?: I): GetChainHeadResponse {
    return GetChainHeadResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainHeadResponse>, I>>(object: I): GetChainHeadResponse {
    const message = createBaseGetChainHeadResponse();
    message.organisationId = object.organisationId ?? "";
    message.stream = object.stream ?? "";
    message.lastEntryHash = object.lastEntryHash ?? "";
    message.entryCount = object.entryCount ?? 0;
    message.lastUpdatedAt = object.lastUpdatedAt ?? undefined;
    return message;
  },
};

function createBaseCreateCheckpointRequest(): CreateCheckpointRequest {
  return { organisationId: "", stream: "", signCheckpoint: false };
}

export const CreateCheckpointRequest = {
  encode(message: CreateCheckpointRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    if (message.signCheckpoint !== false) {
      writer.uint32(24).bool(message.signCheckpoint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateCheckpointRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.signCheckpoint = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckpointRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      signCheckpoint: isSet(object.signCheckpoint) ? globalThis.Boolean(object.signCheckpoint) : false,
    };
  },

  toJSON(message: CreateCheckpointRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.signCheckpoint !== false) {
      obj.signCheckpoint = message.signCheckpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckpointRequest>, I>>(base?: I): CreateCheckpointRequest {
    return CreateCheckpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckpointRequest>, I>>(object: I): CreateCheckpointRequest {
    const message = createBaseCreateCheckpointRequest();
    message.organisationId = object.organisationId ?? "";
    message.stream = object.stream ?? "";
    message.signCheckpoint = object.signCheckpoint ?? false;
    return message;
  },
};

function createBaseCreateCheckpointResponse(): CreateCheckpointResponse {
  return { checkpointId: "", checkpointHash: "", signature: "", createdAt: undefined, entryCount: 0 };
}

export const CreateCheckpointResponse = {
  encode(message: CreateCheckpointResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.checkpointId !== "") {
      writer.uint32(10).string(message.checkpointId);
    }
    if (message.checkpointHash !== "") {
      writer.uint32(18).string(message.checkpointHash);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.entryCount !== 0) {
      writer.uint32(40).int64(message.entryCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateCheckpointResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpointId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.checkpointHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.entryCount = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckpointResponse {
    return {
      checkpointId: isSet(object.checkpointId) ? globalThis.String(object.checkpointId) : "",
      checkpointHash: isSet(object.checkpointHash) ? globalThis.String(object.checkpointHash) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      entryCount: isSet(object.entryCount) ? globalThis.Number(object.entryCount) : 0,
    };
  },

  toJSON(message: CreateCheckpointResponse): unknown {
    const obj: any = {};
    if (message.checkpointId !== "") {
      obj.checkpointId = message.checkpointId;
    }
    if (message.checkpointHash !== "") {
      obj.checkpointHash = message.checkpointHash;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.entryCount !== 0) {
      obj.entryCount = Math.round(message.entryCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckpointResponse>, I>>(base?: I): CreateCheckpointResponse {
    return CreateCheckpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckpointResponse>, I>>(object: I): CreateCheckpointResponse {
    const message = createBaseCreateCheckpointResponse();
    message.checkpointId = object.checkpointId ?? "";
    message.checkpointHash = object.checkpointHash ?? "";
    message.signature = object.signature ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.entryCount = object.entryCount ?? 0;
    return message;
  },
};

function createBaseVerifyCheckpointRequest(): VerifyCheckpointRequest {
  return { checkpointId: "" };
}

export const VerifyCheckpointRequest = {
  encode(message: VerifyCheckpointRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.checkpointId !== "") {
      writer.uint32(10).string(message.checkpointId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VerifyCheckpointRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpointId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyCheckpointRequest {
    return { checkpointId: isSet(object.checkpointId) ? globalThis.String(object.checkpointId) : "" };
  },

  toJSON(message: VerifyCheckpointRequest): unknown {
    const obj: any = {};
    if (message.checkpointId !== "") {
      obj.checkpointId = message.checkpointId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyCheckpointRequest>, I>>(base?: I): VerifyCheckpointRequest {
    return VerifyCheckpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyCheckpointRequest>, I>>(object: I): VerifyCheckpointRequest {
    const message = createBaseVerifyCheckpointRequest();
    message.checkpointId = object.checkpointId ?? "";
    return message;
  },
};

function createBaseVerifyCheckpointResponse(): VerifyCheckpointResponse {
  return { valid: false, checkpointHash: "", signatureValid: false, checkpointCreatedAt: undefined };
}

export const VerifyCheckpointResponse = {
  encode(message: VerifyCheckpointResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.checkpointHash !== "") {
      writer.uint32(18).string(message.checkpointHash);
    }
    if (message.signatureValid !== false) {
      writer.uint32(24).bool(message.signatureValid);
    }
    if (message.checkpointCreatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.checkpointCreatedAt), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VerifyCheckpointResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.checkpointHash = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.signatureValid = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.checkpointCreatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyCheckpointResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      checkpointHash: isSet(object.checkpointHash) ? globalThis.String(object.checkpointHash) : "",
      signatureValid: isSet(object.signatureValid) ? globalThis.Boolean(object.signatureValid) : false,
      checkpointCreatedAt: isSet(object.checkpointCreatedAt)
        ? fromJsonTimestamp(object.checkpointCreatedAt)
        : undefined,
    };
  },

  toJSON(message: VerifyCheckpointResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.checkpointHash !== "") {
      obj.checkpointHash = message.checkpointHash;
    }
    if (message.signatureValid !== false) {
      obj.signatureValid = message.signatureValid;
    }
    if (message.checkpointCreatedAt !== undefined) {
      obj.checkpointCreatedAt = message.checkpointCreatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyCheckpointResponse>, I>>(base?: I): VerifyCheckpointResponse {
    return VerifyCheckpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyCheckpointResponse>, I>>(object: I): VerifyCheckpointResponse {
    const message = createBaseVerifyCheckpointResponse();
    message.valid = object.valid ?? false;
    message.checkpointHash = object.checkpointHash ?? "";
    message.signatureValid = object.signatureValid ?? false;
    message.checkpointCreatedAt = object.checkpointCreatedAt ?? undefined;
    return message;
  },
};

export type AuditServiceService = typeof AuditServiceService;
export const AuditServiceService = {
  /** Write a single audit entry */
  write: {
    path: "/security.AuditService/Write",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WriteAuditRequest) => Buffer.from(WriteAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WriteAuditRequest.decode(value),
    responseSerialize: (value: WriteAuditResponse) => Buffer.from(WriteAuditResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WriteAuditResponse.decode(value),
  },
  /** Batch write audit entries */
  batchWrite: {
    path: "/security.AuditService/BatchWrite",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchWriteAuditRequest) => Buffer.from(BatchWriteAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BatchWriteAuditRequest.decode(value),
    responseSerialize: (value: BatchWriteAuditResponse) => Buffer.from(BatchWriteAuditResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BatchWriteAuditResponse.decode(value),
  },
  /** Query audit entries */
  list: {
    path: "/security.AuditService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAuditRequest) => Buffer.from(ListAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListAuditRequest.decode(value),
    responseSerialize: (value: ListAuditResponse) => Buffer.from(ListAuditResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListAuditResponse.decode(value),
  },
  /** Get a single audit entry */
  get: {
    path: "/security.AuditService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditEntryRequest) => Buffer.from(GetAuditEntryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAuditEntryRequest.decode(value),
    responseSerialize: (value: GetAuditEntryResponse) => Buffer.from(GetAuditEntryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAuditEntryResponse.decode(value),
  },
  /** Export audit entries (controlled, watermarked) */
  export: {
    path: "/security.AuditService/Export",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ExportAuditRequest) => Buffer.from(ExportAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExportAuditRequest.decode(value),
    responseSerialize: (value: ExportAuditChunk) => Buffer.from(ExportAuditChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExportAuditChunk.decode(value),
  },
  /** Verify hash chain integrity */
  verifyChain: {
    path: "/security.AuditService/VerifyChain",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyChainRequest) => Buffer.from(VerifyChainRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyChainRequest.decode(value),
    responseSerialize: (value: VerifyChainResponse) => Buffer.from(VerifyChainResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyChainResponse.decode(value),
  },
  /** Get current chain head */
  getChainHead: {
    path: "/security.AuditService/GetChainHead",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetChainHeadRequest) => Buffer.from(GetChainHeadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetChainHeadRequest.decode(value),
    responseSerialize: (value: GetChainHeadResponse) => Buffer.from(GetChainHeadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetChainHeadResponse.decode(value),
  },
  /** Create a checkpoint (signed snapshot of chain state) */
  createCheckpoint: {
    path: "/security.AuditService/CreateCheckpoint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCheckpointRequest) => Buffer.from(CreateCheckpointRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateCheckpointRequest.decode(value),
    responseSerialize: (value: CreateCheckpointResponse) =>
      Buffer.from(CreateCheckpointResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateCheckpointResponse.decode(value),
  },
  /** Verify a checkpoint */
  verifyCheckpoint: {
    path: "/security.AuditService/VerifyCheckpoint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyCheckpointRequest) => Buffer.from(VerifyCheckpointRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyCheckpointRequest.decode(value),
    responseSerialize: (value: VerifyCheckpointResponse) =>
      Buffer.from(VerifyCheckpointResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyCheckpointResponse.decode(value),
  },
} as const;

export interface AuditServiceServer extends UntypedServiceImplementation {
  /** Write a single audit entry */
  write: handleUnaryCall<WriteAuditRequest, WriteAuditResponse>;
  /** Batch write audit entries */
  batchWrite: handleUnaryCall<BatchWriteAuditRequest, BatchWriteAuditResponse>;
  /** Query audit entries */
  list: handleUnaryCall<ListAuditRequest, ListAuditResponse>;
  /** Get a single audit entry */
  get: handleUnaryCall<GetAuditEntryRequest, GetAuditEntryResponse>;
  /** Export audit entries (controlled, watermarked) */
  export: handleServerStreamingCall<ExportAuditRequest, ExportAuditChunk>;
  /** Verify hash chain integrity */
  verifyChain: handleUnaryCall<VerifyChainRequest, VerifyChainResponse>;
  /** Get current chain head */
  getChainHead: handleUnaryCall<GetChainHeadRequest, GetChainHeadResponse>;
  /** Create a checkpoint (signed snapshot of chain state) */
  createCheckpoint: handleUnaryCall<CreateCheckpointRequest, CreateCheckpointResponse>;
  /** Verify a checkpoint */
  verifyCheckpoint: handleUnaryCall<VerifyCheckpointRequest, VerifyCheckpointResponse>;
}

export interface AuditServiceClient extends Client {
  /** Write a single audit entry */
  write(
    request: WriteAuditRequest,
    callback: (error: ServiceError | null, response: WriteAuditResponse) => void,
  ): ClientUnaryCall;
  write(
    request: WriteAuditRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WriteAuditResponse) => void,
  ): ClientUnaryCall;
  write(
    request: WriteAuditRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WriteAuditResponse) => void,
  ): ClientUnaryCall;
  /** Batch write audit entries */
  batchWrite(
    request: BatchWriteAuditRequest,
    callback: (error: ServiceError | null, response: BatchWriteAuditResponse) => void,
  ): ClientUnaryCall;
  batchWrite(
    request: BatchWriteAuditRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchWriteAuditResponse) => void,
  ): ClientUnaryCall;
  batchWrite(
    request: BatchWriteAuditRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchWriteAuditResponse) => void,
  ): ClientUnaryCall;
  /** Query audit entries */
  list(
    request: ListAuditRequest,
    callback: (error: ServiceError | null, response: ListAuditResponse) => void,
  ): ClientUnaryCall;
  list(
    request: ListAuditRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListAuditResponse) => void,
  ): ClientUnaryCall;
  list(
    request: ListAuditRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListAuditResponse) => void,
  ): ClientUnaryCall;
  /** Get a single audit entry */
  get(
    request: GetAuditEntryRequest,
    callback: (error: ServiceError | null, response: GetAuditEntryResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetAuditEntryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAuditEntryResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetAuditEntryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAuditEntryResponse) => void,
  ): ClientUnaryCall;
  /** Export audit entries (controlled, watermarked) */
  export(request: ExportAuditRequest, options?: Partial<CallOptions>): ClientReadableStream<ExportAuditChunk>;
  export(
    request: ExportAuditRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ExportAuditChunk>;
  /** Verify hash chain integrity */
  verifyChain(
    request: VerifyChainRequest,
    callback: (error: ServiceError | null, response: VerifyChainResponse) => void,
  ): ClientUnaryCall;
  verifyChain(
    request: VerifyChainRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyChainResponse) => void,
  ): ClientUnaryCall;
  verifyChain(
    request: VerifyChainRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyChainResponse) => void,
  ): ClientUnaryCall;
  /** Get current chain head */
  getChainHead(
    request: GetChainHeadRequest,
    callback: (error: ServiceError | null, response: GetChainHeadResponse) => void,
  ): ClientUnaryCall;
  getChainHead(
    request: GetChainHeadRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetChainHeadResponse) => void,
  ): ClientUnaryCall;
  getChainHead(
    request: GetChainHeadRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetChainHeadResponse) => void,
  ): ClientUnaryCall;
  /** Create a checkpoint (signed snapshot of chain state) */
  createCheckpoint(
    request: CreateCheckpointRequest,
    callback: (error: ServiceError | null, response: CreateCheckpointResponse) => void,
  ): ClientUnaryCall;
  createCheckpoint(
    request: CreateCheckpointRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateCheckpointResponse) => void,
  ): ClientUnaryCall;
  createCheckpoint(
    request: CreateCheckpointRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateCheckpointResponse) => void,
  ): ClientUnaryCall;
  /** Verify a checkpoint */
  verifyCheckpoint(
    request: VerifyCheckpointRequest,
    callback: (error: ServiceError | null, response: VerifyCheckpointResponse) => void,
  ): ClientUnaryCall;
  verifyCheckpoint(
    request: VerifyCheckpointRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyCheckpointResponse) => void,
  ): ClientUnaryCall;
  verifyCheckpoint(
    request: VerifyCheckpointRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyCheckpointResponse) => void,
  ): ClientUnaryCall;
}

export const AuditServiceClient = makeGenericClientConstructor(
  AuditServiceService,
  "security.AuditService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuditServiceClient;
  service: typeof AuditServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
