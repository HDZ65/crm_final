// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: security/audit.proto

/* eslint-disable */

/** Audit result for logged actions */
export enum AuditResult {
  AUDIT_RESULT_UNSPECIFIED = 0,
  /** AUDIT_RESULT_ALLOWED - Action was allowed and executed */
  AUDIT_RESULT_ALLOWED = 1,
  /** AUDIT_RESULT_DENIED - Action was denied (authorization failed) */
  AUDIT_RESULT_DENIED = 2,
  /** AUDIT_RESULT_FAILED - Action failed (execution error) */
  AUDIT_RESULT_FAILED = 3,
  UNRECOGNIZED = -1,
}

/** Type of actor performing the action */
export enum ActorType {
  ACTOR_TYPE_UNSPECIFIED = 0,
  /** ACTOR_TYPE_USER - Human user */
  ACTOR_TYPE_USER = 1,
  /** ACTOR_TYPE_SERVICE - Service account or microservice */
  ACTOR_TYPE_SERVICE = 2,
  /** ACTOR_TYPE_SYSTEM - System/automated process */
  ACTOR_TYPE_SYSTEM = 3,
  /** ACTOR_TYPE_WEBHOOK - External webhook */
  ACTOR_TYPE_WEBHOOK = 4,
  UNRECOGNIZED = -1,
}

export enum ExportFormat {
  EXPORT_FORMAT_UNSPECIFIED = 0,
  EXPORT_FORMAT_JSON = 1,
  EXPORT_FORMAT_CSV = 2,
  EXPORT_FORMAT_PARQUET = 3,
  UNRECOGNIZED = -1,
}

/** Information about who performed the action */
export interface AuditActor {
  /** Type of actor */
  actorType: ActorType;
  /** User ID (if actor_type = USER) */
  userId: string;
  /** Keycloak subject ID (for correlation with IdP) */
  keycloakSub: string;
  /** Service name (if actor_type = SERVICE) */
  serviceName: string;
  /** Organisation/tenant context */
  organisationId: string;
  /** Break-glass session ID (if action performed under break-glass) */
  breakglassSessionId: string;
  /** User email (for display, may be redacted) */
  userEmail: string;
  /** IP address hash (SHA256 for privacy) */
  ipHash: string;
  /** User agent hash (SHA256 for privacy) */
  userAgentHash: string;
}

/** Information about the target of the action */
export interface AuditTarget {
  /** Type of target resource (e.g., "payment_intent", "user", "mandate") */
  targetType: string;
  /** ID of the target resource */
  targetId: string;
  /** Additional non-sensitive metadata about the target */
  targetMeta: { [key: string]: string };
}

export interface AuditTarget_TargetMetaEntry {
  key: string;
  value: string;
}

/** A single audit log entry */
export interface AuditLogEntry {
  /** Unique identifier (UUID) */
  id: string;
  /** When the action occurred */
  occurredAt?:
    | Date
    | undefined;
  /** Trace ID for distributed tracing */
  requestId: string;
  /** Business correlation ID (e.g., payment flow ID) */
  correlationId: string;
  /** Who performed the action */
  actor?:
    | AuditActor
    | undefined;
  /** Action label (e.g., "payment.refund.create") */
  action: string;
  /** Permission that was evaluated */
  permission: string;
  /** Result of the action */
  result: AuditResult;
  /** Error message (if result = FAILED or DENIED) */
  errorMessage: string;
  /** What was the action performed on */
  target?:
    | AuditTarget
    | undefined;
  /** State before the action (JSON, encrypted if sensitive) */
  beforeJson: string;
  /** State after the action (JSON, encrypted if sensitive) */
  afterJson: string;
  /** Hash of the previous entry in the chain */
  prevHash: string;
  /** Hash of this entry (SHA256 of prev_hash + canonical entry) */
  entryHash: string;
  /** Additional non-sensitive metadata */
  meta: { [key: string]: string };
}

export interface AuditLogEntry_MetaEntry {
  key: string;
  value: string;
}

export interface WriteAuditRequest {
  /** The audit entry to write (id, prev_hash, entry_hash computed server-side) */
  entry?: AuditLogEntry | undefined;
}

export interface WriteAuditResponse {
  /** Whether the write succeeded */
  success: boolean;
  /** The computed entry hash (for verification) */
  persistedEntryHash: string;
  /** The assigned entry ID */
  entryId: string;
}

/** Batch write for high-throughput scenarios */
export interface BatchWriteAuditRequest {
  /** Entries to write (ordered, hashes computed server-side) */
  entries: AuditLogEntry[];
}

export interface BatchWriteAuditResponse {
  /** Number of entries successfully written */
  successCount: number;
  /** Number of entries that failed */
  failureCount: number;
  /** IDs of failed entries */
  failedEntryIds: string[];
  /** Hash of the last successfully written entry */
  lastEntryHash: string;
}

export interface ListAuditRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range */
  from?: Date | undefined;
  to?:
    | Date
    | undefined;
  /** Filters */
  actions: string[];
  actorUserIds: string[];
  results: AuditResult[];
  targetType: string;
  targetId: string;
  correlationId: string;
  requestId: string;
  /** Pagination */
  page: number;
  limit: number;
  /** Sort order (default: occurred_at DESC) */
  sortBy: string;
  sortOrder: string;
}

export interface ListAuditResponse {
  /** Audit entries matching the query */
  entries: AuditLogEntry[];
  /** Pagination info */
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface GetAuditEntryRequest {
  id: string;
  organisationId: string;
}

export interface GetAuditEntryResponse {
  entry?: AuditLogEntry | undefined;
}

export interface ExportAuditRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range (required for export) */
  from?: Date | undefined;
  to?:
    | Date
    | undefined;
  /** Output format */
  format: ExportFormat;
  /** Include hash chain proof data */
  includeChainProof: boolean;
  /** Filters (same as ListAuditRequest) */
  actions: string[];
  actorUserIds: string[];
}

export interface ExportAuditChunk {
  /** Chunk of export data */
  data: Uint8Array;
  /** Watermark ID (tracks who exported this data) */
  watermarkId: string;
  /** Chunk index (for reassembly) */
  chunkIndex: number;
  /** Total chunks */
  totalChunks: number;
  /** Is this the last chunk? */
  isLast: boolean;
}

export interface VerifyChainRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range to verify */
  from?: Date | undefined;
  to?:
    | Date
    | undefined;
  /** Optional: specific stream (default: "default") */
  stream: string;
}

export interface VerifyChainResponse {
  /** Whether the chain is valid */
  valid: boolean;
  /** First hash in the verified range */
  firstHash: string;
  /** Last hash in the verified range */
  lastHash: string;
  /** Number of entries verified */
  entriesChecked: number;
  /** If invalid: ID of first corrupted entry */
  corruptedEntryId: string;
  /** If invalid: description of the issue */
  corruptionDetails: string;
}

export interface GetChainHeadRequest {
  organisationId: string;
  stream: string;
}

export interface GetChainHeadResponse {
  organisationId: string;
  stream: string;
  lastEntryHash: string;
  entryCount: number;
  lastUpdatedAt?: Date | undefined;
}

export interface CreateCheckpointRequest {
  organisationId: string;
  stream: string;
  /** If true, checkpoint is signed with KMS key */
  signCheckpoint: boolean;
}

export interface CreateCheckpointResponse {
  checkpointId: string;
  checkpointHash: string;
  signature: string;
  createdAt?: Date | undefined;
  entryCount: number;
}

export interface VerifyCheckpointRequest {
  checkpointId: string;
}

export interface VerifyCheckpointResponse {
  valid: boolean;
  checkpointHash: string;
  signatureValid: boolean;
  checkpointCreatedAt?: Date | undefined;
}
