// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: security/auth.proto

/* eslint-disable */

/** Session status */
export enum SessionStatus {
  SESSION_STATUS_UNSPECIFIED = 0,
  SESSION_STATUS_ACTIVE = 1,
  SESSION_STATUS_REVOKED = 2,
  SESSION_STATUS_EXPIRED = 3,
  SESSION_STATUS_SUSPICIOUS = 4,
  UNRECOGNIZED = -1,
}

/** MFA method types */
export enum MfaMethod {
  MFA_METHOD_UNSPECIFIED = 0,
  MFA_METHOD_TOTP = 1,
  MFA_METHOD_WEBAUTHN = 2,
  MFA_METHOD_SMS = 3,
  MFA_METHOD_EMAIL = 4,
  UNRECOGNIZED = -1,
}

/** Break-glass session status */
export enum BreakglassStatus {
  BREAKGLASS_STATUS_UNSPECIFIED = 0,
  BREAKGLASS_STATUS_ACTIVE = 1,
  BREAKGLASS_STATUS_EXPIRED = 2,
  BREAKGLASS_STATUS_ENDED = 3,
  BREAKGLASS_STATUS_REVOKED = 4,
  UNRECOGNIZED = -1,
}

/** Auth session tracking */
export interface AuthSession {
  /** Session ID (from Keycloak sid claim) */
  sessionId: string;
  /** User ID in our system */
  userId: string;
  /** Keycloak subject ID */
  keycloakSub: string;
  /** Organisation context (if single-org session) */
  organisationId: string;
  /** Security metadata (hashed for privacy) */
  ipHash: string;
  userAgentHash: string;
  /** Timestamps */
  createdAt?: Date | undefined;
  lastActivityAt?: Date | undefined;
  expiresAt?:
    | Date
    | undefined;
  /** MFA state */
  mfaVerifiedAt?: Date | undefined;
  mfaMethod: MfaMethod;
  /** Session status */
  status: SessionStatus;
  /** Revocation info (if revoked) */
  revokedBy: string;
  revocationReason: string;
  revokedAt?: Date | undefined;
}

/** Request to track a new session */
export interface TrackSessionRequest {
  sessionId: string;
  userId: string;
  keycloakSub: string;
  organisationId: string;
  ipHash: string;
  userAgentHash: string;
  expiresAt?: Date | undefined;
  mfaVerifiedAt?: Date | undefined;
  mfaMethod: MfaMethod;
}

export interface TrackSessionResponse {
  session?: AuthSession | undefined;
}

/** Request to update session activity */
export interface UpdateSessionActivityRequest {
  sessionId: string;
  ipHash: string;
  userAgentHash: string;
}

export interface UpdateSessionActivityResponse {
  session?:
    | AuthSession
    | undefined;
  /** True if session context changed significantly (IP/UA) */
  contextChanged: boolean;
}

/** Request to revoke a session */
export interface RevokeSessionRequest {
  sessionId: string;
  revokedBy: string;
  reason: string;
}

export interface RevokeSessionResponse {
  success: boolean;
}

/** Request to check session validity */
export interface CheckSessionRequest {
  sessionId: string;
}

export interface CheckSessionResponse {
  valid: boolean;
  session?:
    | AuthSession
    | undefined;
  /** If invalid, reason why */
  invalidReason: string;
}

/** List active sessions for a user */
export interface ListUserSessionsRequest {
  userId: string;
  includeRevoked: boolean;
}

export interface ListUserSessionsResponse {
  sessions: AuthSession[];
}

/** MFA device registration */
export interface MfaDevice {
  id: string;
  userId: string;
  method: MfaMethod;
  deviceName: string;
  registeredAt?: Date | undefined;
  lastUsedAt?: Date | undefined;
  isPrimary: boolean;
}

/** Record MFA verification */
export interface RecordMfaVerificationRequest {
  sessionId: string;
  userId: string;
  method: MfaMethod;
  success: boolean;
}

export interface RecordMfaVerificationResponse {
  recorded: boolean;
  mfaVerifiedAt?: Date | undefined;
}

/** Check if MFA step-up is required */
export interface CheckStepUpRequest {
  sessionId: string;
  permission: string;
  requiredFreshnessSeconds: number;
}

export interface CheckStepUpResponse {
  stepUpRequired: boolean;
  mfaVerifiedAt?: Date | undefined;
  secondsSinceMfa: number;
  stepUpUrl: string;
}

/** Break-glass session */
export interface BreakglassSession {
  id: string;
  organisationId: string;
  utilisateurId: string;
  /** Reason is encrypted at rest */
  reasonCiphertext: string;
  /** Ticket reference (e.g., JIRA ticket, incident ID) */
  ticketRef: string;
  /** Timestamps */
  startedAt?: Date | undefined;
  expiresAt?: Date | undefined;
  endedAt?:
    | Date
    | undefined;
  /** Who ended the session (if manually ended) */
  endedByUserId: string;
  endReason: string;
  /** Status */
  status: BreakglassStatus;
  /** Permissions granted during break-glass */
  grantedPermissions: string[];
}

/** Activate break-glass session */
export interface ActivateBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
  reason: string;
  ticketRef: string;
  /** Duration in seconds (max 3600 = 1 hour) */
  ttlSeconds: number;
  /** Optional: specific permissions (default: SuperAdmin set) */
  requestedPermissions: string[];
}

export interface ActivateBreakglassResponse {
  session?: BreakglassSession | undefined;
}

/** Deactivate break-glass session */
export interface DeactivateBreakglassRequest {
  sessionId: string;
  endedByUserId: string;
  reason: string;
}

export interface DeactivateBreakglassResponse {
  session?: BreakglassSession | undefined;
}

/** Get active break-glass session for user */
export interface GetActiveBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
}

export interface GetActiveBreakglassResponse {
  /** Null if no active session */
  session?: BreakglassSession | undefined;
  hasActiveSession: boolean;
}

/** Check if break-glass is active for context */
export interface CheckBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
}

export interface CheckBreakglassResponse {
  isActive: boolean;
  sessionId: string;
  expiresAt?: Date | undefined;
  grantedPermissions: string[];
}

/** List break-glass sessions (for audit) */
export interface ListBreakglassSessionsRequest {
  organisationId: string;
  from?: Date | undefined;
  to?: Date | undefined;
  statuses: BreakglassStatus[];
  page: number;
  limit: number;
}

export interface ListBreakglassSessionsResponse {
  sessions: BreakglassSession[];
  total: number;
  page: number;
  limit: number;
}

/** Full access context for authorization decisions */
export interface AccessContext {
  /** User identity */
  userId: string;
  keycloakSub: string;
  /** Tenant context */
  organisationId: string;
  /** Roles and permissions */
  roles: string[];
  permissions: string[];
  /** Break-glass context (if active) */
  breakglassSessionId: string;
  breakglassPermissions: string[];
  /** MFA state */
  mfaVerifiedAt?: Date | undefined;
  mfaMethod: MfaMethod;
  /** Session metadata */
  sessionId: string;
  ipHash: string;
  userAgentHash: string;
  /** Request context */
  requestId: string;
  correlationId: string;
}

/** Build access context from session */
export interface BuildAccessContextRequest {
  sessionId: string;
  organisationId: string;
}

export interface BuildAccessContextResponse {
  context?: AccessContext | undefined;
}
