// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: security/auth.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../google/protobuf/timestamp";

/** Session status */
export enum SessionStatus {
  SESSION_STATUS_UNSPECIFIED = 0,
  SESSION_STATUS_ACTIVE = 1,
  SESSION_STATUS_REVOKED = 2,
  SESSION_STATUS_EXPIRED = 3,
  SESSION_STATUS_SUSPICIOUS = 4,
  UNRECOGNIZED = -1,
}

export function sessionStatusFromJSON(object: any): SessionStatus {
  switch (object) {
    case 0:
    case "SESSION_STATUS_UNSPECIFIED":
      return SessionStatus.SESSION_STATUS_UNSPECIFIED;
    case 1:
    case "SESSION_STATUS_ACTIVE":
      return SessionStatus.SESSION_STATUS_ACTIVE;
    case 2:
    case "SESSION_STATUS_REVOKED":
      return SessionStatus.SESSION_STATUS_REVOKED;
    case 3:
    case "SESSION_STATUS_EXPIRED":
      return SessionStatus.SESSION_STATUS_EXPIRED;
    case 4:
    case "SESSION_STATUS_SUSPICIOUS":
      return SessionStatus.SESSION_STATUS_SUSPICIOUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SessionStatus.UNRECOGNIZED;
  }
}

export function sessionStatusToJSON(object: SessionStatus): string {
  switch (object) {
    case SessionStatus.SESSION_STATUS_UNSPECIFIED:
      return "SESSION_STATUS_UNSPECIFIED";
    case SessionStatus.SESSION_STATUS_ACTIVE:
      return "SESSION_STATUS_ACTIVE";
    case SessionStatus.SESSION_STATUS_REVOKED:
      return "SESSION_STATUS_REVOKED";
    case SessionStatus.SESSION_STATUS_EXPIRED:
      return "SESSION_STATUS_EXPIRED";
    case SessionStatus.SESSION_STATUS_SUSPICIOUS:
      return "SESSION_STATUS_SUSPICIOUS";
    case SessionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MFA method types */
export enum MfaMethod {
  MFA_METHOD_UNSPECIFIED = 0,
  MFA_METHOD_TOTP = 1,
  MFA_METHOD_WEBAUTHN = 2,
  MFA_METHOD_SMS = 3,
  MFA_METHOD_EMAIL = 4,
  UNRECOGNIZED = -1,
}

export function mfaMethodFromJSON(object: any): MfaMethod {
  switch (object) {
    case 0:
    case "MFA_METHOD_UNSPECIFIED":
      return MfaMethod.MFA_METHOD_UNSPECIFIED;
    case 1:
    case "MFA_METHOD_TOTP":
      return MfaMethod.MFA_METHOD_TOTP;
    case 2:
    case "MFA_METHOD_WEBAUTHN":
      return MfaMethod.MFA_METHOD_WEBAUTHN;
    case 3:
    case "MFA_METHOD_SMS":
      return MfaMethod.MFA_METHOD_SMS;
    case 4:
    case "MFA_METHOD_EMAIL":
      return MfaMethod.MFA_METHOD_EMAIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MfaMethod.UNRECOGNIZED;
  }
}

export function mfaMethodToJSON(object: MfaMethod): string {
  switch (object) {
    case MfaMethod.MFA_METHOD_UNSPECIFIED:
      return "MFA_METHOD_UNSPECIFIED";
    case MfaMethod.MFA_METHOD_TOTP:
      return "MFA_METHOD_TOTP";
    case MfaMethod.MFA_METHOD_WEBAUTHN:
      return "MFA_METHOD_WEBAUTHN";
    case MfaMethod.MFA_METHOD_SMS:
      return "MFA_METHOD_SMS";
    case MfaMethod.MFA_METHOD_EMAIL:
      return "MFA_METHOD_EMAIL";
    case MfaMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Break-glass session status */
export enum BreakglassStatus {
  BREAKGLASS_STATUS_UNSPECIFIED = 0,
  BREAKGLASS_STATUS_ACTIVE = 1,
  BREAKGLASS_STATUS_EXPIRED = 2,
  BREAKGLASS_STATUS_ENDED = 3,
  BREAKGLASS_STATUS_REVOKED = 4,
  UNRECOGNIZED = -1,
}

export function breakglassStatusFromJSON(object: any): BreakglassStatus {
  switch (object) {
    case 0:
    case "BREAKGLASS_STATUS_UNSPECIFIED":
      return BreakglassStatus.BREAKGLASS_STATUS_UNSPECIFIED;
    case 1:
    case "BREAKGLASS_STATUS_ACTIVE":
      return BreakglassStatus.BREAKGLASS_STATUS_ACTIVE;
    case 2:
    case "BREAKGLASS_STATUS_EXPIRED":
      return BreakglassStatus.BREAKGLASS_STATUS_EXPIRED;
    case 3:
    case "BREAKGLASS_STATUS_ENDED":
      return BreakglassStatus.BREAKGLASS_STATUS_ENDED;
    case 4:
    case "BREAKGLASS_STATUS_REVOKED":
      return BreakglassStatus.BREAKGLASS_STATUS_REVOKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BreakglassStatus.UNRECOGNIZED;
  }
}

export function breakglassStatusToJSON(object: BreakglassStatus): string {
  switch (object) {
    case BreakglassStatus.BREAKGLASS_STATUS_UNSPECIFIED:
      return "BREAKGLASS_STATUS_UNSPECIFIED";
    case BreakglassStatus.BREAKGLASS_STATUS_ACTIVE:
      return "BREAKGLASS_STATUS_ACTIVE";
    case BreakglassStatus.BREAKGLASS_STATUS_EXPIRED:
      return "BREAKGLASS_STATUS_EXPIRED";
    case BreakglassStatus.BREAKGLASS_STATUS_ENDED:
      return "BREAKGLASS_STATUS_ENDED";
    case BreakglassStatus.BREAKGLASS_STATUS_REVOKED:
      return "BREAKGLASS_STATUS_REVOKED";
    case BreakglassStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Auth session tracking */
export interface AuthSession {
  /** Session ID (from Keycloak sid claim) */
  sessionId: string;
  /** User ID in our system */
  userId: string;
  /** Keycloak subject ID */
  keycloakSub: string;
  /** Organisation context (if single-org session) */
  organisationId: string;
  /** Security metadata (hashed for privacy) */
  ipHash: string;
  userAgentHash: string;
  /** Timestamps */
  createdAt?: Date | undefined;
  lastActivityAt?: Date | undefined;
  expiresAt?:
    | Date
    | undefined;
  /** MFA state */
  mfaVerifiedAt?: Date | undefined;
  mfaMethod: MfaMethod;
  /** Session status */
  status: SessionStatus;
  /** Revocation info (if revoked) */
  revokedBy: string;
  revocationReason: string;
  revokedAt?: Date | undefined;
}

/** Request to track a new session */
export interface TrackSessionRequest {
  sessionId: string;
  userId: string;
  keycloakSub: string;
  organisationId: string;
  ipHash: string;
  userAgentHash: string;
  expiresAt?: Date | undefined;
  mfaVerifiedAt?: Date | undefined;
  mfaMethod: MfaMethod;
}

export interface TrackSessionResponse {
  session?: AuthSession | undefined;
}

/** Request to update session activity */
export interface UpdateSessionActivityRequest {
  sessionId: string;
  ipHash: string;
  userAgentHash: string;
}

export interface UpdateSessionActivityResponse {
  session?:
    | AuthSession
    | undefined;
  /** True if session context changed significantly (IP/UA) */
  contextChanged: boolean;
}

/** Request to revoke a session */
export interface RevokeSessionRequest {
  sessionId: string;
  revokedBy: string;
  reason: string;
}

export interface RevokeSessionResponse {
  success: boolean;
}

/** Request to check session validity */
export interface CheckSessionRequest {
  sessionId: string;
}

export interface CheckSessionResponse {
  valid: boolean;
  session?:
    | AuthSession
    | undefined;
  /** If invalid, reason why */
  invalidReason: string;
}

/** List active sessions for a user */
export interface ListUserSessionsRequest {
  userId: string;
  includeRevoked: boolean;
}

export interface ListUserSessionsResponse {
  sessions: AuthSession[];
}

/** MFA device registration */
export interface MfaDevice {
  id: string;
  userId: string;
  method: MfaMethod;
  deviceName: string;
  registeredAt?: Date | undefined;
  lastUsedAt?: Date | undefined;
  isPrimary: boolean;
}

/** Record MFA verification */
export interface RecordMfaVerificationRequest {
  sessionId: string;
  userId: string;
  method: MfaMethod;
  success: boolean;
}

export interface RecordMfaVerificationResponse {
  recorded: boolean;
  mfaVerifiedAt?: Date | undefined;
}

/** Check if MFA step-up is required */
export interface CheckStepUpRequest {
  sessionId: string;
  permission: string;
  requiredFreshnessSeconds: number;
}

export interface CheckStepUpResponse {
  stepUpRequired: boolean;
  mfaVerifiedAt?: Date | undefined;
  secondsSinceMfa: number;
  stepUpUrl: string;
}

/** Break-glass session */
export interface BreakglassSession {
  id: string;
  organisationId: string;
  utilisateurId: string;
  /** Reason is encrypted at rest */
  reasonCiphertext: string;
  /** Ticket reference (e.g., JIRA ticket, incident ID) */
  ticketRef: string;
  /** Timestamps */
  startedAt?: Date | undefined;
  expiresAt?: Date | undefined;
  endedAt?:
    | Date
    | undefined;
  /** Who ended the session (if manually ended) */
  endedByUserId: string;
  endReason: string;
  /** Status */
  status: BreakglassStatus;
  /** Permissions granted during break-glass */
  grantedPermissions: string[];
}

/** Activate break-glass session */
export interface ActivateBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
  reason: string;
  ticketRef: string;
  /** Duration in seconds (max 3600 = 1 hour) */
  ttlSeconds: number;
  /** Optional: specific permissions (default: SuperAdmin set) */
  requestedPermissions: string[];
}

export interface ActivateBreakglassResponse {
  session?: BreakglassSession | undefined;
}

/** Deactivate break-glass session */
export interface DeactivateBreakglassRequest {
  sessionId: string;
  endedByUserId: string;
  reason: string;
}

export interface DeactivateBreakglassResponse {
  session?: BreakglassSession | undefined;
}

/** Get active break-glass session for user */
export interface GetActiveBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
}

export interface GetActiveBreakglassResponse {
  /** Null if no active session */
  session?: BreakglassSession | undefined;
  hasActiveSession: boolean;
}

/** Check if break-glass is active for context */
export interface CheckBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
}

export interface CheckBreakglassResponse {
  isActive: boolean;
  sessionId: string;
  expiresAt?: Date | undefined;
  grantedPermissions: string[];
}

/** List break-glass sessions (for audit) */
export interface ListBreakglassSessionsRequest {
  organisationId: string;
  from?: Date | undefined;
  to?: Date | undefined;
  statuses: BreakglassStatus[];
  page: number;
  limit: number;
}

export interface ListBreakglassSessionsResponse {
  sessions: BreakglassSession[];
  total: number;
  page: number;
  limit: number;
}

/** Full access context for authorization decisions */
export interface AccessContext {
  /** User identity */
  userId: string;
  keycloakSub: string;
  /** Tenant context */
  organisationId: string;
  /** Roles and permissions */
  roles: string[];
  permissions: string[];
  /** Break-glass context (if active) */
  breakglassSessionId: string;
  breakglassPermissions: string[];
  /** MFA state */
  mfaVerifiedAt?: Date | undefined;
  mfaMethod: MfaMethod;
  /** Session metadata */
  sessionId: string;
  ipHash: string;
  userAgentHash: string;
  /** Request context */
  requestId: string;
  correlationId: string;
}

/** Build access context from session */
export interface BuildAccessContextRequest {
  sessionId: string;
  organisationId: string;
}

export interface BuildAccessContextResponse {
  context?: AccessContext | undefined;
}

function createBaseAuthSession(): AuthSession {
  return {
    sessionId: "",
    userId: "",
    keycloakSub: "",
    organisationId: "",
    ipHash: "",
    userAgentHash: "",
    createdAt: undefined,
    lastActivityAt: undefined,
    expiresAt: undefined,
    mfaVerifiedAt: undefined,
    mfaMethod: 0,
    status: 0,
    revokedBy: "",
    revocationReason: "",
    revokedAt: undefined,
  };
}

export const AuthSession = {
  encode(message: AuthSession, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(26).string(message.keycloakSub);
    }
    if (message.organisationId !== "") {
      writer.uint32(34).string(message.organisationId);
    }
    if (message.ipHash !== "") {
      writer.uint32(42).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(50).string(message.userAgentHash);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.lastActivityAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastActivityAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.mfaVerifiedAt), writer.uint32(82).fork()).ldelim();
    }
    if (message.mfaMethod !== 0) {
      writer.uint32(88).int32(message.mfaMethod);
    }
    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    if (message.revokedBy !== "") {
      writer.uint32(106).string(message.revokedBy);
    }
    if (message.revocationReason !== "") {
      writer.uint32(114).string(message.revocationReason);
    }
    if (message.revokedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.revokedAt), writer.uint32(122).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthSession {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lastActivityAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mfaVerifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.mfaMethod = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.revokedBy = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.revocationReason = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.revokedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthSession {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      keycloakSub: isSet(object.keycloakSub) ? globalThis.String(object.keycloakSub) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      ipHash: isSet(object.ipHash) ? globalThis.String(object.ipHash) : "",
      userAgentHash: isSet(object.userAgentHash) ? globalThis.String(object.userAgentHash) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      lastActivityAt: isSet(object.lastActivityAt) ? fromJsonTimestamp(object.lastActivityAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      mfaVerifiedAt: isSet(object.mfaVerifiedAt) ? fromJsonTimestamp(object.mfaVerifiedAt) : undefined,
      mfaMethod: isSet(object.mfaMethod) ? mfaMethodFromJSON(object.mfaMethod) : 0,
      status: isSet(object.status) ? sessionStatusFromJSON(object.status) : 0,
      revokedBy: isSet(object.revokedBy) ? globalThis.String(object.revokedBy) : "",
      revocationReason: isSet(object.revocationReason) ? globalThis.String(object.revocationReason) : "",
      revokedAt: isSet(object.revokedAt) ? fromJsonTimestamp(object.revokedAt) : undefined,
    };
  },

  toJSON(message: AuthSession): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.keycloakSub !== "") {
      obj.keycloakSub = message.keycloakSub;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.ipHash !== "") {
      obj.ipHash = message.ipHash;
    }
    if (message.userAgentHash !== "") {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.lastActivityAt !== undefined) {
      obj.lastActivityAt = message.lastActivityAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.mfaVerifiedAt !== undefined) {
      obj.mfaVerifiedAt = message.mfaVerifiedAt.toISOString();
    }
    if (message.mfaMethod !== 0) {
      obj.mfaMethod = mfaMethodToJSON(message.mfaMethod);
    }
    if (message.status !== 0) {
      obj.status = sessionStatusToJSON(message.status);
    }
    if (message.revokedBy !== "") {
      obj.revokedBy = message.revokedBy;
    }
    if (message.revocationReason !== "") {
      obj.revocationReason = message.revocationReason;
    }
    if (message.revokedAt !== undefined) {
      obj.revokedAt = message.revokedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthSession>, I>>(base?: I): AuthSession {
    return AuthSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthSession>, I>>(object: I): AuthSession {
    const message = createBaseAuthSession();
    message.sessionId = object.sessionId ?? "";
    message.userId = object.userId ?? "";
    message.keycloakSub = object.keycloakSub ?? "";
    message.organisationId = object.organisationId ?? "";
    message.ipHash = object.ipHash ?? "";
    message.userAgentHash = object.userAgentHash ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.lastActivityAt = object.lastActivityAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.mfaVerifiedAt = object.mfaVerifiedAt ?? undefined;
    message.mfaMethod = object.mfaMethod ?? 0;
    message.status = object.status ?? 0;
    message.revokedBy = object.revokedBy ?? "";
    message.revocationReason = object.revocationReason ?? "";
    message.revokedAt = object.revokedAt ?? undefined;
    return message;
  },
};

function createBaseTrackSessionRequest(): TrackSessionRequest {
  return {
    sessionId: "",
    userId: "",
    keycloakSub: "",
    organisationId: "",
    ipHash: "",
    userAgentHash: "",
    expiresAt: undefined,
    mfaVerifiedAt: undefined,
    mfaMethod: 0,
  };
}

export const TrackSessionRequest = {
  encode(message: TrackSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(26).string(message.keycloakSub);
    }
    if (message.organisationId !== "") {
      writer.uint32(34).string(message.organisationId);
    }
    if (message.ipHash !== "") {
      writer.uint32(42).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(50).string(message.userAgentHash);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.mfaVerifiedAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.mfaMethod !== 0) {
      writer.uint32(72).int32(message.mfaMethod);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrackSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mfaVerifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mfaMethod = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      keycloakSub: isSet(object.keycloakSub) ? globalThis.String(object.keycloakSub) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      ipHash: isSet(object.ipHash) ? globalThis.String(object.ipHash) : "",
      userAgentHash: isSet(object.userAgentHash) ? globalThis.String(object.userAgentHash) : "",
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      mfaVerifiedAt: isSet(object.mfaVerifiedAt) ? fromJsonTimestamp(object.mfaVerifiedAt) : undefined,
      mfaMethod: isSet(object.mfaMethod) ? mfaMethodFromJSON(object.mfaMethod) : 0,
    };
  },

  toJSON(message: TrackSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.keycloakSub !== "") {
      obj.keycloakSub = message.keycloakSub;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.ipHash !== "") {
      obj.ipHash = message.ipHash;
    }
    if (message.userAgentHash !== "") {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.mfaVerifiedAt !== undefined) {
      obj.mfaVerifiedAt = message.mfaVerifiedAt.toISOString();
    }
    if (message.mfaMethod !== 0) {
      obj.mfaMethod = mfaMethodToJSON(message.mfaMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackSessionRequest>, I>>(base?: I): TrackSessionRequest {
    return TrackSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackSessionRequest>, I>>(object: I): TrackSessionRequest {
    const message = createBaseTrackSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.userId = object.userId ?? "";
    message.keycloakSub = object.keycloakSub ?? "";
    message.organisationId = object.organisationId ?? "";
    message.ipHash = object.ipHash ?? "";
    message.userAgentHash = object.userAgentHash ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    message.mfaVerifiedAt = object.mfaVerifiedAt ?? undefined;
    message.mfaMethod = object.mfaMethod ?? 0;
    return message;
  },
};

function createBaseTrackSessionResponse(): TrackSessionResponse {
  return { session: undefined };
}

export const TrackSessionResponse = {
  encode(message: TrackSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      AuthSession.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TrackSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = AuthSession.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackSessionResponse {
    return { session: isSet(object.session) ? AuthSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: TrackSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = AuthSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackSessionResponse>, I>>(base?: I): TrackSessionResponse {
    return TrackSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackSessionResponse>, I>>(object: I): TrackSessionResponse {
    const message = createBaseTrackSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? AuthSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUpdateSessionActivityRequest(): UpdateSessionActivityRequest {
  return { sessionId: "", ipHash: "", userAgentHash: "" };
}

export const UpdateSessionActivityRequest = {
  encode(message: UpdateSessionActivityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.ipHash !== "") {
      writer.uint32(18).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(26).string(message.userAgentHash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionActivityRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionActivityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionActivityRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      ipHash: isSet(object.ipHash) ? globalThis.String(object.ipHash) : "",
      userAgentHash: isSet(object.userAgentHash) ? globalThis.String(object.userAgentHash) : "",
    };
  },

  toJSON(message: UpdateSessionActivityRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.ipHash !== "") {
      obj.ipHash = message.ipHash;
    }
    if (message.userAgentHash !== "") {
      obj.userAgentHash = message.userAgentHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionActivityRequest>, I>>(base?: I): UpdateSessionActivityRequest {
    return UpdateSessionActivityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionActivityRequest>, I>>(object: I): UpdateSessionActivityRequest {
    const message = createBaseUpdateSessionActivityRequest();
    message.sessionId = object.sessionId ?? "";
    message.ipHash = object.ipHash ?? "";
    message.userAgentHash = object.userAgentHash ?? "";
    return message;
  },
};

function createBaseUpdateSessionActivityResponse(): UpdateSessionActivityResponse {
  return { session: undefined, contextChanged: false };
}

export const UpdateSessionActivityResponse = {
  encode(message: UpdateSessionActivityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      AuthSession.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    if (message.contextChanged !== false) {
      writer.uint32(16).bool(message.contextChanged);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateSessionActivityResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionActivityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = AuthSession.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.contextChanged = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionActivityResponse {
    return {
      session: isSet(object.session) ? AuthSession.fromJSON(object.session) : undefined,
      contextChanged: isSet(object.contextChanged) ? globalThis.Boolean(object.contextChanged) : false,
    };
  },

  toJSON(message: UpdateSessionActivityResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = AuthSession.toJSON(message.session);
    }
    if (message.contextChanged !== false) {
      obj.contextChanged = message.contextChanged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionActivityResponse>, I>>(base?: I): UpdateSessionActivityResponse {
    return UpdateSessionActivityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionActivityResponse>, I>>(
    object: I,
  ): UpdateSessionActivityResponse {
    const message = createBaseUpdateSessionActivityResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? AuthSession.fromPartial(object.session)
      : undefined;
    message.contextChanged = object.contextChanged ?? false;
    return message;
  },
};

function createBaseRevokeSessionRequest(): RevokeSessionRequest {
  return { sessionId: "", revokedBy: "", reason: "" };
}

export const RevokeSessionRequest = {
  encode(message: RevokeSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.revokedBy !== "") {
      writer.uint32(18).string(message.revokedBy);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RevokeSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revokedBy = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      revokedBy: isSet(object.revokedBy) ? globalThis.String(object.revokedBy) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: RevokeSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.revokedBy !== "") {
      obj.revokedBy = message.revokedBy;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(base?: I): RevokeSessionRequest {
    return RevokeSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(object: I): RevokeSessionRequest {
    const message = createBaseRevokeSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.revokedBy = object.revokedBy ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseRevokeSessionResponse(): RevokeSessionResponse {
  return { success: false };
}

export const RevokeSessionResponse = {
  encode(message: RevokeSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RevokeSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RevokeSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(base?: I): RevokeSessionResponse {
    return RevokeSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(object: I): RevokeSessionResponse {
    const message = createBaseRevokeSessionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCheckSessionRequest(): CheckSessionRequest {
  return { sessionId: "" };
}

export const CheckSessionRequest = {
  encode(message: CheckSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: CheckSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckSessionRequest>, I>>(base?: I): CheckSessionRequest {
    return CheckSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckSessionRequest>, I>>(object: I): CheckSessionRequest {
    const message = createBaseCheckSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseCheckSessionResponse(): CheckSessionResponse {
  return { valid: false, session: undefined, invalidReason: "" };
}

export const CheckSessionResponse = {
  encode(message: CheckSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.session !== undefined) {
      AuthSession.encode(message.session, writer.uint32(18).fork()).ldelim();
    }
    if (message.invalidReason !== "") {
      writer.uint32(26).string(message.invalidReason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.session = AuthSession.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invalidReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckSessionResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      session: isSet(object.session) ? AuthSession.fromJSON(object.session) : undefined,
      invalidReason: isSet(object.invalidReason) ? globalThis.String(object.invalidReason) : "",
    };
  },

  toJSON(message: CheckSessionResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.session !== undefined) {
      obj.session = AuthSession.toJSON(message.session);
    }
    if (message.invalidReason !== "") {
      obj.invalidReason = message.invalidReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckSessionResponse>, I>>(base?: I): CheckSessionResponse {
    return CheckSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckSessionResponse>, I>>(object: I): CheckSessionResponse {
    const message = createBaseCheckSessionResponse();
    message.valid = object.valid ?? false;
    message.session = (object.session !== undefined && object.session !== null)
      ? AuthSession.fromPartial(object.session)
      : undefined;
    message.invalidReason = object.invalidReason ?? "";
    return message;
  },
};

function createBaseListUserSessionsRequest(): ListUserSessionsRequest {
  return { userId: "", includeRevoked: false };
}

export const ListUserSessionsRequest = {
  encode(message: ListUserSessionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.includeRevoked !== false) {
      writer.uint32(16).bool(message.includeRevoked);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserSessionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeRevoked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserSessionsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      includeRevoked: isSet(object.includeRevoked) ? globalThis.Boolean(object.includeRevoked) : false,
    };
  },

  toJSON(message: ListUserSessionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.includeRevoked !== false) {
      obj.includeRevoked = message.includeRevoked;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserSessionsRequest>, I>>(base?: I): ListUserSessionsRequest {
    return ListUserSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserSessionsRequest>, I>>(object: I): ListUserSessionsRequest {
    const message = createBaseListUserSessionsRequest();
    message.userId = object.userId ?? "";
    message.includeRevoked = object.includeRevoked ?? false;
    return message;
  },
};

function createBaseListUserSessionsResponse(): ListUserSessionsResponse {
  return { sessions: [] };
}

export const ListUserSessionsResponse = {
  encode(message: ListUserSessionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.sessions) {
      AuthSession.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUserSessionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessions.push(AuthSession.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => AuthSession.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListUserSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => AuthSession.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserSessionsResponse>, I>>(base?: I): ListUserSessionsResponse {
    return ListUserSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserSessionsResponse>, I>>(object: I): ListUserSessionsResponse {
    const message = createBaseListUserSessionsResponse();
    message.sessions = object.sessions?.map((e) => AuthSession.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMfaDevice(): MfaDevice {
  return {
    id: "",
    userId: "",
    method: 0,
    deviceName: "",
    registeredAt: undefined,
    lastUsedAt: undefined,
    isPrimary: false,
  };
}

export const MfaDevice = {
  encode(message: MfaDevice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.method !== 0) {
      writer.uint32(24).int32(message.method);
    }
    if (message.deviceName !== "") {
      writer.uint32(34).string(message.deviceName);
    }
    if (message.registeredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.registeredAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.lastUsedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUsedAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.isPrimary !== false) {
      writer.uint32(56).bool(message.isPrimary);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MfaDevice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMfaDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.registeredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lastUsedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isPrimary = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MfaDevice {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      method: isSet(object.method) ? mfaMethodFromJSON(object.method) : 0,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
      registeredAt: isSet(object.registeredAt) ? fromJsonTimestamp(object.registeredAt) : undefined,
      lastUsedAt: isSet(object.lastUsedAt) ? fromJsonTimestamp(object.lastUsedAt) : undefined,
      isPrimary: isSet(object.isPrimary) ? globalThis.Boolean(object.isPrimary) : false,
    };
  },

  toJSON(message: MfaDevice): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.method !== 0) {
      obj.method = mfaMethodToJSON(message.method);
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    if (message.registeredAt !== undefined) {
      obj.registeredAt = message.registeredAt.toISOString();
    }
    if (message.lastUsedAt !== undefined) {
      obj.lastUsedAt = message.lastUsedAt.toISOString();
    }
    if (message.isPrimary !== false) {
      obj.isPrimary = message.isPrimary;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MfaDevice>, I>>(base?: I): MfaDevice {
    return MfaDevice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MfaDevice>, I>>(object: I): MfaDevice {
    const message = createBaseMfaDevice();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.method = object.method ?? 0;
    message.deviceName = object.deviceName ?? "";
    message.registeredAt = object.registeredAt ?? undefined;
    message.lastUsedAt = object.lastUsedAt ?? undefined;
    message.isPrimary = object.isPrimary ?? false;
    return message;
  },
};

function createBaseRecordMfaVerificationRequest(): RecordMfaVerificationRequest {
  return { sessionId: "", userId: "", method: 0, success: false };
}

export const RecordMfaVerificationRequest = {
  encode(message: RecordMfaVerificationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.method !== 0) {
      writer.uint32(24).int32(message.method);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RecordMfaVerificationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordMfaVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordMfaVerificationRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      method: isSet(object.method) ? mfaMethodFromJSON(object.method) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: RecordMfaVerificationRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.method !== 0) {
      obj.method = mfaMethodToJSON(message.method);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordMfaVerificationRequest>, I>>(base?: I): RecordMfaVerificationRequest {
    return RecordMfaVerificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordMfaVerificationRequest>, I>>(object: I): RecordMfaVerificationRequest {
    const message = createBaseRecordMfaVerificationRequest();
    message.sessionId = object.sessionId ?? "";
    message.userId = object.userId ?? "";
    message.method = object.method ?? 0;
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseRecordMfaVerificationResponse(): RecordMfaVerificationResponse {
  return { recorded: false, mfaVerifiedAt: undefined };
}

export const RecordMfaVerificationResponse = {
  encode(message: RecordMfaVerificationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.recorded !== false) {
      writer.uint32(8).bool(message.recorded);
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.mfaVerifiedAt), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RecordMfaVerificationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordMfaVerificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.recorded = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mfaVerifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordMfaVerificationResponse {
    return {
      recorded: isSet(object.recorded) ? globalThis.Boolean(object.recorded) : false,
      mfaVerifiedAt: isSet(object.mfaVerifiedAt) ? fromJsonTimestamp(object.mfaVerifiedAt) : undefined,
    };
  },

  toJSON(message: RecordMfaVerificationResponse): unknown {
    const obj: any = {};
    if (message.recorded !== false) {
      obj.recorded = message.recorded;
    }
    if (message.mfaVerifiedAt !== undefined) {
      obj.mfaVerifiedAt = message.mfaVerifiedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordMfaVerificationResponse>, I>>(base?: I): RecordMfaVerificationResponse {
    return RecordMfaVerificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordMfaVerificationResponse>, I>>(
    object: I,
  ): RecordMfaVerificationResponse {
    const message = createBaseRecordMfaVerificationResponse();
    message.recorded = object.recorded ?? false;
    message.mfaVerifiedAt = object.mfaVerifiedAt ?? undefined;
    return message;
  },
};

function createBaseCheckStepUpRequest(): CheckStepUpRequest {
  return { sessionId: "", permission: "", requiredFreshnessSeconds: 0 };
}

export const CheckStepUpRequest = {
  encode(message: CheckStepUpRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.permission !== "") {
      writer.uint32(18).string(message.permission);
    }
    if (message.requiredFreshnessSeconds !== 0) {
      writer.uint32(24).int32(message.requiredFreshnessSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckStepUpRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStepUpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permission = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requiredFreshnessSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckStepUpRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      permission: isSet(object.permission) ? globalThis.String(object.permission) : "",
      requiredFreshnessSeconds: isSet(object.requiredFreshnessSeconds)
        ? globalThis.Number(object.requiredFreshnessSeconds)
        : 0,
    };
  },

  toJSON(message: CheckStepUpRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.permission !== "") {
      obj.permission = message.permission;
    }
    if (message.requiredFreshnessSeconds !== 0) {
      obj.requiredFreshnessSeconds = Math.round(message.requiredFreshnessSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckStepUpRequest>, I>>(base?: I): CheckStepUpRequest {
    return CheckStepUpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckStepUpRequest>, I>>(object: I): CheckStepUpRequest {
    const message = createBaseCheckStepUpRequest();
    message.sessionId = object.sessionId ?? "";
    message.permission = object.permission ?? "";
    message.requiredFreshnessSeconds = object.requiredFreshnessSeconds ?? 0;
    return message;
  },
};

function createBaseCheckStepUpResponse(): CheckStepUpResponse {
  return { stepUpRequired: false, mfaVerifiedAt: undefined, secondsSinceMfa: 0, stepUpUrl: "" };
}

export const CheckStepUpResponse = {
  encode(message: CheckStepUpResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepUpRequired !== false) {
      writer.uint32(8).bool(message.stepUpRequired);
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.mfaVerifiedAt), writer.uint32(18).fork()).ldelim();
    }
    if (message.secondsSinceMfa !== 0) {
      writer.uint32(24).int32(message.secondsSinceMfa);
    }
    if (message.stepUpUrl !== "") {
      writer.uint32(34).string(message.stepUpUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckStepUpResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStepUpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stepUpRequired = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mfaVerifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.secondsSinceMfa = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stepUpUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckStepUpResponse {
    return {
      stepUpRequired: isSet(object.stepUpRequired) ? globalThis.Boolean(object.stepUpRequired) : false,
      mfaVerifiedAt: isSet(object.mfaVerifiedAt) ? fromJsonTimestamp(object.mfaVerifiedAt) : undefined,
      secondsSinceMfa: isSet(object.secondsSinceMfa) ? globalThis.Number(object.secondsSinceMfa) : 0,
      stepUpUrl: isSet(object.stepUpUrl) ? globalThis.String(object.stepUpUrl) : "",
    };
  },

  toJSON(message: CheckStepUpResponse): unknown {
    const obj: any = {};
    if (message.stepUpRequired !== false) {
      obj.stepUpRequired = message.stepUpRequired;
    }
    if (message.mfaVerifiedAt !== undefined) {
      obj.mfaVerifiedAt = message.mfaVerifiedAt.toISOString();
    }
    if (message.secondsSinceMfa !== 0) {
      obj.secondsSinceMfa = Math.round(message.secondsSinceMfa);
    }
    if (message.stepUpUrl !== "") {
      obj.stepUpUrl = message.stepUpUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckStepUpResponse>, I>>(base?: I): CheckStepUpResponse {
    return CheckStepUpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckStepUpResponse>, I>>(object: I): CheckStepUpResponse {
    const message = createBaseCheckStepUpResponse();
    message.stepUpRequired = object.stepUpRequired ?? false;
    message.mfaVerifiedAt = object.mfaVerifiedAt ?? undefined;
    message.secondsSinceMfa = object.secondsSinceMfa ?? 0;
    message.stepUpUrl = object.stepUpUrl ?? "";
    return message;
  },
};

function createBaseBreakglassSession(): BreakglassSession {
  return {
    id: "",
    organisationId: "",
    utilisateurId: "",
    reasonCiphertext: "",
    ticketRef: "",
    startedAt: undefined,
    expiresAt: undefined,
    endedAt: undefined,
    endedByUserId: "",
    endReason: "",
    status: 0,
    grantedPermissions: [],
  };
}

export const BreakglassSession = {
  encode(message: BreakglassSession, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(26).string(message.utilisateurId);
    }
    if (message.reasonCiphertext !== "") {
      writer.uint32(34).string(message.reasonCiphertext);
    }
    if (message.ticketRef !== "") {
      writer.uint32(42).string(message.ticketRef);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.endedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.endedAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.endedByUserId !== "") {
      writer.uint32(74).string(message.endedByUserId);
    }
    if (message.endReason !== "") {
      writer.uint32(82).string(message.endReason);
    }
    if (message.status !== 0) {
      writer.uint32(88).int32(message.status);
    }
    for (const v of message.grantedPermissions) {
      writer.uint32(98).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BreakglassSession {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakglassSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reasonCiphertext = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ticketRef = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.endedByUserId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.endReason = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.grantedPermissions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BreakglassSession {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      utilisateurId: isSet(object.utilisateurId) ? globalThis.String(object.utilisateurId) : "",
      reasonCiphertext: isSet(object.reasonCiphertext) ? globalThis.String(object.reasonCiphertext) : "",
      ticketRef: isSet(object.ticketRef) ? globalThis.String(object.ticketRef) : "",
      startedAt: isSet(object.startedAt) ? fromJsonTimestamp(object.startedAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      endedAt: isSet(object.endedAt) ? fromJsonTimestamp(object.endedAt) : undefined,
      endedByUserId: isSet(object.endedByUserId) ? globalThis.String(object.endedByUserId) : "",
      endReason: isSet(object.endReason) ? globalThis.String(object.endReason) : "",
      status: isSet(object.status) ? breakglassStatusFromJSON(object.status) : 0,
      grantedPermissions: globalThis.Array.isArray(object?.grantedPermissions)
        ? object.grantedPermissions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BreakglassSession): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.utilisateurId !== "") {
      obj.utilisateurId = message.utilisateurId;
    }
    if (message.reasonCiphertext !== "") {
      obj.reasonCiphertext = message.reasonCiphertext;
    }
    if (message.ticketRef !== "") {
      obj.ticketRef = message.ticketRef;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.endedAt !== undefined) {
      obj.endedAt = message.endedAt.toISOString();
    }
    if (message.endedByUserId !== "") {
      obj.endedByUserId = message.endedByUserId;
    }
    if (message.endReason !== "") {
      obj.endReason = message.endReason;
    }
    if (message.status !== 0) {
      obj.status = breakglassStatusToJSON(message.status);
    }
    if (message.grantedPermissions?.length) {
      obj.grantedPermissions = message.grantedPermissions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BreakglassSession>, I>>(base?: I): BreakglassSession {
    return BreakglassSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BreakglassSession>, I>>(object: I): BreakglassSession {
    const message = createBaseBreakglassSession();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.utilisateurId = object.utilisateurId ?? "";
    message.reasonCiphertext = object.reasonCiphertext ?? "";
    message.ticketRef = object.ticketRef ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.endedAt = object.endedAt ?? undefined;
    message.endedByUserId = object.endedByUserId ?? "";
    message.endReason = object.endReason ?? "";
    message.status = object.status ?? 0;
    message.grantedPermissions = object.grantedPermissions?.map((e) => e) || [];
    return message;
  },
};

function createBaseActivateBreakglassRequest(): ActivateBreakglassRequest {
  return { organisationId: "", utilisateurId: "", reason: "", ticketRef: "", ttlSeconds: 0, requestedPermissions: [] };
}

export const ActivateBreakglassRequest = {
  encode(message: ActivateBreakglassRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.ticketRef !== "") {
      writer.uint32(34).string(message.ticketRef);
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(40).int32(message.ttlSeconds);
    }
    for (const v of message.requestedPermissions) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateBreakglassRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ticketRef = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ttlSeconds = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestedPermissions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivateBreakglassRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      utilisateurId: isSet(object.utilisateurId) ? globalThis.String(object.utilisateurId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      ticketRef: isSet(object.ticketRef) ? globalThis.String(object.ticketRef) : "",
      ttlSeconds: isSet(object.ttlSeconds) ? globalThis.Number(object.ttlSeconds) : 0,
      requestedPermissions: globalThis.Array.isArray(object?.requestedPermissions)
        ? object.requestedPermissions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ActivateBreakglassRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.utilisateurId !== "") {
      obj.utilisateurId = message.utilisateurId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.ticketRef !== "") {
      obj.ticketRef = message.ticketRef;
    }
    if (message.ttlSeconds !== 0) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    if (message.requestedPermissions?.length) {
      obj.requestedPermissions = message.requestedPermissions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateBreakglassRequest>, I>>(base?: I): ActivateBreakglassRequest {
    return ActivateBreakglassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivateBreakglassRequest>, I>>(object: I): ActivateBreakglassRequest {
    const message = createBaseActivateBreakglassRequest();
    message.organisationId = object.organisationId ?? "";
    message.utilisateurId = object.utilisateurId ?? "";
    message.reason = object.reason ?? "";
    message.ticketRef = object.ticketRef ?? "";
    message.ttlSeconds = object.ttlSeconds ?? 0;
    message.requestedPermissions = object.requestedPermissions?.map((e) => e) || [];
    return message;
  },
};

function createBaseActivateBreakglassResponse(): ActivateBreakglassResponse {
  return { session: undefined };
}

export const ActivateBreakglassResponse = {
  encode(message: ActivateBreakglassResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      BreakglassSession.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateBreakglassResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = BreakglassSession.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivateBreakglassResponse {
    return { session: isSet(object.session) ? BreakglassSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: ActivateBreakglassResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = BreakglassSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateBreakglassResponse>, I>>(base?: I): ActivateBreakglassResponse {
    return ActivateBreakglassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivateBreakglassResponse>, I>>(object: I): ActivateBreakglassResponse {
    const message = createBaseActivateBreakglassResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? BreakglassSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseDeactivateBreakglassRequest(): DeactivateBreakglassRequest {
  return { sessionId: "", endedByUserId: "", reason: "" };
}

export const DeactivateBreakglassRequest = {
  encode(message: DeactivateBreakglassRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.endedByUserId !== "") {
      writer.uint32(18).string(message.endedByUserId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeactivateBreakglassRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeactivateBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endedByUserId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeactivateBreakglassRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      endedByUserId: isSet(object.endedByUserId) ? globalThis.String(object.endedByUserId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: DeactivateBreakglassRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.endedByUserId !== "") {
      obj.endedByUserId = message.endedByUserId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeactivateBreakglassRequest>, I>>(base?: I): DeactivateBreakglassRequest {
    return DeactivateBreakglassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeactivateBreakglassRequest>, I>>(object: I): DeactivateBreakglassRequest {
    const message = createBaseDeactivateBreakglassRequest();
    message.sessionId = object.sessionId ?? "";
    message.endedByUserId = object.endedByUserId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseDeactivateBreakglassResponse(): DeactivateBreakglassResponse {
  return { session: undefined };
}

export const DeactivateBreakglassResponse = {
  encode(message: DeactivateBreakglassResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      BreakglassSession.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeactivateBreakglassResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeactivateBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = BreakglassSession.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeactivateBreakglassResponse {
    return { session: isSet(object.session) ? BreakglassSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: DeactivateBreakglassResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = BreakglassSession.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeactivateBreakglassResponse>, I>>(base?: I): DeactivateBreakglassResponse {
    return DeactivateBreakglassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeactivateBreakglassResponse>, I>>(object: I): DeactivateBreakglassResponse {
    const message = createBaseDeactivateBreakglassResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? BreakglassSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseGetActiveBreakglassRequest(): GetActiveBreakglassRequest {
  return { organisationId: "", utilisateurId: "" };
}

export const GetActiveBreakglassRequest = {
  encode(message: GetActiveBreakglassRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetActiveBreakglassRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveBreakglassRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      utilisateurId: isSet(object.utilisateurId) ? globalThis.String(object.utilisateurId) : "",
    };
  },

  toJSON(message: GetActiveBreakglassRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.utilisateurId !== "") {
      obj.utilisateurId = message.utilisateurId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveBreakglassRequest>, I>>(base?: I): GetActiveBreakglassRequest {
    return GetActiveBreakglassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveBreakglassRequest>, I>>(object: I): GetActiveBreakglassRequest {
    const message = createBaseGetActiveBreakglassRequest();
    message.organisationId = object.organisationId ?? "";
    message.utilisateurId = object.utilisateurId ?? "";
    return message;
  },
};

function createBaseGetActiveBreakglassResponse(): GetActiveBreakglassResponse {
  return { session: undefined, hasActiveSession: false };
}

export const GetActiveBreakglassResponse = {
  encode(message: GetActiveBreakglassResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.session !== undefined) {
      BreakglassSession.encode(message.session, writer.uint32(10).fork()).ldelim();
    }
    if (message.hasActiveSession !== false) {
      writer.uint32(16).bool(message.hasActiveSession);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetActiveBreakglassResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = BreakglassSession.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hasActiveSession = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActiveBreakglassResponse {
    return {
      session: isSet(object.session) ? BreakglassSession.fromJSON(object.session) : undefined,
      hasActiveSession: isSet(object.hasActiveSession) ? globalThis.Boolean(object.hasActiveSession) : false,
    };
  },

  toJSON(message: GetActiveBreakglassResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = BreakglassSession.toJSON(message.session);
    }
    if (message.hasActiveSession !== false) {
      obj.hasActiveSession = message.hasActiveSession;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActiveBreakglassResponse>, I>>(base?: I): GetActiveBreakglassResponse {
    return GetActiveBreakglassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActiveBreakglassResponse>, I>>(object: I): GetActiveBreakglassResponse {
    const message = createBaseGetActiveBreakglassResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? BreakglassSession.fromPartial(object.session)
      : undefined;
    message.hasActiveSession = object.hasActiveSession ?? false;
    return message;
  },
};

function createBaseCheckBreakglassRequest(): CheckBreakglassRequest {
  return { organisationId: "", utilisateurId: "" };
}

export const CheckBreakglassRequest = {
  encode(message: CheckBreakglassRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckBreakglassRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckBreakglassRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      utilisateurId: isSet(object.utilisateurId) ? globalThis.String(object.utilisateurId) : "",
    };
  },

  toJSON(message: CheckBreakglassRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.utilisateurId !== "") {
      obj.utilisateurId = message.utilisateurId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckBreakglassRequest>, I>>(base?: I): CheckBreakglassRequest {
    return CheckBreakglassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckBreakglassRequest>, I>>(object: I): CheckBreakglassRequest {
    const message = createBaseCheckBreakglassRequest();
    message.organisationId = object.organisationId ?? "";
    message.utilisateurId = object.utilisateurId ?? "";
    return message;
  },
};

function createBaseCheckBreakglassResponse(): CheckBreakglassResponse {
  return { isActive: false, sessionId: "", expiresAt: undefined, grantedPermissions: [] };
}

export const CheckBreakglassResponse = {
  encode(message: CheckBreakglassResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.grantedPermissions) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckBreakglassResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.grantedPermissions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckBreakglassResponse {
    return {
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      grantedPermissions: globalThis.Array.isArray(object?.grantedPermissions)
        ? object.grantedPermissions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CheckBreakglassResponse): unknown {
    const obj: any = {};
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.grantedPermissions?.length) {
      obj.grantedPermissions = message.grantedPermissions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckBreakglassResponse>, I>>(base?: I): CheckBreakglassResponse {
    return CheckBreakglassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckBreakglassResponse>, I>>(object: I): CheckBreakglassResponse {
    const message = createBaseCheckBreakglassResponse();
    message.isActive = object.isActive ?? false;
    message.sessionId = object.sessionId ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    message.grantedPermissions = object.grantedPermissions?.map((e) => e) || [];
    return message;
  },
};

function createBaseListBreakglassSessionsRequest(): ListBreakglassSessionsRequest {
  return { organisationId: "", from: undefined, to: undefined, statuses: [], page: 0, limit: 0 };
}

export const ListBreakglassSessionsRequest = {
  encode(message: ListBreakglassSessionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.page !== 0) {
      writer.uint32(40).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(48).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBreakglassSessionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBreakglassSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag === 32) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBreakglassSessionsRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => breakglassStatusFromJSON(e))
        : [],
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListBreakglassSessionsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => breakglassStatusToJSON(e));
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBreakglassSessionsRequest>, I>>(base?: I): ListBreakglassSessionsRequest {
    return ListBreakglassSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBreakglassSessionsRequest>, I>>(
    object: I,
  ): ListBreakglassSessionsRequest {
    const message = createBaseListBreakglassSessionsRequest();
    message.organisationId = object.organisationId ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.statuses = object.statuses?.map((e) => e) || [];
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseListBreakglassSessionsResponse(): ListBreakglassSessionsResponse {
  return { sessions: [], total: 0, page: 0, limit: 0 };
}

export const ListBreakglassSessionsResponse = {
  encode(message: ListBreakglassSessionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.sessions) {
      BreakglassSession.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBreakglassSessionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBreakglassSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessions.push(BreakglassSession.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBreakglassSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => BreakglassSession.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListBreakglassSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => BreakglassSession.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBreakglassSessionsResponse>, I>>(base?: I): ListBreakglassSessionsResponse {
    return ListBreakglassSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBreakglassSessionsResponse>, I>>(
    object: I,
  ): ListBreakglassSessionsResponse {
    const message = createBaseListBreakglassSessionsResponse();
    message.sessions = object.sessions?.map((e) => BreakglassSession.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseAccessContext(): AccessContext {
  return {
    userId: "",
    keycloakSub: "",
    organisationId: "",
    roles: [],
    permissions: [],
    breakglassSessionId: "",
    breakglassPermissions: [],
    mfaVerifiedAt: undefined,
    mfaMethod: 0,
    sessionId: "",
    ipHash: "",
    userAgentHash: "",
    requestId: "",
    correlationId: "",
  };
}

export const AccessContext = {
  encode(message: AccessContext, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(18).string(message.keycloakSub);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    for (const v of message.roles) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.permissions) {
      writer.uint32(42).string(v!);
    }
    if (message.breakglassSessionId !== "") {
      writer.uint32(50).string(message.breakglassSessionId);
    }
    for (const v of message.breakglassPermissions) {
      writer.uint32(58).string(v!);
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.mfaVerifiedAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.mfaMethod !== 0) {
      writer.uint32(72).int32(message.mfaMethod);
    }
    if (message.sessionId !== "") {
      writer.uint32(82).string(message.sessionId);
    }
    if (message.ipHash !== "") {
      writer.uint32(90).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(98).string(message.userAgentHash);
    }
    if (message.requestId !== "") {
      writer.uint32(106).string(message.requestId);
    }
    if (message.correlationId !== "") {
      writer.uint32(114).string(message.correlationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccessContext {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.breakglassSessionId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.breakglassPermissions.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mfaVerifiedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mfaMethod = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.correlationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessContext {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      keycloakSub: isSet(object.keycloakSub) ? globalThis.String(object.keycloakSub) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => globalThis.String(e)) : [],
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => globalThis.String(e))
        : [],
      breakglassSessionId: isSet(object.breakglassSessionId) ? globalThis.String(object.breakglassSessionId) : "",
      breakglassPermissions: globalThis.Array.isArray(object?.breakglassPermissions)
        ? object.breakglassPermissions.map((e: any) => globalThis.String(e))
        : [],
      mfaVerifiedAt: isSet(object.mfaVerifiedAt) ? fromJsonTimestamp(object.mfaVerifiedAt) : undefined,
      mfaMethod: isSet(object.mfaMethod) ? mfaMethodFromJSON(object.mfaMethod) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      ipHash: isSet(object.ipHash) ? globalThis.String(object.ipHash) : "",
      userAgentHash: isSet(object.userAgentHash) ? globalThis.String(object.userAgentHash) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
    };
  },

  toJSON(message: AccessContext): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.keycloakSub !== "") {
      obj.keycloakSub = message.keycloakSub;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions;
    }
    if (message.breakglassSessionId !== "") {
      obj.breakglassSessionId = message.breakglassSessionId;
    }
    if (message.breakglassPermissions?.length) {
      obj.breakglassPermissions = message.breakglassPermissions;
    }
    if (message.mfaVerifiedAt !== undefined) {
      obj.mfaVerifiedAt = message.mfaVerifiedAt.toISOString();
    }
    if (message.mfaMethod !== 0) {
      obj.mfaMethod = mfaMethodToJSON(message.mfaMethod);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.ipHash !== "") {
      obj.ipHash = message.ipHash;
    }
    if (message.userAgentHash !== "") {
      obj.userAgentHash = message.userAgentHash;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessContext>, I>>(base?: I): AccessContext {
    return AccessContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessContext>, I>>(object: I): AccessContext {
    const message = createBaseAccessContext();
    message.userId = object.userId ?? "";
    message.keycloakSub = object.keycloakSub ?? "";
    message.organisationId = object.organisationId ?? "";
    message.roles = object.roles?.map((e) => e) || [];
    message.permissions = object.permissions?.map((e) => e) || [];
    message.breakglassSessionId = object.breakglassSessionId ?? "";
    message.breakglassPermissions = object.breakglassPermissions?.map((e) => e) || [];
    message.mfaVerifiedAt = object.mfaVerifiedAt ?? undefined;
    message.mfaMethod = object.mfaMethod ?? 0;
    message.sessionId = object.sessionId ?? "";
    message.ipHash = object.ipHash ?? "";
    message.userAgentHash = object.userAgentHash ?? "";
    message.requestId = object.requestId ?? "";
    message.correlationId = object.correlationId ?? "";
    return message;
  },
};

function createBaseBuildAccessContextRequest(): BuildAccessContextRequest {
  return { sessionId: "", organisationId: "" };
}

export const BuildAccessContextRequest = {
  encode(message: BuildAccessContextRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildAccessContextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildAccessContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildAccessContextRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
    };
  },

  toJSON(message: BuildAccessContextRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildAccessContextRequest>, I>>(base?: I): BuildAccessContextRequest {
    return BuildAccessContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildAccessContextRequest>, I>>(object: I): BuildAccessContextRequest {
    const message = createBaseBuildAccessContextRequest();
    message.sessionId = object.sessionId ?? "";
    message.organisationId = object.organisationId ?? "";
    return message;
  },
};

function createBaseBuildAccessContextResponse(): BuildAccessContextResponse {
  return { context: undefined };
}

export const BuildAccessContextResponse = {
  encode(message: BuildAccessContextResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.context !== undefined) {
      AccessContext.encode(message.context, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildAccessContextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildAccessContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = AccessContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildAccessContextResponse {
    return { context: isSet(object.context) ? AccessContext.fromJSON(object.context) : undefined };
  },

  toJSON(message: BuildAccessContextResponse): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = AccessContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildAccessContextResponse>, I>>(base?: I): BuildAccessContextResponse {
    return BuildAccessContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildAccessContextResponse>, I>>(object: I): BuildAccessContextResponse {
    const message = createBaseBuildAccessContextResponse();
    message.context = (object.context !== undefined && object.context !== null)
      ? AccessContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

/** ========== SESSION MANAGEMENT ========== */
export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  trackSession: {
    path: "/security.AuthService/TrackSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TrackSessionRequest) => Buffer.from(TrackSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => TrackSessionRequest.decode(value),
    responseSerialize: (value: TrackSessionResponse) => Buffer.from(TrackSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TrackSessionResponse.decode(value),
  },
  updateSessionActivity: {
    path: "/security.AuthService/UpdateSessionActivity",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSessionActivityRequest) =>
      Buffer.from(UpdateSessionActivityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateSessionActivityRequest.decode(value),
    responseSerialize: (value: UpdateSessionActivityResponse) =>
      Buffer.from(UpdateSessionActivityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateSessionActivityResponse.decode(value),
  },
  revokeSession: {
    path: "/security.AuthService/RevokeSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokeSessionRequest) => Buffer.from(RevokeSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RevokeSessionRequest.decode(value),
    responseSerialize: (value: RevokeSessionResponse) => Buffer.from(RevokeSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RevokeSessionResponse.decode(value),
  },
  checkSession: {
    path: "/security.AuthService/CheckSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckSessionRequest) => Buffer.from(CheckSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckSessionRequest.decode(value),
    responseSerialize: (value: CheckSessionResponse) => Buffer.from(CheckSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckSessionResponse.decode(value),
  },
  listUserSessions: {
    path: "/security.AuthService/ListUserSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListUserSessionsRequest) => Buffer.from(ListUserSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListUserSessionsRequest.decode(value),
    responseSerialize: (value: ListUserSessionsResponse) =>
      Buffer.from(ListUserSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListUserSessionsResponse.decode(value),
  },
  recordMfaVerification: {
    path: "/security.AuthService/RecordMfaVerification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RecordMfaVerificationRequest) =>
      Buffer.from(RecordMfaVerificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RecordMfaVerificationRequest.decode(value),
    responseSerialize: (value: RecordMfaVerificationResponse) =>
      Buffer.from(RecordMfaVerificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RecordMfaVerificationResponse.decode(value),
  },
  checkStepUp: {
    path: "/security.AuthService/CheckStepUp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckStepUpRequest) => Buffer.from(CheckStepUpRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckStepUpRequest.decode(value),
    responseSerialize: (value: CheckStepUpResponse) => Buffer.from(CheckStepUpResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckStepUpResponse.decode(value),
  },
  activateBreakglass: {
    path: "/security.AuthService/ActivateBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateBreakglassRequest) =>
      Buffer.from(ActivateBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ActivateBreakglassRequest.decode(value),
    responseSerialize: (value: ActivateBreakglassResponse) =>
      Buffer.from(ActivateBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ActivateBreakglassResponse.decode(value),
  },
  deactivateBreakglass: {
    path: "/security.AuthService/DeactivateBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeactivateBreakglassRequest) =>
      Buffer.from(DeactivateBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeactivateBreakglassRequest.decode(value),
    responseSerialize: (value: DeactivateBreakglassResponse) =>
      Buffer.from(DeactivateBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeactivateBreakglassResponse.decode(value),
  },
  getActiveBreakglass: {
    path: "/security.AuthService/GetActiveBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetActiveBreakglassRequest) =>
      Buffer.from(GetActiveBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetActiveBreakglassRequest.decode(value),
    responseSerialize: (value: GetActiveBreakglassResponse) =>
      Buffer.from(GetActiveBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetActiveBreakglassResponse.decode(value),
  },
  checkBreakglass: {
    path: "/security.AuthService/CheckBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckBreakglassRequest) => Buffer.from(CheckBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckBreakglassRequest.decode(value),
    responseSerialize: (value: CheckBreakglassResponse) => Buffer.from(CheckBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckBreakglassResponse.decode(value),
  },
  listBreakglassSessions: {
    path: "/security.AuthService/ListBreakglassSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListBreakglassSessionsRequest) =>
      Buffer.from(ListBreakglassSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListBreakglassSessionsRequest.decode(value),
    responseSerialize: (value: ListBreakglassSessionsResponse) =>
      Buffer.from(ListBreakglassSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListBreakglassSessionsResponse.decode(value),
  },
  buildAccessContext: {
    path: "/security.AuthService/BuildAccessContext",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BuildAccessContextRequest) =>
      Buffer.from(BuildAccessContextRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BuildAccessContextRequest.decode(value),
    responseSerialize: (value: BuildAccessContextResponse) =>
      Buffer.from(BuildAccessContextResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BuildAccessContextResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  trackSession: handleUnaryCall<TrackSessionRequest, TrackSessionResponse>;
  updateSessionActivity: handleUnaryCall<UpdateSessionActivityRequest, UpdateSessionActivityResponse>;
  revokeSession: handleUnaryCall<RevokeSessionRequest, RevokeSessionResponse>;
  checkSession: handleUnaryCall<CheckSessionRequest, CheckSessionResponse>;
  listUserSessions: handleUnaryCall<ListUserSessionsRequest, ListUserSessionsResponse>;
  recordMfaVerification: handleUnaryCall<RecordMfaVerificationRequest, RecordMfaVerificationResponse>;
  checkStepUp: handleUnaryCall<CheckStepUpRequest, CheckStepUpResponse>;
  activateBreakglass: handleUnaryCall<ActivateBreakglassRequest, ActivateBreakglassResponse>;
  deactivateBreakglass: handleUnaryCall<DeactivateBreakglassRequest, DeactivateBreakglassResponse>;
  getActiveBreakglass: handleUnaryCall<GetActiveBreakglassRequest, GetActiveBreakglassResponse>;
  checkBreakglass: handleUnaryCall<CheckBreakglassRequest, CheckBreakglassResponse>;
  listBreakglassSessions: handleUnaryCall<ListBreakglassSessionsRequest, ListBreakglassSessionsResponse>;
  buildAccessContext: handleUnaryCall<BuildAccessContextRequest, BuildAccessContextResponse>;
}

export interface AuthServiceClient extends Client {
  trackSession(
    request: TrackSessionRequest,
    callback: (error: ServiceError | null, response: TrackSessionResponse) => void,
  ): ClientUnaryCall;
  trackSession(
    request: TrackSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TrackSessionResponse) => void,
  ): ClientUnaryCall;
  trackSession(
    request: TrackSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TrackSessionResponse) => void,
  ): ClientUnaryCall;
  updateSessionActivity(
    request: UpdateSessionActivityRequest,
    callback: (error: ServiceError | null, response: UpdateSessionActivityResponse) => void,
  ): ClientUnaryCall;
  updateSessionActivity(
    request: UpdateSessionActivityRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateSessionActivityResponse) => void,
  ): ClientUnaryCall;
  updateSessionActivity(
    request: UpdateSessionActivityRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateSessionActivityResponse) => void,
  ): ClientUnaryCall;
  revokeSession(
    request: RevokeSessionRequest,
    callback: (error: ServiceError | null, response: RevokeSessionResponse) => void,
  ): ClientUnaryCall;
  revokeSession(
    request: RevokeSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RevokeSessionResponse) => void,
  ): ClientUnaryCall;
  revokeSession(
    request: RevokeSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RevokeSessionResponse) => void,
  ): ClientUnaryCall;
  checkSession(
    request: CheckSessionRequest,
    callback: (error: ServiceError | null, response: CheckSessionResponse) => void,
  ): ClientUnaryCall;
  checkSession(
    request: CheckSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckSessionResponse) => void,
  ): ClientUnaryCall;
  checkSession(
    request: CheckSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckSessionResponse) => void,
  ): ClientUnaryCall;
  listUserSessions(
    request: ListUserSessionsRequest,
    callback: (error: ServiceError | null, response: ListUserSessionsResponse) => void,
  ): ClientUnaryCall;
  listUserSessions(
    request: ListUserSessionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListUserSessionsResponse) => void,
  ): ClientUnaryCall;
  listUserSessions(
    request: ListUserSessionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListUserSessionsResponse) => void,
  ): ClientUnaryCall;
  recordMfaVerification(
    request: RecordMfaVerificationRequest,
    callback: (error: ServiceError | null, response: RecordMfaVerificationResponse) => void,
  ): ClientUnaryCall;
  recordMfaVerification(
    request: RecordMfaVerificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RecordMfaVerificationResponse) => void,
  ): ClientUnaryCall;
  recordMfaVerification(
    request: RecordMfaVerificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RecordMfaVerificationResponse) => void,
  ): ClientUnaryCall;
  checkStepUp(
    request: CheckStepUpRequest,
    callback: (error: ServiceError | null, response: CheckStepUpResponse) => void,
  ): ClientUnaryCall;
  checkStepUp(
    request: CheckStepUpRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckStepUpResponse) => void,
  ): ClientUnaryCall;
  checkStepUp(
    request: CheckStepUpRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckStepUpResponse) => void,
  ): ClientUnaryCall;
  activateBreakglass(
    request: ActivateBreakglassRequest,
    callback: (error: ServiceError | null, response: ActivateBreakglassResponse) => void,
  ): ClientUnaryCall;
  activateBreakglass(
    request: ActivateBreakglassRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ActivateBreakglassResponse) => void,
  ): ClientUnaryCall;
  activateBreakglass(
    request: ActivateBreakglassRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ActivateBreakglassResponse) => void,
  ): ClientUnaryCall;
  deactivateBreakglass(
    request: DeactivateBreakglassRequest,
    callback: (error: ServiceError | null, response: DeactivateBreakglassResponse) => void,
  ): ClientUnaryCall;
  deactivateBreakglass(
    request: DeactivateBreakglassRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeactivateBreakglassResponse) => void,
  ): ClientUnaryCall;
  deactivateBreakglass(
    request: DeactivateBreakglassRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeactivateBreakglassResponse) => void,
  ): ClientUnaryCall;
  getActiveBreakglass(
    request: GetActiveBreakglassRequest,
    callback: (error: ServiceError | null, response: GetActiveBreakglassResponse) => void,
  ): ClientUnaryCall;
  getActiveBreakglass(
    request: GetActiveBreakglassRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetActiveBreakglassResponse) => void,
  ): ClientUnaryCall;
  getActiveBreakglass(
    request: GetActiveBreakglassRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetActiveBreakglassResponse) => void,
  ): ClientUnaryCall;
  checkBreakglass(
    request: CheckBreakglassRequest,
    callback: (error: ServiceError | null, response: CheckBreakglassResponse) => void,
  ): ClientUnaryCall;
  checkBreakglass(
    request: CheckBreakglassRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckBreakglassResponse) => void,
  ): ClientUnaryCall;
  checkBreakglass(
    request: CheckBreakglassRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckBreakglassResponse) => void,
  ): ClientUnaryCall;
  listBreakglassSessions(
    request: ListBreakglassSessionsRequest,
    callback: (error: ServiceError | null, response: ListBreakglassSessionsResponse) => void,
  ): ClientUnaryCall;
  listBreakglassSessions(
    request: ListBreakglassSessionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListBreakglassSessionsResponse) => void,
  ): ClientUnaryCall;
  listBreakglassSessions(
    request: ListBreakglassSessionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListBreakglassSessionsResponse) => void,
  ): ClientUnaryCall;
  buildAccessContext(
    request: BuildAccessContextRequest,
    callback: (error: ServiceError | null, response: BuildAccessContextResponse) => void,
  ): ClientUnaryCall;
  buildAccessContext(
    request: BuildAccessContextRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BuildAccessContextResponse) => void,
  ): ClientUnaryCall;
  buildAccessContext(
    request: BuildAccessContextRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BuildAccessContextResponse) => void,
  ): ClientUnaryCall;
}

export const AuthServiceClient = makeGenericClientConstructor(
  AuthServiceService,
  "security.AuthService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthServiceClient;
  service: typeof AuthServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
