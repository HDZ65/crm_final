// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: security/errors.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

/**
 * Security error codes grouped by category
 * 100-199: Authentication
 * 200-299: Authorization
 * 300-399: MFA / Step-up
 * 400-499: Audit
 * 500-599: Retention / Purge
 * 600-699: Encryption
 * 700-799: Break-glass
 */
export enum SecurityErrorCode {
  SECURITY_ERROR_CODE_UNSPECIFIED = 0,
  /** UNAUTHORIZED - No valid credentials provided */
  UNAUTHORIZED = 100,
  /** SESSION_EXPIRED - Token has expired (access or refresh) */
  SESSION_EXPIRED = 101,
  /** SESSION_REVOKED - Session has been explicitly revoked (logout or admin action) */
  SESSION_REVOKED = 102,
  /** SSO_ASSERTION_INVALID - OIDC/SAML assertion is invalid or malformed */
  SSO_ASSERTION_INVALID = 103,
  /** TOKEN_REFRESH_FAILED - Refresh token is invalid, expired, or has been reused */
  TOKEN_REFRESH_FAILED = 104,
  /** INVALID_CREDENTIALS - Invalid credentials during authentication */
  INVALID_CREDENTIALS = 105,
  /** ACCOUNT_LOCKED - Account is locked due to too many failed attempts */
  ACCOUNT_LOCKED = 106,
  /** ACCOUNT_DISABLED - Account has been disabled by administrator */
  ACCOUNT_DISABLED = 107,
  /** FORBIDDEN - Generic forbidden - user authenticated but not allowed */
  FORBIDDEN = 200,
  /** PERMISSION_MISSING - Specific permission not granted to user's role(s) */
  PERMISSION_MISSING = 201,
  /** TENANT_SCOPE_VIOLATION - Request's organisation_id doesn't match user's membership */
  TENANT_SCOPE_VIOLATION = 202,
  /** ROLE_INSUFFICIENT - User's role is insufficient for this operation */
  ROLE_INSUFFICIENT = 203,
  /** MEMBERSHIP_INACTIVE - User's membership in organisation is not active */
  MEMBERSHIP_INACTIVE = 204,
  /** RESOURCE_NOT_ACCESSIBLE - Resource belongs to different tenant */
  RESOURCE_NOT_ACCESSIBLE = 205,
  /** MFA_REQUIRED - MFA is not configured for user but is required */
  MFA_REQUIRED = 300,
  /** MFA_STEP_UP_REQUIRED - MFA verification is stale, need to re-verify */
  MFA_STEP_UP_REQUIRED = 301,
  /** MFA_CHALLENGE_FAILED - MFA challenge failed (wrong OTP, WebAuthn failed, etc.) */
  MFA_CHALLENGE_FAILED = 302,
  /** MFA_DEVICE_NOT_FOUND - MFA device not registered */
  MFA_DEVICE_NOT_FOUND = 303,
  /** MFA_CHALLENGE_EXPIRED - MFA challenge has expired */
  MFA_CHALLENGE_EXPIRED = 304,
  /** MFA_ATTEMPTS_EXCEEDED - Too many MFA attempts, temporarily locked */
  MFA_ATTEMPTS_EXCEEDED = 305,
  /**
   * AUDIT_WRITE_FAILED - Audit write failed - BLOCKING for sensitive operations
   * If this error is returned, the sensitive action was NOT executed
   */
  AUDIT_WRITE_FAILED = 400,
  /** AUDIT_SERVICE_UNAVAILABLE - Audit service is unavailable */
  AUDIT_SERVICE_UNAVAILABLE = 401,
  /** AUDIT_CHAIN_INVALID - Audit chain verification failed (tampering detected) */
  AUDIT_CHAIN_INVALID = 402,
  /** AUDIT_EXPORT_DENIED - Audit export is not allowed for this query */
  AUDIT_EXPORT_DENIED = 403,
  /** RETENTION_POLICY_INVALID - Retention policy configuration is invalid */
  RETENTION_POLICY_INVALID = 500,
  /** PURGE_NOT_ALLOWED - Purge is not allowed (legal hold, etc.) */
  PURGE_NOT_ALLOWED = 501,
  /** PURGE_IN_PROGRESS - Purge request is already in progress */
  PURGE_IN_PROGRESS = 502,
  /** PURGE_REQUEST_NOT_FOUND - Purge request not found */
  PURGE_REQUEST_NOT_FOUND = 503,
  /** PURGE_PARTIAL_FAILURE - Purge failed for one or more services */
  PURGE_PARTIAL_FAILURE = 504,
  /** PURGE_SUBJECT_NOT_FOUND - Subject for purge not found */
  PURGE_SUBJECT_NOT_FOUND = 505,
  /** DECRYPTION_FAILED - Decryption failed - key version mismatch or data corrupted */
  DECRYPTION_FAILED = 600,
  /** KEY_NOT_FOUND - KMS key not found or inaccessible */
  KEY_NOT_FOUND = 601,
  /** ENCRYPTION_FAILED - Encryption operation failed */
  ENCRYPTION_FAILED = 602,
  /** KEY_ROTATION_IN_PROGRESS - Key rotation is in progress, retry later */
  KEY_ROTATION_IN_PROGRESS = 603,
  /** BREAKGLASS_REQUIRED - This action requires an active break-glass session */
  BREAKGLASS_REQUIRED = 700,
  /** BREAKGLASS_EXPIRED - Break-glass session has expired */
  BREAKGLASS_EXPIRED = 701,
  /** BREAKGLASS_NOT_ACTIVE - No active break-glass session found */
  BREAKGLASS_NOT_ACTIVE = 702,
  /** BREAKGLASS_ACTIVATION_FAILED - Break-glass activation failed */
  BREAKGLASS_ACTIVATION_FAILED = 703,
  /** BREAKGLASS_ALREADY_ACTIVE - Break-glass session already active */
  BREAKGLASS_ALREADY_ACTIVE = 704,
  /** BREAKGLASS_DURATION_EXCEEDED - Break-glass duration exceeds maximum allowed */
  BREAKGLASS_DURATION_EXCEEDED = 705,
  UNRECOGNIZED = -1,
}

export function securityErrorCodeFromJSON(object: any): SecurityErrorCode {
  switch (object) {
    case 0:
    case "SECURITY_ERROR_CODE_UNSPECIFIED":
      return SecurityErrorCode.SECURITY_ERROR_CODE_UNSPECIFIED;
    case 100:
    case "UNAUTHORIZED":
      return SecurityErrorCode.UNAUTHORIZED;
    case 101:
    case "SESSION_EXPIRED":
      return SecurityErrorCode.SESSION_EXPIRED;
    case 102:
    case "SESSION_REVOKED":
      return SecurityErrorCode.SESSION_REVOKED;
    case 103:
    case "SSO_ASSERTION_INVALID":
      return SecurityErrorCode.SSO_ASSERTION_INVALID;
    case 104:
    case "TOKEN_REFRESH_FAILED":
      return SecurityErrorCode.TOKEN_REFRESH_FAILED;
    case 105:
    case "INVALID_CREDENTIALS":
      return SecurityErrorCode.INVALID_CREDENTIALS;
    case 106:
    case "ACCOUNT_LOCKED":
      return SecurityErrorCode.ACCOUNT_LOCKED;
    case 107:
    case "ACCOUNT_DISABLED":
      return SecurityErrorCode.ACCOUNT_DISABLED;
    case 200:
    case "FORBIDDEN":
      return SecurityErrorCode.FORBIDDEN;
    case 201:
    case "PERMISSION_MISSING":
      return SecurityErrorCode.PERMISSION_MISSING;
    case 202:
    case "TENANT_SCOPE_VIOLATION":
      return SecurityErrorCode.TENANT_SCOPE_VIOLATION;
    case 203:
    case "ROLE_INSUFFICIENT":
      return SecurityErrorCode.ROLE_INSUFFICIENT;
    case 204:
    case "MEMBERSHIP_INACTIVE":
      return SecurityErrorCode.MEMBERSHIP_INACTIVE;
    case 205:
    case "RESOURCE_NOT_ACCESSIBLE":
      return SecurityErrorCode.RESOURCE_NOT_ACCESSIBLE;
    case 300:
    case "MFA_REQUIRED":
      return SecurityErrorCode.MFA_REQUIRED;
    case 301:
    case "MFA_STEP_UP_REQUIRED":
      return SecurityErrorCode.MFA_STEP_UP_REQUIRED;
    case 302:
    case "MFA_CHALLENGE_FAILED":
      return SecurityErrorCode.MFA_CHALLENGE_FAILED;
    case 303:
    case "MFA_DEVICE_NOT_FOUND":
      return SecurityErrorCode.MFA_DEVICE_NOT_FOUND;
    case 304:
    case "MFA_CHALLENGE_EXPIRED":
      return SecurityErrorCode.MFA_CHALLENGE_EXPIRED;
    case 305:
    case "MFA_ATTEMPTS_EXCEEDED":
      return SecurityErrorCode.MFA_ATTEMPTS_EXCEEDED;
    case 400:
    case "AUDIT_WRITE_FAILED":
      return SecurityErrorCode.AUDIT_WRITE_FAILED;
    case 401:
    case "AUDIT_SERVICE_UNAVAILABLE":
      return SecurityErrorCode.AUDIT_SERVICE_UNAVAILABLE;
    case 402:
    case "AUDIT_CHAIN_INVALID":
      return SecurityErrorCode.AUDIT_CHAIN_INVALID;
    case 403:
    case "AUDIT_EXPORT_DENIED":
      return SecurityErrorCode.AUDIT_EXPORT_DENIED;
    case 500:
    case "RETENTION_POLICY_INVALID":
      return SecurityErrorCode.RETENTION_POLICY_INVALID;
    case 501:
    case "PURGE_NOT_ALLOWED":
      return SecurityErrorCode.PURGE_NOT_ALLOWED;
    case 502:
    case "PURGE_IN_PROGRESS":
      return SecurityErrorCode.PURGE_IN_PROGRESS;
    case 503:
    case "PURGE_REQUEST_NOT_FOUND":
      return SecurityErrorCode.PURGE_REQUEST_NOT_FOUND;
    case 504:
    case "PURGE_PARTIAL_FAILURE":
      return SecurityErrorCode.PURGE_PARTIAL_FAILURE;
    case 505:
    case "PURGE_SUBJECT_NOT_FOUND":
      return SecurityErrorCode.PURGE_SUBJECT_NOT_FOUND;
    case 600:
    case "DECRYPTION_FAILED":
      return SecurityErrorCode.DECRYPTION_FAILED;
    case 601:
    case "KEY_NOT_FOUND":
      return SecurityErrorCode.KEY_NOT_FOUND;
    case 602:
    case "ENCRYPTION_FAILED":
      return SecurityErrorCode.ENCRYPTION_FAILED;
    case 603:
    case "KEY_ROTATION_IN_PROGRESS":
      return SecurityErrorCode.KEY_ROTATION_IN_PROGRESS;
    case 700:
    case "BREAKGLASS_REQUIRED":
      return SecurityErrorCode.BREAKGLASS_REQUIRED;
    case 701:
    case "BREAKGLASS_EXPIRED":
      return SecurityErrorCode.BREAKGLASS_EXPIRED;
    case 702:
    case "BREAKGLASS_NOT_ACTIVE":
      return SecurityErrorCode.BREAKGLASS_NOT_ACTIVE;
    case 703:
    case "BREAKGLASS_ACTIVATION_FAILED":
      return SecurityErrorCode.BREAKGLASS_ACTIVATION_FAILED;
    case 704:
    case "BREAKGLASS_ALREADY_ACTIVE":
      return SecurityErrorCode.BREAKGLASS_ALREADY_ACTIVE;
    case 705:
    case "BREAKGLASS_DURATION_EXCEEDED":
      return SecurityErrorCode.BREAKGLASS_DURATION_EXCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecurityErrorCode.UNRECOGNIZED;
  }
}

export function securityErrorCodeToJSON(object: SecurityErrorCode): string {
  switch (object) {
    case SecurityErrorCode.SECURITY_ERROR_CODE_UNSPECIFIED:
      return "SECURITY_ERROR_CODE_UNSPECIFIED";
    case SecurityErrorCode.UNAUTHORIZED:
      return "UNAUTHORIZED";
    case SecurityErrorCode.SESSION_EXPIRED:
      return "SESSION_EXPIRED";
    case SecurityErrorCode.SESSION_REVOKED:
      return "SESSION_REVOKED";
    case SecurityErrorCode.SSO_ASSERTION_INVALID:
      return "SSO_ASSERTION_INVALID";
    case SecurityErrorCode.TOKEN_REFRESH_FAILED:
      return "TOKEN_REFRESH_FAILED";
    case SecurityErrorCode.INVALID_CREDENTIALS:
      return "INVALID_CREDENTIALS";
    case SecurityErrorCode.ACCOUNT_LOCKED:
      return "ACCOUNT_LOCKED";
    case SecurityErrorCode.ACCOUNT_DISABLED:
      return "ACCOUNT_DISABLED";
    case SecurityErrorCode.FORBIDDEN:
      return "FORBIDDEN";
    case SecurityErrorCode.PERMISSION_MISSING:
      return "PERMISSION_MISSING";
    case SecurityErrorCode.TENANT_SCOPE_VIOLATION:
      return "TENANT_SCOPE_VIOLATION";
    case SecurityErrorCode.ROLE_INSUFFICIENT:
      return "ROLE_INSUFFICIENT";
    case SecurityErrorCode.MEMBERSHIP_INACTIVE:
      return "MEMBERSHIP_INACTIVE";
    case SecurityErrorCode.RESOURCE_NOT_ACCESSIBLE:
      return "RESOURCE_NOT_ACCESSIBLE";
    case SecurityErrorCode.MFA_REQUIRED:
      return "MFA_REQUIRED";
    case SecurityErrorCode.MFA_STEP_UP_REQUIRED:
      return "MFA_STEP_UP_REQUIRED";
    case SecurityErrorCode.MFA_CHALLENGE_FAILED:
      return "MFA_CHALLENGE_FAILED";
    case SecurityErrorCode.MFA_DEVICE_NOT_FOUND:
      return "MFA_DEVICE_NOT_FOUND";
    case SecurityErrorCode.MFA_CHALLENGE_EXPIRED:
      return "MFA_CHALLENGE_EXPIRED";
    case SecurityErrorCode.MFA_ATTEMPTS_EXCEEDED:
      return "MFA_ATTEMPTS_EXCEEDED";
    case SecurityErrorCode.AUDIT_WRITE_FAILED:
      return "AUDIT_WRITE_FAILED";
    case SecurityErrorCode.AUDIT_SERVICE_UNAVAILABLE:
      return "AUDIT_SERVICE_UNAVAILABLE";
    case SecurityErrorCode.AUDIT_CHAIN_INVALID:
      return "AUDIT_CHAIN_INVALID";
    case SecurityErrorCode.AUDIT_EXPORT_DENIED:
      return "AUDIT_EXPORT_DENIED";
    case SecurityErrorCode.RETENTION_POLICY_INVALID:
      return "RETENTION_POLICY_INVALID";
    case SecurityErrorCode.PURGE_NOT_ALLOWED:
      return "PURGE_NOT_ALLOWED";
    case SecurityErrorCode.PURGE_IN_PROGRESS:
      return "PURGE_IN_PROGRESS";
    case SecurityErrorCode.PURGE_REQUEST_NOT_FOUND:
      return "PURGE_REQUEST_NOT_FOUND";
    case SecurityErrorCode.PURGE_PARTIAL_FAILURE:
      return "PURGE_PARTIAL_FAILURE";
    case SecurityErrorCode.PURGE_SUBJECT_NOT_FOUND:
      return "PURGE_SUBJECT_NOT_FOUND";
    case SecurityErrorCode.DECRYPTION_FAILED:
      return "DECRYPTION_FAILED";
    case SecurityErrorCode.KEY_NOT_FOUND:
      return "KEY_NOT_FOUND";
    case SecurityErrorCode.ENCRYPTION_FAILED:
      return "ENCRYPTION_FAILED";
    case SecurityErrorCode.KEY_ROTATION_IN_PROGRESS:
      return "KEY_ROTATION_IN_PROGRESS";
    case SecurityErrorCode.BREAKGLASS_REQUIRED:
      return "BREAKGLASS_REQUIRED";
    case SecurityErrorCode.BREAKGLASS_EXPIRED:
      return "BREAKGLASS_EXPIRED";
    case SecurityErrorCode.BREAKGLASS_NOT_ACTIVE:
      return "BREAKGLASS_NOT_ACTIVE";
    case SecurityErrorCode.BREAKGLASS_ACTIVATION_FAILED:
      return "BREAKGLASS_ACTIVATION_FAILED";
    case SecurityErrorCode.BREAKGLASS_ALREADY_ACTIVE:
      return "BREAKGLASS_ALREADY_ACTIVE";
    case SecurityErrorCode.BREAKGLASS_DURATION_EXCEEDED:
      return "BREAKGLASS_DURATION_EXCEEDED";
    case SecurityErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Structured security error response */
export interface SecurityError {
  /** Error code for programmatic handling */
  code: SecurityErrorCode;
  /** Human-readable message (safe for UI display) */
  message: string;
  /** Request ID for log correlation and support */
  requestId: string;
  /** Additional non-sensitive context */
  details: { [key: string]: string };
  /** For step-up flows: URL to redirect for MFA */
  stepUpUrl: string;
  /** For step-up flows: how long the step-up is valid (seconds) */
  stepUpTtlSeconds: number;
  /** For permission errors: the permission that was required */
  requiredPermission: string;
  /** For tenant errors: the expected organisation_id */
  expectedOrganisationId: string;
  /** Timestamp when error occurred (ISO 8601) */
  occurredAt: string;
}

export interface SecurityError_DetailsEntry {
  key: string;
  value: string;
}

/** Validation error for input validation failures */
export interface ValidationError {
  /** Field that failed validation */
  field: string;
  /** Validation rule that failed */
  rule: string;
  /** Human-readable error message */
  message: string;
  /** The invalid value (redacted if sensitive) */
  value: string;
}

/** Collection of validation errors */
export interface ValidationErrors {
  /** List of individual field validation errors */
  errors: ValidationError[];
  /** Request ID for log correlation */
  requestId: string;
}

/** Rate limit error response */
export interface RateLimitError {
  /** When the client can retry (Unix timestamp) */
  retryAfter: number;
  /** Current limit that was exceeded */
  limit: number;
  /** Time window for the limit (seconds) */
  windowSeconds: number;
  /** Request ID for log correlation */
  requestId: string;
}

function createBaseSecurityError(): SecurityError {
  return {
    code: 0,
    message: "",
    requestId: "",
    details: {},
    stepUpUrl: "",
    stepUpTtlSeconds: 0,
    requiredPermission: "",
    expectedOrganisationId: "",
    occurredAt: "",
  };
}

export const SecurityError: MessageFns<SecurityError> = {
  encode(message: SecurityError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    globalThis.Object.entries(message.details).forEach(([key, value]: [string, string]) => {
      SecurityError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.stepUpUrl !== "") {
      writer.uint32(42).string(message.stepUpUrl);
    }
    if (message.stepUpTtlSeconds !== 0) {
      writer.uint32(48).int32(message.stepUpTtlSeconds);
    }
    if (message.requiredPermission !== "") {
      writer.uint32(58).string(message.requiredPermission);
    }
    if (message.expectedOrganisationId !== "") {
      writer.uint32(66).string(message.expectedOrganisationId);
    }
    if (message.occurredAt !== "") {
      writer.uint32(74).string(message.occurredAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SecurityError_DetailsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.details[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stepUpUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.stepUpTtlSeconds = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requiredPermission = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expectedOrganisationId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.occurredAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityError {
    return {
      code: isSet(object.code) ? securityErrorCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
      details: isObject(object.details)
        ? (globalThis.Object.entries(object.details) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      stepUpUrl: isSet(object.stepUpUrl)
        ? globalThis.String(object.stepUpUrl)
        : isSet(object.step_up_url)
        ? globalThis.String(object.step_up_url)
        : "",
      stepUpTtlSeconds: isSet(object.stepUpTtlSeconds)
        ? globalThis.Number(object.stepUpTtlSeconds)
        : isSet(object.step_up_ttl_seconds)
        ? globalThis.Number(object.step_up_ttl_seconds)
        : 0,
      requiredPermission: isSet(object.requiredPermission)
        ? globalThis.String(object.requiredPermission)
        : isSet(object.required_permission)
        ? globalThis.String(object.required_permission)
        : "",
      expectedOrganisationId: isSet(object.expectedOrganisationId)
        ? globalThis.String(object.expectedOrganisationId)
        : isSet(object.expected_organisation_id)
        ? globalThis.String(object.expected_organisation_id)
        : "",
      occurredAt: isSet(object.occurredAt)
        ? globalThis.String(object.occurredAt)
        : isSet(object.occurred_at)
        ? globalThis.String(object.occurred_at)
        : "",
    };
  },

  toJSON(message: SecurityError): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = securityErrorCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.details) {
      const entries = globalThis.Object.entries(message.details) as [string, string][];
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    if (message.stepUpUrl !== "") {
      obj.stepUpUrl = message.stepUpUrl;
    }
    if (message.stepUpTtlSeconds !== 0) {
      obj.stepUpTtlSeconds = Math.round(message.stepUpTtlSeconds);
    }
    if (message.requiredPermission !== "") {
      obj.requiredPermission = message.requiredPermission;
    }
    if (message.expectedOrganisationId !== "") {
      obj.expectedOrganisationId = message.expectedOrganisationId;
    }
    if (message.occurredAt !== "") {
      obj.occurredAt = message.occurredAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityError>, I>>(base?: I): SecurityError {
    return SecurityError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityError>, I>>(object: I): SecurityError {
    const message = createBaseSecurityError();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.requestId = object.requestId ?? "";
    message.details = (globalThis.Object.entries(object.details ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.stepUpUrl = object.stepUpUrl ?? "";
    message.stepUpTtlSeconds = object.stepUpTtlSeconds ?? 0;
    message.requiredPermission = object.requiredPermission ?? "";
    message.expectedOrganisationId = object.expectedOrganisationId ?? "";
    message.occurredAt = object.occurredAt ?? "";
    return message;
  },
};

function createBaseSecurityError_DetailsEntry(): SecurityError_DetailsEntry {
  return { key: "", value: "" };
}

export const SecurityError_DetailsEntry: MessageFns<SecurityError_DetailsEntry> = {
  encode(message: SecurityError_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityError_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityError_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SecurityError_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityError_DetailsEntry>, I>>(base?: I): SecurityError_DetailsEntry {
    return SecurityError_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityError_DetailsEntry>, I>>(object: I): SecurityError_DetailsEntry {
    const message = createBaseSecurityError_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseValidationError(): ValidationError {
  return { field: "", rule: "", message: "", value: "" };
}

export const ValidationError: MessageFns<ValidationError> = {
  encode(message: ValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.rule !== "") {
      writer.uint32(18).string(message.rule);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationError {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      rule: isSet(object.rule) ? globalThis.String(object.rule) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ValidationError): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.rule !== "") {
      obj.rule = message.rule;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidationError>, I>>(base?: I): ValidationError {
    return ValidationError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidationError>, I>>(object: I): ValidationError {
    const message = createBaseValidationError();
    message.field = object.field ?? "";
    message.rule = object.rule ?? "";
    message.message = object.message ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseValidationErrors(): ValidationErrors {
  return { errors: [], requestId: "" };
}

export const ValidationErrors: MessageFns<ValidationErrors> = {
  encode(message: ValidationErrors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      ValidationError.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationErrors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationErrors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationErrors {
    return {
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => ValidationError.fromJSON(e))
        : [],
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
    };
  },

  toJSON(message: ValidationErrors): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ValidationError.toJSON(e));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidationErrors>, I>>(base?: I): ValidationErrors {
    return ValidationErrors.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidationErrors>, I>>(object: I): ValidationErrors {
    const message = createBaseValidationErrors();
    message.errors = object.errors?.map((e) => ValidationError.fromPartial(e)) || [];
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseRateLimitError(): RateLimitError {
  return { retryAfter: 0, limit: 0, windowSeconds: 0, requestId: "" };
}

export const RateLimitError: MessageFns<RateLimitError> = {
  encode(message: RateLimitError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryAfter !== 0) {
      writer.uint32(8).int64(message.retryAfter);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.windowSeconds !== 0) {
      writer.uint32(24).int32(message.windowSeconds);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.retryAfter = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.windowSeconds = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RateLimitError {
    return {
      retryAfter: isSet(object.retryAfter)
        ? globalThis.Number(object.retryAfter)
        : isSet(object.retry_after)
        ? globalThis.Number(object.retry_after)
        : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      windowSeconds: isSet(object.windowSeconds)
        ? globalThis.Number(object.windowSeconds)
        : isSet(object.window_seconds)
        ? globalThis.Number(object.window_seconds)
        : 0,
      requestId: isSet(object.requestId)
        ? globalThis.String(object.requestId)
        : isSet(object.request_id)
        ? globalThis.String(object.request_id)
        : "",
    };
  },

  toJSON(message: RateLimitError): unknown {
    const obj: any = {};
    if (message.retryAfter !== 0) {
      obj.retryAfter = Math.round(message.retryAfter);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.windowSeconds !== 0) {
      obj.windowSeconds = Math.round(message.windowSeconds);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RateLimitError>, I>>(base?: I): RateLimitError {
    return RateLimitError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RateLimitError>, I>>(object: I): RateLimitError {
    const message = createBaseRateLimitError();
    message.retryAfter = object.retryAfter ?? 0;
    message.limit = object.limit ?? 0;
    message.windowSeconds = object.windowSeconds ?? 0;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
