// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: security/retention.proto

/* eslint-disable */

/** Purge mode for data removal */
export enum PurgeMode {
  PURGE_MODE_UNSPECIFIED = 0,
  /** PURGE_MODE_DELETE - Hard delete - completely remove data */
  PURGE_MODE_DELETE = 1,
  /** PURGE_MODE_ANONYMIZE - Anonymize - remove PII but keep structure for analytics */
  PURGE_MODE_ANONYMIZE = 2,
  /** PURGE_MODE_ARCHIVE - Archive - move to cold storage */
  PURGE_MODE_ARCHIVE = 3,
  UNRECOGNIZED = -1,
}

/** Status of a purge request */
export enum PurgeRequestStatus {
  PURGE_REQUEST_STATUS_UNSPECIFIED = 0,
  /** PURGE_REQUEST_STATUS_PENDING - Request created, not yet processed */
  PURGE_REQUEST_STATUS_PENDING = 1,
  /** PURGE_REQUEST_STATUS_RUNNING - Purge is currently running */
  PURGE_REQUEST_STATUS_RUNNING = 2,
  /** PURGE_REQUEST_STATUS_COMPLETED - Purge completed successfully */
  PURGE_REQUEST_STATUS_COMPLETED = 3,
  /** PURGE_REQUEST_STATUS_PARTIAL - Partial purge (some data retained due to legal hold) */
  PURGE_REQUEST_STATUS_PARTIAL = 4,
  /** PURGE_REQUEST_STATUS_REJECTED - Request rejected (e.g., not authorized) */
  PURGE_REQUEST_STATUS_REJECTED = 5,
  /** PURGE_REQUEST_STATUS_FAILED - Purge failed with error */
  PURGE_REQUEST_STATUS_FAILED = 6,
  UNRECOGNIZED = -1,
}

/** Status of individual purge execution per service */
export enum PurgeExecutionStatus {
  PURGE_EXECUTION_STATUS_UNSPECIFIED = 0,
  PURGE_EXECUTION_STATUS_SUCCESS = 1,
  PURGE_EXECUTION_STATUS_PARTIAL = 2,
  PURGE_EXECUTION_STATUS_FAILED = 3,
  PURGE_EXECUTION_STATUS_SKIPPED = 4,
  UNRECOGNIZED = -1,
}

/** Subject type for purge requests */
export enum SubjectType {
  SUBJECT_TYPE_UNSPECIFIED = 0,
  /** SUBJECT_TYPE_USER - Internal user (employee, admin) */
  SUBJECT_TYPE_USER = 1,
  /** SUBJECT_TYPE_CUSTOMER - External customer */
  SUBJECT_TYPE_CUSTOMER = 2,
  /** SUBJECT_TYPE_PARTNER - Partner/vendor */
  SUBJECT_TYPE_PARTNER = 3,
  UNRECOGNIZED = -1,
}

/** Retention policy for a data category */
export interface RetentionPolicy {
  id: string;
  /** Category identifier (e.g., PAYMENT_10Y, AUDIT_7Y, TECH_90D) */
  category: string;
  /** Service that owns this data */
  serviceName: string;
  /** Entity/table name */
  entityName: string;
  /** Retention period in days */
  retentionDays: number;
  /** How to handle data after retention period */
  purgeMode: PurgeMode;
  /** Legal basis for retention (for compliance documentation) */
  legalBasis: string;
  /** Description for documentation */
  description: string;
  /** Timestamps */
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  updatedByUserId: string;
  /** Whether this policy is active */
  isActive: boolean;
}

/** Create or update retention policy */
export interface UpsertRetentionPolicyRequest {
  category: string;
  serviceName: string;
  entityName: string;
  retentionDays: number;
  purgeMode: PurgeMode;
  legalBasis: string;
  description: string;
}

export interface UpsertRetentionPolicyResponse {
  policy?: RetentionPolicy | undefined;
  created: boolean;
}

/** List retention policies */
export interface ListRetentionPoliciesRequest {
  serviceName: string;
  category: string;
  includeInactive: boolean;
}

export interface ListRetentionPoliciesResponse {
  policies: RetentionPolicy[];
}

/** Get specific policy */
export interface GetRetentionPolicyRequest {
  id: string;
}

export interface GetRetentionPolicyResponse {
  policy?: RetentionPolicy | undefined;
}

/** Purge job for scheduled retention enforcement */
export interface PurgeJob {
  id: string;
  /** Which policy triggered this job */
  retentionPolicyId: string;
  /** Service being purged */
  serviceName: string;
  /** Entity being purged */
  entityName: string;
  /** Cutoff date (records before this date are purged) */
  cutoffDate?:
    | Date
    | undefined;
  /** Job status */
  status: PurgeExecutionStatus;
  /** Counts */
  recordsScanned: number;
  recordsDeleted: number;
  recordsAnonymized: number;
  recordsArchived: number;
  recordsRetained: number;
  /** Reason for retention (if any records retained) */
  retentionReason: string;
  /** Timestamps */
  startedAt?: Date | undefined;
  completedAt?:
    | Date
    | undefined;
  /** Error info (if failed) */
  errorMessage: string;
  /** Is this a dry run? */
  dryRun: boolean;
}

/** Run scheduled purge (daily job) */
export interface RunScheduledPurgeRequest {
  /** Optional: limit to specific service */
  serviceName: string;
  /** Optional: limit to specific category */
  category: string;
  /** If true, only report what would be purged */
  dryRun: boolean;
}

export interface RunScheduledPurgeResponse {
  jobs: PurgeJob[];
  totalJobs: number;
  successfulJobs: number;
  failedJobs: number;
  totalRecordsPurged: number;
}

/** List purge job history */
export interface ListPurgeJobsRequest {
  serviceName: string;
  from?: Date | undefined;
  to?: Date | undefined;
  statuses: PurgeExecutionStatus[];
  page: number;
  limit: number;
}

export interface ListPurgeJobsResponse {
  jobs: PurgeJob[];
  total: number;
  page: number;
  limit: number;
}

/** GDPR purge request for a specific subject */
export interface PurgeRequest {
  id: string;
  /** Tenant context */
  organisationId: string;
  /** Who requested the purge */
  requestedByUserId: string;
  /** Subject of the purge */
  subjectType: SubjectType;
  subjectId: string;
  /** Optional: subject email (for cross-service lookup) */
  subjectEmail: string;
  /** Reason for purge (GDPR article, etc.) */
  reason: string;
  /** Legal basis for purge */
  legalBasis: string;
  /** If true, some data may be retained for legal reasons */
  legalHold: boolean;
  /** Legal hold details (if applicable) */
  legalHoldReason: string;
  legalHoldUntil?:
    | Date
    | undefined;
  /** Status */
  status: PurgeRequestStatus;
  /** Timestamps */
  createdAt?: Date | undefined;
  startedAt?: Date | undefined;
  completedAt?:
    | Date
    | undefined;
  /** External reference (e.g., support ticket) */
  externalReference: string;
}

/** Per-service execution result for a purge request */
export interface PurgeExecution {
  id: string;
  purgeRequestId: string;
  /** Service that executed the purge */
  serviceName: string;
  /** Entity purged */
  entityName: string;
  /** Status */
  status: PurgeExecutionStatus;
  /** Counts */
  deletedCount: number;
  anonymizedCount: number;
  retainedCount: number;
  /** If any retained, why */
  retainedReason: string;
  /** Verification */
  verificationQuery: string;
  verificationPassed: boolean;
  /** Timestamps */
  executedAt?:
    | Date
    | undefined;
  /** Error info (if failed) */
  errorMessage: string;
}

/** Create GDPR purge request */
export interface CreatePurgeRequestRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  subjectEmail: string;
  reason: string;
  legalBasis: string;
  externalReference: string;
}

export interface CreatePurgeRequestResponse {
  request?: PurgeRequest | undefined;
}

/** Execute purge request */
export interface ExecutePurgeRequest {
  purgeRequestId: string;
  /** If true, only report what would be purged */
  dryRun: boolean;
}

export interface ExecutePurgeResponse {
  request?: PurgeRequest | undefined;
  executions: PurgeExecution[];
}

/** Get purge request with executions */
export interface GetPurgeRequestRequest {
  purgeRequestId: string;
}

export interface GetPurgeRequestResponse {
  request?: PurgeRequest | undefined;
  executions: PurgeExecution[];
}

/** List purge requests */
export interface ListPurgeRequestsRequest {
  organisationId: string;
  statuses: PurgeRequestStatus[];
  subjectType: SubjectType;
  from?: Date | undefined;
  to?: Date | undefined;
  page: number;
  limit: number;
}

export interface ListPurgeRequestsResponse {
  requests: PurgeRequest[];
  total: number;
  page: number;
  limit: number;
}

/** Cancel pending purge request */
export interface CancelPurgeRequestRequest {
  purgeRequestId: string;
  reason: string;
}

export interface CancelPurgeRequestResponse {
  request?: PurgeRequest | undefined;
}

/** Legal hold on a subject's data */
export interface LegalHold {
  id: string;
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  /** Legal hold details */
  reason: string;
  caseReference: string;
  /** Who placed the hold */
  placedByUserId: string;
  placedAt?:
    | Date
    | undefined;
  /** Optional expiration */
  expiresAt?:
    | Date
    | undefined;
  /** Is hold active? */
  isActive: boolean;
  /** If lifted, details */
  liftedByUserId: string;
  liftedAt?: Date | undefined;
  liftReason: string;
}

/** Place legal hold */
export interface PlaceLegalHoldRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  reason: string;
  caseReference: string;
  expiresAt?: Date | undefined;
}

export interface PlaceLegalHoldResponse {
  hold?: LegalHold | undefined;
}

/** Lift legal hold */
export interface LiftLegalHoldRequest {
  holdId: string;
  reason: string;
}

export interface LiftLegalHoldResponse {
  hold?: LegalHold | undefined;
}

/** Check for legal hold */
export interface CheckLegalHoldRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
}

export interface CheckLegalHoldResponse {
  hasHold: boolean;
  activeHolds: LegalHold[];
}

/** Proof of purge for compliance documentation */
export interface PurgeProof {
  purgeRequestId: string;
  /** Summary */
  purgeCompletedAt?: Date | undefined;
  finalStatus: PurgeRequestStatus;
  /** Per-service summary */
  executions: PurgeExecution[];
  /** Totals */
  totalDeleted: number;
  totalAnonymized: number;
  totalRetained: number;
  /** Verification results */
  allVerificationsPassed: boolean;
  failedVerifications: string[];
  /** Digital signature for proof integrity */
  proofSignature: string;
  proofGeneratedAt?: Date | undefined;
}

/** Generate proof of purge */
export interface GeneratePurgeProofRequest {
  purgeRequestId: string;
}

export interface GeneratePurgeProofResponse {
  proof?: PurgeProof | undefined;
}
