// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               unknown
// source: security/retention.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../google/protobuf/timestamp";

/** Purge mode for data removal */
export enum PurgeMode {
  PURGE_MODE_UNSPECIFIED = 0,
  /** PURGE_MODE_DELETE - Hard delete - completely remove data */
  PURGE_MODE_DELETE = 1,
  /** PURGE_MODE_ANONYMIZE - Anonymize - remove PII but keep structure for analytics */
  PURGE_MODE_ANONYMIZE = 2,
  /** PURGE_MODE_ARCHIVE - Archive - move to cold storage */
  PURGE_MODE_ARCHIVE = 3,
  UNRECOGNIZED = -1,
}

export function purgeModeFromJSON(object: any): PurgeMode {
  switch (object) {
    case 0:
    case "PURGE_MODE_UNSPECIFIED":
      return PurgeMode.PURGE_MODE_UNSPECIFIED;
    case 1:
    case "PURGE_MODE_DELETE":
      return PurgeMode.PURGE_MODE_DELETE;
    case 2:
    case "PURGE_MODE_ANONYMIZE":
      return PurgeMode.PURGE_MODE_ANONYMIZE;
    case 3:
    case "PURGE_MODE_ARCHIVE":
      return PurgeMode.PURGE_MODE_ARCHIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PurgeMode.UNRECOGNIZED;
  }
}

export function purgeModeToJSON(object: PurgeMode): string {
  switch (object) {
    case PurgeMode.PURGE_MODE_UNSPECIFIED:
      return "PURGE_MODE_UNSPECIFIED";
    case PurgeMode.PURGE_MODE_DELETE:
      return "PURGE_MODE_DELETE";
    case PurgeMode.PURGE_MODE_ANONYMIZE:
      return "PURGE_MODE_ANONYMIZE";
    case PurgeMode.PURGE_MODE_ARCHIVE:
      return "PURGE_MODE_ARCHIVE";
    case PurgeMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status of a purge request */
export enum PurgeRequestStatus {
  PURGE_REQUEST_STATUS_UNSPECIFIED = 0,
  /** PURGE_REQUEST_STATUS_PENDING - Request created, not yet processed */
  PURGE_REQUEST_STATUS_PENDING = 1,
  /** PURGE_REQUEST_STATUS_RUNNING - Purge is currently running */
  PURGE_REQUEST_STATUS_RUNNING = 2,
  /** PURGE_REQUEST_STATUS_COMPLETED - Purge completed successfully */
  PURGE_REQUEST_STATUS_COMPLETED = 3,
  /** PURGE_REQUEST_STATUS_PARTIAL - Partial purge (some data retained due to legal hold) */
  PURGE_REQUEST_STATUS_PARTIAL = 4,
  /** PURGE_REQUEST_STATUS_REJECTED - Request rejected (e.g., not authorized) */
  PURGE_REQUEST_STATUS_REJECTED = 5,
  /** PURGE_REQUEST_STATUS_FAILED - Purge failed with error */
  PURGE_REQUEST_STATUS_FAILED = 6,
  UNRECOGNIZED = -1,
}

export function purgeRequestStatusFromJSON(object: any): PurgeRequestStatus {
  switch (object) {
    case 0:
    case "PURGE_REQUEST_STATUS_UNSPECIFIED":
      return PurgeRequestStatus.PURGE_REQUEST_STATUS_UNSPECIFIED;
    case 1:
    case "PURGE_REQUEST_STATUS_PENDING":
      return PurgeRequestStatus.PURGE_REQUEST_STATUS_PENDING;
    case 2:
    case "PURGE_REQUEST_STATUS_RUNNING":
      return PurgeRequestStatus.PURGE_REQUEST_STATUS_RUNNING;
    case 3:
    case "PURGE_REQUEST_STATUS_COMPLETED":
      return PurgeRequestStatus.PURGE_REQUEST_STATUS_COMPLETED;
    case 4:
    case "PURGE_REQUEST_STATUS_PARTIAL":
      return PurgeRequestStatus.PURGE_REQUEST_STATUS_PARTIAL;
    case 5:
    case "PURGE_REQUEST_STATUS_REJECTED":
      return PurgeRequestStatus.PURGE_REQUEST_STATUS_REJECTED;
    case 6:
    case "PURGE_REQUEST_STATUS_FAILED":
      return PurgeRequestStatus.PURGE_REQUEST_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PurgeRequestStatus.UNRECOGNIZED;
  }
}

export function purgeRequestStatusToJSON(object: PurgeRequestStatus): string {
  switch (object) {
    case PurgeRequestStatus.PURGE_REQUEST_STATUS_UNSPECIFIED:
      return "PURGE_REQUEST_STATUS_UNSPECIFIED";
    case PurgeRequestStatus.PURGE_REQUEST_STATUS_PENDING:
      return "PURGE_REQUEST_STATUS_PENDING";
    case PurgeRequestStatus.PURGE_REQUEST_STATUS_RUNNING:
      return "PURGE_REQUEST_STATUS_RUNNING";
    case PurgeRequestStatus.PURGE_REQUEST_STATUS_COMPLETED:
      return "PURGE_REQUEST_STATUS_COMPLETED";
    case PurgeRequestStatus.PURGE_REQUEST_STATUS_PARTIAL:
      return "PURGE_REQUEST_STATUS_PARTIAL";
    case PurgeRequestStatus.PURGE_REQUEST_STATUS_REJECTED:
      return "PURGE_REQUEST_STATUS_REJECTED";
    case PurgeRequestStatus.PURGE_REQUEST_STATUS_FAILED:
      return "PURGE_REQUEST_STATUS_FAILED";
    case PurgeRequestStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status of individual purge execution per service */
export enum PurgeExecutionStatus {
  PURGE_EXECUTION_STATUS_UNSPECIFIED = 0,
  PURGE_EXECUTION_STATUS_SUCCESS = 1,
  PURGE_EXECUTION_STATUS_PARTIAL = 2,
  PURGE_EXECUTION_STATUS_FAILED = 3,
  PURGE_EXECUTION_STATUS_SKIPPED = 4,
  UNRECOGNIZED = -1,
}

export function purgeExecutionStatusFromJSON(object: any): PurgeExecutionStatus {
  switch (object) {
    case 0:
    case "PURGE_EXECUTION_STATUS_UNSPECIFIED":
      return PurgeExecutionStatus.PURGE_EXECUTION_STATUS_UNSPECIFIED;
    case 1:
    case "PURGE_EXECUTION_STATUS_SUCCESS":
      return PurgeExecutionStatus.PURGE_EXECUTION_STATUS_SUCCESS;
    case 2:
    case "PURGE_EXECUTION_STATUS_PARTIAL":
      return PurgeExecutionStatus.PURGE_EXECUTION_STATUS_PARTIAL;
    case 3:
    case "PURGE_EXECUTION_STATUS_FAILED":
      return PurgeExecutionStatus.PURGE_EXECUTION_STATUS_FAILED;
    case 4:
    case "PURGE_EXECUTION_STATUS_SKIPPED":
      return PurgeExecutionStatus.PURGE_EXECUTION_STATUS_SKIPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PurgeExecutionStatus.UNRECOGNIZED;
  }
}

export function purgeExecutionStatusToJSON(object: PurgeExecutionStatus): string {
  switch (object) {
    case PurgeExecutionStatus.PURGE_EXECUTION_STATUS_UNSPECIFIED:
      return "PURGE_EXECUTION_STATUS_UNSPECIFIED";
    case PurgeExecutionStatus.PURGE_EXECUTION_STATUS_SUCCESS:
      return "PURGE_EXECUTION_STATUS_SUCCESS";
    case PurgeExecutionStatus.PURGE_EXECUTION_STATUS_PARTIAL:
      return "PURGE_EXECUTION_STATUS_PARTIAL";
    case PurgeExecutionStatus.PURGE_EXECUTION_STATUS_FAILED:
      return "PURGE_EXECUTION_STATUS_FAILED";
    case PurgeExecutionStatus.PURGE_EXECUTION_STATUS_SKIPPED:
      return "PURGE_EXECUTION_STATUS_SKIPPED";
    case PurgeExecutionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Subject type for purge requests */
export enum SubjectType {
  SUBJECT_TYPE_UNSPECIFIED = 0,
  /** SUBJECT_TYPE_USER - Internal user (employee, admin) */
  SUBJECT_TYPE_USER = 1,
  /** SUBJECT_TYPE_CUSTOMER - External customer */
  SUBJECT_TYPE_CUSTOMER = 2,
  /** SUBJECT_TYPE_PARTNER - Partner/vendor */
  SUBJECT_TYPE_PARTNER = 3,
  UNRECOGNIZED = -1,
}

export function subjectTypeFromJSON(object: any): SubjectType {
  switch (object) {
    case 0:
    case "SUBJECT_TYPE_UNSPECIFIED":
      return SubjectType.SUBJECT_TYPE_UNSPECIFIED;
    case 1:
    case "SUBJECT_TYPE_USER":
      return SubjectType.SUBJECT_TYPE_USER;
    case 2:
    case "SUBJECT_TYPE_CUSTOMER":
      return SubjectType.SUBJECT_TYPE_CUSTOMER;
    case 3:
    case "SUBJECT_TYPE_PARTNER":
      return SubjectType.SUBJECT_TYPE_PARTNER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubjectType.UNRECOGNIZED;
  }
}

export function subjectTypeToJSON(object: SubjectType): string {
  switch (object) {
    case SubjectType.SUBJECT_TYPE_UNSPECIFIED:
      return "SUBJECT_TYPE_UNSPECIFIED";
    case SubjectType.SUBJECT_TYPE_USER:
      return "SUBJECT_TYPE_USER";
    case SubjectType.SUBJECT_TYPE_CUSTOMER:
      return "SUBJECT_TYPE_CUSTOMER";
    case SubjectType.SUBJECT_TYPE_PARTNER:
      return "SUBJECT_TYPE_PARTNER";
    case SubjectType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Retention policy for a data category */
export interface RetentionPolicy {
  id: string;
  /** Category identifier (e.g., PAYMENT_10Y, AUDIT_7Y, TECH_90D) */
  category: string;
  /** Service that owns this data */
  serviceName: string;
  /** Entity/table name */
  entityName: string;
  /** Retention period in days */
  retentionDays: number;
  /** How to handle data after retention period */
  purgeMode: PurgeMode;
  /** Legal basis for retention (for compliance documentation) */
  legalBasis: string;
  /** Description for documentation */
  description: string;
  /** Timestamps */
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  updatedByUserId: string;
  /** Whether this policy is active */
  isActive: boolean;
}

/** Create or update retention policy */
export interface UpsertRetentionPolicyRequest {
  category: string;
  serviceName: string;
  entityName: string;
  retentionDays: number;
  purgeMode: PurgeMode;
  legalBasis: string;
  description: string;
}

export interface UpsertRetentionPolicyResponse {
  policy?: RetentionPolicy | undefined;
  created: boolean;
}

/** List retention policies */
export interface ListRetentionPoliciesRequest {
  serviceName: string;
  category: string;
  includeInactive: boolean;
}

export interface ListRetentionPoliciesResponse {
  policies: RetentionPolicy[];
}

/** Get specific policy */
export interface GetRetentionPolicyRequest {
  id: string;
}

export interface GetRetentionPolicyResponse {
  policy?: RetentionPolicy | undefined;
}

/** Purge job for scheduled retention enforcement */
export interface PurgeJob {
  id: string;
  /** Which policy triggered this job */
  retentionPolicyId: string;
  /** Service being purged */
  serviceName: string;
  /** Entity being purged */
  entityName: string;
  /** Cutoff date (records before this date are purged) */
  cutoffDate?:
    | Date
    | undefined;
  /** Job status */
  status: PurgeExecutionStatus;
  /** Counts */
  recordsScanned: number;
  recordsDeleted: number;
  recordsAnonymized: number;
  recordsArchived: number;
  recordsRetained: number;
  /** Reason for retention (if any records retained) */
  retentionReason: string;
  /** Timestamps */
  startedAt?: Date | undefined;
  completedAt?:
    | Date
    | undefined;
  /** Error info (if failed) */
  errorMessage: string;
  /** Is this a dry run? */
  dryRun: boolean;
}

/** Run scheduled purge (daily job) */
export interface RunScheduledPurgeRequest {
  /** Optional: limit to specific service */
  serviceName: string;
  /** Optional: limit to specific category */
  category: string;
  /** If true, only report what would be purged */
  dryRun: boolean;
}

export interface RunScheduledPurgeResponse {
  jobs: PurgeJob[];
  totalJobs: number;
  successfulJobs: number;
  failedJobs: number;
  totalRecordsPurged: number;
}

/** List purge job history */
export interface ListPurgeJobsRequest {
  serviceName: string;
  from?: Date | undefined;
  to?: Date | undefined;
  statuses: PurgeExecutionStatus[];
  page: number;
  limit: number;
}

export interface ListPurgeJobsResponse {
  jobs: PurgeJob[];
  total: number;
  page: number;
  limit: number;
}

/** GDPR purge request for a specific subject */
export interface PurgeRequest {
  id: string;
  /** Tenant context */
  organisationId: string;
  /** Who requested the purge */
  requestedByUserId: string;
  /** Subject of the purge */
  subjectType: SubjectType;
  subjectId: string;
  /** Optional: subject email (for cross-service lookup) */
  subjectEmail: string;
  /** Reason for purge (GDPR article, etc.) */
  reason: string;
  /** Legal basis for purge */
  legalBasis: string;
  /** If true, some data may be retained for legal reasons */
  legalHold: boolean;
  /** Legal hold details (if applicable) */
  legalHoldReason: string;
  legalHoldUntil?:
    | Date
    | undefined;
  /** Status */
  status: PurgeRequestStatus;
  /** Timestamps */
  createdAt?: Date | undefined;
  startedAt?: Date | undefined;
  completedAt?:
    | Date
    | undefined;
  /** External reference (e.g., support ticket) */
  externalReference: string;
}

/** Per-service execution result for a purge request */
export interface PurgeExecution {
  id: string;
  purgeRequestId: string;
  /** Service that executed the purge */
  serviceName: string;
  /** Entity purged */
  entityName: string;
  /** Status */
  status: PurgeExecutionStatus;
  /** Counts */
  deletedCount: number;
  anonymizedCount: number;
  retainedCount: number;
  /** If any retained, why */
  retainedReason: string;
  /** Verification */
  verificationQuery: string;
  verificationPassed: boolean;
  /** Timestamps */
  executedAt?:
    | Date
    | undefined;
  /** Error info (if failed) */
  errorMessage: string;
}

/** Create GDPR purge request */
export interface CreatePurgeRequestRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  subjectEmail: string;
  reason: string;
  legalBasis: string;
  externalReference: string;
}

export interface CreatePurgeRequestResponse {
  request?: PurgeRequest | undefined;
}

/** Execute purge request */
export interface ExecutePurgeRequest {
  purgeRequestId: string;
  /** If true, only report what would be purged */
  dryRun: boolean;
}

export interface ExecutePurgeResponse {
  request?: PurgeRequest | undefined;
  executions: PurgeExecution[];
}

/** Get purge request with executions */
export interface GetPurgeRequestRequest {
  purgeRequestId: string;
}

export interface GetPurgeRequestResponse {
  request?: PurgeRequest | undefined;
  executions: PurgeExecution[];
}

/** List purge requests */
export interface ListPurgeRequestsRequest {
  organisationId: string;
  statuses: PurgeRequestStatus[];
  subjectType: SubjectType;
  from?: Date | undefined;
  to?: Date | undefined;
  page: number;
  limit: number;
}

export interface ListPurgeRequestsResponse {
  requests: PurgeRequest[];
  total: number;
  page: number;
  limit: number;
}

/** Cancel pending purge request */
export interface CancelPurgeRequestRequest {
  purgeRequestId: string;
  reason: string;
}

export interface CancelPurgeRequestResponse {
  request?: PurgeRequest | undefined;
}

/** Legal hold on a subject's data */
export interface LegalHold {
  id: string;
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  /** Legal hold details */
  reason: string;
  caseReference: string;
  /** Who placed the hold */
  placedByUserId: string;
  placedAt?:
    | Date
    | undefined;
  /** Optional expiration */
  expiresAt?:
    | Date
    | undefined;
  /** Is hold active? */
  isActive: boolean;
  /** If lifted, details */
  liftedByUserId: string;
  liftedAt?: Date | undefined;
  liftReason: string;
}

/** Place legal hold */
export interface PlaceLegalHoldRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  reason: string;
  caseReference: string;
  expiresAt?: Date | undefined;
}

export interface PlaceLegalHoldResponse {
  hold?: LegalHold | undefined;
}

/** Lift legal hold */
export interface LiftLegalHoldRequest {
  holdId: string;
  reason: string;
}

export interface LiftLegalHoldResponse {
  hold?: LegalHold | undefined;
}

/** Check for legal hold */
export interface CheckLegalHoldRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
}

export interface CheckLegalHoldResponse {
  hasHold: boolean;
  activeHolds: LegalHold[];
}

/** Proof of purge for compliance documentation */
export interface PurgeProof {
  purgeRequestId: string;
  /** Summary */
  purgeCompletedAt?: Date | undefined;
  finalStatus: PurgeRequestStatus;
  /** Per-service summary */
  executions: PurgeExecution[];
  /** Totals */
  totalDeleted: number;
  totalAnonymized: number;
  totalRetained: number;
  /** Verification results */
  allVerificationsPassed: boolean;
  failedVerifications: string[];
  /** Digital signature for proof integrity */
  proofSignature: string;
  proofGeneratedAt?: Date | undefined;
}

/** Generate proof of purge */
export interface GeneratePurgeProofRequest {
  purgeRequestId: string;
}

export interface GeneratePurgeProofResponse {
  proof?: PurgeProof | undefined;
}

function createBaseRetentionPolicy(): RetentionPolicy {
  return {
    id: "",
    category: "",
    serviceName: "",
    entityName: "",
    retentionDays: 0,
    purgeMode: 0,
    legalBasis: "",
    description: "",
    createdAt: undefined,
    updatedAt: undefined,
    updatedByUserId: "",
    isActive: false,
  };
}

export const RetentionPolicy: MessageFns<RetentionPolicy> = {
  encode(message: RetentionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.serviceName !== "") {
      writer.uint32(26).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(34).string(message.entityName);
    }
    if (message.retentionDays !== 0) {
      writer.uint32(40).int32(message.retentionDays);
    }
    if (message.purgeMode !== 0) {
      writer.uint32(48).int32(message.purgeMode);
    }
    if (message.legalBasis !== "") {
      writer.uint32(58).string(message.legalBasis);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).join();
    }
    if (message.updatedByUserId !== "") {
      writer.uint32(90).string(message.updatedByUserId);
    }
    if (message.isActive !== false) {
      writer.uint32(96).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetentionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.retentionDays = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.purgeMode = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedByUserId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetentionPolicy {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      entityName: isSet(object.entityName)
        ? globalThis.String(object.entityName)
        : isSet(object.entity_name)
        ? globalThis.String(object.entity_name)
        : "",
      retentionDays: isSet(object.retentionDays)
        ? globalThis.Number(object.retentionDays)
        : isSet(object.retention_days)
        ? globalThis.Number(object.retention_days)
        : 0,
      purgeMode: isSet(object.purgeMode)
        ? purgeModeFromJSON(object.purgeMode)
        : isSet(object.purge_mode)
        ? purgeModeFromJSON(object.purge_mode)
        : 0,
      legalBasis: isSet(object.legalBasis)
        ? globalThis.String(object.legalBasis)
        : isSet(object.legal_basis)
        ? globalThis.String(object.legal_basis)
        : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      updatedAt: isSet(object.updatedAt)
        ? fromJsonTimestamp(object.updatedAt)
        : isSet(object.updated_at)
        ? fromJsonTimestamp(object.updated_at)
        : undefined,
      updatedByUserId: isSet(object.updatedByUserId)
        ? globalThis.String(object.updatedByUserId)
        : isSet(object.updated_by_user_id)
        ? globalThis.String(object.updated_by_user_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
    };
  },

  toJSON(message: RetentionPolicy): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.entityName !== "") {
      obj.entityName = message.entityName;
    }
    if (message.retentionDays !== 0) {
      obj.retentionDays = Math.round(message.retentionDays);
    }
    if (message.purgeMode !== 0) {
      obj.purgeMode = purgeModeToJSON(message.purgeMode);
    }
    if (message.legalBasis !== "") {
      obj.legalBasis = message.legalBasis;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.updatedByUserId !== "") {
      obj.updatedByUserId = message.updatedByUserId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetentionPolicy>, I>>(base?: I): RetentionPolicy {
    return RetentionPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetentionPolicy>, I>>(object: I): RetentionPolicy {
    const message = createBaseRetentionPolicy();
    message.id = object.id ?? "";
    message.category = object.category ?? "";
    message.serviceName = object.serviceName ?? "";
    message.entityName = object.entityName ?? "";
    message.retentionDays = object.retentionDays ?? 0;
    message.purgeMode = object.purgeMode ?? 0;
    message.legalBasis = object.legalBasis ?? "";
    message.description = object.description ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.updatedByUserId = object.updatedByUserId ?? "";
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseUpsertRetentionPolicyRequest(): UpsertRetentionPolicyRequest {
  return {
    category: "",
    serviceName: "",
    entityName: "",
    retentionDays: 0,
    purgeMode: 0,
    legalBasis: "",
    description: "",
  };
}

export const UpsertRetentionPolicyRequest: MessageFns<UpsertRetentionPolicyRequest> = {
  encode(message: UpsertRetentionPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.serviceName !== "") {
      writer.uint32(18).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(26).string(message.entityName);
    }
    if (message.retentionDays !== 0) {
      writer.uint32(32).int32(message.retentionDays);
    }
    if (message.purgeMode !== 0) {
      writer.uint32(40).int32(message.purgeMode);
    }
    if (message.legalBasis !== "") {
      writer.uint32(50).string(message.legalBasis);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRetentionPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRetentionPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.retentionDays = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.purgeMode = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertRetentionPolicyRequest {
    return {
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      entityName: isSet(object.entityName)
        ? globalThis.String(object.entityName)
        : isSet(object.entity_name)
        ? globalThis.String(object.entity_name)
        : "",
      retentionDays: isSet(object.retentionDays)
        ? globalThis.Number(object.retentionDays)
        : isSet(object.retention_days)
        ? globalThis.Number(object.retention_days)
        : 0,
      purgeMode: isSet(object.purgeMode)
        ? purgeModeFromJSON(object.purgeMode)
        : isSet(object.purge_mode)
        ? purgeModeFromJSON(object.purge_mode)
        : 0,
      legalBasis: isSet(object.legalBasis)
        ? globalThis.String(object.legalBasis)
        : isSet(object.legal_basis)
        ? globalThis.String(object.legal_basis)
        : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: UpsertRetentionPolicyRequest): unknown {
    const obj: any = {};
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.entityName !== "") {
      obj.entityName = message.entityName;
    }
    if (message.retentionDays !== 0) {
      obj.retentionDays = Math.round(message.retentionDays);
    }
    if (message.purgeMode !== 0) {
      obj.purgeMode = purgeModeToJSON(message.purgeMode);
    }
    if (message.legalBasis !== "") {
      obj.legalBasis = message.legalBasis;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertRetentionPolicyRequest>, I>>(base?: I): UpsertRetentionPolicyRequest {
    return UpsertRetentionPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertRetentionPolicyRequest>, I>>(object: I): UpsertRetentionPolicyRequest {
    const message = createBaseUpsertRetentionPolicyRequest();
    message.category = object.category ?? "";
    message.serviceName = object.serviceName ?? "";
    message.entityName = object.entityName ?? "";
    message.retentionDays = object.retentionDays ?? 0;
    message.purgeMode = object.purgeMode ?? 0;
    message.legalBasis = object.legalBasis ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseUpsertRetentionPolicyResponse(): UpsertRetentionPolicyResponse {
  return { policy: undefined, created: false };
}

export const UpsertRetentionPolicyResponse: MessageFns<UpsertRetentionPolicyResponse> = {
  encode(message: UpsertRetentionPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      RetentionPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    if (message.created !== false) {
      writer.uint32(16).bool(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRetentionPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRetentionPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = RetentionPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.created = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertRetentionPolicyResponse {
    return {
      policy: isSet(object.policy) ? RetentionPolicy.fromJSON(object.policy) : undefined,
      created: isSet(object.created) ? globalThis.Boolean(object.created) : false,
    };
  },

  toJSON(message: UpsertRetentionPolicyResponse): unknown {
    const obj: any = {};
    if (message.policy !== undefined) {
      obj.policy = RetentionPolicy.toJSON(message.policy);
    }
    if (message.created !== false) {
      obj.created = message.created;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertRetentionPolicyResponse>, I>>(base?: I): UpsertRetentionPolicyResponse {
    return UpsertRetentionPolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertRetentionPolicyResponse>, I>>(
    object: I,
  ): UpsertRetentionPolicyResponse {
    const message = createBaseUpsertRetentionPolicyResponse();
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? RetentionPolicy.fromPartial(object.policy)
      : undefined;
    message.created = object.created ?? false;
    return message;
  },
};

function createBaseListRetentionPoliciesRequest(): ListRetentionPoliciesRequest {
  return { serviceName: "", category: "", includeInactive: false };
}

export const ListRetentionPoliciesRequest: MessageFns<ListRetentionPoliciesRequest> = {
  encode(message: ListRetentionPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.includeInactive !== false) {
      writer.uint32(24).bool(message.includeInactive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetentionPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetentionPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetentionPoliciesRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      includeInactive: isSet(object.includeInactive)
        ? globalThis.Boolean(object.includeInactive)
        : isSet(object.include_inactive)
        ? globalThis.Boolean(object.include_inactive)
        : false,
    };
  },

  toJSON(message: ListRetentionPoliciesRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.includeInactive !== false) {
      obj.includeInactive = message.includeInactive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetentionPoliciesRequest>, I>>(base?: I): ListRetentionPoliciesRequest {
    return ListRetentionPoliciesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetentionPoliciesRequest>, I>>(object: I): ListRetentionPoliciesRequest {
    const message = createBaseListRetentionPoliciesRequest();
    message.serviceName = object.serviceName ?? "";
    message.category = object.category ?? "";
    message.includeInactive = object.includeInactive ?? false;
    return message;
  },
};

function createBaseListRetentionPoliciesResponse(): ListRetentionPoliciesResponse {
  return { policies: [] };
}

export const ListRetentionPoliciesResponse: MessageFns<ListRetentionPoliciesResponse> = {
  encode(message: ListRetentionPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policies) {
      RetentionPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetentionPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetentionPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policies.push(RetentionPolicy.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRetentionPoliciesResponse {
    return {
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => RetentionPolicy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListRetentionPoliciesResponse): unknown {
    const obj: any = {};
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => RetentionPolicy.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRetentionPoliciesResponse>, I>>(base?: I): ListRetentionPoliciesResponse {
    return ListRetentionPoliciesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRetentionPoliciesResponse>, I>>(
    object: I,
  ): ListRetentionPoliciesResponse {
    const message = createBaseListRetentionPoliciesResponse();
    message.policies = object.policies?.map((e) => RetentionPolicy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetRetentionPolicyRequest(): GetRetentionPolicyRequest {
  return { id: "" };
}

export const GetRetentionPolicyRequest: MessageFns<GetRetentionPolicyRequest> = {
  encode(message: GetRetentionPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetentionPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetentionPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRetentionPolicyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetRetentionPolicyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRetentionPolicyRequest>, I>>(base?: I): GetRetentionPolicyRequest {
    return GetRetentionPolicyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRetentionPolicyRequest>, I>>(object: I): GetRetentionPolicyRequest {
    const message = createBaseGetRetentionPolicyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetRetentionPolicyResponse(): GetRetentionPolicyResponse {
  return { policy: undefined };
}

export const GetRetentionPolicyResponse: MessageFns<GetRetentionPolicyResponse> = {
  encode(message: GetRetentionPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      RetentionPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetentionPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetentionPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = RetentionPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRetentionPolicyResponse {
    return { policy: isSet(object.policy) ? RetentionPolicy.fromJSON(object.policy) : undefined };
  },

  toJSON(message: GetRetentionPolicyResponse): unknown {
    const obj: any = {};
    if (message.policy !== undefined) {
      obj.policy = RetentionPolicy.toJSON(message.policy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRetentionPolicyResponse>, I>>(base?: I): GetRetentionPolicyResponse {
    return GetRetentionPolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRetentionPolicyResponse>, I>>(object: I): GetRetentionPolicyResponse {
    const message = createBaseGetRetentionPolicyResponse();
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? RetentionPolicy.fromPartial(object.policy)
      : undefined;
    return message;
  },
};

function createBasePurgeJob(): PurgeJob {
  return {
    id: "",
    retentionPolicyId: "",
    serviceName: "",
    entityName: "",
    cutoffDate: undefined,
    status: 0,
    recordsScanned: 0,
    recordsDeleted: 0,
    recordsAnonymized: 0,
    recordsArchived: 0,
    recordsRetained: 0,
    retentionReason: "",
    startedAt: undefined,
    completedAt: undefined,
    errorMessage: "",
    dryRun: false,
  };
}

export const PurgeJob: MessageFns<PurgeJob> = {
  encode(message: PurgeJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.retentionPolicyId !== "") {
      writer.uint32(18).string(message.retentionPolicyId);
    }
    if (message.serviceName !== "") {
      writer.uint32(26).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(34).string(message.entityName);
    }
    if (message.cutoffDate !== undefined) {
      Timestamp.encode(toTimestamp(message.cutoffDate), writer.uint32(42).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.recordsScanned !== 0) {
      writer.uint32(56).int64(message.recordsScanned);
    }
    if (message.recordsDeleted !== 0) {
      writer.uint32(64).int64(message.recordsDeleted);
    }
    if (message.recordsAnonymized !== 0) {
      writer.uint32(72).int64(message.recordsAnonymized);
    }
    if (message.recordsArchived !== 0) {
      writer.uint32(80).int64(message.recordsArchived);
    }
    if (message.recordsRetained !== 0) {
      writer.uint32(88).int64(message.recordsRetained);
    }
    if (message.retentionReason !== "") {
      writer.uint32(98).string(message.retentionReason);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(106).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(114).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(122).string(message.errorMessage);
    }
    if (message.dryRun !== false) {
      writer.uint32(128).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retentionPolicyId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cutoffDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recordsScanned = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.recordsDeleted = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.recordsAnonymized = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.recordsArchived = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.recordsRetained = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.retentionReason = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeJob {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      retentionPolicyId: isSet(object.retentionPolicyId)
        ? globalThis.String(object.retentionPolicyId)
        : isSet(object.retention_policy_id)
        ? globalThis.String(object.retention_policy_id)
        : "",
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      entityName: isSet(object.entityName)
        ? globalThis.String(object.entityName)
        : isSet(object.entity_name)
        ? globalThis.String(object.entity_name)
        : "",
      cutoffDate: isSet(object.cutoffDate)
        ? fromJsonTimestamp(object.cutoffDate)
        : isSet(object.cutoff_date)
        ? fromJsonTimestamp(object.cutoff_date)
        : undefined,
      status: isSet(object.status) ? purgeExecutionStatusFromJSON(object.status) : 0,
      recordsScanned: isSet(object.recordsScanned)
        ? globalThis.Number(object.recordsScanned)
        : isSet(object.records_scanned)
        ? globalThis.Number(object.records_scanned)
        : 0,
      recordsDeleted: isSet(object.recordsDeleted)
        ? globalThis.Number(object.recordsDeleted)
        : isSet(object.records_deleted)
        ? globalThis.Number(object.records_deleted)
        : 0,
      recordsAnonymized: isSet(object.recordsAnonymized)
        ? globalThis.Number(object.recordsAnonymized)
        : isSet(object.records_anonymized)
        ? globalThis.Number(object.records_anonymized)
        : 0,
      recordsArchived: isSet(object.recordsArchived)
        ? globalThis.Number(object.recordsArchived)
        : isSet(object.records_archived)
        ? globalThis.Number(object.records_archived)
        : 0,
      recordsRetained: isSet(object.recordsRetained)
        ? globalThis.Number(object.recordsRetained)
        : isSet(object.records_retained)
        ? globalThis.Number(object.records_retained)
        : 0,
      retentionReason: isSet(object.retentionReason)
        ? globalThis.String(object.retentionReason)
        : isSet(object.retention_reason)
        ? globalThis.String(object.retention_reason)
        : "",
      startedAt: isSet(object.startedAt)
        ? fromJsonTimestamp(object.startedAt)
        : isSet(object.started_at)
        ? fromJsonTimestamp(object.started_at)
        : undefined,
      completedAt: isSet(object.completedAt)
        ? fromJsonTimestamp(object.completedAt)
        : isSet(object.completed_at)
        ? fromJsonTimestamp(object.completed_at)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
    };
  },

  toJSON(message: PurgeJob): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.retentionPolicyId !== "") {
      obj.retentionPolicyId = message.retentionPolicyId;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.entityName !== "") {
      obj.entityName = message.entityName;
    }
    if (message.cutoffDate !== undefined) {
      obj.cutoffDate = message.cutoffDate.toISOString();
    }
    if (message.status !== 0) {
      obj.status = purgeExecutionStatusToJSON(message.status);
    }
    if (message.recordsScanned !== 0) {
      obj.recordsScanned = Math.round(message.recordsScanned);
    }
    if (message.recordsDeleted !== 0) {
      obj.recordsDeleted = Math.round(message.recordsDeleted);
    }
    if (message.recordsAnonymized !== 0) {
      obj.recordsAnonymized = Math.round(message.recordsAnonymized);
    }
    if (message.recordsArchived !== 0) {
      obj.recordsArchived = Math.round(message.recordsArchived);
    }
    if (message.recordsRetained !== 0) {
      obj.recordsRetained = Math.round(message.recordsRetained);
    }
    if (message.retentionReason !== "") {
      obj.retentionReason = message.retentionReason;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurgeJob>, I>>(base?: I): PurgeJob {
    return PurgeJob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurgeJob>, I>>(object: I): PurgeJob {
    const message = createBasePurgeJob();
    message.id = object.id ?? "";
    message.retentionPolicyId = object.retentionPolicyId ?? "";
    message.serviceName = object.serviceName ?? "";
    message.entityName = object.entityName ?? "";
    message.cutoffDate = object.cutoffDate ?? undefined;
    message.status = object.status ?? 0;
    message.recordsScanned = object.recordsScanned ?? 0;
    message.recordsDeleted = object.recordsDeleted ?? 0;
    message.recordsAnonymized = object.recordsAnonymized ?? 0;
    message.recordsArchived = object.recordsArchived ?? 0;
    message.recordsRetained = object.recordsRetained ?? 0;
    message.retentionReason = object.retentionReason ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.errorMessage = object.errorMessage ?? "";
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseRunScheduledPurgeRequest(): RunScheduledPurgeRequest {
  return { serviceName: "", category: "", dryRun: false };
}

export const RunScheduledPurgeRequest: MessageFns<RunScheduledPurgeRequest> = {
  encode(message: RunScheduledPurgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.dryRun !== false) {
      writer.uint32(24).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunScheduledPurgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunScheduledPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunScheduledPurgeRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
    };
  },

  toJSON(message: RunScheduledPurgeRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunScheduledPurgeRequest>, I>>(base?: I): RunScheduledPurgeRequest {
    return RunScheduledPurgeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunScheduledPurgeRequest>, I>>(object: I): RunScheduledPurgeRequest {
    const message = createBaseRunScheduledPurgeRequest();
    message.serviceName = object.serviceName ?? "";
    message.category = object.category ?? "";
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseRunScheduledPurgeResponse(): RunScheduledPurgeResponse {
  return { jobs: [], totalJobs: 0, successfulJobs: 0, failedJobs: 0, totalRecordsPurged: 0 };
}

export const RunScheduledPurgeResponse: MessageFns<RunScheduledPurgeResponse> = {
  encode(message: RunScheduledPurgeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      PurgeJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalJobs !== 0) {
      writer.uint32(16).int32(message.totalJobs);
    }
    if (message.successfulJobs !== 0) {
      writer.uint32(24).int32(message.successfulJobs);
    }
    if (message.failedJobs !== 0) {
      writer.uint32(32).int32(message.failedJobs);
    }
    if (message.totalRecordsPurged !== 0) {
      writer.uint32(40).int64(message.totalRecordsPurged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunScheduledPurgeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunScheduledPurgeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(PurgeJob.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalJobs = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.successfulJobs = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.failedJobs = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalRecordsPurged = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunScheduledPurgeResponse {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => PurgeJob.fromJSON(e)) : [],
      totalJobs: isSet(object.totalJobs)
        ? globalThis.Number(object.totalJobs)
        : isSet(object.total_jobs)
        ? globalThis.Number(object.total_jobs)
        : 0,
      successfulJobs: isSet(object.successfulJobs)
        ? globalThis.Number(object.successfulJobs)
        : isSet(object.successful_jobs)
        ? globalThis.Number(object.successful_jobs)
        : 0,
      failedJobs: isSet(object.failedJobs)
        ? globalThis.Number(object.failedJobs)
        : isSet(object.failed_jobs)
        ? globalThis.Number(object.failed_jobs)
        : 0,
      totalRecordsPurged: isSet(object.totalRecordsPurged)
        ? globalThis.Number(object.totalRecordsPurged)
        : isSet(object.total_records_purged)
        ? globalThis.Number(object.total_records_purged)
        : 0,
    };
  },

  toJSON(message: RunScheduledPurgeResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => PurgeJob.toJSON(e));
    }
    if (message.totalJobs !== 0) {
      obj.totalJobs = Math.round(message.totalJobs);
    }
    if (message.successfulJobs !== 0) {
      obj.successfulJobs = Math.round(message.successfulJobs);
    }
    if (message.failedJobs !== 0) {
      obj.failedJobs = Math.round(message.failedJobs);
    }
    if (message.totalRecordsPurged !== 0) {
      obj.totalRecordsPurged = Math.round(message.totalRecordsPurged);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunScheduledPurgeResponse>, I>>(base?: I): RunScheduledPurgeResponse {
    return RunScheduledPurgeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunScheduledPurgeResponse>, I>>(object: I): RunScheduledPurgeResponse {
    const message = createBaseRunScheduledPurgeResponse();
    message.jobs = object.jobs?.map((e) => PurgeJob.fromPartial(e)) || [];
    message.totalJobs = object.totalJobs ?? 0;
    message.successfulJobs = object.successfulJobs ?? 0;
    message.failedJobs = object.failedJobs ?? 0;
    message.totalRecordsPurged = object.totalRecordsPurged ?? 0;
    return message;
  },
};

function createBaseListPurgeJobsRequest(): ListPurgeJobsRequest {
  return { serviceName: "", from: undefined, to: undefined, statuses: [], page: 0, limit: 0 };
}

export const ListPurgeJobsRequest: MessageFns<ListPurgeJobsRequest> = {
  encode(message: ListPurgeJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.page !== 0) {
      writer.uint32(40).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(48).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurgeJobsRequest {
    return {
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => purgeExecutionStatusFromJSON(e))
        : [],
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListPurgeJobsRequest): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => purgeExecutionStatusToJSON(e));
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPurgeJobsRequest>, I>>(base?: I): ListPurgeJobsRequest {
    return ListPurgeJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPurgeJobsRequest>, I>>(object: I): ListPurgeJobsRequest {
    const message = createBaseListPurgeJobsRequest();
    message.serviceName = object.serviceName ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.statuses = object.statuses?.map((e) => e) || [];
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseListPurgeJobsResponse(): ListPurgeJobsResponse {
  return { jobs: [], total: 0, page: 0, limit: 0 };
}

export const ListPurgeJobsResponse: MessageFns<ListPurgeJobsResponse> = {
  encode(message: ListPurgeJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      PurgeJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(PurgeJob.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurgeJobsResponse {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => PurgeJob.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListPurgeJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => PurgeJob.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPurgeJobsResponse>, I>>(base?: I): ListPurgeJobsResponse {
    return ListPurgeJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPurgeJobsResponse>, I>>(object: I): ListPurgeJobsResponse {
    const message = createBaseListPurgeJobsResponse();
    message.jobs = object.jobs?.map((e) => PurgeJob.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBasePurgeRequest(): PurgeRequest {
  return {
    id: "",
    organisationId: "",
    requestedByUserId: "",
    subjectType: 0,
    subjectId: "",
    subjectEmail: "",
    reason: "",
    legalBasis: "",
    legalHold: false,
    legalHoldReason: "",
    legalHoldUntil: undefined,
    status: 0,
    createdAt: undefined,
    startedAt: undefined,
    completedAt: undefined,
    externalReference: "",
  };
}

export const PurgeRequest: MessageFns<PurgeRequest> = {
  encode(message: PurgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.requestedByUserId !== "") {
      writer.uint32(26).string(message.requestedByUserId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(32).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(42).string(message.subjectId);
    }
    if (message.subjectEmail !== "") {
      writer.uint32(50).string(message.subjectEmail);
    }
    if (message.reason !== "") {
      writer.uint32(58).string(message.reason);
    }
    if (message.legalBasis !== "") {
      writer.uint32(66).string(message.legalBasis);
    }
    if (message.legalHold !== false) {
      writer.uint32(72).bool(message.legalHold);
    }
    if (message.legalHoldReason !== "") {
      writer.uint32(82).string(message.legalHoldReason);
    }
    if (message.legalHoldUntil !== undefined) {
      Timestamp.encode(toTimestamp(message.legalHoldUntil), writer.uint32(90).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(106).fork()).join();
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(114).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(122).fork()).join();
    }
    if (message.externalReference !== "") {
      writer.uint32(130).string(message.externalReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestedByUserId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subjectEmail = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.legalHold = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.legalHoldReason = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.legalHoldUntil = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.externalReference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      requestedByUserId: isSet(object.requestedByUserId)
        ? globalThis.String(object.requestedByUserId)
        : isSet(object.requested_by_user_id)
        ? globalThis.String(object.requested_by_user_id)
        : "",
      subjectType: isSet(object.subjectType)
        ? subjectTypeFromJSON(object.subjectType)
        : isSet(object.subject_type)
        ? subjectTypeFromJSON(object.subject_type)
        : 0,
      subjectId: isSet(object.subjectId)
        ? globalThis.String(object.subjectId)
        : isSet(object.subject_id)
        ? globalThis.String(object.subject_id)
        : "",
      subjectEmail: isSet(object.subjectEmail)
        ? globalThis.String(object.subjectEmail)
        : isSet(object.subject_email)
        ? globalThis.String(object.subject_email)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      legalBasis: isSet(object.legalBasis)
        ? globalThis.String(object.legalBasis)
        : isSet(object.legal_basis)
        ? globalThis.String(object.legal_basis)
        : "",
      legalHold: isSet(object.legalHold)
        ? globalThis.Boolean(object.legalHold)
        : isSet(object.legal_hold)
        ? globalThis.Boolean(object.legal_hold)
        : false,
      legalHoldReason: isSet(object.legalHoldReason)
        ? globalThis.String(object.legalHoldReason)
        : isSet(object.legal_hold_reason)
        ? globalThis.String(object.legal_hold_reason)
        : "",
      legalHoldUntil: isSet(object.legalHoldUntil)
        ? fromJsonTimestamp(object.legalHoldUntil)
        : isSet(object.legal_hold_until)
        ? fromJsonTimestamp(object.legal_hold_until)
        : undefined,
      status: isSet(object.status) ? purgeRequestStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      startedAt: isSet(object.startedAt)
        ? fromJsonTimestamp(object.startedAt)
        : isSet(object.started_at)
        ? fromJsonTimestamp(object.started_at)
        : undefined,
      completedAt: isSet(object.completedAt)
        ? fromJsonTimestamp(object.completedAt)
        : isSet(object.completed_at)
        ? fromJsonTimestamp(object.completed_at)
        : undefined,
      externalReference: isSet(object.externalReference)
        ? globalThis.String(object.externalReference)
        : isSet(object.external_reference)
        ? globalThis.String(object.external_reference)
        : "",
    };
  },

  toJSON(message: PurgeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.requestedByUserId !== "") {
      obj.requestedByUserId = message.requestedByUserId;
    }
    if (message.subjectType !== 0) {
      obj.subjectType = subjectTypeToJSON(message.subjectType);
    }
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.subjectEmail !== "") {
      obj.subjectEmail = message.subjectEmail;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.legalBasis !== "") {
      obj.legalBasis = message.legalBasis;
    }
    if (message.legalHold !== false) {
      obj.legalHold = message.legalHold;
    }
    if (message.legalHoldReason !== "") {
      obj.legalHoldReason = message.legalHoldReason;
    }
    if (message.legalHoldUntil !== undefined) {
      obj.legalHoldUntil = message.legalHoldUntil.toISOString();
    }
    if (message.status !== 0) {
      obj.status = purgeRequestStatusToJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completedAt = message.completedAt.toISOString();
    }
    if (message.externalReference !== "") {
      obj.externalReference = message.externalReference;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurgeRequest>, I>>(base?: I): PurgeRequest {
    return PurgeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurgeRequest>, I>>(object: I): PurgeRequest {
    const message = createBasePurgeRequest();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.requestedByUserId = object.requestedByUserId ?? "";
    message.subjectType = object.subjectType ?? 0;
    message.subjectId = object.subjectId ?? "";
    message.subjectEmail = object.subjectEmail ?? "";
    message.reason = object.reason ?? "";
    message.legalBasis = object.legalBasis ?? "";
    message.legalHold = object.legalHold ?? false;
    message.legalHoldReason = object.legalHoldReason ?? "";
    message.legalHoldUntil = object.legalHoldUntil ?? undefined;
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.externalReference = object.externalReference ?? "";
    return message;
  },
};

function createBasePurgeExecution(): PurgeExecution {
  return {
    id: "",
    purgeRequestId: "",
    serviceName: "",
    entityName: "",
    status: 0,
    deletedCount: 0,
    anonymizedCount: 0,
    retainedCount: 0,
    retainedReason: "",
    verificationQuery: "",
    verificationPassed: false,
    executedAt: undefined,
    errorMessage: "",
  };
}

export const PurgeExecution: MessageFns<PurgeExecution> = {
  encode(message: PurgeExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.purgeRequestId !== "") {
      writer.uint32(18).string(message.purgeRequestId);
    }
    if (message.serviceName !== "") {
      writer.uint32(26).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(34).string(message.entityName);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.deletedCount !== 0) {
      writer.uint32(48).int64(message.deletedCount);
    }
    if (message.anonymizedCount !== 0) {
      writer.uint32(56).int64(message.anonymizedCount);
    }
    if (message.retainedCount !== 0) {
      writer.uint32(64).int64(message.retainedCount);
    }
    if (message.retainedReason !== "") {
      writer.uint32(74).string(message.retainedReason);
    }
    if (message.verificationQuery !== "") {
      writer.uint32(82).string(message.verificationQuery);
    }
    if (message.verificationPassed !== false) {
      writer.uint32(88).bool(message.verificationPassed);
    }
    if (message.executedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.executedAt), writer.uint32(98).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(106).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.deletedCount = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.anonymizedCount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.retainedCount = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.retainedReason = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.verificationQuery = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.verificationPassed = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.executedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeExecution {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      purgeRequestId: isSet(object.purgeRequestId)
        ? globalThis.String(object.purgeRequestId)
        : isSet(object.purge_request_id)
        ? globalThis.String(object.purge_request_id)
        : "",
      serviceName: isSet(object.serviceName)
        ? globalThis.String(object.serviceName)
        : isSet(object.service_name)
        ? globalThis.String(object.service_name)
        : "",
      entityName: isSet(object.entityName)
        ? globalThis.String(object.entityName)
        : isSet(object.entity_name)
        ? globalThis.String(object.entity_name)
        : "",
      status: isSet(object.status) ? purgeExecutionStatusFromJSON(object.status) : 0,
      deletedCount: isSet(object.deletedCount)
        ? globalThis.Number(object.deletedCount)
        : isSet(object.deleted_count)
        ? globalThis.Number(object.deleted_count)
        : 0,
      anonymizedCount: isSet(object.anonymizedCount)
        ? globalThis.Number(object.anonymizedCount)
        : isSet(object.anonymized_count)
        ? globalThis.Number(object.anonymized_count)
        : 0,
      retainedCount: isSet(object.retainedCount)
        ? globalThis.Number(object.retainedCount)
        : isSet(object.retained_count)
        ? globalThis.Number(object.retained_count)
        : 0,
      retainedReason: isSet(object.retainedReason)
        ? globalThis.String(object.retainedReason)
        : isSet(object.retained_reason)
        ? globalThis.String(object.retained_reason)
        : "",
      verificationQuery: isSet(object.verificationQuery)
        ? globalThis.String(object.verificationQuery)
        : isSet(object.verification_query)
        ? globalThis.String(object.verification_query)
        : "",
      verificationPassed: isSet(object.verificationPassed)
        ? globalThis.Boolean(object.verificationPassed)
        : isSet(object.verification_passed)
        ? globalThis.Boolean(object.verification_passed)
        : false,
      executedAt: isSet(object.executedAt)
        ? fromJsonTimestamp(object.executedAt)
        : isSet(object.executed_at)
        ? fromJsonTimestamp(object.executed_at)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : "",
    };
  },

  toJSON(message: PurgeExecution): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.purgeRequestId !== "") {
      obj.purgeRequestId = message.purgeRequestId;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.entityName !== "") {
      obj.entityName = message.entityName;
    }
    if (message.status !== 0) {
      obj.status = purgeExecutionStatusToJSON(message.status);
    }
    if (message.deletedCount !== 0) {
      obj.deletedCount = Math.round(message.deletedCount);
    }
    if (message.anonymizedCount !== 0) {
      obj.anonymizedCount = Math.round(message.anonymizedCount);
    }
    if (message.retainedCount !== 0) {
      obj.retainedCount = Math.round(message.retainedCount);
    }
    if (message.retainedReason !== "") {
      obj.retainedReason = message.retainedReason;
    }
    if (message.verificationQuery !== "") {
      obj.verificationQuery = message.verificationQuery;
    }
    if (message.verificationPassed !== false) {
      obj.verificationPassed = message.verificationPassed;
    }
    if (message.executedAt !== undefined) {
      obj.executedAt = message.executedAt.toISOString();
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurgeExecution>, I>>(base?: I): PurgeExecution {
    return PurgeExecution.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurgeExecution>, I>>(object: I): PurgeExecution {
    const message = createBasePurgeExecution();
    message.id = object.id ?? "";
    message.purgeRequestId = object.purgeRequestId ?? "";
    message.serviceName = object.serviceName ?? "";
    message.entityName = object.entityName ?? "";
    message.status = object.status ?? 0;
    message.deletedCount = object.deletedCount ?? 0;
    message.anonymizedCount = object.anonymizedCount ?? 0;
    message.retainedCount = object.retainedCount ?? 0;
    message.retainedReason = object.retainedReason ?? "";
    message.verificationQuery = object.verificationQuery ?? "";
    message.verificationPassed = object.verificationPassed ?? false;
    message.executedAt = object.executedAt ?? undefined;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseCreatePurgeRequestRequest(): CreatePurgeRequestRequest {
  return {
    organisationId: "",
    subjectType: 0,
    subjectId: "",
    subjectEmail: "",
    reason: "",
    legalBasis: "",
    externalReference: "",
  };
}

export const CreatePurgeRequestRequest: MessageFns<CreatePurgeRequestRequest> = {
  encode(message: CreatePurgeRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(16).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(26).string(message.subjectId);
    }
    if (message.subjectEmail !== "") {
      writer.uint32(34).string(message.subjectEmail);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    if (message.legalBasis !== "") {
      writer.uint32(50).string(message.legalBasis);
    }
    if (message.externalReference !== "") {
      writer.uint32(58).string(message.externalReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePurgeRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePurgeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subjectEmail = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.externalReference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePurgeRequestRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      subjectType: isSet(object.subjectType)
        ? subjectTypeFromJSON(object.subjectType)
        : isSet(object.subject_type)
        ? subjectTypeFromJSON(object.subject_type)
        : 0,
      subjectId: isSet(object.subjectId)
        ? globalThis.String(object.subjectId)
        : isSet(object.subject_id)
        ? globalThis.String(object.subject_id)
        : "",
      subjectEmail: isSet(object.subjectEmail)
        ? globalThis.String(object.subjectEmail)
        : isSet(object.subject_email)
        ? globalThis.String(object.subject_email)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      legalBasis: isSet(object.legalBasis)
        ? globalThis.String(object.legalBasis)
        : isSet(object.legal_basis)
        ? globalThis.String(object.legal_basis)
        : "",
      externalReference: isSet(object.externalReference)
        ? globalThis.String(object.externalReference)
        : isSet(object.external_reference)
        ? globalThis.String(object.external_reference)
        : "",
    };
  },

  toJSON(message: CreatePurgeRequestRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.subjectType !== 0) {
      obj.subjectType = subjectTypeToJSON(message.subjectType);
    }
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.subjectEmail !== "") {
      obj.subjectEmail = message.subjectEmail;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.legalBasis !== "") {
      obj.legalBasis = message.legalBasis;
    }
    if (message.externalReference !== "") {
      obj.externalReference = message.externalReference;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePurgeRequestRequest>, I>>(base?: I): CreatePurgeRequestRequest {
    return CreatePurgeRequestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePurgeRequestRequest>, I>>(object: I): CreatePurgeRequestRequest {
    const message = createBaseCreatePurgeRequestRequest();
    message.organisationId = object.organisationId ?? "";
    message.subjectType = object.subjectType ?? 0;
    message.subjectId = object.subjectId ?? "";
    message.subjectEmail = object.subjectEmail ?? "";
    message.reason = object.reason ?? "";
    message.legalBasis = object.legalBasis ?? "";
    message.externalReference = object.externalReference ?? "";
    return message;
  },
};

function createBaseCreatePurgeRequestResponse(): CreatePurgeRequestResponse {
  return { request: undefined };
}

export const CreatePurgeRequestResponse: MessageFns<CreatePurgeRequestResponse> = {
  encode(message: CreatePurgeRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePurgeRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePurgeRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePurgeRequestResponse {
    return { request: isSet(object.request) ? PurgeRequest.fromJSON(object.request) : undefined };
  },

  toJSON(message: CreatePurgeRequestResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = PurgeRequest.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePurgeRequestResponse>, I>>(base?: I): CreatePurgeRequestResponse {
    return CreatePurgeRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePurgeRequestResponse>, I>>(object: I): CreatePurgeRequestResponse {
    const message = createBaseCreatePurgeRequestResponse();
    message.request = (object.request !== undefined && object.request !== null)
      ? PurgeRequest.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseExecutePurgeRequest(): ExecutePurgeRequest {
  return { purgeRequestId: "", dryRun: false };
}

export const ExecutePurgeRequest: MessageFns<ExecutePurgeRequest> = {
  encode(message: ExecutePurgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    if (message.dryRun !== false) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutePurgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutePurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutePurgeRequest {
    return {
      purgeRequestId: isSet(object.purgeRequestId)
        ? globalThis.String(object.purgeRequestId)
        : isSet(object.purge_request_id)
        ? globalThis.String(object.purge_request_id)
        : "",
      dryRun: isSet(object.dryRun)
        ? globalThis.Boolean(object.dryRun)
        : isSet(object.dry_run)
        ? globalThis.Boolean(object.dry_run)
        : false,
    };
  },

  toJSON(message: ExecutePurgeRequest): unknown {
    const obj: any = {};
    if (message.purgeRequestId !== "") {
      obj.purgeRequestId = message.purgeRequestId;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutePurgeRequest>, I>>(base?: I): ExecutePurgeRequest {
    return ExecutePurgeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutePurgeRequest>, I>>(object: I): ExecutePurgeRequest {
    const message = createBaseExecutePurgeRequest();
    message.purgeRequestId = object.purgeRequestId ?? "";
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseExecutePurgeResponse(): ExecutePurgeResponse {
  return { request: undefined, executions: [] };
}

export const ExecutePurgeResponse: MessageFns<ExecutePurgeResponse> = {
  encode(message: ExecutePurgeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    for (const v of message.executions) {
      PurgeExecution.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutePurgeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutePurgeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executions.push(PurgeExecution.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutePurgeResponse {
    return {
      request: isSet(object.request) ? PurgeRequest.fromJSON(object.request) : undefined,
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => PurgeExecution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExecutePurgeResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = PurgeRequest.toJSON(message.request);
    }
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => PurgeExecution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutePurgeResponse>, I>>(base?: I): ExecutePurgeResponse {
    return ExecutePurgeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutePurgeResponse>, I>>(object: I): ExecutePurgeResponse {
    const message = createBaseExecutePurgeResponse();
    message.request = (object.request !== undefined && object.request !== null)
      ? PurgeRequest.fromPartial(object.request)
      : undefined;
    message.executions = object.executions?.map((e) => PurgeExecution.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPurgeRequestRequest(): GetPurgeRequestRequest {
  return { purgeRequestId: "" };
}

export const GetPurgeRequestRequest: MessageFns<GetPurgeRequestRequest> = {
  encode(message: GetPurgeRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPurgeRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPurgeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPurgeRequestRequest {
    return {
      purgeRequestId: isSet(object.purgeRequestId)
        ? globalThis.String(object.purgeRequestId)
        : isSet(object.purge_request_id)
        ? globalThis.String(object.purge_request_id)
        : "",
    };
  },

  toJSON(message: GetPurgeRequestRequest): unknown {
    const obj: any = {};
    if (message.purgeRequestId !== "") {
      obj.purgeRequestId = message.purgeRequestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPurgeRequestRequest>, I>>(base?: I): GetPurgeRequestRequest {
    return GetPurgeRequestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPurgeRequestRequest>, I>>(object: I): GetPurgeRequestRequest {
    const message = createBaseGetPurgeRequestRequest();
    message.purgeRequestId = object.purgeRequestId ?? "";
    return message;
  },
};

function createBaseGetPurgeRequestResponse(): GetPurgeRequestResponse {
  return { request: undefined, executions: [] };
}

export const GetPurgeRequestResponse: MessageFns<GetPurgeRequestResponse> = {
  encode(message: GetPurgeRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    for (const v of message.executions) {
      PurgeExecution.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPurgeRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPurgeRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executions.push(PurgeExecution.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPurgeRequestResponse {
    return {
      request: isSet(object.request) ? PurgeRequest.fromJSON(object.request) : undefined,
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => PurgeExecution.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPurgeRequestResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = PurgeRequest.toJSON(message.request);
    }
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => PurgeExecution.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPurgeRequestResponse>, I>>(base?: I): GetPurgeRequestResponse {
    return GetPurgeRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPurgeRequestResponse>, I>>(object: I): GetPurgeRequestResponse {
    const message = createBaseGetPurgeRequestResponse();
    message.request = (object.request !== undefined && object.request !== null)
      ? PurgeRequest.fromPartial(object.request)
      : undefined;
    message.executions = object.executions?.map((e) => PurgeExecution.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListPurgeRequestsRequest(): ListPurgeRequestsRequest {
  return { organisationId: "", statuses: [], subjectType: 0, from: undefined, to: undefined, page: 0, limit: 0 };
}

export const ListPurgeRequestsRequest: MessageFns<ListPurgeRequestsRequest> = {
  encode(message: ListPurgeRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    writer.uint32(18).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.subjectType !== 0) {
      writer.uint32(24).int32(message.subjectType);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(34).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(42).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(48).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(56).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurgeRequestsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => purgeRequestStatusFromJSON(e))
        : [],
      subjectType: isSet(object.subjectType)
        ? subjectTypeFromJSON(object.subjectType)
        : isSet(object.subject_type)
        ? subjectTypeFromJSON(object.subject_type)
        : 0,
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListPurgeRequestsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => purgeRequestStatusToJSON(e));
    }
    if (message.subjectType !== 0) {
      obj.subjectType = subjectTypeToJSON(message.subjectType);
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPurgeRequestsRequest>, I>>(base?: I): ListPurgeRequestsRequest {
    return ListPurgeRequestsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPurgeRequestsRequest>, I>>(object: I): ListPurgeRequestsRequest {
    const message = createBaseListPurgeRequestsRequest();
    message.organisationId = object.organisationId ?? "";
    message.statuses = object.statuses?.map((e) => e) || [];
    message.subjectType = object.subjectType ?? 0;
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseListPurgeRequestsResponse(): ListPurgeRequestsResponse {
  return { requests: [], total: 0, page: 0, limit: 0 };
}

export const ListPurgeRequestsResponse: MessageFns<ListPurgeRequestsResponse> = {
  encode(message: ListPurgeRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      PurgeRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(PurgeRequest.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPurgeRequestsResponse {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => PurgeRequest.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListPurgeRequestsResponse): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => PurgeRequest.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPurgeRequestsResponse>, I>>(base?: I): ListPurgeRequestsResponse {
    return ListPurgeRequestsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPurgeRequestsResponse>, I>>(object: I): ListPurgeRequestsResponse {
    const message = createBaseListPurgeRequestsResponse();
    message.requests = object.requests?.map((e) => PurgeRequest.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseCancelPurgeRequestRequest(): CancelPurgeRequestRequest {
  return { purgeRequestId: "", reason: "" };
}

export const CancelPurgeRequestRequest: MessageFns<CancelPurgeRequestRequest> = {
  encode(message: CancelPurgeRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPurgeRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPurgeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPurgeRequestRequest {
    return {
      purgeRequestId: isSet(object.purgeRequestId)
        ? globalThis.String(object.purgeRequestId)
        : isSet(object.purge_request_id)
        ? globalThis.String(object.purge_request_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CancelPurgeRequestRequest): unknown {
    const obj: any = {};
    if (message.purgeRequestId !== "") {
      obj.purgeRequestId = message.purgeRequestId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPurgeRequestRequest>, I>>(base?: I): CancelPurgeRequestRequest {
    return CancelPurgeRequestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPurgeRequestRequest>, I>>(object: I): CancelPurgeRequestRequest {
    const message = createBaseCancelPurgeRequestRequest();
    message.purgeRequestId = object.purgeRequestId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseCancelPurgeRequestResponse(): CancelPurgeRequestResponse {
  return { request: undefined };
}

export const CancelPurgeRequestResponse: MessageFns<CancelPurgeRequestResponse> = {
  encode(message: CancelPurgeRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPurgeRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPurgeRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPurgeRequestResponse {
    return { request: isSet(object.request) ? PurgeRequest.fromJSON(object.request) : undefined };
  },

  toJSON(message: CancelPurgeRequestResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = PurgeRequest.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelPurgeRequestResponse>, I>>(base?: I): CancelPurgeRequestResponse {
    return CancelPurgeRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelPurgeRequestResponse>, I>>(object: I): CancelPurgeRequestResponse {
    const message = createBaseCancelPurgeRequestResponse();
    message.request = (object.request !== undefined && object.request !== null)
      ? PurgeRequest.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseLegalHold(): LegalHold {
  return {
    id: "",
    organisationId: "",
    subjectType: 0,
    subjectId: "",
    reason: "",
    caseReference: "",
    placedByUserId: "",
    placedAt: undefined,
    expiresAt: undefined,
    isActive: false,
    liftedByUserId: "",
    liftedAt: undefined,
    liftReason: "",
  };
}

export const LegalHold: MessageFns<LegalHold> = {
  encode(message: LegalHold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(24).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(34).string(message.subjectId);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    if (message.caseReference !== "") {
      writer.uint32(50).string(message.caseReference);
    }
    if (message.placedByUserId !== "") {
      writer.uint32(58).string(message.placedByUserId);
    }
    if (message.placedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.placedAt), writer.uint32(66).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(74).fork()).join();
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.liftedByUserId !== "") {
      writer.uint32(90).string(message.liftedByUserId);
    }
    if (message.liftedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.liftedAt), writer.uint32(98).fork()).join();
    }
    if (message.liftReason !== "") {
      writer.uint32(106).string(message.liftReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LegalHold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLegalHold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.caseReference = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.placedByUserId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.placedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.liftedByUserId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.liftedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.liftReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LegalHold {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      subjectType: isSet(object.subjectType)
        ? subjectTypeFromJSON(object.subjectType)
        : isSet(object.subject_type)
        ? subjectTypeFromJSON(object.subject_type)
        : 0,
      subjectId: isSet(object.subjectId)
        ? globalThis.String(object.subjectId)
        : isSet(object.subject_id)
        ? globalThis.String(object.subject_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      caseReference: isSet(object.caseReference)
        ? globalThis.String(object.caseReference)
        : isSet(object.case_reference)
        ? globalThis.String(object.case_reference)
        : "",
      placedByUserId: isSet(object.placedByUserId)
        ? globalThis.String(object.placedByUserId)
        : isSet(object.placed_by_user_id)
        ? globalThis.String(object.placed_by_user_id)
        : "",
      placedAt: isSet(object.placedAt)
        ? fromJsonTimestamp(object.placedAt)
        : isSet(object.placed_at)
        ? fromJsonTimestamp(object.placed_at)
        : undefined,
      expiresAt: isSet(object.expiresAt)
        ? fromJsonTimestamp(object.expiresAt)
        : isSet(object.expires_at)
        ? fromJsonTimestamp(object.expires_at)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      liftedByUserId: isSet(object.liftedByUserId)
        ? globalThis.String(object.liftedByUserId)
        : isSet(object.lifted_by_user_id)
        ? globalThis.String(object.lifted_by_user_id)
        : "",
      liftedAt: isSet(object.liftedAt)
        ? fromJsonTimestamp(object.liftedAt)
        : isSet(object.lifted_at)
        ? fromJsonTimestamp(object.lifted_at)
        : undefined,
      liftReason: isSet(object.liftReason)
        ? globalThis.String(object.liftReason)
        : isSet(object.lift_reason)
        ? globalThis.String(object.lift_reason)
        : "",
    };
  },

  toJSON(message: LegalHold): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.subjectType !== 0) {
      obj.subjectType = subjectTypeToJSON(message.subjectType);
    }
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.caseReference !== "") {
      obj.caseReference = message.caseReference;
    }
    if (message.placedByUserId !== "") {
      obj.placedByUserId = message.placedByUserId;
    }
    if (message.placedAt !== undefined) {
      obj.placedAt = message.placedAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.liftedByUserId !== "") {
      obj.liftedByUserId = message.liftedByUserId;
    }
    if (message.liftedAt !== undefined) {
      obj.liftedAt = message.liftedAt.toISOString();
    }
    if (message.liftReason !== "") {
      obj.liftReason = message.liftReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LegalHold>, I>>(base?: I): LegalHold {
    return LegalHold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LegalHold>, I>>(object: I): LegalHold {
    const message = createBaseLegalHold();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.subjectType = object.subjectType ?? 0;
    message.subjectId = object.subjectId ?? "";
    message.reason = object.reason ?? "";
    message.caseReference = object.caseReference ?? "";
    message.placedByUserId = object.placedByUserId ?? "";
    message.placedAt = object.placedAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.isActive = object.isActive ?? false;
    message.liftedByUserId = object.liftedByUserId ?? "";
    message.liftedAt = object.liftedAt ?? undefined;
    message.liftReason = object.liftReason ?? "";
    return message;
  },
};

function createBasePlaceLegalHoldRequest(): PlaceLegalHoldRequest {
  return { organisationId: "", subjectType: 0, subjectId: "", reason: "", caseReference: "", expiresAt: undefined };
}

export const PlaceLegalHoldRequest: MessageFns<PlaceLegalHoldRequest> = {
  encode(message: PlaceLegalHoldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(16).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(26).string(message.subjectId);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.caseReference !== "") {
      writer.uint32(42).string(message.caseReference);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceLegalHoldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceLegalHoldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.caseReference = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceLegalHoldRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      subjectType: isSet(object.subjectType)
        ? subjectTypeFromJSON(object.subjectType)
        : isSet(object.subject_type)
        ? subjectTypeFromJSON(object.subject_type)
        : 0,
      subjectId: isSet(object.subjectId)
        ? globalThis.String(object.subjectId)
        : isSet(object.subject_id)
        ? globalThis.String(object.subject_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      caseReference: isSet(object.caseReference)
        ? globalThis.String(object.caseReference)
        : isSet(object.case_reference)
        ? globalThis.String(object.case_reference)
        : "",
      expiresAt: isSet(object.expiresAt)
        ? fromJsonTimestamp(object.expiresAt)
        : isSet(object.expires_at)
        ? fromJsonTimestamp(object.expires_at)
        : undefined,
    };
  },

  toJSON(message: PlaceLegalHoldRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.subjectType !== 0) {
      obj.subjectType = subjectTypeToJSON(message.subjectType);
    }
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.caseReference !== "") {
      obj.caseReference = message.caseReference;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceLegalHoldRequest>, I>>(base?: I): PlaceLegalHoldRequest {
    return PlaceLegalHoldRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceLegalHoldRequest>, I>>(object: I): PlaceLegalHoldRequest {
    const message = createBasePlaceLegalHoldRequest();
    message.organisationId = object.organisationId ?? "";
    message.subjectType = object.subjectType ?? 0;
    message.subjectId = object.subjectId ?? "";
    message.reason = object.reason ?? "";
    message.caseReference = object.caseReference ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBasePlaceLegalHoldResponse(): PlaceLegalHoldResponse {
  return { hold: undefined };
}

export const PlaceLegalHoldResponse: MessageFns<PlaceLegalHoldResponse> = {
  encode(message: PlaceLegalHoldResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hold !== undefined) {
      LegalHold.encode(message.hold, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceLegalHoldResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceLegalHoldResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hold = LegalHold.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceLegalHoldResponse {
    return { hold: isSet(object.hold) ? LegalHold.fromJSON(object.hold) : undefined };
  },

  toJSON(message: PlaceLegalHoldResponse): unknown {
    const obj: any = {};
    if (message.hold !== undefined) {
      obj.hold = LegalHold.toJSON(message.hold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceLegalHoldResponse>, I>>(base?: I): PlaceLegalHoldResponse {
    return PlaceLegalHoldResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceLegalHoldResponse>, I>>(object: I): PlaceLegalHoldResponse {
    const message = createBasePlaceLegalHoldResponse();
    message.hold = (object.hold !== undefined && object.hold !== null) ? LegalHold.fromPartial(object.hold) : undefined;
    return message;
  },
};

function createBaseLiftLegalHoldRequest(): LiftLegalHoldRequest {
  return { holdId: "", reason: "" };
}

export const LiftLegalHoldRequest: MessageFns<LiftLegalHoldRequest> = {
  encode(message: LiftLegalHoldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.holdId !== "") {
      writer.uint32(10).string(message.holdId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiftLegalHoldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiftLegalHoldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holdId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiftLegalHoldRequest {
    return {
      holdId: isSet(object.holdId)
        ? globalThis.String(object.holdId)
        : isSet(object.hold_id)
        ? globalThis.String(object.hold_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: LiftLegalHoldRequest): unknown {
    const obj: any = {};
    if (message.holdId !== "") {
      obj.holdId = message.holdId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LiftLegalHoldRequest>, I>>(base?: I): LiftLegalHoldRequest {
    return LiftLegalHoldRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiftLegalHoldRequest>, I>>(object: I): LiftLegalHoldRequest {
    const message = createBaseLiftLegalHoldRequest();
    message.holdId = object.holdId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseLiftLegalHoldResponse(): LiftLegalHoldResponse {
  return { hold: undefined };
}

export const LiftLegalHoldResponse: MessageFns<LiftLegalHoldResponse> = {
  encode(message: LiftLegalHoldResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hold !== undefined) {
      LegalHold.encode(message.hold, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiftLegalHoldResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiftLegalHoldResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hold = LegalHold.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiftLegalHoldResponse {
    return { hold: isSet(object.hold) ? LegalHold.fromJSON(object.hold) : undefined };
  },

  toJSON(message: LiftLegalHoldResponse): unknown {
    const obj: any = {};
    if (message.hold !== undefined) {
      obj.hold = LegalHold.toJSON(message.hold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LiftLegalHoldResponse>, I>>(base?: I): LiftLegalHoldResponse {
    return LiftLegalHoldResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LiftLegalHoldResponse>, I>>(object: I): LiftLegalHoldResponse {
    const message = createBaseLiftLegalHoldResponse();
    message.hold = (object.hold !== undefined && object.hold !== null) ? LegalHold.fromPartial(object.hold) : undefined;
    return message;
  },
};

function createBaseCheckLegalHoldRequest(): CheckLegalHoldRequest {
  return { organisationId: "", subjectType: 0, subjectId: "" };
}

export const CheckLegalHoldRequest: MessageFns<CheckLegalHoldRequest> = {
  encode(message: CheckLegalHoldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(16).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(26).string(message.subjectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckLegalHoldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckLegalHoldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckLegalHoldRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      subjectType: isSet(object.subjectType)
        ? subjectTypeFromJSON(object.subjectType)
        : isSet(object.subject_type)
        ? subjectTypeFromJSON(object.subject_type)
        : 0,
      subjectId: isSet(object.subjectId)
        ? globalThis.String(object.subjectId)
        : isSet(object.subject_id)
        ? globalThis.String(object.subject_id)
        : "",
    };
  },

  toJSON(message: CheckLegalHoldRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.subjectType !== 0) {
      obj.subjectType = subjectTypeToJSON(message.subjectType);
    }
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckLegalHoldRequest>, I>>(base?: I): CheckLegalHoldRequest {
    return CheckLegalHoldRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckLegalHoldRequest>, I>>(object: I): CheckLegalHoldRequest {
    const message = createBaseCheckLegalHoldRequest();
    message.organisationId = object.organisationId ?? "";
    message.subjectType = object.subjectType ?? 0;
    message.subjectId = object.subjectId ?? "";
    return message;
  },
};

function createBaseCheckLegalHoldResponse(): CheckLegalHoldResponse {
  return { hasHold: false, activeHolds: [] };
}

export const CheckLegalHoldResponse: MessageFns<CheckLegalHoldResponse> = {
  encode(message: CheckLegalHoldResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasHold !== false) {
      writer.uint32(8).bool(message.hasHold);
    }
    for (const v of message.activeHolds) {
      LegalHold.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckLegalHoldResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckLegalHoldResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasHold = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activeHolds.push(LegalHold.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckLegalHoldResponse {
    return {
      hasHold: isSet(object.hasHold)
        ? globalThis.Boolean(object.hasHold)
        : isSet(object.has_hold)
        ? globalThis.Boolean(object.has_hold)
        : false,
      activeHolds: globalThis.Array.isArray(object?.activeHolds)
        ? object.activeHolds.map((e: any) => LegalHold.fromJSON(e))
        : globalThis.Array.isArray(object?.active_holds)
        ? object.active_holds.map((e: any) => LegalHold.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CheckLegalHoldResponse): unknown {
    const obj: any = {};
    if (message.hasHold !== false) {
      obj.hasHold = message.hasHold;
    }
    if (message.activeHolds?.length) {
      obj.activeHolds = message.activeHolds.map((e) => LegalHold.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckLegalHoldResponse>, I>>(base?: I): CheckLegalHoldResponse {
    return CheckLegalHoldResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckLegalHoldResponse>, I>>(object: I): CheckLegalHoldResponse {
    const message = createBaseCheckLegalHoldResponse();
    message.hasHold = object.hasHold ?? false;
    message.activeHolds = object.activeHolds?.map((e) => LegalHold.fromPartial(e)) || [];
    return message;
  },
};

function createBasePurgeProof(): PurgeProof {
  return {
    purgeRequestId: "",
    purgeCompletedAt: undefined,
    finalStatus: 0,
    executions: [],
    totalDeleted: 0,
    totalAnonymized: 0,
    totalRetained: 0,
    allVerificationsPassed: false,
    failedVerifications: [],
    proofSignature: "",
    proofGeneratedAt: undefined,
  };
}

export const PurgeProof: MessageFns<PurgeProof> = {
  encode(message: PurgeProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    if (message.purgeCompletedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.purgeCompletedAt), writer.uint32(18).fork()).join();
    }
    if (message.finalStatus !== 0) {
      writer.uint32(24).int32(message.finalStatus);
    }
    for (const v of message.executions) {
      PurgeExecution.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.totalDeleted !== 0) {
      writer.uint32(40).int64(message.totalDeleted);
    }
    if (message.totalAnonymized !== 0) {
      writer.uint32(48).int64(message.totalAnonymized);
    }
    if (message.totalRetained !== 0) {
      writer.uint32(56).int64(message.totalRetained);
    }
    if (message.allVerificationsPassed !== false) {
      writer.uint32(64).bool(message.allVerificationsPassed);
    }
    for (const v of message.failedVerifications) {
      writer.uint32(74).string(v!);
    }
    if (message.proofSignature !== "") {
      writer.uint32(82).string(message.proofSignature);
    }
    if (message.proofGeneratedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.proofGeneratedAt), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.purgeCompletedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.finalStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.executions.push(PurgeExecution.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalDeleted = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalAnonymized = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalRetained = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.allVerificationsPassed = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.failedVerifications.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.proofSignature = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.proofGeneratedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeProof {
    return {
      purgeRequestId: isSet(object.purgeRequestId)
        ? globalThis.String(object.purgeRequestId)
        : isSet(object.purge_request_id)
        ? globalThis.String(object.purge_request_id)
        : "",
      purgeCompletedAt: isSet(object.purgeCompletedAt)
        ? fromJsonTimestamp(object.purgeCompletedAt)
        : isSet(object.purge_completed_at)
        ? fromJsonTimestamp(object.purge_completed_at)
        : undefined,
      finalStatus: isSet(object.finalStatus)
        ? purgeRequestStatusFromJSON(object.finalStatus)
        : isSet(object.final_status)
        ? purgeRequestStatusFromJSON(object.final_status)
        : 0,
      executions: globalThis.Array.isArray(object?.executions)
        ? object.executions.map((e: any) => PurgeExecution.fromJSON(e))
        : [],
      totalDeleted: isSet(object.totalDeleted)
        ? globalThis.Number(object.totalDeleted)
        : isSet(object.total_deleted)
        ? globalThis.Number(object.total_deleted)
        : 0,
      totalAnonymized: isSet(object.totalAnonymized)
        ? globalThis.Number(object.totalAnonymized)
        : isSet(object.total_anonymized)
        ? globalThis.Number(object.total_anonymized)
        : 0,
      totalRetained: isSet(object.totalRetained)
        ? globalThis.Number(object.totalRetained)
        : isSet(object.total_retained)
        ? globalThis.Number(object.total_retained)
        : 0,
      allVerificationsPassed: isSet(object.allVerificationsPassed)
        ? globalThis.Boolean(object.allVerificationsPassed)
        : isSet(object.all_verifications_passed)
        ? globalThis.Boolean(object.all_verifications_passed)
        : false,
      failedVerifications: globalThis.Array.isArray(object?.failedVerifications)
        ? object.failedVerifications.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.failed_verifications)
        ? object.failed_verifications.map((e: any) => globalThis.String(e))
        : [],
      proofSignature: isSet(object.proofSignature)
        ? globalThis.String(object.proofSignature)
        : isSet(object.proof_signature)
        ? globalThis.String(object.proof_signature)
        : "",
      proofGeneratedAt: isSet(object.proofGeneratedAt)
        ? fromJsonTimestamp(object.proofGeneratedAt)
        : isSet(object.proof_generated_at)
        ? fromJsonTimestamp(object.proof_generated_at)
        : undefined,
    };
  },

  toJSON(message: PurgeProof): unknown {
    const obj: any = {};
    if (message.purgeRequestId !== "") {
      obj.purgeRequestId = message.purgeRequestId;
    }
    if (message.purgeCompletedAt !== undefined) {
      obj.purgeCompletedAt = message.purgeCompletedAt.toISOString();
    }
    if (message.finalStatus !== 0) {
      obj.finalStatus = purgeRequestStatusToJSON(message.finalStatus);
    }
    if (message.executions?.length) {
      obj.executions = message.executions.map((e) => PurgeExecution.toJSON(e));
    }
    if (message.totalDeleted !== 0) {
      obj.totalDeleted = Math.round(message.totalDeleted);
    }
    if (message.totalAnonymized !== 0) {
      obj.totalAnonymized = Math.round(message.totalAnonymized);
    }
    if (message.totalRetained !== 0) {
      obj.totalRetained = Math.round(message.totalRetained);
    }
    if (message.allVerificationsPassed !== false) {
      obj.allVerificationsPassed = message.allVerificationsPassed;
    }
    if (message.failedVerifications?.length) {
      obj.failedVerifications = message.failedVerifications;
    }
    if (message.proofSignature !== "") {
      obj.proofSignature = message.proofSignature;
    }
    if (message.proofGeneratedAt !== undefined) {
      obj.proofGeneratedAt = message.proofGeneratedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PurgeProof>, I>>(base?: I): PurgeProof {
    return PurgeProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PurgeProof>, I>>(object: I): PurgeProof {
    const message = createBasePurgeProof();
    message.purgeRequestId = object.purgeRequestId ?? "";
    message.purgeCompletedAt = object.purgeCompletedAt ?? undefined;
    message.finalStatus = object.finalStatus ?? 0;
    message.executions = object.executions?.map((e) => PurgeExecution.fromPartial(e)) || [];
    message.totalDeleted = object.totalDeleted ?? 0;
    message.totalAnonymized = object.totalAnonymized ?? 0;
    message.totalRetained = object.totalRetained ?? 0;
    message.allVerificationsPassed = object.allVerificationsPassed ?? false;
    message.failedVerifications = object.failedVerifications?.map((e) => e) || [];
    message.proofSignature = object.proofSignature ?? "";
    message.proofGeneratedAt = object.proofGeneratedAt ?? undefined;
    return message;
  },
};

function createBaseGeneratePurgeProofRequest(): GeneratePurgeProofRequest {
  return { purgeRequestId: "" };
}

export const GeneratePurgeProofRequest: MessageFns<GeneratePurgeProofRequest> = {
  encode(message: GeneratePurgeProofRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratePurgeProofRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratePurgeProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratePurgeProofRequest {
    return {
      purgeRequestId: isSet(object.purgeRequestId)
        ? globalThis.String(object.purgeRequestId)
        : isSet(object.purge_request_id)
        ? globalThis.String(object.purge_request_id)
        : "",
    };
  },

  toJSON(message: GeneratePurgeProofRequest): unknown {
    const obj: any = {};
    if (message.purgeRequestId !== "") {
      obj.purgeRequestId = message.purgeRequestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneratePurgeProofRequest>, I>>(base?: I): GeneratePurgeProofRequest {
    return GeneratePurgeProofRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneratePurgeProofRequest>, I>>(object: I): GeneratePurgeProofRequest {
    const message = createBaseGeneratePurgeProofRequest();
    message.purgeRequestId = object.purgeRequestId ?? "";
    return message;
  },
};

function createBaseGeneratePurgeProofResponse(): GeneratePurgeProofResponse {
  return { proof: undefined };
}

export const GeneratePurgeProofResponse: MessageFns<GeneratePurgeProofResponse> = {
  encode(message: GeneratePurgeProofResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proof !== undefined) {
      PurgeProof.encode(message.proof, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratePurgeProofResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratePurgeProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proof = PurgeProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratePurgeProofResponse {
    return { proof: isSet(object.proof) ? PurgeProof.fromJSON(object.proof) : undefined };
  },

  toJSON(message: GeneratePurgeProofResponse): unknown {
    const obj: any = {};
    if (message.proof !== undefined) {
      obj.proof = PurgeProof.toJSON(message.proof);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneratePurgeProofResponse>, I>>(base?: I): GeneratePurgeProofResponse {
    return GeneratePurgeProofResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneratePurgeProofResponse>, I>>(object: I): GeneratePurgeProofResponse {
    const message = createBaseGeneratePurgeProofResponse();
    message.proof = (object.proof !== undefined && object.proof !== null)
      ? PurgeProof.fromPartial(object.proof)
      : undefined;
    return message;
  },
};

/** ========== RETENTION POLICIES ========== */
export type ComplianceServiceService = typeof ComplianceServiceService;
export const ComplianceServiceService = {
  upsertRetentionPolicy: {
    path: "/security.ComplianceService/UpsertRetentionPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpsertRetentionPolicyRequest): Buffer =>
      Buffer.from(UpsertRetentionPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpsertRetentionPolicyRequest => UpsertRetentionPolicyRequest.decode(value),
    responseSerialize: (value: UpsertRetentionPolicyResponse): Buffer =>
      Buffer.from(UpsertRetentionPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpsertRetentionPolicyResponse => UpsertRetentionPolicyResponse.decode(value),
  },
  listRetentionPolicies: {
    path: "/security.ComplianceService/ListRetentionPolicies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetentionPoliciesRequest): Buffer =>
      Buffer.from(ListRetentionPoliciesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetentionPoliciesRequest => ListRetentionPoliciesRequest.decode(value),
    responseSerialize: (value: ListRetentionPoliciesResponse): Buffer =>
      Buffer.from(ListRetentionPoliciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetentionPoliciesResponse => ListRetentionPoliciesResponse.decode(value),
  },
  getRetentionPolicy: {
    path: "/security.ComplianceService/GetRetentionPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetentionPolicyRequest): Buffer =>
      Buffer.from(GetRetentionPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetentionPolicyRequest => GetRetentionPolicyRequest.decode(value),
    responseSerialize: (value: GetRetentionPolicyResponse): Buffer =>
      Buffer.from(GetRetentionPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetRetentionPolicyResponse => GetRetentionPolicyResponse.decode(value),
  },
  runScheduledPurge: {
    path: "/security.ComplianceService/RunScheduledPurge",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RunScheduledPurgeRequest): Buffer =>
      Buffer.from(RunScheduledPurgeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunScheduledPurgeRequest => RunScheduledPurgeRequest.decode(value),
    responseSerialize: (value: RunScheduledPurgeResponse): Buffer =>
      Buffer.from(RunScheduledPurgeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunScheduledPurgeResponse => RunScheduledPurgeResponse.decode(value),
  },
  listPurgeJobs: {
    path: "/security.ComplianceService/ListPurgeJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPurgeJobsRequest): Buffer => Buffer.from(ListPurgeJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPurgeJobsRequest => ListPurgeJobsRequest.decode(value),
    responseSerialize: (value: ListPurgeJobsResponse): Buffer =>
      Buffer.from(ListPurgeJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPurgeJobsResponse => ListPurgeJobsResponse.decode(value),
  },
  createPurgeRequest: {
    path: "/security.ComplianceService/CreatePurgeRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePurgeRequestRequest): Buffer =>
      Buffer.from(CreatePurgeRequestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePurgeRequestRequest => CreatePurgeRequestRequest.decode(value),
    responseSerialize: (value: CreatePurgeRequestResponse): Buffer =>
      Buffer.from(CreatePurgeRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreatePurgeRequestResponse => CreatePurgeRequestResponse.decode(value),
  },
  executePurge: {
    path: "/security.ComplianceService/ExecutePurge",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecutePurgeRequest): Buffer => Buffer.from(ExecutePurgeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecutePurgeRequest => ExecutePurgeRequest.decode(value),
    responseSerialize: (value: ExecutePurgeResponse): Buffer =>
      Buffer.from(ExecutePurgeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecutePurgeResponse => ExecutePurgeResponse.decode(value),
  },
  getPurgeRequest: {
    path: "/security.ComplianceService/GetPurgeRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPurgeRequestRequest): Buffer =>
      Buffer.from(GetPurgeRequestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPurgeRequestRequest => GetPurgeRequestRequest.decode(value),
    responseSerialize: (value: GetPurgeRequestResponse): Buffer =>
      Buffer.from(GetPurgeRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPurgeRequestResponse => GetPurgeRequestResponse.decode(value),
  },
  listPurgeRequests: {
    path: "/security.ComplianceService/ListPurgeRequests",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPurgeRequestsRequest): Buffer =>
      Buffer.from(ListPurgeRequestsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPurgeRequestsRequest => ListPurgeRequestsRequest.decode(value),
    responseSerialize: (value: ListPurgeRequestsResponse): Buffer =>
      Buffer.from(ListPurgeRequestsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPurgeRequestsResponse => ListPurgeRequestsResponse.decode(value),
  },
  cancelPurgeRequest: {
    path: "/security.ComplianceService/CancelPurgeRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelPurgeRequestRequest): Buffer =>
      Buffer.from(CancelPurgeRequestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelPurgeRequestRequest => CancelPurgeRequestRequest.decode(value),
    responseSerialize: (value: CancelPurgeRequestResponse): Buffer =>
      Buffer.from(CancelPurgeRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CancelPurgeRequestResponse => CancelPurgeRequestResponse.decode(value),
  },
  placeLegalHold: {
    path: "/security.ComplianceService/PlaceLegalHold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PlaceLegalHoldRequest): Buffer =>
      Buffer.from(PlaceLegalHoldRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PlaceLegalHoldRequest => PlaceLegalHoldRequest.decode(value),
    responseSerialize: (value: PlaceLegalHoldResponse): Buffer =>
      Buffer.from(PlaceLegalHoldResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PlaceLegalHoldResponse => PlaceLegalHoldResponse.decode(value),
  },
  liftLegalHold: {
    path: "/security.ComplianceService/LiftLegalHold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LiftLegalHoldRequest): Buffer => Buffer.from(LiftLegalHoldRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LiftLegalHoldRequest => LiftLegalHoldRequest.decode(value),
    responseSerialize: (value: LiftLegalHoldResponse): Buffer =>
      Buffer.from(LiftLegalHoldResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LiftLegalHoldResponse => LiftLegalHoldResponse.decode(value),
  },
  checkLegalHold: {
    path: "/security.ComplianceService/CheckLegalHold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckLegalHoldRequest): Buffer =>
      Buffer.from(CheckLegalHoldRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckLegalHoldRequest => CheckLegalHoldRequest.decode(value),
    responseSerialize: (value: CheckLegalHoldResponse): Buffer =>
      Buffer.from(CheckLegalHoldResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckLegalHoldResponse => CheckLegalHoldResponse.decode(value),
  },
  generatePurgeProof: {
    path: "/security.ComplianceService/GeneratePurgeProof",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GeneratePurgeProofRequest): Buffer =>
      Buffer.from(GeneratePurgeProofRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GeneratePurgeProofRequest => GeneratePurgeProofRequest.decode(value),
    responseSerialize: (value: GeneratePurgeProofResponse): Buffer =>
      Buffer.from(GeneratePurgeProofResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GeneratePurgeProofResponse => GeneratePurgeProofResponse.decode(value),
  },
} as const;

export interface ComplianceServiceServer extends UntypedServiceImplementation {
  upsertRetentionPolicy: handleUnaryCall<UpsertRetentionPolicyRequest, UpsertRetentionPolicyResponse>;
  listRetentionPolicies: handleUnaryCall<ListRetentionPoliciesRequest, ListRetentionPoliciesResponse>;
  getRetentionPolicy: handleUnaryCall<GetRetentionPolicyRequest, GetRetentionPolicyResponse>;
  runScheduledPurge: handleUnaryCall<RunScheduledPurgeRequest, RunScheduledPurgeResponse>;
  listPurgeJobs: handleUnaryCall<ListPurgeJobsRequest, ListPurgeJobsResponse>;
  createPurgeRequest: handleUnaryCall<CreatePurgeRequestRequest, CreatePurgeRequestResponse>;
  executePurge: handleUnaryCall<ExecutePurgeRequest, ExecutePurgeResponse>;
  getPurgeRequest: handleUnaryCall<GetPurgeRequestRequest, GetPurgeRequestResponse>;
  listPurgeRequests: handleUnaryCall<ListPurgeRequestsRequest, ListPurgeRequestsResponse>;
  cancelPurgeRequest: handleUnaryCall<CancelPurgeRequestRequest, CancelPurgeRequestResponse>;
  placeLegalHold: handleUnaryCall<PlaceLegalHoldRequest, PlaceLegalHoldResponse>;
  liftLegalHold: handleUnaryCall<LiftLegalHoldRequest, LiftLegalHoldResponse>;
  checkLegalHold: handleUnaryCall<CheckLegalHoldRequest, CheckLegalHoldResponse>;
  generatePurgeProof: handleUnaryCall<GeneratePurgeProofRequest, GeneratePurgeProofResponse>;
}

export interface ComplianceServiceClient extends Client {
  upsertRetentionPolicy(
    request: UpsertRetentionPolicyRequest,
    callback: (error: ServiceError | null, response: UpsertRetentionPolicyResponse) => void,
  ): ClientUnaryCall;
  upsertRetentionPolicy(
    request: UpsertRetentionPolicyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpsertRetentionPolicyResponse) => void,
  ): ClientUnaryCall;
  upsertRetentionPolicy(
    request: UpsertRetentionPolicyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpsertRetentionPolicyResponse) => void,
  ): ClientUnaryCall;
  listRetentionPolicies(
    request: ListRetentionPoliciesRequest,
    callback: (error: ServiceError | null, response: ListRetentionPoliciesResponse) => void,
  ): ClientUnaryCall;
  listRetentionPolicies(
    request: ListRetentionPoliciesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRetentionPoliciesResponse) => void,
  ): ClientUnaryCall;
  listRetentionPolicies(
    request: ListRetentionPoliciesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRetentionPoliciesResponse) => void,
  ): ClientUnaryCall;
  getRetentionPolicy(
    request: GetRetentionPolicyRequest,
    callback: (error: ServiceError | null, response: GetRetentionPolicyResponse) => void,
  ): ClientUnaryCall;
  getRetentionPolicy(
    request: GetRetentionPolicyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetRetentionPolicyResponse) => void,
  ): ClientUnaryCall;
  getRetentionPolicy(
    request: GetRetentionPolicyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetRetentionPolicyResponse) => void,
  ): ClientUnaryCall;
  runScheduledPurge(
    request: RunScheduledPurgeRequest,
    callback: (error: ServiceError | null, response: RunScheduledPurgeResponse) => void,
  ): ClientUnaryCall;
  runScheduledPurge(
    request: RunScheduledPurgeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RunScheduledPurgeResponse) => void,
  ): ClientUnaryCall;
  runScheduledPurge(
    request: RunScheduledPurgeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RunScheduledPurgeResponse) => void,
  ): ClientUnaryCall;
  listPurgeJobs(
    request: ListPurgeJobsRequest,
    callback: (error: ServiceError | null, response: ListPurgeJobsResponse) => void,
  ): ClientUnaryCall;
  listPurgeJobs(
    request: ListPurgeJobsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPurgeJobsResponse) => void,
  ): ClientUnaryCall;
  listPurgeJobs(
    request: ListPurgeJobsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPurgeJobsResponse) => void,
  ): ClientUnaryCall;
  createPurgeRequest(
    request: CreatePurgeRequestRequest,
    callback: (error: ServiceError | null, response: CreatePurgeRequestResponse) => void,
  ): ClientUnaryCall;
  createPurgeRequest(
    request: CreatePurgeRequestRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreatePurgeRequestResponse) => void,
  ): ClientUnaryCall;
  createPurgeRequest(
    request: CreatePurgeRequestRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreatePurgeRequestResponse) => void,
  ): ClientUnaryCall;
  executePurge(
    request: ExecutePurgeRequest,
    callback: (error: ServiceError | null, response: ExecutePurgeResponse) => void,
  ): ClientUnaryCall;
  executePurge(
    request: ExecutePurgeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExecutePurgeResponse) => void,
  ): ClientUnaryCall;
  executePurge(
    request: ExecutePurgeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExecutePurgeResponse) => void,
  ): ClientUnaryCall;
  getPurgeRequest(
    request: GetPurgeRequestRequest,
    callback: (error: ServiceError | null, response: GetPurgeRequestResponse) => void,
  ): ClientUnaryCall;
  getPurgeRequest(
    request: GetPurgeRequestRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetPurgeRequestResponse) => void,
  ): ClientUnaryCall;
  getPurgeRequest(
    request: GetPurgeRequestRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetPurgeRequestResponse) => void,
  ): ClientUnaryCall;
  listPurgeRequests(
    request: ListPurgeRequestsRequest,
    callback: (error: ServiceError | null, response: ListPurgeRequestsResponse) => void,
  ): ClientUnaryCall;
  listPurgeRequests(
    request: ListPurgeRequestsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPurgeRequestsResponse) => void,
  ): ClientUnaryCall;
  listPurgeRequests(
    request: ListPurgeRequestsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPurgeRequestsResponse) => void,
  ): ClientUnaryCall;
  cancelPurgeRequest(
    request: CancelPurgeRequestRequest,
    callback: (error: ServiceError | null, response: CancelPurgeRequestResponse) => void,
  ): ClientUnaryCall;
  cancelPurgeRequest(
    request: CancelPurgeRequestRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CancelPurgeRequestResponse) => void,
  ): ClientUnaryCall;
  cancelPurgeRequest(
    request: CancelPurgeRequestRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CancelPurgeRequestResponse) => void,
  ): ClientUnaryCall;
  placeLegalHold(
    request: PlaceLegalHoldRequest,
    callback: (error: ServiceError | null, response: PlaceLegalHoldResponse) => void,
  ): ClientUnaryCall;
  placeLegalHold(
    request: PlaceLegalHoldRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PlaceLegalHoldResponse) => void,
  ): ClientUnaryCall;
  placeLegalHold(
    request: PlaceLegalHoldRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PlaceLegalHoldResponse) => void,
  ): ClientUnaryCall;
  liftLegalHold(
    request: LiftLegalHoldRequest,
    callback: (error: ServiceError | null, response: LiftLegalHoldResponse) => void,
  ): ClientUnaryCall;
  liftLegalHold(
    request: LiftLegalHoldRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LiftLegalHoldResponse) => void,
  ): ClientUnaryCall;
  liftLegalHold(
    request: LiftLegalHoldRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LiftLegalHoldResponse) => void,
  ): ClientUnaryCall;
  checkLegalHold(
    request: CheckLegalHoldRequest,
    callback: (error: ServiceError | null, response: CheckLegalHoldResponse) => void,
  ): ClientUnaryCall;
  checkLegalHold(
    request: CheckLegalHoldRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckLegalHoldResponse) => void,
  ): ClientUnaryCall;
  checkLegalHold(
    request: CheckLegalHoldRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckLegalHoldResponse) => void,
  ): ClientUnaryCall;
  generatePurgeProof(
    request: GeneratePurgeProofRequest,
    callback: (error: ServiceError | null, response: GeneratePurgeProofResponse) => void,
  ): ClientUnaryCall;
  generatePurgeProof(
    request: GeneratePurgeProofRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GeneratePurgeProofResponse) => void,
  ): ClientUnaryCall;
  generatePurgeProof(
    request: GeneratePurgeProofRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GeneratePurgeProofResponse) => void,
  ): ClientUnaryCall;
}

export const ComplianceServiceClient = makeGenericClientConstructor(
  ComplianceServiceService,
  "security.ComplianceService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ComplianceServiceClient;
  service: typeof ComplianceServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
