// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: services/wincash.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "wincash";

export enum StatutOperation {
  STATUT_OPERATION_UNSPECIFIED = 0,
  STATUT_OPERATION_EN_ATTENTE = 1,
  STATUT_OPERATION_VALIDEE = 2,
  STATUT_OPERATION_REJETEE = 3,
  STATUT_OPERATION_VERSEE = 4,
  STATUT_OPERATION_ANNULEE = 5,
  STATUT_OPERATION_EXPIREE = 6,
  UNRECOGNIZED = -1,
}

export function statutOperationFromJSON(object: any): StatutOperation {
  switch (object) {
    case 0:
    case "STATUT_OPERATION_UNSPECIFIED":
      return StatutOperation.STATUT_OPERATION_UNSPECIFIED;
    case 1:
    case "STATUT_OPERATION_EN_ATTENTE":
      return StatutOperation.STATUT_OPERATION_EN_ATTENTE;
    case 2:
    case "STATUT_OPERATION_VALIDEE":
      return StatutOperation.STATUT_OPERATION_VALIDEE;
    case 3:
    case "STATUT_OPERATION_REJETEE":
      return StatutOperation.STATUT_OPERATION_REJETEE;
    case 4:
    case "STATUT_OPERATION_VERSEE":
      return StatutOperation.STATUT_OPERATION_VERSEE;
    case 5:
    case "STATUT_OPERATION_ANNULEE":
      return StatutOperation.STATUT_OPERATION_ANNULEE;
    case 6:
    case "STATUT_OPERATION_EXPIREE":
      return StatutOperation.STATUT_OPERATION_EXPIREE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatutOperation.UNRECOGNIZED;
  }
}

export function statutOperationToJSON(object: StatutOperation): string {
  switch (object) {
    case StatutOperation.STATUT_OPERATION_UNSPECIFIED:
      return "STATUT_OPERATION_UNSPECIFIED";
    case StatutOperation.STATUT_OPERATION_EN_ATTENTE:
      return "STATUT_OPERATION_EN_ATTENTE";
    case StatutOperation.STATUT_OPERATION_VALIDEE:
      return "STATUT_OPERATION_VALIDEE";
    case StatutOperation.STATUT_OPERATION_REJETEE:
      return "STATUT_OPERATION_REJETEE";
    case StatutOperation.STATUT_OPERATION_VERSEE:
      return "STATUT_OPERATION_VERSEE";
    case StatutOperation.STATUT_OPERATION_ANNULEE:
      return "STATUT_OPERATION_ANNULEE";
    case StatutOperation.STATUT_OPERATION_EXPIREE:
      return "STATUT_OPERATION_EXPIREE";
    case StatutOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TypeOperation {
  TYPE_OPERATION_UNSPECIFIED = 0,
  /** TYPE_OPERATION_GAIN - Cashback earned */
  TYPE_OPERATION_GAIN = 1,
  /** TYPE_OPERATION_UTILISATION - Cashback used */
  TYPE_OPERATION_UTILISATION = 2,
  /** TYPE_OPERATION_AJUSTEMENT - Manual adjustment */
  TYPE_OPERATION_AJUSTEMENT = 3,
  /** TYPE_OPERATION_EXPIRATION - Expired cashback */
  TYPE_OPERATION_EXPIRATION = 4,
  /** TYPE_OPERATION_BONUS - Bonus/promotional cashback */
  TYPE_OPERATION_BONUS = 5,
  UNRECOGNIZED = -1,
}

export function typeOperationFromJSON(object: any): TypeOperation {
  switch (object) {
    case 0:
    case "TYPE_OPERATION_UNSPECIFIED":
      return TypeOperation.TYPE_OPERATION_UNSPECIFIED;
    case 1:
    case "TYPE_OPERATION_GAIN":
      return TypeOperation.TYPE_OPERATION_GAIN;
    case 2:
    case "TYPE_OPERATION_UTILISATION":
      return TypeOperation.TYPE_OPERATION_UTILISATION;
    case 3:
    case "TYPE_OPERATION_AJUSTEMENT":
      return TypeOperation.TYPE_OPERATION_AJUSTEMENT;
    case 4:
    case "TYPE_OPERATION_EXPIRATION":
      return TypeOperation.TYPE_OPERATION_EXPIRATION;
    case 5:
    case "TYPE_OPERATION_BONUS":
      return TypeOperation.TYPE_OPERATION_BONUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TypeOperation.UNRECOGNIZED;
  }
}

export function typeOperationToJSON(object: TypeOperation): string {
  switch (object) {
    case TypeOperation.TYPE_OPERATION_UNSPECIFIED:
      return "TYPE_OPERATION_UNSPECIFIED";
    case TypeOperation.TYPE_OPERATION_GAIN:
      return "TYPE_OPERATION_GAIN";
    case TypeOperation.TYPE_OPERATION_UTILISATION:
      return "TYPE_OPERATION_UTILISATION";
    case TypeOperation.TYPE_OPERATION_AJUSTEMENT:
      return "TYPE_OPERATION_AJUSTEMENT";
    case TypeOperation.TYPE_OPERATION_EXPIRATION:
      return "TYPE_OPERATION_EXPIRATION";
    case TypeOperation.TYPE_OPERATION_BONUS:
      return "TYPE_OPERATION_BONUS";
    case TypeOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OperationCashback {
  id: string;
  organisationId: string;
  clientId: string;
  /** Linked contract */
  contratId: string;
  /** External reference from WinCash */
  referenceExterne: string;
  type: TypeOperation;
  statut: StatutOperation;
  /** Amount in EUR */
  montant: number;
  devise: string;
  description: string;
  dateOperation: string;
  dateValidation: string;
  dateVersement: string;
  dateExpiration: string;
  /** JSON metadata from partner */
  metadata: string;
  /** Last sync timestamp */
  syncedAt: string;
  createdAt: string;
  updatedAt: string;
}

export interface SyncCashbackRequest {
  organisationId: string;
  /** Sync specific client, or all if empty */
  clientId?:
    | string
    | undefined;
  /** ISO date, incremental sync */
  since?: string | undefined;
  forceFullSync: boolean;
}

export interface SyncCashbackResponse {
  operationsCreees: number;
  operationsMisesAJour: number;
  operationsIgnorees: number;
  erreurs: number;
  errors: SyncError[];
  syncId: string;
  syncedAt: Date | undefined;
}

export interface SyncError {
  referenceExterne: string;
  message: string;
  code: string;
}

export interface GetOperationRequest {
  id: string;
}

export interface GetOperationResponse {
  operation: OperationCashback | undefined;
}

export interface ListOperationsRequest {
  organisationId: string;
  clientId?: string | undefined;
  contratId?: string | undefined;
  statut?: StatutOperation | undefined;
  type?: TypeOperation | undefined;
  search?: string | undefined;
  pagination: PaginationRequest | undefined;
}

export interface ListOperationsResponse {
  operations: OperationCashback[];
  pagination:
    | PaginationResponse
    | undefined;
  /** Summary: total earned */
  totalGains: number;
  /** Summary: total used */
  totalUtilise: number;
  /** Summary: available balance */
  soldeDisponible: number;
}

export interface PaginationRequest {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResponse {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

function createBaseOperationCashback(): OperationCashback {
  return {
    id: "",
    organisationId: "",
    clientId: "",
    contratId: "",
    referenceExterne: "",
    type: 0,
    statut: 0,
    montant: 0,
    devise: "",
    description: "",
    dateOperation: "",
    dateValidation: "",
    dateVersement: "",
    dateExpiration: "",
    metadata: "",
    syncedAt: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const OperationCashback: MessageFns<OperationCashback> = {
  encode(message: OperationCashback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(34).string(message.contratId);
    }
    if (message.referenceExterne !== "") {
      writer.uint32(42).string(message.referenceExterne);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.statut !== 0) {
      writer.uint32(56).int32(message.statut);
    }
    if (message.montant !== 0) {
      writer.uint32(65).double(message.montant);
    }
    if (message.devise !== "") {
      writer.uint32(74).string(message.devise);
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    if (message.dateOperation !== "") {
      writer.uint32(90).string(message.dateOperation);
    }
    if (message.dateValidation !== "") {
      writer.uint32(98).string(message.dateValidation);
    }
    if (message.dateVersement !== "") {
      writer.uint32(106).string(message.dateVersement);
    }
    if (message.dateExpiration !== "") {
      writer.uint32(114).string(message.dateExpiration);
    }
    if (message.metadata !== "") {
      writer.uint32(122).string(message.metadata);
    }
    if (message.syncedAt !== "") {
      writer.uint32(130).string(message.syncedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(138).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(146).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationCashback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationCashback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referenceExterne = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.statut = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.montant = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.devise = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dateOperation = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dateValidation = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.dateVersement = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dateExpiration = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.syncedAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationCashback {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : "",
      referenceExterne: isSet(object.referenceExterne)
        ? globalThis.String(object.referenceExterne)
        : isSet(object.reference_externe)
        ? globalThis.String(object.reference_externe)
        : "",
      type: isSet(object.type) ? typeOperationFromJSON(object.type) : 0,
      statut: isSet(object.statut) ? statutOperationFromJSON(object.statut) : 0,
      montant: isSet(object.montant) ? globalThis.Number(object.montant) : 0,
      devise: isSet(object.devise) ? globalThis.String(object.devise) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dateOperation: isSet(object.dateOperation)
        ? globalThis.String(object.dateOperation)
        : isSet(object.date_operation)
        ? globalThis.String(object.date_operation)
        : "",
      dateValidation: isSet(object.dateValidation)
        ? globalThis.String(object.dateValidation)
        : isSet(object.date_validation)
        ? globalThis.String(object.date_validation)
        : "",
      dateVersement: isSet(object.dateVersement)
        ? globalThis.String(object.dateVersement)
        : isSet(object.date_versement)
        ? globalThis.String(object.date_versement)
        : "",
      dateExpiration: isSet(object.dateExpiration)
        ? globalThis.String(object.dateExpiration)
        : isSet(object.date_expiration)
        ? globalThis.String(object.date_expiration)
        : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      syncedAt: isSet(object.syncedAt)
        ? globalThis.String(object.syncedAt)
        : isSet(object.synced_at)
        ? globalThis.String(object.synced_at)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: OperationCashback): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.contratId !== "") {
      obj.contratId = message.contratId;
    }
    if (message.referenceExterne !== "") {
      obj.referenceExterne = message.referenceExterne;
    }
    if (message.type !== 0) {
      obj.type = typeOperationToJSON(message.type);
    }
    if (message.statut !== 0) {
      obj.statut = statutOperationToJSON(message.statut);
    }
    if (message.montant !== 0) {
      obj.montant = message.montant;
    }
    if (message.devise !== "") {
      obj.devise = message.devise;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dateOperation !== "") {
      obj.dateOperation = message.dateOperation;
    }
    if (message.dateValidation !== "") {
      obj.dateValidation = message.dateValidation;
    }
    if (message.dateVersement !== "") {
      obj.dateVersement = message.dateVersement;
    }
    if (message.dateExpiration !== "") {
      obj.dateExpiration = message.dateExpiration;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.syncedAt !== "") {
      obj.syncedAt = message.syncedAt;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationCashback>, I>>(base?: I): OperationCashback {
    return OperationCashback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationCashback>, I>>(object: I): OperationCashback {
    const message = createBaseOperationCashback();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? "";
    message.contratId = object.contratId ?? "";
    message.referenceExterne = object.referenceExterne ?? "";
    message.type = object.type ?? 0;
    message.statut = object.statut ?? 0;
    message.montant = object.montant ?? 0;
    message.devise = object.devise ?? "";
    message.description = object.description ?? "";
    message.dateOperation = object.dateOperation ?? "";
    message.dateValidation = object.dateValidation ?? "";
    message.dateVersement = object.dateVersement ?? "";
    message.dateExpiration = object.dateExpiration ?? "";
    message.metadata = object.metadata ?? "";
    message.syncedAt = object.syncedAt ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSyncCashbackRequest(): SyncCashbackRequest {
  return { organisationId: "", clientId: undefined, since: undefined, forceFullSync: false };
}

export const SyncCashbackRequest: MessageFns<SyncCashbackRequest> = {
  encode(message: SyncCashbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(18).string(message.clientId);
    }
    if (message.since !== undefined) {
      writer.uint32(26).string(message.since);
    }
    if (message.forceFullSync !== false) {
      writer.uint32(32).bool(message.forceFullSync);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncCashbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncCashbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.since = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.forceFullSync = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncCashbackRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      since: isSet(object.since) ? globalThis.String(object.since) : undefined,
      forceFullSync: isSet(object.forceFullSync)
        ? globalThis.Boolean(object.forceFullSync)
        : isSet(object.force_full_sync)
        ? globalThis.Boolean(object.force_full_sync)
        : false,
    };
  },

  toJSON(message: SyncCashbackRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.since !== undefined) {
      obj.since = message.since;
    }
    if (message.forceFullSync !== false) {
      obj.forceFullSync = message.forceFullSync;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncCashbackRequest>, I>>(base?: I): SyncCashbackRequest {
    return SyncCashbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncCashbackRequest>, I>>(object: I): SyncCashbackRequest {
    const message = createBaseSyncCashbackRequest();
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? undefined;
    message.since = object.since ?? undefined;
    message.forceFullSync = object.forceFullSync ?? false;
    return message;
  },
};

function createBaseSyncCashbackResponse(): SyncCashbackResponse {
  return {
    operationsCreees: 0,
    operationsMisesAJour: 0,
    operationsIgnorees: 0,
    erreurs: 0,
    errors: [],
    syncId: "",
    syncedAt: undefined,
  };
}

export const SyncCashbackResponse: MessageFns<SyncCashbackResponse> = {
  encode(message: SyncCashbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationsCreees !== 0) {
      writer.uint32(8).int32(message.operationsCreees);
    }
    if (message.operationsMisesAJour !== 0) {
      writer.uint32(16).int32(message.operationsMisesAJour);
    }
    if (message.operationsIgnorees !== 0) {
      writer.uint32(24).int32(message.operationsIgnorees);
    }
    if (message.erreurs !== 0) {
      writer.uint32(32).int32(message.erreurs);
    }
    for (const v of message.errors) {
      SyncError.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.syncId !== "") {
      writer.uint32(50).string(message.syncId);
    }
    if (message.syncedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.syncedAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncCashbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncCashbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.operationsCreees = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operationsMisesAJour = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationsIgnorees = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.erreurs = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errors.push(SyncError.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.syncId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.syncedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncCashbackResponse {
    return {
      operationsCreees: isSet(object.operationsCreees)
        ? globalThis.Number(object.operationsCreees)
        : isSet(object.operations_creees)
        ? globalThis.Number(object.operations_creees)
        : 0,
      operationsMisesAJour: isSet(object.operationsMisesAJour)
        ? globalThis.Number(object.operationsMisesAJour)
        : isSet(object.operations_mises_a_jour)
        ? globalThis.Number(object.operations_mises_a_jour)
        : 0,
      operationsIgnorees: isSet(object.operationsIgnorees)
        ? globalThis.Number(object.operationsIgnorees)
        : isSet(object.operations_ignorees)
        ? globalThis.Number(object.operations_ignorees)
        : 0,
      erreurs: isSet(object.erreurs) ? globalThis.Number(object.erreurs) : 0,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => SyncError.fromJSON(e)) : [],
      syncId: isSet(object.syncId)
        ? globalThis.String(object.syncId)
        : isSet(object.sync_id)
        ? globalThis.String(object.sync_id)
        : "",
      syncedAt: isSet(object.syncedAt)
        ? fromJsonTimestamp(object.syncedAt)
        : isSet(object.synced_at)
        ? fromJsonTimestamp(object.synced_at)
        : undefined,
    };
  },

  toJSON(message: SyncCashbackResponse): unknown {
    const obj: any = {};
    if (message.operationsCreees !== 0) {
      obj.operationsCreees = Math.round(message.operationsCreees);
    }
    if (message.operationsMisesAJour !== 0) {
      obj.operationsMisesAJour = Math.round(message.operationsMisesAJour);
    }
    if (message.operationsIgnorees !== 0) {
      obj.operationsIgnorees = Math.round(message.operationsIgnorees);
    }
    if (message.erreurs !== 0) {
      obj.erreurs = Math.round(message.erreurs);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => SyncError.toJSON(e));
    }
    if (message.syncId !== "") {
      obj.syncId = message.syncId;
    }
    if (message.syncedAt !== undefined) {
      obj.syncedAt = message.syncedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncCashbackResponse>, I>>(base?: I): SyncCashbackResponse {
    return SyncCashbackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncCashbackResponse>, I>>(object: I): SyncCashbackResponse {
    const message = createBaseSyncCashbackResponse();
    message.operationsCreees = object.operationsCreees ?? 0;
    message.operationsMisesAJour = object.operationsMisesAJour ?? 0;
    message.operationsIgnorees = object.operationsIgnorees ?? 0;
    message.erreurs = object.erreurs ?? 0;
    message.errors = object.errors?.map((e) => SyncError.fromPartial(e)) || [];
    message.syncId = object.syncId ?? "";
    message.syncedAt = object.syncedAt ?? undefined;
    return message;
  },
};

function createBaseSyncError(): SyncError {
  return { referenceExterne: "", message: "", code: "" };
}

export const SyncError: MessageFns<SyncError> = {
  encode(message: SyncError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceExterne !== "") {
      writer.uint32(10).string(message.referenceExterne);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceExterne = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncError {
    return {
      referenceExterne: isSet(object.referenceExterne)
        ? globalThis.String(object.referenceExterne)
        : isSet(object.reference_externe)
        ? globalThis.String(object.reference_externe)
        : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: SyncError): unknown {
    const obj: any = {};
    if (message.referenceExterne !== "") {
      obj.referenceExterne = message.referenceExterne;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncError>, I>>(base?: I): SyncError {
    return SyncError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncError>, I>>(object: I): SyncError {
    const message = createBaseSyncError();
    message.referenceExterne = object.referenceExterne ?? "";
    message.message = object.message ?? "";
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseGetOperationRequest(): GetOperationRequest {
  return { id: "" };
}

export const GetOperationRequest: MessageFns<GetOperationRequest> = {
  encode(message: GetOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOperationRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetOperationRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOperationRequest>, I>>(base?: I): GetOperationRequest {
    return GetOperationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOperationRequest>, I>>(object: I): GetOperationRequest {
    const message = createBaseGetOperationRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetOperationResponse(): GetOperationResponse {
  return { operation: undefined };
}

export const GetOperationResponse: MessageFns<GetOperationResponse> = {
  encode(message: GetOperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== undefined) {
      OperationCashback.encode(message.operation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operation = OperationCashback.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOperationResponse {
    return { operation: isSet(object.operation) ? OperationCashback.fromJSON(object.operation) : undefined };
  },

  toJSON(message: GetOperationResponse): unknown {
    const obj: any = {};
    if (message.operation !== undefined) {
      obj.operation = OperationCashback.toJSON(message.operation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOperationResponse>, I>>(base?: I): GetOperationResponse {
    return GetOperationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOperationResponse>, I>>(object: I): GetOperationResponse {
    const message = createBaseGetOperationResponse();
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? OperationCashback.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseListOperationsRequest(): ListOperationsRequest {
  return {
    organisationId: "",
    clientId: undefined,
    contratId: undefined,
    statut: undefined,
    type: undefined,
    search: undefined,
    pagination: undefined,
  };
}

export const ListOperationsRequest: MessageFns<ListOperationsRequest> = {
  encode(message: ListOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(18).string(message.clientId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(26).string(message.contratId);
    }
    if (message.statut !== undefined) {
      writer.uint32(32).int32(message.statut);
    }
    if (message.type !== undefined) {
      writer.uint32(40).int32(message.type);
    }
    if (message.search !== undefined) {
      writer.uint32(50).string(message.search);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.statut = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      contratId: isSet(object.contratId)
        ? globalThis.String(object.contratId)
        : isSet(object.contrat_id)
        ? globalThis.String(object.contrat_id)
        : undefined,
      statut: isSet(object.statut) ? statutOperationFromJSON(object.statut) : undefined,
      type: isSet(object.type) ? typeOperationFromJSON(object.type) : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : undefined,
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListOperationsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.statut !== undefined) {
      obj.statut = statutOperationToJSON(message.statut);
    }
    if (message.type !== undefined) {
      obj.type = typeOperationToJSON(message.type);
    }
    if (message.search !== undefined) {
      obj.search = message.search;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOperationsRequest>, I>>(base?: I): ListOperationsRequest {
    return ListOperationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOperationsRequest>, I>>(object: I): ListOperationsRequest {
    const message = createBaseListOperationsRequest();
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? undefined;
    message.contratId = object.contratId ?? undefined;
    message.statut = object.statut ?? undefined;
    message.type = object.type ?? undefined;
    message.search = object.search ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListOperationsResponse(): ListOperationsResponse {
  return { operations: [], pagination: undefined, totalGains: 0, totalUtilise: 0, soldeDisponible: 0 };
}

export const ListOperationsResponse: MessageFns<ListOperationsResponse> = {
  encode(message: ListOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      OperationCashback.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.totalGains !== 0) {
      writer.uint32(25).double(message.totalGains);
    }
    if (message.totalUtilise !== 0) {
      writer.uint32(33).double(message.totalUtilise);
    }
    if (message.soldeDisponible !== 0) {
      writer.uint32(41).double(message.soldeDisponible);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operations.push(OperationCashback.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.totalGains = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.totalUtilise = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.soldeDisponible = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsResponse {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => OperationCashback.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
      totalGains: isSet(object.totalGains)
        ? globalThis.Number(object.totalGains)
        : isSet(object.total_gains)
        ? globalThis.Number(object.total_gains)
        : 0,
      totalUtilise: isSet(object.totalUtilise)
        ? globalThis.Number(object.totalUtilise)
        : isSet(object.total_utilise)
        ? globalThis.Number(object.total_utilise)
        : 0,
      soldeDisponible: isSet(object.soldeDisponible)
        ? globalThis.Number(object.soldeDisponible)
        : isSet(object.solde_disponible)
        ? globalThis.Number(object.solde_disponible)
        : 0,
    };
  },

  toJSON(message: ListOperationsResponse): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => OperationCashback.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    if (message.totalGains !== 0) {
      obj.totalGains = message.totalGains;
    }
    if (message.totalUtilise !== 0) {
      obj.totalUtilise = message.totalUtilise;
    }
    if (message.soldeDisponible !== 0) {
      obj.soldeDisponible = message.soldeDisponible;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOperationsResponse>, I>>(base?: I): ListOperationsResponse {
    return ListOperationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOperationsResponse>, I>>(object: I): ListOperationsResponse {
    const message = createBaseListOperationsResponse();
    message.operations = object.operations?.map((e) => OperationCashback.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    message.totalGains = object.totalGains ?? 0;
    message.totalUtilise = object.totalUtilise ?? 0;
    message.soldeDisponible = object.soldeDisponible ?? 0;
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      sortBy: isSet(object.sortBy)
        ? globalThis.String(object.sortBy)
        : isSet(object.sort_by)
        ? globalThis.String(object.sort_by)
        : "",
      sortOrder: isSet(object.sortOrder)
        ? globalThis.String(object.sortOrder)
        : isSet(object.sort_order)
        ? globalThis.String(object.sort_order)
        : "",
    };
  },

  toJSON(message: PaginationRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationRequest>, I>>(base?: I): PaginationRequest {
    return PaginationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationRequest>, I>>(object: I): PaginationRequest {
    const message = createBasePaginationRequest();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResponse {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: PaginationResponse): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResponse>, I>>(base?: I): PaginationResponse {
    return PaginationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResponse>, I>>(object: I): PaginationResponse {
    const message = createBasePaginationResponse();
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

export type WincashSvcService = typeof WincashSvcService;
export const WincashSvcService = {
  syncCashback: {
    path: "/wincash.WincashSvc/SyncCashback",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SyncCashbackRequest): Buffer => Buffer.from(SyncCashbackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SyncCashbackRequest => SyncCashbackRequest.decode(value),
    responseSerialize: (value: SyncCashbackResponse): Buffer =>
      Buffer.from(SyncCashbackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SyncCashbackResponse => SyncCashbackResponse.decode(value),
  },
  getOperation: {
    path: "/wincash.WincashSvc/GetOperation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOperationRequest): Buffer => Buffer.from(GetOperationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetOperationRequest => GetOperationRequest.decode(value),
    responseSerialize: (value: GetOperationResponse): Buffer =>
      Buffer.from(GetOperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetOperationResponse => GetOperationResponse.decode(value),
  },
  listOperations: {
    path: "/wincash.WincashSvc/ListOperations",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListOperationsRequest): Buffer =>
      Buffer.from(ListOperationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListOperationsRequest => ListOperationsRequest.decode(value),
    responseSerialize: (value: ListOperationsResponse): Buffer =>
      Buffer.from(ListOperationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListOperationsResponse => ListOperationsResponse.decode(value),
  },
} as const;

export interface WincashSvcServer extends UntypedServiceImplementation {
  syncCashback: handleUnaryCall<SyncCashbackRequest, SyncCashbackResponse>;
  getOperation: handleUnaryCall<GetOperationRequest, GetOperationResponse>;
  listOperations: handleUnaryCall<ListOperationsRequest, ListOperationsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
