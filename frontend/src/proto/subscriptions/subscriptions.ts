// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               unknown
// source: subscriptions/subscriptions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";

export const protobufPackage = "subscriptions";

export enum PlanType {
  PLAN_TYPE_UNSPECIFIED = 0,
  PLAN_TYPE_FREE_AVOD = 1,
  PLAN_TYPE_PREMIUM_SVOD = 2,
  PLAN_TYPE_VIP = 3,
  UNRECOGNIZED = -1,
}

export function planTypeFromJSON(object: any): PlanType {
  switch (object) {
    case 0:
    case "PLAN_TYPE_UNSPECIFIED":
      return PlanType.PLAN_TYPE_UNSPECIFIED;
    case 1:
    case "PLAN_TYPE_FREE_AVOD":
      return PlanType.PLAN_TYPE_FREE_AVOD;
    case 2:
    case "PLAN_TYPE_PREMIUM_SVOD":
      return PlanType.PLAN_TYPE_PREMIUM_SVOD;
    case 3:
    case "PLAN_TYPE_VIP":
      return PlanType.PLAN_TYPE_VIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PlanType.UNRECOGNIZED;
  }
}

export function planTypeToJSON(object: PlanType): string {
  switch (object) {
    case PlanType.PLAN_TYPE_UNSPECIFIED:
      return "PLAN_TYPE_UNSPECIFIED";
    case PlanType.PLAN_TYPE_FREE_AVOD:
      return "PLAN_TYPE_FREE_AVOD";
    case PlanType.PLAN_TYPE_PREMIUM_SVOD:
      return "PLAN_TYPE_PREMIUM_SVOD";
    case PlanType.PLAN_TYPE_VIP:
      return "PLAN_TYPE_VIP";
    case PlanType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SubscriptionStatus {
  SUBSCRIPTION_STATUS_UNSPECIFIED = 0,
  SUBSCRIPTION_STATUS_PENDING = 1,
  SUBSCRIPTION_STATUS_TRIAL = 2,
  SUBSCRIPTION_STATUS_ACTIVE = 3,
  SUBSCRIPTION_STATUS_PAUSED = 4,
  SUBSCRIPTION_STATUS_PAST_DUE = 5,
  SUBSCRIPTION_STATUS_SUSPENDED = 6,
  SUBSCRIPTION_STATUS_CANCELLED = 7,
  SUBSCRIPTION_STATUS_EXPIRED = 8,
  UNRECOGNIZED = -1,
}

export function subscriptionStatusFromJSON(object: any): SubscriptionStatus {
  switch (object) {
    case 0:
    case "SUBSCRIPTION_STATUS_UNSPECIFIED":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_UNSPECIFIED;
    case 1:
    case "SUBSCRIPTION_STATUS_PENDING":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_PENDING;
    case 2:
    case "SUBSCRIPTION_STATUS_TRIAL":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_TRIAL;
    case 3:
    case "SUBSCRIPTION_STATUS_ACTIVE":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_ACTIVE;
    case 4:
    case "SUBSCRIPTION_STATUS_PAUSED":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_PAUSED;
    case 5:
    case "SUBSCRIPTION_STATUS_PAST_DUE":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_PAST_DUE;
    case 6:
    case "SUBSCRIPTION_STATUS_SUSPENDED":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_SUSPENDED;
    case 7:
    case "SUBSCRIPTION_STATUS_CANCELLED":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_CANCELLED;
    case 8:
    case "SUBSCRIPTION_STATUS_EXPIRED":
      return SubscriptionStatus.SUBSCRIPTION_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubscriptionStatus.UNRECOGNIZED;
  }
}

export function subscriptionStatusToJSON(object: SubscriptionStatus): string {
  switch (object) {
    case SubscriptionStatus.SUBSCRIPTION_STATUS_UNSPECIFIED:
      return "SUBSCRIPTION_STATUS_UNSPECIFIED";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_PENDING:
      return "SUBSCRIPTION_STATUS_PENDING";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_TRIAL:
      return "SUBSCRIPTION_STATUS_TRIAL";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_ACTIVE:
      return "SUBSCRIPTION_STATUS_ACTIVE";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_PAUSED:
      return "SUBSCRIPTION_STATUS_PAUSED";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_PAST_DUE:
      return "SUBSCRIPTION_STATUS_PAST_DUE";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_SUSPENDED:
      return "SUBSCRIPTION_STATUS_SUSPENDED";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_CANCELLED:
      return "SUBSCRIPTION_STATUS_CANCELLED";
    case SubscriptionStatus.SUBSCRIPTION_STATUS_EXPIRED:
      return "SUBSCRIPTION_STATUS_EXPIRED";
    case SubscriptionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SubscriptionFrequency {
  SUBSCRIPTION_FREQUENCY_UNSPECIFIED = 0,
  SUBSCRIPTION_FREQUENCY_MONTHLY = 1,
  SUBSCRIPTION_FREQUENCY_ANNUAL = 2,
  UNRECOGNIZED = -1,
}

export function subscriptionFrequencyFromJSON(object: any): SubscriptionFrequency {
  switch (object) {
    case 0:
    case "SUBSCRIPTION_FREQUENCY_UNSPECIFIED":
      return SubscriptionFrequency.SUBSCRIPTION_FREQUENCY_UNSPECIFIED;
    case 1:
    case "SUBSCRIPTION_FREQUENCY_MONTHLY":
      return SubscriptionFrequency.SUBSCRIPTION_FREQUENCY_MONTHLY;
    case 2:
    case "SUBSCRIPTION_FREQUENCY_ANNUAL":
      return SubscriptionFrequency.SUBSCRIPTION_FREQUENCY_ANNUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubscriptionFrequency.UNRECOGNIZED;
  }
}

export function subscriptionFrequencyToJSON(object: SubscriptionFrequency): string {
  switch (object) {
    case SubscriptionFrequency.SUBSCRIPTION_FREQUENCY_UNSPECIFIED:
      return "SUBSCRIPTION_FREQUENCY_UNSPECIFIED";
    case SubscriptionFrequency.SUBSCRIPTION_FREQUENCY_MONTHLY:
      return "SUBSCRIPTION_FREQUENCY_MONTHLY";
    case SubscriptionFrequency.SUBSCRIPTION_FREQUENCY_ANNUAL:
      return "SUBSCRIPTION_FREQUENCY_ANNUAL";
    case SubscriptionFrequency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StoreSource {
  STORE_SOURCE_UNSPECIFIED = 0,
  STORE_SOURCE_NONE = 1,
  STORE_SOURCE_WEB_DIRECT = 2,
  STORE_SOURCE_APPLE_STORE = 3,
  STORE_SOURCE_GOOGLE_STORE = 4,
  STORE_SOURCE_TV_STORE = 5,
  STORE_SOURCE_BOX = 6,
  UNRECOGNIZED = -1,
}

export function storeSourceFromJSON(object: any): StoreSource {
  switch (object) {
    case 0:
    case "STORE_SOURCE_UNSPECIFIED":
      return StoreSource.STORE_SOURCE_UNSPECIFIED;
    case 1:
    case "STORE_SOURCE_NONE":
      return StoreSource.STORE_SOURCE_NONE;
    case 2:
    case "STORE_SOURCE_WEB_DIRECT":
      return StoreSource.STORE_SOURCE_WEB_DIRECT;
    case 3:
    case "STORE_SOURCE_APPLE_STORE":
      return StoreSource.STORE_SOURCE_APPLE_STORE;
    case 4:
    case "STORE_SOURCE_GOOGLE_STORE":
      return StoreSource.STORE_SOURCE_GOOGLE_STORE;
    case 5:
    case "STORE_SOURCE_TV_STORE":
      return StoreSource.STORE_SOURCE_TV_STORE;
    case 6:
    case "STORE_SOURCE_BOX":
      return StoreSource.STORE_SOURCE_BOX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StoreSource.UNRECOGNIZED;
  }
}

export function storeSourceToJSON(object: StoreSource): string {
  switch (object) {
    case StoreSource.STORE_SOURCE_UNSPECIFIED:
      return "STORE_SOURCE_UNSPECIFIED";
    case StoreSource.STORE_SOURCE_NONE:
      return "STORE_SOURCE_NONE";
    case StoreSource.STORE_SOURCE_WEB_DIRECT:
      return "STORE_SOURCE_WEB_DIRECT";
    case StoreSource.STORE_SOURCE_APPLE_STORE:
      return "STORE_SOURCE_APPLE_STORE";
    case StoreSource.STORE_SOURCE_GOOGLE_STORE:
      return "STORE_SOURCE_GOOGLE_STORE";
    case StoreSource.STORE_SOURCE_TV_STORE:
      return "STORE_SOURCE_TV_STORE";
    case StoreSource.STORE_SOURCE_BOX:
      return "STORE_SOURCE_BOX";
    case StoreSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BillingInterval {
  BILLING_INTERVAL_UNSPECIFIED = 0,
  BILLING_INTERVAL_WEEKLY = 1,
  BILLING_INTERVAL_BIWEEKLY = 2,
  BILLING_INTERVAL_MONTHLY = 3,
  BILLING_INTERVAL_QUARTERLY = 4,
  BILLING_INTERVAL_YEARLY = 5,
  UNRECOGNIZED = -1,
}

export function billingIntervalFromJSON(object: any): BillingInterval {
  switch (object) {
    case 0:
    case "BILLING_INTERVAL_UNSPECIFIED":
      return BillingInterval.BILLING_INTERVAL_UNSPECIFIED;
    case 1:
    case "BILLING_INTERVAL_WEEKLY":
      return BillingInterval.BILLING_INTERVAL_WEEKLY;
    case 2:
    case "BILLING_INTERVAL_BIWEEKLY":
      return BillingInterval.BILLING_INTERVAL_BIWEEKLY;
    case 3:
    case "BILLING_INTERVAL_MONTHLY":
      return BillingInterval.BILLING_INTERVAL_MONTHLY;
    case 4:
    case "BILLING_INTERVAL_QUARTERLY":
      return BillingInterval.BILLING_INTERVAL_QUARTERLY;
    case 5:
    case "BILLING_INTERVAL_YEARLY":
      return BillingInterval.BILLING_INTERVAL_YEARLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BillingInterval.UNRECOGNIZED;
  }
}

export function billingIntervalToJSON(object: BillingInterval): string {
  switch (object) {
    case BillingInterval.BILLING_INTERVAL_UNSPECIFIED:
      return "BILLING_INTERVAL_UNSPECIFIED";
    case BillingInterval.BILLING_INTERVAL_WEEKLY:
      return "BILLING_INTERVAL_WEEKLY";
    case BillingInterval.BILLING_INTERVAL_BIWEEKLY:
      return "BILLING_INTERVAL_BIWEEKLY";
    case BillingInterval.BILLING_INTERVAL_MONTHLY:
      return "BILLING_INTERVAL_MONTHLY";
    case BillingInterval.BILLING_INTERVAL_QUARTERLY:
      return "BILLING_INTERVAL_QUARTERLY";
    case BillingInterval.BILLING_INTERVAL_YEARLY:
      return "BILLING_INTERVAL_YEARLY";
    case BillingInterval.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TriggeredBy {
  TRIGGERED_BY_UNSPECIFIED = 0,
  TRIGGERED_BY_USER = 1,
  TRIGGERED_BY_SYSTEM = 2,
  TRIGGERED_BY_IMS = 3,
  TRIGGERED_BY_STORE = 4,
  TRIGGERED_BY_DUNNING = 5,
  UNRECOGNIZED = -1,
}

export function triggeredByFromJSON(object: any): TriggeredBy {
  switch (object) {
    case 0:
    case "TRIGGERED_BY_UNSPECIFIED":
      return TriggeredBy.TRIGGERED_BY_UNSPECIFIED;
    case 1:
    case "TRIGGERED_BY_USER":
      return TriggeredBy.TRIGGERED_BY_USER;
    case 2:
    case "TRIGGERED_BY_SYSTEM":
      return TriggeredBy.TRIGGERED_BY_SYSTEM;
    case 3:
    case "TRIGGERED_BY_IMS":
      return TriggeredBy.TRIGGERED_BY_IMS;
    case 4:
    case "TRIGGERED_BY_STORE":
      return TriggeredBy.TRIGGERED_BY_STORE;
    case 5:
    case "TRIGGERED_BY_DUNNING":
      return TriggeredBy.TRIGGERED_BY_DUNNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TriggeredBy.UNRECOGNIZED;
  }
}

export function triggeredByToJSON(object: TriggeredBy): string {
  switch (object) {
    case TriggeredBy.TRIGGERED_BY_UNSPECIFIED:
      return "TRIGGERED_BY_UNSPECIFIED";
    case TriggeredBy.TRIGGERED_BY_USER:
      return "TRIGGERED_BY_USER";
    case TriggeredBy.TRIGGERED_BY_SYSTEM:
      return "TRIGGERED_BY_SYSTEM";
    case TriggeredBy.TRIGGERED_BY_IMS:
      return "TRIGGERED_BY_IMS";
    case TriggeredBy.TRIGGERED_BY_STORE:
      return "TRIGGERED_BY_STORE";
    case TriggeredBy.TRIGGERED_BY_DUNNING:
      return "TRIGGERED_BY_DUNNING";
    case TriggeredBy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SubscriptionPlan {
  id: string;
  organisationId: string;
  /** FREE_AVOD, PREMIUM_SVOD, VIP */
  code: string;
  name: string;
  description: string;
  planType: PlanType;
  priceMonthly: number;
  priceAnnual: number;
  currency: string;
  billingInterval: BillingInterval;
  billingCycleDays: number;
  /** 0 = no trial */
  trialDays: number;
  /** JSON string for plan features */
  features: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateSubscriptionPlanRequest {
  organisationId: string;
  code: string;
  name: string;
  description: string;
  planType: PlanType;
  priceMonthly: number;
  priceAnnual: number;
  currency: string;
  billingInterval: BillingInterval;
  billingCycleDays: number;
  trialDays: number;
  features: string;
}

export interface UpdateSubscriptionPlanRequest {
  id: string;
  name?: string | undefined;
  description?: string | undefined;
  priceMonthly?: number | undefined;
  priceAnnual?: number | undefined;
  currency?: string | undefined;
  billingInterval?: BillingInterval | undefined;
  billingCycleDays?: number | undefined;
  trialDays?: number | undefined;
  features?: string | undefined;
  isActive?: boolean | undefined;
}

export interface ListSubscriptionPlanRequest {
  pagination: Pagination | undefined;
}

export interface ListSubscriptionPlanResponse {
  plans: SubscriptionPlan[];
  pagination: PaginationResult | undefined;
}

export interface Subscription {
  id: string;
  organisationId: string;
  clientId: string;
  planId: string;
  planType: PlanType;
  status: SubscriptionStatus;
  frequency: SubscriptionFrequency;
  trialStart: string;
  trialEnd: string;
  currentPeriodStart: string;
  currentPeriodEnd: string;
  nextChargeAt: string;
  amount: number;
  currency: string;
  storeSource: StoreSource;
  imsSubscriptionId?: string | undefined;
  couponId?: string | undefined;
  cancelAtPeriodEnd: boolean;
  cancelledAt?: string | undefined;
  suspendedAt?: string | undefined;
  suspensionReason?:
    | string
    | undefined;
  /** JSON string for add-ons */
  addOns: string;
  startDate: string;
  endDate?: string | undefined;
  pauseDate?: string | undefined;
  resumeDate?: string | undefined;
  cancellationReason?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface CreateSubscriptionRequest {
  organisationId: string;
  clientId: string;
  planId: string;
  planType: PlanType;
  frequency: SubscriptionFrequency;
  storeSource: StoreSource;
  startDate: string;
  imsSubscriptionId?: string | undefined;
  couponId?: string | undefined;
  cancellationReason?: string | undefined;
}

export interface UpdateSubscriptionRequest {
  id: string;
  planId?: string | undefined;
  planType?: PlanType | undefined;
  frequency?: SubscriptionFrequency | undefined;
  startDate?: string | undefined;
  endDate?: string | undefined;
  addOns?: string | undefined;
  cancelAtPeriodEnd?: boolean | undefined;
}

export interface ActivateSubscriptionRequest {
  id: string;
  triggeredBy: TriggeredBy;
}

export interface PauseSubscriptionRequest {
  id: string;
  reason?: string | undefined;
  triggeredBy: TriggeredBy;
}

export interface ResumeSubscriptionRequest {
  id: string;
  triggeredBy: TriggeredBy;
}

export interface CancelSubscriptionRequest {
  id: string;
  reason?: string | undefined;
  triggeredBy: TriggeredBy;
}

export interface SuspendSubscriptionRequest {
  id: string;
  reason?: string | undefined;
  triggeredBy: TriggeredBy;
}

export interface ReactivateSubscriptionRequest {
  id: string;
  triggeredBy: TriggeredBy;
}

export interface ExpireSubscriptionRequest {
  id: string;
}

export interface GetDueForChargeRequest {
  organisationId: string;
  beforeDate?: string | undefined;
}

export interface GetDueForTrialConversionRequest {
  organisationId: string;
}

export interface ListSubscriptionRequest {
  organisationId: string;
  clientId?: string | undefined;
  planId?: string | undefined;
  status?: SubscriptionStatus | undefined;
  storeSource?: StoreSource | undefined;
  planType?: PlanType | undefined;
  search?: string | undefined;
  pagination: Pagination | undefined;
}

export interface ListSubscriptionResponse {
  subscriptions: Subscription[];
  pagination: PaginationResult | undefined;
}

export interface ListByClientRequest {
  clientId: string;
  pagination: Pagination | undefined;
}

export interface ListByPlanRequest {
  planId: string;
  pagination: Pagination | undefined;
}

/** ========== SUBSCRIPTION CYCLE ========== */
export interface SubscriptionCycle {
  id: string;
  subscriptionId: string;
  cycleNumber: number;
  startDate: string;
  endDate: string;
  amount: number;
  currency: string;
  status: string;
  invoiceId?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

/** ========== SUBSCRIPTION STATUS HISTORY ========== */
export interface SubscriptionStatusHistory {
  id: string;
  subscriptionId: string;
  oldStatus: SubscriptionStatus;
  newStatus: SubscriptionStatus;
  changedAt: string;
  reason?: string | undefined;
  triggeredBy: TriggeredBy;
  /** JSON string for extra context */
  metadata: string;
  createdAt: string;
}

export interface PreferenceSchema {
  id: string;
  organisationId: string;
  name: string;
  description: string;
  fields: PreferenceField[];
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface PreferenceField {
  name: string;
  /** string, number, boolean, enum, date */
  type: string;
  label: string;
  required: boolean;
  defaultValue?: string | undefined;
  enumValues: string[];
}

export interface CreatePreferenceSchemaRequest {
  organisationId: string;
  name: string;
  description: string;
  fields: PreferenceField[];
}

export interface UpdatePreferenceSchemaRequest {
  id: string;
  name?: string | undefined;
  description?: string | undefined;
  fields: PreferenceField[];
  isActive?: boolean | undefined;
}

export interface ListPreferenceSchemaRequest {
  pagination: Pagination | undefined;
}

export interface ListPreferenceSchemaResponse {
  schemas: PreferenceSchema[];
  pagination: PaginationResult | undefined;
}

export interface Preference {
  id: string;
  subscriptionId: string;
  schemaId: string;
  values: { [key: string]: string };
  createdAt: string;
  updatedAt: string;
}

export interface Preference_ValuesEntry {
  key: string;
  value: string;
}

export interface CreatePreferenceRequest {
  subscriptionId: string;
  schemaId: string;
  values: { [key: string]: string };
}

export interface CreatePreferenceRequest_ValuesEntry {
  key: string;
  value: string;
}

export interface UpdatePreferenceRequest {
  id: string;
  values: { [key: string]: string };
}

export interface UpdatePreferenceRequest_ValuesEntry {
  key: string;
  value: string;
}

export interface ListPreferenceRequest {
  pagination: Pagination | undefined;
}

export interface ListPreferenceResponse {
  preferences: Preference[];
  pagination: PaginationResult | undefined;
}

export interface GetBySubscriptionRequest {
  subscriptionId: string;
}

export interface PreferenceHistoryEntry {
  id: string;
  preferenceId: string;
  oldValues: { [key: string]: string };
  newValues: { [key: string]: string };
  changedAt: string;
  createdAt: string;
}

export interface PreferenceHistoryEntry_OldValuesEntry {
  key: string;
  value: string;
}

export interface PreferenceHistoryEntry_NewValuesEntry {
  key: string;
  value: string;
}

export interface WooCommerceMapping {
  id: string;
  organisationId: string;
  woocommerceStoreId: string;
  subscriptionPlanId: string;
  woocommerceProductId: string;
  woocommerceSubscriptionId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateWooCommerceMappingRequest {
  organisationId: string;
  woocommerceStoreId: string;
  subscriptionPlanId: string;
  woocommerceProductId: string;
}

export interface UpdateWooCommerceMappingRequest {
  id: string;
  woocommerceProductId?: string | undefined;
  isActive?: boolean | undefined;
}

export interface ListWooCommerceMappingRequest {
  pagination: Pagination | undefined;
}

export interface ListWooCommerceMappingResponse {
  mappings: WooCommerceMapping[];
  pagination: PaginationResult | undefined;
}

export interface WooCommerceWebhookEvent {
  id: string;
  organisationId: string;
  /** subscription.created, subscription.updated, subscription.deleted, etc. */
  eventType: string;
  woocommerceSubscriptionId: string;
  /** JSON string */
  rawPayload: string;
  receivedAt: string;
  processed: boolean;
  processedAt?: string | undefined;
  errorMessage?: string | undefined;
}

export interface ProcessWooCommerceWebhookRequest {
  organisationId: string;
  eventType: string;
  /** JSON string */
  rawPayload: string;
}

export interface WooCommerceWebhookResponse {
  success: boolean;
  message?: string | undefined;
  subscriptionId?: string | undefined;
}

export interface WooCommerceConfig {
  id: string;
  organisationId: string;
  woocommerceStoreId: string;
  apiKey: string;
  apiSecret: string;
  webhookUrl: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface GetWooCommerceConfigRequest {
  organisationId: string;
  woocommerceStoreId: string;
}

export interface UpdateWooCommerceConfigRequest {
  id: string;
  apiKey?: string | undefined;
  apiSecret?: string | undefined;
  webhookUrl?: string | undefined;
  isActive?: boolean | undefined;
}

export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface GetByIdRequest {
  id: string;
}

export interface DeleteByIdRequest {
  id: string;
}

export interface DeleteResponse {
  success: boolean;
}

export interface ListByOrganisationRequest {
  organisationId: string;
  pagination: Pagination | undefined;
}

function createBaseSubscriptionPlan(): SubscriptionPlan {
  return {
    id: "",
    organisationId: "",
    code: "",
    name: "",
    description: "",
    planType: 0,
    priceMonthly: 0,
    priceAnnual: 0,
    currency: "",
    billingInterval: 0,
    billingCycleDays: 0,
    trialDays: 0,
    features: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const SubscriptionPlan: MessageFns<SubscriptionPlan> = {
  encode(message: SubscriptionPlan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.planType !== 0) {
      writer.uint32(48).int32(message.planType);
    }
    if (message.priceMonthly !== 0) {
      writer.uint32(57).double(message.priceMonthly);
    }
    if (message.priceAnnual !== 0) {
      writer.uint32(65).double(message.priceAnnual);
    }
    if (message.currency !== "") {
      writer.uint32(74).string(message.currency);
    }
    if (message.billingInterval !== 0) {
      writer.uint32(80).int32(message.billingInterval);
    }
    if (message.billingCycleDays !== 0) {
      writer.uint32(88).int32(message.billingCycleDays);
    }
    if (message.trialDays !== 0) {
      writer.uint32(96).int32(message.trialDays);
    }
    if (message.features !== "") {
      writer.uint32(106).string(message.features);
    }
    if (message.isActive !== false) {
      writer.uint32(112).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionPlan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.planType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.priceMonthly = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.priceAnnual = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.billingInterval = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.billingCycleDays = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.trialDays = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.features = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionPlan {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      planType: isSet(object.planType)
        ? planTypeFromJSON(object.planType)
        : isSet(object.plan_type)
        ? planTypeFromJSON(object.plan_type)
        : 0,
      priceMonthly: isSet(object.priceMonthly)
        ? globalThis.Number(object.priceMonthly)
        : isSet(object.price_monthly)
        ? globalThis.Number(object.price_monthly)
        : 0,
      priceAnnual: isSet(object.priceAnnual)
        ? globalThis.Number(object.priceAnnual)
        : isSet(object.price_annual)
        ? globalThis.Number(object.price_annual)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      billingInterval: isSet(object.billingInterval)
        ? billingIntervalFromJSON(object.billingInterval)
        : isSet(object.billing_interval)
        ? billingIntervalFromJSON(object.billing_interval)
        : 0,
      billingCycleDays: isSet(object.billingCycleDays)
        ? globalThis.Number(object.billingCycleDays)
        : isSet(object.billing_cycle_days)
        ? globalThis.Number(object.billing_cycle_days)
        : 0,
      trialDays: isSet(object.trialDays)
        ? globalThis.Number(object.trialDays)
        : isSet(object.trial_days)
        ? globalThis.Number(object.trial_days)
        : 0,
      features: isSet(object.features) ? globalThis.String(object.features) : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: SubscriptionPlan): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.planType !== 0) {
      obj.planType = planTypeToJSON(message.planType);
    }
    if (message.priceMonthly !== 0) {
      obj.priceMonthly = message.priceMonthly;
    }
    if (message.priceAnnual !== 0) {
      obj.priceAnnual = message.priceAnnual;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.billingInterval !== 0) {
      obj.billingInterval = billingIntervalToJSON(message.billingInterval);
    }
    if (message.billingCycleDays !== 0) {
      obj.billingCycleDays = Math.round(message.billingCycleDays);
    }
    if (message.trialDays !== 0) {
      obj.trialDays = Math.round(message.trialDays);
    }
    if (message.features !== "") {
      obj.features = message.features;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionPlan>, I>>(base?: I): SubscriptionPlan {
    return SubscriptionPlan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionPlan>, I>>(object: I): SubscriptionPlan {
    const message = createBaseSubscriptionPlan();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.planType = object.planType ?? 0;
    message.priceMonthly = object.priceMonthly ?? 0;
    message.priceAnnual = object.priceAnnual ?? 0;
    message.currency = object.currency ?? "";
    message.billingInterval = object.billingInterval ?? 0;
    message.billingCycleDays = object.billingCycleDays ?? 0;
    message.trialDays = object.trialDays ?? 0;
    message.features = object.features ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateSubscriptionPlanRequest(): CreateSubscriptionPlanRequest {
  return {
    organisationId: "",
    code: "",
    name: "",
    description: "",
    planType: 0,
    priceMonthly: 0,
    priceAnnual: 0,
    currency: "",
    billingInterval: 0,
    billingCycleDays: 0,
    trialDays: 0,
    features: "",
  };
}

export const CreateSubscriptionPlanRequest: MessageFns<CreateSubscriptionPlanRequest> = {
  encode(message: CreateSubscriptionPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.planType !== 0) {
      writer.uint32(40).int32(message.planType);
    }
    if (message.priceMonthly !== 0) {
      writer.uint32(49).double(message.priceMonthly);
    }
    if (message.priceAnnual !== 0) {
      writer.uint32(57).double(message.priceAnnual);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.billingInterval !== 0) {
      writer.uint32(72).int32(message.billingInterval);
    }
    if (message.billingCycleDays !== 0) {
      writer.uint32(80).int32(message.billingCycleDays);
    }
    if (message.trialDays !== 0) {
      writer.uint32(88).int32(message.trialDays);
    }
    if (message.features !== "") {
      writer.uint32(98).string(message.features);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubscriptionPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubscriptionPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.planType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.priceMonthly = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.priceAnnual = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.billingInterval = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.billingCycleDays = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.trialDays = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.features = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubscriptionPlanRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      planType: isSet(object.planType)
        ? planTypeFromJSON(object.planType)
        : isSet(object.plan_type)
        ? planTypeFromJSON(object.plan_type)
        : 0,
      priceMonthly: isSet(object.priceMonthly)
        ? globalThis.Number(object.priceMonthly)
        : isSet(object.price_monthly)
        ? globalThis.Number(object.price_monthly)
        : 0,
      priceAnnual: isSet(object.priceAnnual)
        ? globalThis.Number(object.priceAnnual)
        : isSet(object.price_annual)
        ? globalThis.Number(object.price_annual)
        : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      billingInterval: isSet(object.billingInterval)
        ? billingIntervalFromJSON(object.billingInterval)
        : isSet(object.billing_interval)
        ? billingIntervalFromJSON(object.billing_interval)
        : 0,
      billingCycleDays: isSet(object.billingCycleDays)
        ? globalThis.Number(object.billingCycleDays)
        : isSet(object.billing_cycle_days)
        ? globalThis.Number(object.billing_cycle_days)
        : 0,
      trialDays: isSet(object.trialDays)
        ? globalThis.Number(object.trialDays)
        : isSet(object.trial_days)
        ? globalThis.Number(object.trial_days)
        : 0,
      features: isSet(object.features) ? globalThis.String(object.features) : "",
    };
  },

  toJSON(message: CreateSubscriptionPlanRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.planType !== 0) {
      obj.planType = planTypeToJSON(message.planType);
    }
    if (message.priceMonthly !== 0) {
      obj.priceMonthly = message.priceMonthly;
    }
    if (message.priceAnnual !== 0) {
      obj.priceAnnual = message.priceAnnual;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.billingInterval !== 0) {
      obj.billingInterval = billingIntervalToJSON(message.billingInterval);
    }
    if (message.billingCycleDays !== 0) {
      obj.billingCycleDays = Math.round(message.billingCycleDays);
    }
    if (message.trialDays !== 0) {
      obj.trialDays = Math.round(message.trialDays);
    }
    if (message.features !== "") {
      obj.features = message.features;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSubscriptionPlanRequest>, I>>(base?: I): CreateSubscriptionPlanRequest {
    return CreateSubscriptionPlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSubscriptionPlanRequest>, I>>(
    object: I,
  ): CreateSubscriptionPlanRequest {
    const message = createBaseCreateSubscriptionPlanRequest();
    message.organisationId = object.organisationId ?? "";
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.planType = object.planType ?? 0;
    message.priceMonthly = object.priceMonthly ?? 0;
    message.priceAnnual = object.priceAnnual ?? 0;
    message.currency = object.currency ?? "";
    message.billingInterval = object.billingInterval ?? 0;
    message.billingCycleDays = object.billingCycleDays ?? 0;
    message.trialDays = object.trialDays ?? 0;
    message.features = object.features ?? "";
    return message;
  },
};

function createBaseUpdateSubscriptionPlanRequest(): UpdateSubscriptionPlanRequest {
  return {
    id: "",
    name: undefined,
    description: undefined,
    priceMonthly: undefined,
    priceAnnual: undefined,
    currency: undefined,
    billingInterval: undefined,
    billingCycleDays: undefined,
    trialDays: undefined,
    features: undefined,
    isActive: undefined,
  };
}

export const UpdateSubscriptionPlanRequest: MessageFns<UpdateSubscriptionPlanRequest> = {
  encode(message: UpdateSubscriptionPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.priceMonthly !== undefined) {
      writer.uint32(33).double(message.priceMonthly);
    }
    if (message.priceAnnual !== undefined) {
      writer.uint32(41).double(message.priceAnnual);
    }
    if (message.currency !== undefined) {
      writer.uint32(50).string(message.currency);
    }
    if (message.billingInterval !== undefined) {
      writer.uint32(56).int32(message.billingInterval);
    }
    if (message.billingCycleDays !== undefined) {
      writer.uint32(64).int32(message.billingCycleDays);
    }
    if (message.trialDays !== undefined) {
      writer.uint32(72).int32(message.trialDays);
    }
    if (message.features !== undefined) {
      writer.uint32(82).string(message.features);
    }
    if (message.isActive !== undefined) {
      writer.uint32(88).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscriptionPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.priceMonthly = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.priceAnnual = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.billingInterval = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.billingCycleDays = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.trialDays = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.features = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptionPlanRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      priceMonthly: isSet(object.priceMonthly)
        ? globalThis.Number(object.priceMonthly)
        : isSet(object.price_monthly)
        ? globalThis.Number(object.price_monthly)
        : undefined,
      priceAnnual: isSet(object.priceAnnual)
        ? globalThis.Number(object.priceAnnual)
        : isSet(object.price_annual)
        ? globalThis.Number(object.price_annual)
        : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : undefined,
      billingInterval: isSet(object.billingInterval)
        ? billingIntervalFromJSON(object.billingInterval)
        : isSet(object.billing_interval)
        ? billingIntervalFromJSON(object.billing_interval)
        : undefined,
      billingCycleDays: isSet(object.billingCycleDays)
        ? globalThis.Number(object.billingCycleDays)
        : isSet(object.billing_cycle_days)
        ? globalThis.Number(object.billing_cycle_days)
        : undefined,
      trialDays: isSet(object.trialDays)
        ? globalThis.Number(object.trialDays)
        : isSet(object.trial_days)
        ? globalThis.Number(object.trial_days)
        : undefined,
      features: isSet(object.features) ? globalThis.String(object.features) : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
    };
  },

  toJSON(message: UpdateSubscriptionPlanRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.priceMonthly !== undefined) {
      obj.priceMonthly = message.priceMonthly;
    }
    if (message.priceAnnual !== undefined) {
      obj.priceAnnual = message.priceAnnual;
    }
    if (message.currency !== undefined) {
      obj.currency = message.currency;
    }
    if (message.billingInterval !== undefined) {
      obj.billingInterval = billingIntervalToJSON(message.billingInterval);
    }
    if (message.billingCycleDays !== undefined) {
      obj.billingCycleDays = Math.round(message.billingCycleDays);
    }
    if (message.trialDays !== undefined) {
      obj.trialDays = Math.round(message.trialDays);
    }
    if (message.features !== undefined) {
      obj.features = message.features;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubscriptionPlanRequest>, I>>(base?: I): UpdateSubscriptionPlanRequest {
    return UpdateSubscriptionPlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubscriptionPlanRequest>, I>>(
    object: I,
  ): UpdateSubscriptionPlanRequest {
    const message = createBaseUpdateSubscriptionPlanRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.priceMonthly = object.priceMonthly ?? undefined;
    message.priceAnnual = object.priceAnnual ?? undefined;
    message.currency = object.currency ?? undefined;
    message.billingInterval = object.billingInterval ?? undefined;
    message.billingCycleDays = object.billingCycleDays ?? undefined;
    message.trialDays = object.trialDays ?? undefined;
    message.features = object.features ?? undefined;
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

function createBaseListSubscriptionPlanRequest(): ListSubscriptionPlanRequest {
  return { pagination: undefined };
}

export const ListSubscriptionPlanRequest: MessageFns<ListSubscriptionPlanRequest> = {
  encode(message: ListSubscriptionPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionPlanRequest {
    return { pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListSubscriptionPlanRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionPlanRequest>, I>>(base?: I): ListSubscriptionPlanRequest {
    return ListSubscriptionPlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionPlanRequest>, I>>(object: I): ListSubscriptionPlanRequest {
    const message = createBaseListSubscriptionPlanRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSubscriptionPlanResponse(): ListSubscriptionPlanResponse {
  return { plans: [], pagination: undefined };
}

export const ListSubscriptionPlanResponse: MessageFns<ListSubscriptionPlanResponse> = {
  encode(message: ListSubscriptionPlanResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.plans) {
      SubscriptionPlan.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionPlanResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionPlanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plans.push(SubscriptionPlan.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionPlanResponse {
    return {
      plans: globalThis.Array.isArray(object?.plans) ? object.plans.map((e: any) => SubscriptionPlan.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSubscriptionPlanResponse): unknown {
    const obj: any = {};
    if (message.plans?.length) {
      obj.plans = message.plans.map((e) => SubscriptionPlan.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionPlanResponse>, I>>(base?: I): ListSubscriptionPlanResponse {
    return ListSubscriptionPlanResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionPlanResponse>, I>>(object: I): ListSubscriptionPlanResponse {
    const message = createBaseListSubscriptionPlanResponse();
    message.plans = object.plans?.map((e) => SubscriptionPlan.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSubscription(): Subscription {
  return {
    id: "",
    organisationId: "",
    clientId: "",
    planId: "",
    planType: 0,
    status: 0,
    frequency: 0,
    trialStart: "",
    trialEnd: "",
    currentPeriodStart: "",
    currentPeriodEnd: "",
    nextChargeAt: "",
    amount: 0,
    currency: "",
    storeSource: 0,
    imsSubscriptionId: undefined,
    couponId: undefined,
    cancelAtPeriodEnd: false,
    cancelledAt: undefined,
    suspendedAt: undefined,
    suspensionReason: undefined,
    addOns: "",
    startDate: "",
    endDate: undefined,
    pauseDate: undefined,
    resumeDate: undefined,
    cancellationReason: undefined,
    createdAt: "",
    updatedAt: "",
  };
}

export const Subscription: MessageFns<Subscription> = {
  encode(message: Subscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.planId !== "") {
      writer.uint32(34).string(message.planId);
    }
    if (message.planType !== 0) {
      writer.uint32(40).int32(message.planType);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.frequency !== 0) {
      writer.uint32(56).int32(message.frequency);
    }
    if (message.trialStart !== "") {
      writer.uint32(66).string(message.trialStart);
    }
    if (message.trialEnd !== "") {
      writer.uint32(74).string(message.trialEnd);
    }
    if (message.currentPeriodStart !== "") {
      writer.uint32(82).string(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== "") {
      writer.uint32(90).string(message.currentPeriodEnd);
    }
    if (message.nextChargeAt !== "") {
      writer.uint32(98).string(message.nextChargeAt);
    }
    if (message.amount !== 0) {
      writer.uint32(105).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(114).string(message.currency);
    }
    if (message.storeSource !== 0) {
      writer.uint32(120).int32(message.storeSource);
    }
    if (message.imsSubscriptionId !== undefined) {
      writer.uint32(130).string(message.imsSubscriptionId);
    }
    if (message.couponId !== undefined) {
      writer.uint32(138).string(message.couponId);
    }
    if (message.cancelAtPeriodEnd !== false) {
      writer.uint32(144).bool(message.cancelAtPeriodEnd);
    }
    if (message.cancelledAt !== undefined) {
      writer.uint32(154).string(message.cancelledAt);
    }
    if (message.suspendedAt !== undefined) {
      writer.uint32(162).string(message.suspendedAt);
    }
    if (message.suspensionReason !== undefined) {
      writer.uint32(170).string(message.suspensionReason);
    }
    if (message.addOns !== "") {
      writer.uint32(178).string(message.addOns);
    }
    if (message.startDate !== "") {
      writer.uint32(186).string(message.startDate);
    }
    if (message.endDate !== undefined) {
      writer.uint32(194).string(message.endDate);
    }
    if (message.pauseDate !== undefined) {
      writer.uint32(202).string(message.pauseDate);
    }
    if (message.resumeDate !== undefined) {
      writer.uint32(210).string(message.resumeDate);
    }
    if (message.cancellationReason !== undefined) {
      writer.uint32(218).string(message.cancellationReason);
    }
    if (message.createdAt !== "") {
      writer.uint32(226).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(234).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.planId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.planType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.frequency = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.trialStart = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.trialEnd = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currentPeriodStart = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.currentPeriodEnd = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.nextChargeAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.storeSource = reader.int32() as any;
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.imsSubscriptionId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.couponId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.cancelledAt = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.suspendedAt = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.suspensionReason = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.addOns = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.pauseDate = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.resumeDate = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.cancellationReason = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      planId: isSet(object.planId)
        ? globalThis.String(object.planId)
        : isSet(object.plan_id)
        ? globalThis.String(object.plan_id)
        : "",
      planType: isSet(object.planType)
        ? planTypeFromJSON(object.planType)
        : isSet(object.plan_type)
        ? planTypeFromJSON(object.plan_type)
        : 0,
      status: isSet(object.status) ? subscriptionStatusFromJSON(object.status) : 0,
      frequency: isSet(object.frequency) ? subscriptionFrequencyFromJSON(object.frequency) : 0,
      trialStart: isSet(object.trialStart)
        ? globalThis.String(object.trialStart)
        : isSet(object.trial_start)
        ? globalThis.String(object.trial_start)
        : "",
      trialEnd: isSet(object.trialEnd)
        ? globalThis.String(object.trialEnd)
        : isSet(object.trial_end)
        ? globalThis.String(object.trial_end)
        : "",
      currentPeriodStart: isSet(object.currentPeriodStart)
        ? globalThis.String(object.currentPeriodStart)
        : isSet(object.current_period_start)
        ? globalThis.String(object.current_period_start)
        : "",
      currentPeriodEnd: isSet(object.currentPeriodEnd)
        ? globalThis.String(object.currentPeriodEnd)
        : isSet(object.current_period_end)
        ? globalThis.String(object.current_period_end)
        : "",
      nextChargeAt: isSet(object.nextChargeAt)
        ? globalThis.String(object.nextChargeAt)
        : isSet(object.next_charge_at)
        ? globalThis.String(object.next_charge_at)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      storeSource: isSet(object.storeSource)
        ? storeSourceFromJSON(object.storeSource)
        : isSet(object.store_source)
        ? storeSourceFromJSON(object.store_source)
        : 0,
      imsSubscriptionId: isSet(object.imsSubscriptionId)
        ? globalThis.String(object.imsSubscriptionId)
        : isSet(object.ims_subscription_id)
        ? globalThis.String(object.ims_subscription_id)
        : undefined,
      couponId: isSet(object.couponId)
        ? globalThis.String(object.couponId)
        : isSet(object.coupon_id)
        ? globalThis.String(object.coupon_id)
        : undefined,
      cancelAtPeriodEnd: isSet(object.cancelAtPeriodEnd)
        ? globalThis.Boolean(object.cancelAtPeriodEnd)
        : isSet(object.cancel_at_period_end)
        ? globalThis.Boolean(object.cancel_at_period_end)
        : false,
      cancelledAt: isSet(object.cancelledAt)
        ? globalThis.String(object.cancelledAt)
        : isSet(object.cancelled_at)
        ? globalThis.String(object.cancelled_at)
        : undefined,
      suspendedAt: isSet(object.suspendedAt)
        ? globalThis.String(object.suspendedAt)
        : isSet(object.suspended_at)
        ? globalThis.String(object.suspended_at)
        : undefined,
      suspensionReason: isSet(object.suspensionReason)
        ? globalThis.String(object.suspensionReason)
        : isSet(object.suspension_reason)
        ? globalThis.String(object.suspension_reason)
        : undefined,
      addOns: isSet(object.addOns)
        ? globalThis.String(object.addOns)
        : isSet(object.add_ons)
        ? globalThis.String(object.add_ons)
        : "",
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : undefined,
      pauseDate: isSet(object.pauseDate)
        ? globalThis.String(object.pauseDate)
        : isSet(object.pause_date)
        ? globalThis.String(object.pause_date)
        : undefined,
      resumeDate: isSet(object.resumeDate)
        ? globalThis.String(object.resumeDate)
        : isSet(object.resume_date)
        ? globalThis.String(object.resume_date)
        : undefined,
      cancellationReason: isSet(object.cancellationReason)
        ? globalThis.String(object.cancellationReason)
        : isSet(object.cancellation_reason)
        ? globalThis.String(object.cancellation_reason)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: Subscription): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.planId !== "") {
      obj.planId = message.planId;
    }
    if (message.planType !== 0) {
      obj.planType = planTypeToJSON(message.planType);
    }
    if (message.status !== 0) {
      obj.status = subscriptionStatusToJSON(message.status);
    }
    if (message.frequency !== 0) {
      obj.frequency = subscriptionFrequencyToJSON(message.frequency);
    }
    if (message.trialStart !== "") {
      obj.trialStart = message.trialStart;
    }
    if (message.trialEnd !== "") {
      obj.trialEnd = message.trialEnd;
    }
    if (message.currentPeriodStart !== "") {
      obj.currentPeriodStart = message.currentPeriodStart;
    }
    if (message.currentPeriodEnd !== "") {
      obj.currentPeriodEnd = message.currentPeriodEnd;
    }
    if (message.nextChargeAt !== "") {
      obj.nextChargeAt = message.nextChargeAt;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.storeSource !== 0) {
      obj.storeSource = storeSourceToJSON(message.storeSource);
    }
    if (message.imsSubscriptionId !== undefined) {
      obj.imsSubscriptionId = message.imsSubscriptionId;
    }
    if (message.couponId !== undefined) {
      obj.couponId = message.couponId;
    }
    if (message.cancelAtPeriodEnd !== false) {
      obj.cancelAtPeriodEnd = message.cancelAtPeriodEnd;
    }
    if (message.cancelledAt !== undefined) {
      obj.cancelledAt = message.cancelledAt;
    }
    if (message.suspendedAt !== undefined) {
      obj.suspendedAt = message.suspendedAt;
    }
    if (message.suspensionReason !== undefined) {
      obj.suspensionReason = message.suspensionReason;
    }
    if (message.addOns !== "") {
      obj.addOns = message.addOns;
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== undefined) {
      obj.endDate = message.endDate;
    }
    if (message.pauseDate !== undefined) {
      obj.pauseDate = message.pauseDate;
    }
    if (message.resumeDate !== undefined) {
      obj.resumeDate = message.resumeDate;
    }
    if (message.cancellationReason !== undefined) {
      obj.cancellationReason = message.cancellationReason;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Subscription>, I>>(base?: I): Subscription {
    return Subscription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Subscription>, I>>(object: I): Subscription {
    const message = createBaseSubscription();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? "";
    message.planId = object.planId ?? "";
    message.planType = object.planType ?? 0;
    message.status = object.status ?? 0;
    message.frequency = object.frequency ?? 0;
    message.trialStart = object.trialStart ?? "";
    message.trialEnd = object.trialEnd ?? "";
    message.currentPeriodStart = object.currentPeriodStart ?? "";
    message.currentPeriodEnd = object.currentPeriodEnd ?? "";
    message.nextChargeAt = object.nextChargeAt ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.storeSource = object.storeSource ?? 0;
    message.imsSubscriptionId = object.imsSubscriptionId ?? undefined;
    message.couponId = object.couponId ?? undefined;
    message.cancelAtPeriodEnd = object.cancelAtPeriodEnd ?? false;
    message.cancelledAt = object.cancelledAt ?? undefined;
    message.suspendedAt = object.suspendedAt ?? undefined;
    message.suspensionReason = object.suspensionReason ?? undefined;
    message.addOns = object.addOns ?? "";
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? undefined;
    message.pauseDate = object.pauseDate ?? undefined;
    message.resumeDate = object.resumeDate ?? undefined;
    message.cancellationReason = object.cancellationReason ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateSubscriptionRequest(): CreateSubscriptionRequest {
  return {
    organisationId: "",
    clientId: "",
    planId: "",
    planType: 0,
    frequency: 0,
    storeSource: 0,
    startDate: "",
    imsSubscriptionId: undefined,
    couponId: undefined,
    cancellationReason: undefined,
  };
}

export const CreateSubscriptionRequest: MessageFns<CreateSubscriptionRequest> = {
  encode(message: CreateSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.planId !== "") {
      writer.uint32(26).string(message.planId);
    }
    if (message.planType !== 0) {
      writer.uint32(32).int32(message.planType);
    }
    if (message.frequency !== 0) {
      writer.uint32(40).int32(message.frequency);
    }
    if (message.storeSource !== 0) {
      writer.uint32(48).int32(message.storeSource);
    }
    if (message.startDate !== "") {
      writer.uint32(58).string(message.startDate);
    }
    if (message.imsSubscriptionId !== undefined) {
      writer.uint32(66).string(message.imsSubscriptionId);
    }
    if (message.couponId !== undefined) {
      writer.uint32(74).string(message.couponId);
    }
    if (message.cancellationReason !== undefined) {
      writer.uint32(82).string(message.cancellationReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.planId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.planType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.frequency = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.storeSource = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.imsSubscriptionId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.couponId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cancellationReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubscriptionRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      planId: isSet(object.planId)
        ? globalThis.String(object.planId)
        : isSet(object.plan_id)
        ? globalThis.String(object.plan_id)
        : "",
      planType: isSet(object.planType)
        ? planTypeFromJSON(object.planType)
        : isSet(object.plan_type)
        ? planTypeFromJSON(object.plan_type)
        : 0,
      frequency: isSet(object.frequency) ? subscriptionFrequencyFromJSON(object.frequency) : 0,
      storeSource: isSet(object.storeSource)
        ? storeSourceFromJSON(object.storeSource)
        : isSet(object.store_source)
        ? storeSourceFromJSON(object.store_source)
        : 0,
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      imsSubscriptionId: isSet(object.imsSubscriptionId)
        ? globalThis.String(object.imsSubscriptionId)
        : isSet(object.ims_subscription_id)
        ? globalThis.String(object.ims_subscription_id)
        : undefined,
      couponId: isSet(object.couponId)
        ? globalThis.String(object.couponId)
        : isSet(object.coupon_id)
        ? globalThis.String(object.coupon_id)
        : undefined,
      cancellationReason: isSet(object.cancellationReason)
        ? globalThis.String(object.cancellationReason)
        : isSet(object.cancellation_reason)
        ? globalThis.String(object.cancellation_reason)
        : undefined,
    };
  },

  toJSON(message: CreateSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.planId !== "") {
      obj.planId = message.planId;
    }
    if (message.planType !== 0) {
      obj.planType = planTypeToJSON(message.planType);
    }
    if (message.frequency !== 0) {
      obj.frequency = subscriptionFrequencyToJSON(message.frequency);
    }
    if (message.storeSource !== 0) {
      obj.storeSource = storeSourceToJSON(message.storeSource);
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.imsSubscriptionId !== undefined) {
      obj.imsSubscriptionId = message.imsSubscriptionId;
    }
    if (message.couponId !== undefined) {
      obj.couponId = message.couponId;
    }
    if (message.cancellationReason !== undefined) {
      obj.cancellationReason = message.cancellationReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSubscriptionRequest>, I>>(base?: I): CreateSubscriptionRequest {
    return CreateSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSubscriptionRequest>, I>>(object: I): CreateSubscriptionRequest {
    const message = createBaseCreateSubscriptionRequest();
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? "";
    message.planId = object.planId ?? "";
    message.planType = object.planType ?? 0;
    message.frequency = object.frequency ?? 0;
    message.storeSource = object.storeSource ?? 0;
    message.startDate = object.startDate ?? "";
    message.imsSubscriptionId = object.imsSubscriptionId ?? undefined;
    message.couponId = object.couponId ?? undefined;
    message.cancellationReason = object.cancellationReason ?? undefined;
    return message;
  },
};

function createBaseUpdateSubscriptionRequest(): UpdateSubscriptionRequest {
  return {
    id: "",
    planId: undefined,
    planType: undefined,
    frequency: undefined,
    startDate: undefined,
    endDate: undefined,
    addOns: undefined,
    cancelAtPeriodEnd: undefined,
  };
}

export const UpdateSubscriptionRequest: MessageFns<UpdateSubscriptionRequest> = {
  encode(message: UpdateSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.planId !== undefined) {
      writer.uint32(18).string(message.planId);
    }
    if (message.planType !== undefined) {
      writer.uint32(24).int32(message.planType);
    }
    if (message.frequency !== undefined) {
      writer.uint32(32).int32(message.frequency);
    }
    if (message.startDate !== undefined) {
      writer.uint32(42).string(message.startDate);
    }
    if (message.endDate !== undefined) {
      writer.uint32(50).string(message.endDate);
    }
    if (message.addOns !== undefined) {
      writer.uint32(58).string(message.addOns);
    }
    if (message.cancelAtPeriodEnd !== undefined) {
      writer.uint32(64).bool(message.cancelAtPeriodEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.planId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.planType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.frequency = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.addOns = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      planId: isSet(object.planId)
        ? globalThis.String(object.planId)
        : isSet(object.plan_id)
        ? globalThis.String(object.plan_id)
        : undefined,
      planType: isSet(object.planType)
        ? planTypeFromJSON(object.planType)
        : isSet(object.plan_type)
        ? planTypeFromJSON(object.plan_type)
        : undefined,
      frequency: isSet(object.frequency) ? subscriptionFrequencyFromJSON(object.frequency) : undefined,
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : undefined,
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : undefined,
      addOns: isSet(object.addOns)
        ? globalThis.String(object.addOns)
        : isSet(object.add_ons)
        ? globalThis.String(object.add_ons)
        : undefined,
      cancelAtPeriodEnd: isSet(object.cancelAtPeriodEnd)
        ? globalThis.Boolean(object.cancelAtPeriodEnd)
        : isSet(object.cancel_at_period_end)
        ? globalThis.Boolean(object.cancel_at_period_end)
        : undefined,
    };
  },

  toJSON(message: UpdateSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.planId !== undefined) {
      obj.planId = message.planId;
    }
    if (message.planType !== undefined) {
      obj.planType = planTypeToJSON(message.planType);
    }
    if (message.frequency !== undefined) {
      obj.frequency = subscriptionFrequencyToJSON(message.frequency);
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== undefined) {
      obj.endDate = message.endDate;
    }
    if (message.addOns !== undefined) {
      obj.addOns = message.addOns;
    }
    if (message.cancelAtPeriodEnd !== undefined) {
      obj.cancelAtPeriodEnd = message.cancelAtPeriodEnd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubscriptionRequest>, I>>(base?: I): UpdateSubscriptionRequest {
    return UpdateSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubscriptionRequest>, I>>(object: I): UpdateSubscriptionRequest {
    const message = createBaseUpdateSubscriptionRequest();
    message.id = object.id ?? "";
    message.planId = object.planId ?? undefined;
    message.planType = object.planType ?? undefined;
    message.frequency = object.frequency ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.endDate = object.endDate ?? undefined;
    message.addOns = object.addOns ?? undefined;
    message.cancelAtPeriodEnd = object.cancelAtPeriodEnd ?? undefined;
    return message;
  },
};

function createBaseActivateSubscriptionRequest(): ActivateSubscriptionRequest {
  return { id: "", triggeredBy: 0 };
}

export const ActivateSubscriptionRequest: MessageFns<ActivateSubscriptionRequest> = {
  encode(message: ActivateSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.triggeredBy !== 0) {
      writer.uint32(16).int32(message.triggeredBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.triggeredBy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivateSubscriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      triggeredBy: isSet(object.triggeredBy)
        ? triggeredByFromJSON(object.triggeredBy)
        : isSet(object.triggered_by)
        ? triggeredByFromJSON(object.triggered_by)
        : 0,
    };
  },

  toJSON(message: ActivateSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.triggeredBy !== 0) {
      obj.triggeredBy = triggeredByToJSON(message.triggeredBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateSubscriptionRequest>, I>>(base?: I): ActivateSubscriptionRequest {
    return ActivateSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivateSubscriptionRequest>, I>>(object: I): ActivateSubscriptionRequest {
    const message = createBaseActivateSubscriptionRequest();
    message.id = object.id ?? "";
    message.triggeredBy = object.triggeredBy ?? 0;
    return message;
  },
};

function createBasePauseSubscriptionRequest(): PauseSubscriptionRequest {
  return { id: "", reason: undefined, triggeredBy: 0 };
}

export const PauseSubscriptionRequest: MessageFns<PauseSubscriptionRequest> = {
  encode(message: PauseSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== undefined) {
      writer.uint32(18).string(message.reason);
    }
    if (message.triggeredBy !== 0) {
      writer.uint32(24).int32(message.triggeredBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.triggeredBy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseSubscriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      triggeredBy: isSet(object.triggeredBy)
        ? triggeredByFromJSON(object.triggeredBy)
        : isSet(object.triggered_by)
        ? triggeredByFromJSON(object.triggered_by)
        : 0,
    };
  },

  toJSON(message: PauseSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.triggeredBy !== 0) {
      obj.triggeredBy = triggeredByToJSON(message.triggeredBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PauseSubscriptionRequest>, I>>(base?: I): PauseSubscriptionRequest {
    return PauseSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PauseSubscriptionRequest>, I>>(object: I): PauseSubscriptionRequest {
    const message = createBasePauseSubscriptionRequest();
    message.id = object.id ?? "";
    message.reason = object.reason ?? undefined;
    message.triggeredBy = object.triggeredBy ?? 0;
    return message;
  },
};

function createBaseResumeSubscriptionRequest(): ResumeSubscriptionRequest {
  return { id: "", triggeredBy: 0 };
}

export const ResumeSubscriptionRequest: MessageFns<ResumeSubscriptionRequest> = {
  encode(message: ResumeSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.triggeredBy !== 0) {
      writer.uint32(16).int32(message.triggeredBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.triggeredBy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumeSubscriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      triggeredBy: isSet(object.triggeredBy)
        ? triggeredByFromJSON(object.triggeredBy)
        : isSet(object.triggered_by)
        ? triggeredByFromJSON(object.triggered_by)
        : 0,
    };
  },

  toJSON(message: ResumeSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.triggeredBy !== 0) {
      obj.triggeredBy = triggeredByToJSON(message.triggeredBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResumeSubscriptionRequest>, I>>(base?: I): ResumeSubscriptionRequest {
    return ResumeSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResumeSubscriptionRequest>, I>>(object: I): ResumeSubscriptionRequest {
    const message = createBaseResumeSubscriptionRequest();
    message.id = object.id ?? "";
    message.triggeredBy = object.triggeredBy ?? 0;
    return message;
  },
};

function createBaseCancelSubscriptionRequest(): CancelSubscriptionRequest {
  return { id: "", reason: undefined, triggeredBy: 0 };
}

export const CancelSubscriptionRequest: MessageFns<CancelSubscriptionRequest> = {
  encode(message: CancelSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== undefined) {
      writer.uint32(18).string(message.reason);
    }
    if (message.triggeredBy !== 0) {
      writer.uint32(24).int32(message.triggeredBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.triggeredBy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSubscriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      triggeredBy: isSet(object.triggeredBy)
        ? triggeredByFromJSON(object.triggeredBy)
        : isSet(object.triggered_by)
        ? triggeredByFromJSON(object.triggered_by)
        : 0,
    };
  },

  toJSON(message: CancelSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.triggeredBy !== 0) {
      obj.triggeredBy = triggeredByToJSON(message.triggeredBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelSubscriptionRequest>, I>>(base?: I): CancelSubscriptionRequest {
    return CancelSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelSubscriptionRequest>, I>>(object: I): CancelSubscriptionRequest {
    const message = createBaseCancelSubscriptionRequest();
    message.id = object.id ?? "";
    message.reason = object.reason ?? undefined;
    message.triggeredBy = object.triggeredBy ?? 0;
    return message;
  },
};

function createBaseSuspendSubscriptionRequest(): SuspendSubscriptionRequest {
  return { id: "", reason: undefined, triggeredBy: 0 };
}

export const SuspendSubscriptionRequest: MessageFns<SuspendSubscriptionRequest> = {
  encode(message: SuspendSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== undefined) {
      writer.uint32(18).string(message.reason);
    }
    if (message.triggeredBy !== 0) {
      writer.uint32(24).int32(message.triggeredBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuspendSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuspendSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.triggeredBy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuspendSubscriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      triggeredBy: isSet(object.triggeredBy)
        ? triggeredByFromJSON(object.triggeredBy)
        : isSet(object.triggered_by)
        ? triggeredByFromJSON(object.triggered_by)
        : 0,
    };
  },

  toJSON(message: SuspendSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.triggeredBy !== 0) {
      obj.triggeredBy = triggeredByToJSON(message.triggeredBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuspendSubscriptionRequest>, I>>(base?: I): SuspendSubscriptionRequest {
    return SuspendSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuspendSubscriptionRequest>, I>>(object: I): SuspendSubscriptionRequest {
    const message = createBaseSuspendSubscriptionRequest();
    message.id = object.id ?? "";
    message.reason = object.reason ?? undefined;
    message.triggeredBy = object.triggeredBy ?? 0;
    return message;
  },
};

function createBaseReactivateSubscriptionRequest(): ReactivateSubscriptionRequest {
  return { id: "", triggeredBy: 0 };
}

export const ReactivateSubscriptionRequest: MessageFns<ReactivateSubscriptionRequest> = {
  encode(message: ReactivateSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.triggeredBy !== 0) {
      writer.uint32(16).int32(message.triggeredBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReactivateSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReactivateSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.triggeredBy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReactivateSubscriptionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      triggeredBy: isSet(object.triggeredBy)
        ? triggeredByFromJSON(object.triggeredBy)
        : isSet(object.triggered_by)
        ? triggeredByFromJSON(object.triggered_by)
        : 0,
    };
  },

  toJSON(message: ReactivateSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.triggeredBy !== 0) {
      obj.triggeredBy = triggeredByToJSON(message.triggeredBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReactivateSubscriptionRequest>, I>>(base?: I): ReactivateSubscriptionRequest {
    return ReactivateSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReactivateSubscriptionRequest>, I>>(
    object: I,
  ): ReactivateSubscriptionRequest {
    const message = createBaseReactivateSubscriptionRequest();
    message.id = object.id ?? "";
    message.triggeredBy = object.triggeredBy ?? 0;
    return message;
  },
};

function createBaseExpireSubscriptionRequest(): ExpireSubscriptionRequest {
  return { id: "" };
}

export const ExpireSubscriptionRequest: MessageFns<ExpireSubscriptionRequest> = {
  encode(message: ExpireSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpireSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpireSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExpireSubscriptionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: ExpireSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExpireSubscriptionRequest>, I>>(base?: I): ExpireSubscriptionRequest {
    return ExpireSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExpireSubscriptionRequest>, I>>(object: I): ExpireSubscriptionRequest {
    const message = createBaseExpireSubscriptionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetDueForChargeRequest(): GetDueForChargeRequest {
  return { organisationId: "", beforeDate: undefined };
}

export const GetDueForChargeRequest: MessageFns<GetDueForChargeRequest> = {
  encode(message: GetDueForChargeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.beforeDate !== undefined) {
      writer.uint32(18).string(message.beforeDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDueForChargeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDueForChargeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDueForChargeRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      beforeDate: isSet(object.beforeDate)
        ? globalThis.String(object.beforeDate)
        : isSet(object.before_date)
        ? globalThis.String(object.before_date)
        : undefined,
    };
  },

  toJSON(message: GetDueForChargeRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.beforeDate !== undefined) {
      obj.beforeDate = message.beforeDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDueForChargeRequest>, I>>(base?: I): GetDueForChargeRequest {
    return GetDueForChargeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDueForChargeRequest>, I>>(object: I): GetDueForChargeRequest {
    const message = createBaseGetDueForChargeRequest();
    message.organisationId = object.organisationId ?? "";
    message.beforeDate = object.beforeDate ?? undefined;
    return message;
  },
};

function createBaseGetDueForTrialConversionRequest(): GetDueForTrialConversionRequest {
  return { organisationId: "" };
}

export const GetDueForTrialConversionRequest: MessageFns<GetDueForTrialConversionRequest> = {
  encode(message: GetDueForTrialConversionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDueForTrialConversionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDueForTrialConversionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDueForTrialConversionRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
    };
  },

  toJSON(message: GetDueForTrialConversionRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDueForTrialConversionRequest>, I>>(base?: I): GetDueForTrialConversionRequest {
    return GetDueForTrialConversionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDueForTrialConversionRequest>, I>>(
    object: I,
  ): GetDueForTrialConversionRequest {
    const message = createBaseGetDueForTrialConversionRequest();
    message.organisationId = object.organisationId ?? "";
    return message;
  },
};

function createBaseListSubscriptionRequest(): ListSubscriptionRequest {
  return {
    organisationId: "",
    clientId: undefined,
    planId: undefined,
    status: undefined,
    storeSource: undefined,
    planType: undefined,
    search: undefined,
    pagination: undefined,
  };
}

export const ListSubscriptionRequest: MessageFns<ListSubscriptionRequest> = {
  encode(message: ListSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(18).string(message.clientId);
    }
    if (message.planId !== undefined) {
      writer.uint32(26).string(message.planId);
    }
    if (message.status !== undefined) {
      writer.uint32(32).int32(message.status);
    }
    if (message.storeSource !== undefined) {
      writer.uint32(40).int32(message.storeSource);
    }
    if (message.planType !== undefined) {
      writer.uint32(48).int32(message.planType);
    }
    if (message.search !== undefined) {
      writer.uint32(58).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.planId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storeSource = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.planType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : undefined,
      planId: isSet(object.planId)
        ? globalThis.String(object.planId)
        : isSet(object.plan_id)
        ? globalThis.String(object.plan_id)
        : undefined,
      status: isSet(object.status) ? subscriptionStatusFromJSON(object.status) : undefined,
      storeSource: isSet(object.storeSource)
        ? storeSourceFromJSON(object.storeSource)
        : isSet(object.store_source)
        ? storeSourceFromJSON(object.store_source)
        : undefined,
      planType: isSet(object.planType)
        ? planTypeFromJSON(object.planType)
        : isSet(object.plan_type)
        ? planTypeFromJSON(object.plan_type)
        : undefined,
      search: isSet(object.search) ? globalThis.String(object.search) : undefined,
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.planId !== undefined) {
      obj.planId = message.planId;
    }
    if (message.status !== undefined) {
      obj.status = subscriptionStatusToJSON(message.status);
    }
    if (message.storeSource !== undefined) {
      obj.storeSource = storeSourceToJSON(message.storeSource);
    }
    if (message.planType !== undefined) {
      obj.planType = planTypeToJSON(message.planType);
    }
    if (message.search !== undefined) {
      obj.search = message.search;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionRequest>, I>>(base?: I): ListSubscriptionRequest {
    return ListSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionRequest>, I>>(object: I): ListSubscriptionRequest {
    const message = createBaseListSubscriptionRequest();
    message.organisationId = object.organisationId ?? "";
    message.clientId = object.clientId ?? undefined;
    message.planId = object.planId ?? undefined;
    message.status = object.status ?? undefined;
    message.storeSource = object.storeSource ?? undefined;
    message.planType = object.planType ?? undefined;
    message.search = object.search ?? undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSubscriptionResponse(): ListSubscriptionResponse {
  return { subscriptions: [], pagination: undefined };
}

export const ListSubscriptionResponse: MessageFns<ListSubscriptionResponse> = {
  encode(message: ListSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscriptions) {
      Subscription.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(Subscription.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => Subscription.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => Subscription.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSubscriptionResponse>, I>>(base?: I): ListSubscriptionResponse {
    return ListSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSubscriptionResponse>, I>>(object: I): ListSubscriptionResponse {
    const message = createBaseListSubscriptionResponse();
    message.subscriptions = object.subscriptions?.map((e) => Subscription.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListByClientRequest(): ListByClientRequest {
  return { clientId: "", pagination: undefined };
}

export const ListByClientRequest: MessageFns<ListByClientRequest> = {
  encode(message: ListByClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListByClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListByClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListByClientRequest {
    return {
      clientId: isSet(object.clientId)
        ? globalThis.String(object.clientId)
        : isSet(object.client_id)
        ? globalThis.String(object.client_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListByClientRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListByClientRequest>, I>>(base?: I): ListByClientRequest {
    return ListByClientRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListByClientRequest>, I>>(object: I): ListByClientRequest {
    const message = createBaseListByClientRequest();
    message.clientId = object.clientId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListByPlanRequest(): ListByPlanRequest {
  return { planId: "", pagination: undefined };
}

export const ListByPlanRequest: MessageFns<ListByPlanRequest> = {
  encode(message: ListByPlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.planId !== "") {
      writer.uint32(10).string(message.planId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListByPlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListByPlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.planId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListByPlanRequest {
    return {
      planId: isSet(object.planId)
        ? globalThis.String(object.planId)
        : isSet(object.plan_id)
        ? globalThis.String(object.plan_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListByPlanRequest): unknown {
    const obj: any = {};
    if (message.planId !== "") {
      obj.planId = message.planId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListByPlanRequest>, I>>(base?: I): ListByPlanRequest {
    return ListByPlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListByPlanRequest>, I>>(object: I): ListByPlanRequest {
    const message = createBaseListByPlanRequest();
    message.planId = object.planId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSubscriptionCycle(): SubscriptionCycle {
  return {
    id: "",
    subscriptionId: "",
    cycleNumber: 0,
    startDate: "",
    endDate: "",
    amount: 0,
    currency: "",
    status: "",
    invoiceId: undefined,
    createdAt: "",
    updatedAt: "",
  };
}

export const SubscriptionCycle: MessageFns<SubscriptionCycle> = {
  encode(message: SubscriptionCycle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.cycleNumber !== 0) {
      writer.uint32(24).int32(message.cycleNumber);
    }
    if (message.startDate !== "") {
      writer.uint32(34).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(42).string(message.endDate);
    }
    if (message.amount !== 0) {
      writer.uint32(49).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(66).string(message.status);
    }
    if (message.invoiceId !== undefined) {
      writer.uint32(74).string(message.invoiceId);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionCycle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionCycle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cycleNumber = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionCycle {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      cycleNumber: isSet(object.cycleNumber)
        ? globalThis.Number(object.cycleNumber)
        : isSet(object.cycle_number)
        ? globalThis.Number(object.cycle_number)
        : 0,
      startDate: isSet(object.startDate)
        ? globalThis.String(object.startDate)
        : isSet(object.start_date)
        ? globalThis.String(object.start_date)
        : "",
      endDate: isSet(object.endDate)
        ? globalThis.String(object.endDate)
        : isSet(object.end_date)
        ? globalThis.String(object.end_date)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      invoiceId: isSet(object.invoiceId)
        ? globalThis.String(object.invoiceId)
        : isSet(object.invoice_id)
        ? globalThis.String(object.invoice_id)
        : undefined,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: SubscriptionCycle): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.cycleNumber !== 0) {
      obj.cycleNumber = Math.round(message.cycleNumber);
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = message.invoiceId;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionCycle>, I>>(base?: I): SubscriptionCycle {
    return SubscriptionCycle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionCycle>, I>>(object: I): SubscriptionCycle {
    const message = createBaseSubscriptionCycle();
    message.id = object.id ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.cycleNumber = object.cycleNumber ?? 0;
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.invoiceId = object.invoiceId ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseSubscriptionStatusHistory(): SubscriptionStatusHistory {
  return {
    id: "",
    subscriptionId: "",
    oldStatus: 0,
    newStatus: 0,
    changedAt: "",
    reason: undefined,
    triggeredBy: 0,
    metadata: "",
    createdAt: "",
  };
}

export const SubscriptionStatusHistory: MessageFns<SubscriptionStatusHistory> = {
  encode(message: SubscriptionStatusHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.oldStatus !== 0) {
      writer.uint32(24).int32(message.oldStatus);
    }
    if (message.newStatus !== 0) {
      writer.uint32(32).int32(message.newStatus);
    }
    if (message.changedAt !== "") {
      writer.uint32(42).string(message.changedAt);
    }
    if (message.reason !== undefined) {
      writer.uint32(50).string(message.reason);
    }
    if (message.triggeredBy !== 0) {
      writer.uint32(56).int32(message.triggeredBy);
    }
    if (message.metadata !== "") {
      writer.uint32(66).string(message.metadata);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionStatusHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionStatusHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.oldStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.changedAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.triggeredBy = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionStatusHistory {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      oldStatus: isSet(object.oldStatus)
        ? subscriptionStatusFromJSON(object.oldStatus)
        : isSet(object.old_status)
        ? subscriptionStatusFromJSON(object.old_status)
        : 0,
      newStatus: isSet(object.newStatus)
        ? subscriptionStatusFromJSON(object.newStatus)
        : isSet(object.new_status)
        ? subscriptionStatusFromJSON(object.new_status)
        : 0,
      changedAt: isSet(object.changedAt)
        ? globalThis.String(object.changedAt)
        : isSet(object.changed_at)
        ? globalThis.String(object.changed_at)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      triggeredBy: isSet(object.triggeredBy)
        ? triggeredByFromJSON(object.triggeredBy)
        : isSet(object.triggered_by)
        ? triggeredByFromJSON(object.triggered_by)
        : 0,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
    };
  },

  toJSON(message: SubscriptionStatusHistory): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.oldStatus !== 0) {
      obj.oldStatus = subscriptionStatusToJSON(message.oldStatus);
    }
    if (message.newStatus !== 0) {
      obj.newStatus = subscriptionStatusToJSON(message.newStatus);
    }
    if (message.changedAt !== "") {
      obj.changedAt = message.changedAt;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.triggeredBy !== 0) {
      obj.triggeredBy = triggeredByToJSON(message.triggeredBy);
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscriptionStatusHistory>, I>>(base?: I): SubscriptionStatusHistory {
    return SubscriptionStatusHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscriptionStatusHistory>, I>>(object: I): SubscriptionStatusHistory {
    const message = createBaseSubscriptionStatusHistory();
    message.id = object.id ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.oldStatus = object.oldStatus ?? 0;
    message.newStatus = object.newStatus ?? 0;
    message.changedAt = object.changedAt ?? "";
    message.reason = object.reason ?? undefined;
    message.triggeredBy = object.triggeredBy ?? 0;
    message.metadata = object.metadata ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBasePreferenceSchema(): PreferenceSchema {
  return {
    id: "",
    organisationId: "",
    name: "",
    description: "",
    fields: [],
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const PreferenceSchema: MessageFns<PreferenceSchema> = {
  encode(message: PreferenceSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.fields) {
      PreferenceField.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreferenceSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferenceSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fields.push(PreferenceField.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreferenceSchema {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => PreferenceField.fromJSON(e))
        : [],
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: PreferenceSchema): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => PreferenceField.toJSON(e));
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreferenceSchema>, I>>(base?: I): PreferenceSchema {
    return PreferenceSchema.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreferenceSchema>, I>>(object: I): PreferenceSchema {
    const message = createBasePreferenceSchema();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.fields = object.fields?.map((e) => PreferenceField.fromPartial(e)) || [];
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBasePreferenceField(): PreferenceField {
  return { name: "", type: "", label: "", required: false, defaultValue: undefined, enumValues: [] };
}

export const PreferenceField: MessageFns<PreferenceField> = {
  encode(message: PreferenceField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.required !== false) {
      writer.uint32(32).bool(message.required);
    }
    if (message.defaultValue !== undefined) {
      writer.uint32(42).string(message.defaultValue);
    }
    for (const v of message.enumValues) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreferenceField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferenceField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.required = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultValue = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.enumValues.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreferenceField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      defaultValue: isSet(object.defaultValue)
        ? globalThis.String(object.defaultValue)
        : isSet(object.default_value)
        ? globalThis.String(object.default_value)
        : undefined,
      enumValues: globalThis.Array.isArray(object?.enumValues)
        ? object.enumValues.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.enum_values)
        ? object.enum_values.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PreferenceField): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    if (message.enumValues?.length) {
      obj.enumValues = message.enumValues;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreferenceField>, I>>(base?: I): PreferenceField {
    return PreferenceField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreferenceField>, I>>(object: I): PreferenceField {
    const message = createBasePreferenceField();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.label = object.label ?? "";
    message.required = object.required ?? false;
    message.defaultValue = object.defaultValue ?? undefined;
    message.enumValues = object.enumValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreatePreferenceSchemaRequest(): CreatePreferenceSchemaRequest {
  return { organisationId: "", name: "", description: "", fields: [] };
}

export const CreatePreferenceSchemaRequest: MessageFns<CreatePreferenceSchemaRequest> = {
  encode(message: CreatePreferenceSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.fields) {
      PreferenceField.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePreferenceSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePreferenceSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fields.push(PreferenceField.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePreferenceSchemaRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => PreferenceField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreatePreferenceSchemaRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => PreferenceField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePreferenceSchemaRequest>, I>>(base?: I): CreatePreferenceSchemaRequest {
    return CreatePreferenceSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePreferenceSchemaRequest>, I>>(
    object: I,
  ): CreatePreferenceSchemaRequest {
    const message = createBaseCreatePreferenceSchemaRequest();
    message.organisationId = object.organisationId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.fields = object.fields?.map((e) => PreferenceField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdatePreferenceSchemaRequest(): UpdatePreferenceSchemaRequest {
  return { id: "", name: undefined, description: undefined, fields: [], isActive: undefined };
}

export const UpdatePreferenceSchemaRequest: MessageFns<UpdatePreferenceSchemaRequest> = {
  encode(message: UpdatePreferenceSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.fields) {
      PreferenceField.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.isActive !== undefined) {
      writer.uint32(40).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePreferenceSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePreferenceSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fields.push(PreferenceField.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePreferenceSchemaRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => PreferenceField.fromJSON(e))
        : [],
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
    };
  },

  toJSON(message: UpdatePreferenceSchemaRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => PreferenceField.toJSON(e));
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePreferenceSchemaRequest>, I>>(base?: I): UpdatePreferenceSchemaRequest {
    return UpdatePreferenceSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePreferenceSchemaRequest>, I>>(
    object: I,
  ): UpdatePreferenceSchemaRequest {
    const message = createBaseUpdatePreferenceSchemaRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.fields = object.fields?.map((e) => PreferenceField.fromPartial(e)) || [];
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

function createBaseListPreferenceSchemaRequest(): ListPreferenceSchemaRequest {
  return { pagination: undefined };
}

export const ListPreferenceSchemaRequest: MessageFns<ListPreferenceSchemaRequest> = {
  encode(message: ListPreferenceSchemaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPreferenceSchemaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPreferenceSchemaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPreferenceSchemaRequest {
    return { pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListPreferenceSchemaRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPreferenceSchemaRequest>, I>>(base?: I): ListPreferenceSchemaRequest {
    return ListPreferenceSchemaRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPreferenceSchemaRequest>, I>>(object: I): ListPreferenceSchemaRequest {
    const message = createBaseListPreferenceSchemaRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListPreferenceSchemaResponse(): ListPreferenceSchemaResponse {
  return { schemas: [], pagination: undefined };
}

export const ListPreferenceSchemaResponse: MessageFns<ListPreferenceSchemaResponse> = {
  encode(message: ListPreferenceSchemaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schemas) {
      PreferenceSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPreferenceSchemaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPreferenceSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemas.push(PreferenceSchema.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPreferenceSchemaResponse {
    return {
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => PreferenceSchema.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListPreferenceSchemaResponse): unknown {
    const obj: any = {};
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => PreferenceSchema.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPreferenceSchemaResponse>, I>>(base?: I): ListPreferenceSchemaResponse {
    return ListPreferenceSchemaResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPreferenceSchemaResponse>, I>>(object: I): ListPreferenceSchemaResponse {
    const message = createBaseListPreferenceSchemaResponse();
    message.schemas = object.schemas?.map((e) => PreferenceSchema.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBasePreference(): Preference {
  return { id: "", subscriptionId: "", schemaId: "", values: {}, createdAt: "", updatedAt: "" };
}

export const Preference: MessageFns<Preference> = {
  encode(message: Preference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.schemaId !== "") {
      writer.uint32(26).string(message.schemaId);
    }
    globalThis.Object.entries(message.values).forEach(([key, value]: [string, string]) => {
      Preference_ValuesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Preference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schemaId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Preference_ValuesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.values[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Preference {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      schemaId: isSet(object.schemaId)
        ? globalThis.String(object.schemaId)
        : isSet(object.schema_id)
        ? globalThis.String(object.schema_id)
        : "",
      values: isObject(object.values)
        ? (globalThis.Object.entries(object.values) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: Preference): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.schemaId !== "") {
      obj.schemaId = message.schemaId;
    }
    if (message.values) {
      const entries = globalThis.Object.entries(message.values) as [string, string][];
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Preference>, I>>(base?: I): Preference {
    return Preference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Preference>, I>>(object: I): Preference {
    const message = createBasePreference();
    message.id = object.id ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.schemaId = object.schemaId ?? "";
    message.values = (globalThis.Object.entries(object.values ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBasePreference_ValuesEntry(): Preference_ValuesEntry {
  return { key: "", value: "" };
}

export const Preference_ValuesEntry: MessageFns<Preference_ValuesEntry> = {
  encode(message: Preference_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Preference_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreference_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Preference_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Preference_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Preference_ValuesEntry>, I>>(base?: I): Preference_ValuesEntry {
    return Preference_ValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Preference_ValuesEntry>, I>>(object: I): Preference_ValuesEntry {
    const message = createBasePreference_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreatePreferenceRequest(): CreatePreferenceRequest {
  return { subscriptionId: "", schemaId: "", values: {} };
}

export const CreatePreferenceRequest: MessageFns<CreatePreferenceRequest> = {
  encode(message: CreatePreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.schemaId !== "") {
      writer.uint32(18).string(message.schemaId);
    }
    globalThis.Object.entries(message.values).forEach(([key, value]: [string, string]) => {
      CreatePreferenceRequest_ValuesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schemaId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = CreatePreferenceRequest_ValuesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.values[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePreferenceRequest {
    return {
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
      schemaId: isSet(object.schemaId)
        ? globalThis.String(object.schemaId)
        : isSet(object.schema_id)
        ? globalThis.String(object.schema_id)
        : "",
      values: isObject(object.values)
        ? (globalThis.Object.entries(object.values) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreatePreferenceRequest): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.schemaId !== "") {
      obj.schemaId = message.schemaId;
    }
    if (message.values) {
      const entries = globalThis.Object.entries(message.values) as [string, string][];
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePreferenceRequest>, I>>(base?: I): CreatePreferenceRequest {
    return CreatePreferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePreferenceRequest>, I>>(object: I): CreatePreferenceRequest {
    const message = createBaseCreatePreferenceRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    message.schemaId = object.schemaId ?? "";
    message.values = (globalThis.Object.entries(object.values ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreatePreferenceRequest_ValuesEntry(): CreatePreferenceRequest_ValuesEntry {
  return { key: "", value: "" };
}

export const CreatePreferenceRequest_ValuesEntry: MessageFns<CreatePreferenceRequest_ValuesEntry> = {
  encode(message: CreatePreferenceRequest_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePreferenceRequest_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePreferenceRequest_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePreferenceRequest_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePreferenceRequest_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePreferenceRequest_ValuesEntry>, I>>(
    base?: I,
  ): CreatePreferenceRequest_ValuesEntry {
    return CreatePreferenceRequest_ValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePreferenceRequest_ValuesEntry>, I>>(
    object: I,
  ): CreatePreferenceRequest_ValuesEntry {
    const message = createBaseCreatePreferenceRequest_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdatePreferenceRequest(): UpdatePreferenceRequest {
  return { id: "", values: {} };
}

export const UpdatePreferenceRequest: MessageFns<UpdatePreferenceRequest> = {
  encode(message: UpdatePreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    globalThis.Object.entries(message.values).forEach(([key, value]: [string, string]) => {
      UpdatePreferenceRequest_ValuesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = UpdatePreferenceRequest_ValuesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.values[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePreferenceRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      values: isObject(object.values)
        ? (globalThis.Object.entries(object.values) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: UpdatePreferenceRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.values) {
      const entries = globalThis.Object.entries(message.values) as [string, string][];
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePreferenceRequest>, I>>(base?: I): UpdatePreferenceRequest {
    return UpdatePreferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePreferenceRequest>, I>>(object: I): UpdatePreferenceRequest {
    const message = createBaseUpdatePreferenceRequest();
    message.id = object.id ?? "";
    message.values = (globalThis.Object.entries(object.values ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUpdatePreferenceRequest_ValuesEntry(): UpdatePreferenceRequest_ValuesEntry {
  return { key: "", value: "" };
}

export const UpdatePreferenceRequest_ValuesEntry: MessageFns<UpdatePreferenceRequest_ValuesEntry> = {
  encode(message: UpdatePreferenceRequest_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePreferenceRequest_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePreferenceRequest_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePreferenceRequest_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdatePreferenceRequest_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePreferenceRequest_ValuesEntry>, I>>(
    base?: I,
  ): UpdatePreferenceRequest_ValuesEntry {
    return UpdatePreferenceRequest_ValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePreferenceRequest_ValuesEntry>, I>>(
    object: I,
  ): UpdatePreferenceRequest_ValuesEntry {
    const message = createBaseUpdatePreferenceRequest_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListPreferenceRequest(): ListPreferenceRequest {
  return { pagination: undefined };
}

export const ListPreferenceRequest: MessageFns<ListPreferenceRequest> = {
  encode(message: ListPreferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPreferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPreferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPreferenceRequest {
    return { pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListPreferenceRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPreferenceRequest>, I>>(base?: I): ListPreferenceRequest {
    return ListPreferenceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPreferenceRequest>, I>>(object: I): ListPreferenceRequest {
    const message = createBaseListPreferenceRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListPreferenceResponse(): ListPreferenceResponse {
  return { preferences: [], pagination: undefined };
}

export const ListPreferenceResponse: MessageFns<ListPreferenceResponse> = {
  encode(message: ListPreferenceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.preferences) {
      Preference.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPreferenceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPreferenceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preferences.push(Preference.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPreferenceResponse {
    return {
      preferences: globalThis.Array.isArray(object?.preferences)
        ? object.preferences.map((e: any) => Preference.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListPreferenceResponse): unknown {
    const obj: any = {};
    if (message.preferences?.length) {
      obj.preferences = message.preferences.map((e) => Preference.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPreferenceResponse>, I>>(base?: I): ListPreferenceResponse {
    return ListPreferenceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPreferenceResponse>, I>>(object: I): ListPreferenceResponse {
    const message = createBaseListPreferenceResponse();
    message.preferences = object.preferences?.map((e) => Preference.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetBySubscriptionRequest(): GetBySubscriptionRequest {
  return { subscriptionId: "" };
}

export const GetBySubscriptionRequest: MessageFns<GetBySubscriptionRequest> = {
  encode(message: GetBySubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBySubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBySubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBySubscriptionRequest {
    return {
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : "",
    };
  },

  toJSON(message: GetBySubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBySubscriptionRequest>, I>>(base?: I): GetBySubscriptionRequest {
    return GetBySubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBySubscriptionRequest>, I>>(object: I): GetBySubscriptionRequest {
    const message = createBaseGetBySubscriptionRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  },
};

function createBasePreferenceHistoryEntry(): PreferenceHistoryEntry {
  return { id: "", preferenceId: "", oldValues: {}, newValues: {}, changedAt: "", createdAt: "" };
}

export const PreferenceHistoryEntry: MessageFns<PreferenceHistoryEntry> = {
  encode(message: PreferenceHistoryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.preferenceId !== "") {
      writer.uint32(18).string(message.preferenceId);
    }
    globalThis.Object.entries(message.oldValues).forEach(([key, value]: [string, string]) => {
      PreferenceHistoryEntry_OldValuesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    globalThis.Object.entries(message.newValues).forEach(([key, value]: [string, string]) => {
      PreferenceHistoryEntry_NewValuesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.changedAt !== "") {
      writer.uint32(42).string(message.changedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreferenceHistoryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferenceHistoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preferenceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = PreferenceHistoryEntry_OldValuesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.oldValues[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = PreferenceHistoryEntry_NewValuesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.newValues[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.changedAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreferenceHistoryEntry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      preferenceId: isSet(object.preferenceId)
        ? globalThis.String(object.preferenceId)
        : isSet(object.preference_id)
        ? globalThis.String(object.preference_id)
        : "",
      oldValues: isObject(object.oldValues)
        ? (globalThis.Object.entries(object.oldValues) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : isObject(object.old_values)
        ? (globalThis.Object.entries(object.old_values) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      newValues: isObject(object.newValues)
        ? (globalThis.Object.entries(object.newValues) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : isObject(object.new_values)
        ? (globalThis.Object.entries(object.new_values) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      changedAt: isSet(object.changedAt)
        ? globalThis.String(object.changedAt)
        : isSet(object.changed_at)
        ? globalThis.String(object.changed_at)
        : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
    };
  },

  toJSON(message: PreferenceHistoryEntry): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.preferenceId !== "") {
      obj.preferenceId = message.preferenceId;
    }
    if (message.oldValues) {
      const entries = globalThis.Object.entries(message.oldValues) as [string, string][];
      if (entries.length > 0) {
        obj.oldValues = {};
        entries.forEach(([k, v]) => {
          obj.oldValues[k] = v;
        });
      }
    }
    if (message.newValues) {
      const entries = globalThis.Object.entries(message.newValues) as [string, string][];
      if (entries.length > 0) {
        obj.newValues = {};
        entries.forEach(([k, v]) => {
          obj.newValues[k] = v;
        });
      }
    }
    if (message.changedAt !== "") {
      obj.changedAt = message.changedAt;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreferenceHistoryEntry>, I>>(base?: I): PreferenceHistoryEntry {
    return PreferenceHistoryEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreferenceHistoryEntry>, I>>(object: I): PreferenceHistoryEntry {
    const message = createBasePreferenceHistoryEntry();
    message.id = object.id ?? "";
    message.preferenceId = object.preferenceId ?? "";
    message.oldValues = (globalThis.Object.entries(object.oldValues ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.newValues = (globalThis.Object.entries(object.newValues ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.changedAt = object.changedAt ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBasePreferenceHistoryEntry_OldValuesEntry(): PreferenceHistoryEntry_OldValuesEntry {
  return { key: "", value: "" };
}

export const PreferenceHistoryEntry_OldValuesEntry: MessageFns<PreferenceHistoryEntry_OldValuesEntry> = {
  encode(message: PreferenceHistoryEntry_OldValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreferenceHistoryEntry_OldValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferenceHistoryEntry_OldValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreferenceHistoryEntry_OldValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PreferenceHistoryEntry_OldValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreferenceHistoryEntry_OldValuesEntry>, I>>(
    base?: I,
  ): PreferenceHistoryEntry_OldValuesEntry {
    return PreferenceHistoryEntry_OldValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreferenceHistoryEntry_OldValuesEntry>, I>>(
    object: I,
  ): PreferenceHistoryEntry_OldValuesEntry {
    const message = createBasePreferenceHistoryEntry_OldValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePreferenceHistoryEntry_NewValuesEntry(): PreferenceHistoryEntry_NewValuesEntry {
  return { key: "", value: "" };
}

export const PreferenceHistoryEntry_NewValuesEntry: MessageFns<PreferenceHistoryEntry_NewValuesEntry> = {
  encode(message: PreferenceHistoryEntry_NewValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreferenceHistoryEntry_NewValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferenceHistoryEntry_NewValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreferenceHistoryEntry_NewValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PreferenceHistoryEntry_NewValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreferenceHistoryEntry_NewValuesEntry>, I>>(
    base?: I,
  ): PreferenceHistoryEntry_NewValuesEntry {
    return PreferenceHistoryEntry_NewValuesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreferenceHistoryEntry_NewValuesEntry>, I>>(
    object: I,
  ): PreferenceHistoryEntry_NewValuesEntry {
    const message = createBasePreferenceHistoryEntry_NewValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWooCommerceMapping(): WooCommerceMapping {
  return {
    id: "",
    organisationId: "",
    woocommerceStoreId: "",
    subscriptionPlanId: "",
    woocommerceProductId: "",
    woocommerceSubscriptionId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const WooCommerceMapping: MessageFns<WooCommerceMapping> = {
  encode(message: WooCommerceMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.woocommerceStoreId !== "") {
      writer.uint32(26).string(message.woocommerceStoreId);
    }
    if (message.subscriptionPlanId !== "") {
      writer.uint32(34).string(message.subscriptionPlanId);
    }
    if (message.woocommerceProductId !== "") {
      writer.uint32(42).string(message.woocommerceProductId);
    }
    if (message.woocommerceSubscriptionId !== "") {
      writer.uint32(50).string(message.woocommerceSubscriptionId);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WooCommerceMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWooCommerceMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.woocommerceStoreId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subscriptionPlanId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.woocommerceProductId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.woocommerceSubscriptionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WooCommerceMapping {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      woocommerceStoreId: isSet(object.woocommerceStoreId)
        ? globalThis.String(object.woocommerceStoreId)
        : isSet(object.woocommerce_store_id)
        ? globalThis.String(object.woocommerce_store_id)
        : "",
      subscriptionPlanId: isSet(object.subscriptionPlanId)
        ? globalThis.String(object.subscriptionPlanId)
        : isSet(object.subscription_plan_id)
        ? globalThis.String(object.subscription_plan_id)
        : "",
      woocommerceProductId: isSet(object.woocommerceProductId)
        ? globalThis.String(object.woocommerceProductId)
        : isSet(object.woocommerce_product_id)
        ? globalThis.String(object.woocommerce_product_id)
        : "",
      woocommerceSubscriptionId: isSet(object.woocommerceSubscriptionId)
        ? globalThis.String(object.woocommerceSubscriptionId)
        : isSet(object.woocommerce_subscription_id)
        ? globalThis.String(object.woocommerce_subscription_id)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: WooCommerceMapping): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.woocommerceStoreId !== "") {
      obj.woocommerceStoreId = message.woocommerceStoreId;
    }
    if (message.subscriptionPlanId !== "") {
      obj.subscriptionPlanId = message.subscriptionPlanId;
    }
    if (message.woocommerceProductId !== "") {
      obj.woocommerceProductId = message.woocommerceProductId;
    }
    if (message.woocommerceSubscriptionId !== "") {
      obj.woocommerceSubscriptionId = message.woocommerceSubscriptionId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WooCommerceMapping>, I>>(base?: I): WooCommerceMapping {
    return WooCommerceMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WooCommerceMapping>, I>>(object: I): WooCommerceMapping {
    const message = createBaseWooCommerceMapping();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.woocommerceStoreId = object.woocommerceStoreId ?? "";
    message.subscriptionPlanId = object.subscriptionPlanId ?? "";
    message.woocommerceProductId = object.woocommerceProductId ?? "";
    message.woocommerceSubscriptionId = object.woocommerceSubscriptionId ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseCreateWooCommerceMappingRequest(): CreateWooCommerceMappingRequest {
  return { organisationId: "", woocommerceStoreId: "", subscriptionPlanId: "", woocommerceProductId: "" };
}

export const CreateWooCommerceMappingRequest: MessageFns<CreateWooCommerceMappingRequest> = {
  encode(message: CreateWooCommerceMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.woocommerceStoreId !== "") {
      writer.uint32(18).string(message.woocommerceStoreId);
    }
    if (message.subscriptionPlanId !== "") {
      writer.uint32(26).string(message.subscriptionPlanId);
    }
    if (message.woocommerceProductId !== "") {
      writer.uint32(34).string(message.woocommerceProductId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWooCommerceMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWooCommerceMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.woocommerceStoreId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscriptionPlanId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.woocommerceProductId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWooCommerceMappingRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      woocommerceStoreId: isSet(object.woocommerceStoreId)
        ? globalThis.String(object.woocommerceStoreId)
        : isSet(object.woocommerce_store_id)
        ? globalThis.String(object.woocommerce_store_id)
        : "",
      subscriptionPlanId: isSet(object.subscriptionPlanId)
        ? globalThis.String(object.subscriptionPlanId)
        : isSet(object.subscription_plan_id)
        ? globalThis.String(object.subscription_plan_id)
        : "",
      woocommerceProductId: isSet(object.woocommerceProductId)
        ? globalThis.String(object.woocommerceProductId)
        : isSet(object.woocommerce_product_id)
        ? globalThis.String(object.woocommerce_product_id)
        : "",
    };
  },

  toJSON(message: CreateWooCommerceMappingRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.woocommerceStoreId !== "") {
      obj.woocommerceStoreId = message.woocommerceStoreId;
    }
    if (message.subscriptionPlanId !== "") {
      obj.subscriptionPlanId = message.subscriptionPlanId;
    }
    if (message.woocommerceProductId !== "") {
      obj.woocommerceProductId = message.woocommerceProductId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateWooCommerceMappingRequest>, I>>(base?: I): CreateWooCommerceMappingRequest {
    return CreateWooCommerceMappingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateWooCommerceMappingRequest>, I>>(
    object: I,
  ): CreateWooCommerceMappingRequest {
    const message = createBaseCreateWooCommerceMappingRequest();
    message.organisationId = object.organisationId ?? "";
    message.woocommerceStoreId = object.woocommerceStoreId ?? "";
    message.subscriptionPlanId = object.subscriptionPlanId ?? "";
    message.woocommerceProductId = object.woocommerceProductId ?? "";
    return message;
  },
};

function createBaseUpdateWooCommerceMappingRequest(): UpdateWooCommerceMappingRequest {
  return { id: "", woocommerceProductId: undefined, isActive: undefined };
}

export const UpdateWooCommerceMappingRequest: MessageFns<UpdateWooCommerceMappingRequest> = {
  encode(message: UpdateWooCommerceMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.woocommerceProductId !== undefined) {
      writer.uint32(18).string(message.woocommerceProductId);
    }
    if (message.isActive !== undefined) {
      writer.uint32(24).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWooCommerceMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWooCommerceMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.woocommerceProductId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWooCommerceMappingRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      woocommerceProductId: isSet(object.woocommerceProductId)
        ? globalThis.String(object.woocommerceProductId)
        : isSet(object.woocommerce_product_id)
        ? globalThis.String(object.woocommerce_product_id)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
    };
  },

  toJSON(message: UpdateWooCommerceMappingRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.woocommerceProductId !== undefined) {
      obj.woocommerceProductId = message.woocommerceProductId;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateWooCommerceMappingRequest>, I>>(base?: I): UpdateWooCommerceMappingRequest {
    return UpdateWooCommerceMappingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateWooCommerceMappingRequest>, I>>(
    object: I,
  ): UpdateWooCommerceMappingRequest {
    const message = createBaseUpdateWooCommerceMappingRequest();
    message.id = object.id ?? "";
    message.woocommerceProductId = object.woocommerceProductId ?? undefined;
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

function createBaseListWooCommerceMappingRequest(): ListWooCommerceMappingRequest {
  return { pagination: undefined };
}

export const ListWooCommerceMappingRequest: MessageFns<ListWooCommerceMappingRequest> = {
  encode(message: ListWooCommerceMappingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWooCommerceMappingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWooCommerceMappingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWooCommerceMappingRequest {
    return { pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: ListWooCommerceMappingRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWooCommerceMappingRequest>, I>>(base?: I): ListWooCommerceMappingRequest {
    return ListWooCommerceMappingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWooCommerceMappingRequest>, I>>(
    object: I,
  ): ListWooCommerceMappingRequest {
    const message = createBaseListWooCommerceMappingRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListWooCommerceMappingResponse(): ListWooCommerceMappingResponse {
  return { mappings: [], pagination: undefined };
}

export const ListWooCommerceMappingResponse: MessageFns<ListWooCommerceMappingResponse> = {
  encode(message: ListWooCommerceMappingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mappings) {
      WooCommerceMapping.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWooCommerceMappingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWooCommerceMappingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mappings.push(WooCommerceMapping.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWooCommerceMappingResponse {
    return {
      mappings: globalThis.Array.isArray(object?.mappings)
        ? object.mappings.map((e: any) => WooCommerceMapping.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResult.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListWooCommerceMappingResponse): unknown {
    const obj: any = {};
    if (message.mappings?.length) {
      obj.mappings = message.mappings.map((e) => WooCommerceMapping.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResult.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWooCommerceMappingResponse>, I>>(base?: I): ListWooCommerceMappingResponse {
    return ListWooCommerceMappingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWooCommerceMappingResponse>, I>>(
    object: I,
  ): ListWooCommerceMappingResponse {
    const message = createBaseListWooCommerceMappingResponse();
    message.mappings = object.mappings?.map((e) => WooCommerceMapping.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResult.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseWooCommerceWebhookEvent(): WooCommerceWebhookEvent {
  return {
    id: "",
    organisationId: "",
    eventType: "",
    woocommerceSubscriptionId: "",
    rawPayload: "",
    receivedAt: "",
    processed: false,
    processedAt: undefined,
    errorMessage: undefined,
  };
}

export const WooCommerceWebhookEvent: MessageFns<WooCommerceWebhookEvent> = {
  encode(message: WooCommerceWebhookEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.woocommerceSubscriptionId !== "") {
      writer.uint32(34).string(message.woocommerceSubscriptionId);
    }
    if (message.rawPayload !== "") {
      writer.uint32(42).string(message.rawPayload);
    }
    if (message.receivedAt !== "") {
      writer.uint32(50).string(message.receivedAt);
    }
    if (message.processed !== false) {
      writer.uint32(56).bool(message.processed);
    }
    if (message.processedAt !== undefined) {
      writer.uint32(66).string(message.processedAt);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WooCommerceWebhookEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWooCommerceWebhookEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.woocommerceSubscriptionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WooCommerceWebhookEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      woocommerceSubscriptionId: isSet(object.woocommerceSubscriptionId)
        ? globalThis.String(object.woocommerceSubscriptionId)
        : isSet(object.woocommerce_subscription_id)
        ? globalThis.String(object.woocommerce_subscription_id)
        : "",
      rawPayload: isSet(object.rawPayload)
        ? globalThis.String(object.rawPayload)
        : isSet(object.raw_payload)
        ? globalThis.String(object.raw_payload)
        : "",
      receivedAt: isSet(object.receivedAt)
        ? globalThis.String(object.receivedAt)
        : isSet(object.received_at)
        ? globalThis.String(object.received_at)
        : "",
      processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false,
      processedAt: isSet(object.processedAt)
        ? globalThis.String(object.processedAt)
        : isSet(object.processed_at)
        ? globalThis.String(object.processed_at)
        : undefined,
      errorMessage: isSet(object.errorMessage)
        ? globalThis.String(object.errorMessage)
        : isSet(object.error_message)
        ? globalThis.String(object.error_message)
        : undefined,
    };
  },

  toJSON(message: WooCommerceWebhookEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.woocommerceSubscriptionId !== "") {
      obj.woocommerceSubscriptionId = message.woocommerceSubscriptionId;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    if (message.receivedAt !== "") {
      obj.receivedAt = message.receivedAt;
    }
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    if (message.processedAt !== undefined) {
      obj.processedAt = message.processedAt;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WooCommerceWebhookEvent>, I>>(base?: I): WooCommerceWebhookEvent {
    return WooCommerceWebhookEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WooCommerceWebhookEvent>, I>>(object: I): WooCommerceWebhookEvent {
    const message = createBaseWooCommerceWebhookEvent();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.eventType = object.eventType ?? "";
    message.woocommerceSubscriptionId = object.woocommerceSubscriptionId ?? "";
    message.rawPayload = object.rawPayload ?? "";
    message.receivedAt = object.receivedAt ?? "";
    message.processed = object.processed ?? false;
    message.processedAt = object.processedAt ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseProcessWooCommerceWebhookRequest(): ProcessWooCommerceWebhookRequest {
  return { organisationId: "", eventType: "", rawPayload: "" };
}

export const ProcessWooCommerceWebhookRequest: MessageFns<ProcessWooCommerceWebhookRequest> = {
  encode(message: ProcessWooCommerceWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(26).string(message.rawPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessWooCommerceWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessWooCommerceWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessWooCommerceWebhookRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      eventType: isSet(object.eventType)
        ? globalThis.String(object.eventType)
        : isSet(object.event_type)
        ? globalThis.String(object.event_type)
        : "",
      rawPayload: isSet(object.rawPayload)
        ? globalThis.String(object.rawPayload)
        : isSet(object.raw_payload)
        ? globalThis.String(object.raw_payload)
        : "",
    };
  },

  toJSON(message: ProcessWooCommerceWebhookRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessWooCommerceWebhookRequest>, I>>(
    base?: I,
  ): ProcessWooCommerceWebhookRequest {
    return ProcessWooCommerceWebhookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessWooCommerceWebhookRequest>, I>>(
    object: I,
  ): ProcessWooCommerceWebhookRequest {
    const message = createBaseProcessWooCommerceWebhookRequest();
    message.organisationId = object.organisationId ?? "";
    message.eventType = object.eventType ?? "";
    message.rawPayload = object.rawPayload ?? "";
    return message;
  },
};

function createBaseWooCommerceWebhookResponse(): WooCommerceWebhookResponse {
  return { success: false, message: undefined, subscriptionId: undefined };
}

export const WooCommerceWebhookResponse: MessageFns<WooCommerceWebhookResponse> = {
  encode(message: WooCommerceWebhookResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== undefined) {
      writer.uint32(18).string(message.message);
    }
    if (message.subscriptionId !== undefined) {
      writer.uint32(26).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WooCommerceWebhookResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWooCommerceWebhookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WooCommerceWebhookResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      subscriptionId: isSet(object.subscriptionId)
        ? globalThis.String(object.subscriptionId)
        : isSet(object.subscription_id)
        ? globalThis.String(object.subscription_id)
        : undefined,
    };
  },

  toJSON(message: WooCommerceWebhookResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.subscriptionId !== undefined) {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WooCommerceWebhookResponse>, I>>(base?: I): WooCommerceWebhookResponse {
    return WooCommerceWebhookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WooCommerceWebhookResponse>, I>>(object: I): WooCommerceWebhookResponse {
    const message = createBaseWooCommerceWebhookResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? undefined;
    message.subscriptionId = object.subscriptionId ?? undefined;
    return message;
  },
};

function createBaseWooCommerceConfig(): WooCommerceConfig {
  return {
    id: "",
    organisationId: "",
    woocommerceStoreId: "",
    apiKey: "",
    apiSecret: "",
    webhookUrl: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const WooCommerceConfig: MessageFns<WooCommerceConfig> = {
  encode(message: WooCommerceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.woocommerceStoreId !== "") {
      writer.uint32(26).string(message.woocommerceStoreId);
    }
    if (message.apiKey !== "") {
      writer.uint32(34).string(message.apiKey);
    }
    if (message.apiSecret !== "") {
      writer.uint32(42).string(message.apiSecret);
    }
    if (message.webhookUrl !== "") {
      writer.uint32(50).string(message.webhookUrl);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WooCommerceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWooCommerceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.woocommerceStoreId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.apiSecret = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.webhookUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WooCommerceConfig {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      woocommerceStoreId: isSet(object.woocommerceStoreId)
        ? globalThis.String(object.woocommerceStoreId)
        : isSet(object.woocommerce_store_id)
        ? globalThis.String(object.woocommerce_store_id)
        : "",
      apiKey: isSet(object.apiKey)
        ? globalThis.String(object.apiKey)
        : isSet(object.api_key)
        ? globalThis.String(object.api_key)
        : "",
      apiSecret: isSet(object.apiSecret)
        ? globalThis.String(object.apiSecret)
        : isSet(object.api_secret)
        ? globalThis.String(object.api_secret)
        : "",
      webhookUrl: isSet(object.webhookUrl)
        ? globalThis.String(object.webhookUrl)
        : isSet(object.webhook_url)
        ? globalThis.String(object.webhook_url)
        : "",
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
    };
  },

  toJSON(message: WooCommerceConfig): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.woocommerceStoreId !== "") {
      obj.woocommerceStoreId = message.woocommerceStoreId;
    }
    if (message.apiKey !== "") {
      obj.apiKey = message.apiKey;
    }
    if (message.apiSecret !== "") {
      obj.apiSecret = message.apiSecret;
    }
    if (message.webhookUrl !== "") {
      obj.webhookUrl = message.webhookUrl;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WooCommerceConfig>, I>>(base?: I): WooCommerceConfig {
    return WooCommerceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WooCommerceConfig>, I>>(object: I): WooCommerceConfig {
    const message = createBaseWooCommerceConfig();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.woocommerceStoreId = object.woocommerceStoreId ?? "";
    message.apiKey = object.apiKey ?? "";
    message.apiSecret = object.apiSecret ?? "";
    message.webhookUrl = object.webhookUrl ?? "";
    message.isActive = object.isActive ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    return message;
  },
};

function createBaseGetWooCommerceConfigRequest(): GetWooCommerceConfigRequest {
  return { organisationId: "", woocommerceStoreId: "" };
}

export const GetWooCommerceConfigRequest: MessageFns<GetWooCommerceConfigRequest> = {
  encode(message: GetWooCommerceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.woocommerceStoreId !== "") {
      writer.uint32(18).string(message.woocommerceStoreId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWooCommerceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWooCommerceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.woocommerceStoreId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWooCommerceConfigRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      woocommerceStoreId: isSet(object.woocommerceStoreId)
        ? globalThis.String(object.woocommerceStoreId)
        : isSet(object.woocommerce_store_id)
        ? globalThis.String(object.woocommerce_store_id)
        : "",
    };
  },

  toJSON(message: GetWooCommerceConfigRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.woocommerceStoreId !== "") {
      obj.woocommerceStoreId = message.woocommerceStoreId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWooCommerceConfigRequest>, I>>(base?: I): GetWooCommerceConfigRequest {
    return GetWooCommerceConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWooCommerceConfigRequest>, I>>(object: I): GetWooCommerceConfigRequest {
    const message = createBaseGetWooCommerceConfigRequest();
    message.organisationId = object.organisationId ?? "";
    message.woocommerceStoreId = object.woocommerceStoreId ?? "";
    return message;
  },
};

function createBaseUpdateWooCommerceConfigRequest(): UpdateWooCommerceConfigRequest {
  return { id: "", apiKey: undefined, apiSecret: undefined, webhookUrl: undefined, isActive: undefined };
}

export const UpdateWooCommerceConfigRequest: MessageFns<UpdateWooCommerceConfigRequest> = {
  encode(message: UpdateWooCommerceConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.apiKey !== undefined) {
      writer.uint32(18).string(message.apiKey);
    }
    if (message.apiSecret !== undefined) {
      writer.uint32(26).string(message.apiSecret);
    }
    if (message.webhookUrl !== undefined) {
      writer.uint32(34).string(message.webhookUrl);
    }
    if (message.isActive !== undefined) {
      writer.uint32(40).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWooCommerceConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWooCommerceConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apiSecret = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.webhookUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWooCommerceConfigRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      apiKey: isSet(object.apiKey)
        ? globalThis.String(object.apiKey)
        : isSet(object.api_key)
        ? globalThis.String(object.api_key)
        : undefined,
      apiSecret: isSet(object.apiSecret)
        ? globalThis.String(object.apiSecret)
        : isSet(object.api_secret)
        ? globalThis.String(object.api_secret)
        : undefined,
      webhookUrl: isSet(object.webhookUrl)
        ? globalThis.String(object.webhookUrl)
        : isSet(object.webhook_url)
        ? globalThis.String(object.webhook_url)
        : undefined,
      isActive: isSet(object.isActive)
        ? globalThis.Boolean(object.isActive)
        : isSet(object.is_active)
        ? globalThis.Boolean(object.is_active)
        : undefined,
    };
  },

  toJSON(message: UpdateWooCommerceConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.apiKey !== undefined) {
      obj.apiKey = message.apiKey;
    }
    if (message.apiSecret !== undefined) {
      obj.apiSecret = message.apiSecret;
    }
    if (message.webhookUrl !== undefined) {
      obj.webhookUrl = message.webhookUrl;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateWooCommerceConfigRequest>, I>>(base?: I): UpdateWooCommerceConfigRequest {
    return UpdateWooCommerceConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateWooCommerceConfigRequest>, I>>(
    object: I,
  ): UpdateWooCommerceConfigRequest {
    const message = createBaseUpdateWooCommerceConfigRequest();
    message.id = object.id ?? "";
    message.apiKey = object.apiKey ?? undefined;
    message.apiSecret = object.apiSecret ?? undefined;
    message.webhookUrl = object.webhookUrl ?? undefined;
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pagination {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      sortBy: isSet(object.sortBy)
        ? globalThis.String(object.sortBy)
        : isSet(object.sort_by)
        ? globalThis.String(object.sort_by)
        : "",
      sortOrder: isSet(object.sortOrder)
        ? globalThis.String(object.sortOrder)
        : isSet(object.sort_order)
        ? globalThis.String(object.sort_order)
        : "",
    };
  },

  toJSON(message: Pagination): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pagination>, I>>(base?: I): Pagination {
    return Pagination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pagination>, I>>(object: I): Pagination {
    const message = createBasePagination();
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResult {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      totalPages: isSet(object.totalPages)
        ? globalThis.Number(object.totalPages)
        : isSet(object.total_pages)
        ? globalThis.Number(object.total_pages)
        : 0,
    };
  },

  toJSON(message: PaginationResult): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResult>, I>>(base?: I): PaginationResult {
    return PaginationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResult>, I>>(object: I): PaginationResult {
    const message = createBasePaginationResult();
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.limit = object.limit ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "" };
}

export const GetByIdRequest: MessageFns<GetByIdRequest> = {
  encode(message: GetByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetByIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetByIdRequest>, I>>(base?: I): GetByIdRequest {
    return GetByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetByIdRequest>, I>>(object: I): GetByIdRequest {
    const message = createBaseGetByIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteByIdRequest(): DeleteByIdRequest {
  return { id: "" };
}

export const DeleteByIdRequest: MessageFns<DeleteByIdRequest> = {
  encode(message: DeleteByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteByIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteByIdRequest>, I>>(base?: I): DeleteByIdRequest {
    return DeleteByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteByIdRequest>, I>>(object: I): DeleteByIdRequest {
    const message = createBaseDeleteByIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListByOrganisationRequest(): ListByOrganisationRequest {
  return { organisationId: "", pagination: undefined };
}

export const ListByOrganisationRequest: MessageFns<ListByOrganisationRequest> = {
  encode(message: ListByOrganisationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListByOrganisationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListByOrganisationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListByOrganisationRequest {
    return {
      organisationId: isSet(object.organisationId)
        ? globalThis.String(object.organisationId)
        : isSet(object.organisation_id)
        ? globalThis.String(object.organisation_id)
        : "",
      pagination: isSet(object.pagination) ? Pagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListByOrganisationRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = Pagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListByOrganisationRequest>, I>>(base?: I): ListByOrganisationRequest {
    return ListByOrganisationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListByOrganisationRequest>, I>>(object: I): ListByOrganisationRequest {
    const message = createBaseListByOrganisationRequest();
    message.organisationId = object.organisationId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? Pagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

/** ========== SUBSCRIPTION PLAN SERVICE ========== */
export type SubscriptionPlanServiceService = typeof SubscriptionPlanServiceService;
export const SubscriptionPlanServiceService = {
  create: {
    path: "/subscriptions.SubscriptionPlanService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSubscriptionPlanRequest): Buffer =>
      Buffer.from(CreateSubscriptionPlanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSubscriptionPlanRequest => CreateSubscriptionPlanRequest.decode(value),
    responseSerialize: (value: SubscriptionPlan): Buffer => Buffer.from(SubscriptionPlan.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubscriptionPlan => SubscriptionPlan.decode(value),
  },
  update: {
    path: "/subscriptions.SubscriptionPlanService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSubscriptionPlanRequest): Buffer =>
      Buffer.from(UpdateSubscriptionPlanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSubscriptionPlanRequest => UpdateSubscriptionPlanRequest.decode(value),
    responseSerialize: (value: SubscriptionPlan): Buffer => Buffer.from(SubscriptionPlan.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubscriptionPlan => SubscriptionPlan.decode(value),
  },
  get: {
    path: "/subscriptions.SubscriptionPlanService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: SubscriptionPlan): Buffer => Buffer.from(SubscriptionPlan.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubscriptionPlan => SubscriptionPlan.decode(value),
  },
  list: {
    path: "/subscriptions.SubscriptionPlanService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSubscriptionPlanRequest): Buffer =>
      Buffer.from(ListSubscriptionPlanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSubscriptionPlanRequest => ListSubscriptionPlanRequest.decode(value),
    responseSerialize: (value: ListSubscriptionPlanResponse): Buffer =>
      Buffer.from(ListSubscriptionPlanResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSubscriptionPlanResponse => ListSubscriptionPlanResponse.decode(value),
  },
  delete: {
    path: "/subscriptions.SubscriptionPlanService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteByIdRequest): Buffer => Buffer.from(DeleteByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteByIdRequest => DeleteByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  listByOrganisation: {
    path: "/subscriptions.SubscriptionPlanService/ListByOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListByOrganisationRequest): Buffer =>
      Buffer.from(ListByOrganisationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListByOrganisationRequest => ListByOrganisationRequest.decode(value),
    responseSerialize: (value: ListSubscriptionPlanResponse): Buffer =>
      Buffer.from(ListSubscriptionPlanResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSubscriptionPlanResponse => ListSubscriptionPlanResponse.decode(value),
  },
} as const;

export interface SubscriptionPlanServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateSubscriptionPlanRequest, SubscriptionPlan>;
  update: handleUnaryCall<UpdateSubscriptionPlanRequest, SubscriptionPlan>;
  get: handleUnaryCall<GetByIdRequest, SubscriptionPlan>;
  list: handleUnaryCall<ListSubscriptionPlanRequest, ListSubscriptionPlanResponse>;
  delete: handleUnaryCall<DeleteByIdRequest, DeleteResponse>;
  listByOrganisation: handleUnaryCall<ListByOrganisationRequest, ListSubscriptionPlanResponse>;
}

/** ========== SUBSCRIPTION SERVICE ========== */
export type SubscriptionServiceService = typeof SubscriptionServiceService;
export const SubscriptionServiceService = {
  create: {
    path: "/subscriptions.SubscriptionService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSubscriptionRequest): Buffer =>
      Buffer.from(CreateSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSubscriptionRequest => CreateSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  update: {
    path: "/subscriptions.SubscriptionService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSubscriptionRequest): Buffer =>
      Buffer.from(UpdateSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSubscriptionRequest => UpdateSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  get: {
    path: "/subscriptions.SubscriptionService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  list: {
    path: "/subscriptions.SubscriptionService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSubscriptionRequest): Buffer =>
      Buffer.from(ListSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSubscriptionRequest => ListSubscriptionRequest.decode(value),
    responseSerialize: (value: ListSubscriptionResponse): Buffer =>
      Buffer.from(ListSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSubscriptionResponse => ListSubscriptionResponse.decode(value),
  },
  delete: {
    path: "/subscriptions.SubscriptionService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteByIdRequest): Buffer => Buffer.from(DeleteByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteByIdRequest => DeleteByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  activate: {
    path: "/subscriptions.SubscriptionService/Activate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateSubscriptionRequest): Buffer =>
      Buffer.from(ActivateSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ActivateSubscriptionRequest => ActivateSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  pause: {
    path: "/subscriptions.SubscriptionService/Pause",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PauseSubscriptionRequest): Buffer =>
      Buffer.from(PauseSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PauseSubscriptionRequest => PauseSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  resume: {
    path: "/subscriptions.SubscriptionService/Resume",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResumeSubscriptionRequest): Buffer =>
      Buffer.from(ResumeSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResumeSubscriptionRequest => ResumeSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  cancel: {
    path: "/subscriptions.SubscriptionService/Cancel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelSubscriptionRequest): Buffer =>
      Buffer.from(CancelSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelSubscriptionRequest => CancelSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  suspend: {
    path: "/subscriptions.SubscriptionService/Suspend",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SuspendSubscriptionRequest): Buffer =>
      Buffer.from(SuspendSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SuspendSubscriptionRequest => SuspendSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  reactivate: {
    path: "/subscriptions.SubscriptionService/Reactivate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReactivateSubscriptionRequest): Buffer =>
      Buffer.from(ReactivateSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReactivateSubscriptionRequest => ReactivateSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  expire: {
    path: "/subscriptions.SubscriptionService/Expire",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExpireSubscriptionRequest): Buffer =>
      Buffer.from(ExpireSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExpireSubscriptionRequest => ExpireSubscriptionRequest.decode(value),
    responseSerialize: (value: Subscription): Buffer => Buffer.from(Subscription.encode(value).finish()),
    responseDeserialize: (value: Buffer): Subscription => Subscription.decode(value),
  },
  getDueForCharge: {
    path: "/subscriptions.SubscriptionService/GetDueForCharge",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDueForChargeRequest): Buffer =>
      Buffer.from(GetDueForChargeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDueForChargeRequest => GetDueForChargeRequest.decode(value),
    responseSerialize: (value: ListSubscriptionResponse): Buffer =>
      Buffer.from(ListSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSubscriptionResponse => ListSubscriptionResponse.decode(value),
  },
  getDueForTrialConversion: {
    path: "/subscriptions.SubscriptionService/GetDueForTrialConversion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDueForTrialConversionRequest): Buffer =>
      Buffer.from(GetDueForTrialConversionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDueForTrialConversionRequest =>
      GetDueForTrialConversionRequest.decode(value),
    responseSerialize: (value: ListSubscriptionResponse): Buffer =>
      Buffer.from(ListSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSubscriptionResponse => ListSubscriptionResponse.decode(value),
  },
  listByClient: {
    path: "/subscriptions.SubscriptionService/ListByClient",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListByClientRequest): Buffer => Buffer.from(ListByClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListByClientRequest => ListByClientRequest.decode(value),
    responseSerialize: (value: ListSubscriptionResponse): Buffer =>
      Buffer.from(ListSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSubscriptionResponse => ListSubscriptionResponse.decode(value),
  },
  listByPlan: {
    path: "/subscriptions.SubscriptionService/ListByPlan",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListByPlanRequest): Buffer => Buffer.from(ListByPlanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListByPlanRequest => ListByPlanRequest.decode(value),
    responseSerialize: (value: ListSubscriptionResponse): Buffer =>
      Buffer.from(ListSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSubscriptionResponse => ListSubscriptionResponse.decode(value),
  },
} as const;

export interface SubscriptionServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateSubscriptionRequest, Subscription>;
  update: handleUnaryCall<UpdateSubscriptionRequest, Subscription>;
  get: handleUnaryCall<GetByIdRequest, Subscription>;
  list: handleUnaryCall<ListSubscriptionRequest, ListSubscriptionResponse>;
  delete: handleUnaryCall<DeleteByIdRequest, DeleteResponse>;
  activate: handleUnaryCall<ActivateSubscriptionRequest, Subscription>;
  pause: handleUnaryCall<PauseSubscriptionRequest, Subscription>;
  resume: handleUnaryCall<ResumeSubscriptionRequest, Subscription>;
  cancel: handleUnaryCall<CancelSubscriptionRequest, Subscription>;
  suspend: handleUnaryCall<SuspendSubscriptionRequest, Subscription>;
  reactivate: handleUnaryCall<ReactivateSubscriptionRequest, Subscription>;
  expire: handleUnaryCall<ExpireSubscriptionRequest, Subscription>;
  getDueForCharge: handleUnaryCall<GetDueForChargeRequest, ListSubscriptionResponse>;
  getDueForTrialConversion: handleUnaryCall<GetDueForTrialConversionRequest, ListSubscriptionResponse>;
  listByClient: handleUnaryCall<ListByClientRequest, ListSubscriptionResponse>;
  listByPlan: handleUnaryCall<ListByPlanRequest, ListSubscriptionResponse>;
}

/** ========== SUBSCRIPTION PREFERENCE SCHEMA SERVICE ========== */
export type SubscriptionPreferenceSchemaServiceService = typeof SubscriptionPreferenceSchemaServiceService;
export const SubscriptionPreferenceSchemaServiceService = {
  create: {
    path: "/subscriptions.SubscriptionPreferenceSchemaService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePreferenceSchemaRequest): Buffer =>
      Buffer.from(CreatePreferenceSchemaRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePreferenceSchemaRequest => CreatePreferenceSchemaRequest.decode(value),
    responseSerialize: (value: PreferenceSchema): Buffer => Buffer.from(PreferenceSchema.encode(value).finish()),
    responseDeserialize: (value: Buffer): PreferenceSchema => PreferenceSchema.decode(value),
  },
  update: {
    path: "/subscriptions.SubscriptionPreferenceSchemaService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePreferenceSchemaRequest): Buffer =>
      Buffer.from(UpdatePreferenceSchemaRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePreferenceSchemaRequest => UpdatePreferenceSchemaRequest.decode(value),
    responseSerialize: (value: PreferenceSchema): Buffer => Buffer.from(PreferenceSchema.encode(value).finish()),
    responseDeserialize: (value: Buffer): PreferenceSchema => PreferenceSchema.decode(value),
  },
  get: {
    path: "/subscriptions.SubscriptionPreferenceSchemaService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PreferenceSchema): Buffer => Buffer.from(PreferenceSchema.encode(value).finish()),
    responseDeserialize: (value: Buffer): PreferenceSchema => PreferenceSchema.decode(value),
  },
  list: {
    path: "/subscriptions.SubscriptionPreferenceSchemaService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPreferenceSchemaRequest): Buffer =>
      Buffer.from(ListPreferenceSchemaRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPreferenceSchemaRequest => ListPreferenceSchemaRequest.decode(value),
    responseSerialize: (value: ListPreferenceSchemaResponse): Buffer =>
      Buffer.from(ListPreferenceSchemaResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPreferenceSchemaResponse => ListPreferenceSchemaResponse.decode(value),
  },
  delete: {
    path: "/subscriptions.SubscriptionPreferenceSchemaService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteByIdRequest): Buffer => Buffer.from(DeleteByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteByIdRequest => DeleteByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface SubscriptionPreferenceSchemaServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreatePreferenceSchemaRequest, PreferenceSchema>;
  update: handleUnaryCall<UpdatePreferenceSchemaRequest, PreferenceSchema>;
  get: handleUnaryCall<GetByIdRequest, PreferenceSchema>;
  list: handleUnaryCall<ListPreferenceSchemaRequest, ListPreferenceSchemaResponse>;
  delete: handleUnaryCall<DeleteByIdRequest, DeleteResponse>;
}

/** ========== SUBSCRIPTION PREFERENCE SERVICE ========== */
export type SubscriptionPreferenceServiceService = typeof SubscriptionPreferenceServiceService;
export const SubscriptionPreferenceServiceService = {
  create: {
    path: "/subscriptions.SubscriptionPreferenceService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePreferenceRequest): Buffer =>
      Buffer.from(CreatePreferenceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePreferenceRequest => CreatePreferenceRequest.decode(value),
    responseSerialize: (value: Preference): Buffer => Buffer.from(Preference.encode(value).finish()),
    responseDeserialize: (value: Buffer): Preference => Preference.decode(value),
  },
  update: {
    path: "/subscriptions.SubscriptionPreferenceService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePreferenceRequest): Buffer =>
      Buffer.from(UpdatePreferenceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePreferenceRequest => UpdatePreferenceRequest.decode(value),
    responseSerialize: (value: Preference): Buffer => Buffer.from(Preference.encode(value).finish()),
    responseDeserialize: (value: Buffer): Preference => Preference.decode(value),
  },
  get: {
    path: "/subscriptions.SubscriptionPreferenceService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: Preference): Buffer => Buffer.from(Preference.encode(value).finish()),
    responseDeserialize: (value: Buffer): Preference => Preference.decode(value),
  },
  list: {
    path: "/subscriptions.SubscriptionPreferenceService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPreferenceRequest): Buffer =>
      Buffer.from(ListPreferenceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPreferenceRequest => ListPreferenceRequest.decode(value),
    responseSerialize: (value: ListPreferenceResponse): Buffer =>
      Buffer.from(ListPreferenceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPreferenceResponse => ListPreferenceResponse.decode(value),
  },
  delete: {
    path: "/subscriptions.SubscriptionPreferenceService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteByIdRequest): Buffer => Buffer.from(DeleteByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteByIdRequest => DeleteByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getBySubscription: {
    path: "/subscriptions.SubscriptionPreferenceService/GetBySubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBySubscriptionRequest): Buffer =>
      Buffer.from(GetBySubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBySubscriptionRequest => GetBySubscriptionRequest.decode(value),
    responseSerialize: (value: Preference): Buffer => Buffer.from(Preference.encode(value).finish()),
    responseDeserialize: (value: Buffer): Preference => Preference.decode(value),
  },
} as const;

export interface SubscriptionPreferenceServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreatePreferenceRequest, Preference>;
  update: handleUnaryCall<UpdatePreferenceRequest, Preference>;
  get: handleUnaryCall<GetByIdRequest, Preference>;
  list: handleUnaryCall<ListPreferenceRequest, ListPreferenceResponse>;
  delete: handleUnaryCall<DeleteByIdRequest, DeleteResponse>;
  getBySubscription: handleUnaryCall<GetBySubscriptionRequest, Preference>;
}

/** ========== WOOCOMMERCE SERVICE ========== */
export type WooCommerceServiceService = typeof WooCommerceServiceService;
export const WooCommerceServiceService = {
  createMapping: {
    path: "/subscriptions.WooCommerceService/CreateMapping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateWooCommerceMappingRequest): Buffer =>
      Buffer.from(CreateWooCommerceMappingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateWooCommerceMappingRequest =>
      CreateWooCommerceMappingRequest.decode(value),
    responseSerialize: (value: WooCommerceMapping): Buffer => Buffer.from(WooCommerceMapping.encode(value).finish()),
    responseDeserialize: (value: Buffer): WooCommerceMapping => WooCommerceMapping.decode(value),
  },
  updateMapping: {
    path: "/subscriptions.WooCommerceService/UpdateMapping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateWooCommerceMappingRequest): Buffer =>
      Buffer.from(UpdateWooCommerceMappingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateWooCommerceMappingRequest =>
      UpdateWooCommerceMappingRequest.decode(value),
    responseSerialize: (value: WooCommerceMapping): Buffer => Buffer.from(WooCommerceMapping.encode(value).finish()),
    responseDeserialize: (value: Buffer): WooCommerceMapping => WooCommerceMapping.decode(value),
  },
  getMapping: {
    path: "/subscriptions.WooCommerceService/GetMapping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: WooCommerceMapping): Buffer => Buffer.from(WooCommerceMapping.encode(value).finish()),
    responseDeserialize: (value: Buffer): WooCommerceMapping => WooCommerceMapping.decode(value),
  },
  listMappings: {
    path: "/subscriptions.WooCommerceService/ListMappings",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWooCommerceMappingRequest): Buffer =>
      Buffer.from(ListWooCommerceMappingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWooCommerceMappingRequest => ListWooCommerceMappingRequest.decode(value),
    responseSerialize: (value: ListWooCommerceMappingResponse): Buffer =>
      Buffer.from(ListWooCommerceMappingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListWooCommerceMappingResponse =>
      ListWooCommerceMappingResponse.decode(value),
  },
  deleteMapping: {
    path: "/subscriptions.WooCommerceService/DeleteMapping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteByIdRequest): Buffer => Buffer.from(DeleteByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteByIdRequest => DeleteByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  processWebhook: {
    path: "/subscriptions.WooCommerceService/ProcessWebhook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessWooCommerceWebhookRequest): Buffer =>
      Buffer.from(ProcessWooCommerceWebhookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessWooCommerceWebhookRequest =>
      ProcessWooCommerceWebhookRequest.decode(value),
    responseSerialize: (value: WooCommerceWebhookResponse): Buffer =>
      Buffer.from(WooCommerceWebhookResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): WooCommerceWebhookResponse => WooCommerceWebhookResponse.decode(value),
  },
  getConfig: {
    path: "/subscriptions.WooCommerceService/GetConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWooCommerceConfigRequest): Buffer =>
      Buffer.from(GetWooCommerceConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetWooCommerceConfigRequest => GetWooCommerceConfigRequest.decode(value),
    responseSerialize: (value: WooCommerceConfig): Buffer => Buffer.from(WooCommerceConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer): WooCommerceConfig => WooCommerceConfig.decode(value),
  },
  updateConfig: {
    path: "/subscriptions.WooCommerceService/UpdateConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateWooCommerceConfigRequest): Buffer =>
      Buffer.from(UpdateWooCommerceConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateWooCommerceConfigRequest => UpdateWooCommerceConfigRequest.decode(value),
    responseSerialize: (value: WooCommerceConfig): Buffer => Buffer.from(WooCommerceConfig.encode(value).finish()),
    responseDeserialize: (value: Buffer): WooCommerceConfig => WooCommerceConfig.decode(value),
  },
} as const;

export interface WooCommerceServiceServer extends UntypedServiceImplementation {
  createMapping: handleUnaryCall<CreateWooCommerceMappingRequest, WooCommerceMapping>;
  updateMapping: handleUnaryCall<UpdateWooCommerceMappingRequest, WooCommerceMapping>;
  getMapping: handleUnaryCall<GetByIdRequest, WooCommerceMapping>;
  listMappings: handleUnaryCall<ListWooCommerceMappingRequest, ListWooCommerceMappingResponse>;
  deleteMapping: handleUnaryCall<DeleteByIdRequest, DeleteResponse>;
  processWebhook: handleUnaryCall<ProcessWooCommerceWebhookRequest, WooCommerceWebhookResponse>;
  getConfig: handleUnaryCall<GetWooCommerceConfigRequest, WooCommerceConfig>;
  updateConfig: handleUnaryCall<UpdateWooCommerceConfigRequest, WooCommerceConfig>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
