// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: payments/payment.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "payment";

export interface Empty {
}

export interface GetByIdRequest {
  id: string;
  /** Pour le multi-tenant */
  societeId: string;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface CreateStripeCheckoutSessionRequest {
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  /** 'payment', 'subscription', 'setup' */
  mode: string;
  successUrl: string;
  cancelUrl: string;
  customerId?: string | undefined;
  customerEmail?:
    | string
    | undefined;
  /** Pour les abonnements */
  priceId?: string | undefined;
  metadata: { [key: string]: string };
  lineItems: LineItem[];
}

export interface CreateStripeCheckoutSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface LineItem {
  name: string;
  description: string;
  amount: number;
  quantity: number;
  currency: string;
}

export interface StripeCheckoutSessionResponse {
  id: string;
  url: string;
  status: string;
  paymentStatus: string;
  customerId?: string | undefined;
  subscriptionId?: string | undefined;
}

export interface CreateStripePaymentIntentRequest {
  societeId: string;
  amount: number;
  currency: string;
  customerId?: string | undefined;
  description?: string | undefined;
  paymentMethod?: string | undefined;
  confirm: boolean;
  automaticPaymentMethods: boolean;
  metadata: { [key: string]: string };
}

export interface CreateStripePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripePaymentIntentResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  clientSecret?: string | undefined;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeCustomerRequest {
  societeId: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  description?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeCustomerRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeCustomerResponse {
  id: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  created: number;
}

export interface CreateStripeSubscriptionRequest {
  societeId: string;
  customerId: string;
  priceId: string;
  paymentMethod?: string | undefined;
  defaultPaymentMethod?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSubscriptionResponse {
  id: string;
  customerId: string;
  status: string;
  currentPeriodStart: number;
  currentPeriodEnd: number;
  cancelAtPeriodEnd: boolean;
}

export interface CreateStripeRefundRequest {
  societeId: string;
  paymentIntentId: string;
  /** Partial refund, omit for full */
  amount?: number | undefined;
  reason?: string | undefined;
}

export interface StripeRefundResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  paymentIntentId: string;
}

export interface CreateStripeSetupIntentRequest {
  societeId: string;
  customerId?: string | undefined;
  paymentMethodTypes: string[];
  metadata: { [key: string]: string };
}

export interface CreateStripeSetupIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSetupIntentResponse {
  id: string;
  clientSecret: string;
  status: string;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeBillingPortalRequest {
  societeId: string;
  customerId: string;
  returnUrl: string;
}

export interface StripeBillingPortalResponse {
  id: string;
  url: string;
}

export interface CreatePayPalOrderRequest {
  societeId: string;
  /** 'CAPTURE' or 'AUTHORIZE' */
  intent: string;
  purchaseUnits: PayPalPurchaseUnit[];
  returnUrl: string;
  cancelUrl: string;
  metadata: { [key: string]: string };
}

export interface CreatePayPalOrderRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PayPalPurchaseUnit {
  referenceId?:
    | string
    | undefined;
  /** En centimes */
  amount: number;
  currency: string;
  description?: string | undefined;
  customId?: string | undefined;
  invoiceId?: string | undefined;
}

export interface PayPalOrderResponse {
  id: string;
  status: string;
  approveUrl?: string | undefined;
  captureUrl?: string | undefined;
  links: PayPalLink[];
}

export interface PayPalLink {
  href: string;
  rel: string;
  method: string;
}

export interface GetPayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface CapturePayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface PayPalCaptureResponse {
  id: string;
  status: string;
  payer?: PayPalPayer | undefined;
  purchaseUnits: PayPalCapturedPurchaseUnit[];
}

export interface PayPalPayer {
  emailAddress?: string | undefined;
  payerId?: string | undefined;
  givenName?: string | undefined;
  surname?: string | undefined;
}

export interface PayPalCapturedPurchaseUnit {
  referenceId?: string | undefined;
  captures: PayPalCapture[];
}

export interface PayPalCapture {
  id: string;
  status: string;
  amount?: PayPalAmount | undefined;
}

export interface PayPalAmount {
  currencyCode: string;
  value: string;
}

export interface SetupGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
  /** 'bacs', 'sepa_core', 'ach', etc. */
  scheme: string;
  description?: string | undefined;
  successRedirectUrl: string;
  sessionToken?: string | undefined;
}

export interface GoCardlessMandateResponse {
  id: string;
  clientId: string;
  mandateId: string;
  status: string;
  scheme: string;
  bankName?: string | undefined;
  accountHolderName?: string | undefined;
  accountNumberEnding?: string | undefined;
  redirectUrl?: string | undefined;
}

export interface GetGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
}

export interface CreateGoCardlessPaymentRequest {
  clientId: string;
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  description?:
    | string
    | undefined;
  /** YYYY-MM-DD */
  chargeDate?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessPaymentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessPaymentResponse {
  id: string;
  paymentId: string;
  amount: number;
  currency: string;
  status: string;
  chargeDate?: string | undefined;
}

export interface CreateGoCardlessSubscriptionRequest {
  clientId: string;
  societeId: string;
  amount: number;
  currency: string;
  /** 'weekly', 'monthly', 'yearly' */
  intervalUnit: string;
  interval: number;
  name?: string | undefined;
  startDate?:
    | string
    | undefined;
  /** Number of payments, omit for indefinite */
  count?: number | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessSubscriptionResponse {
  id: string;
  subscriptionId: string;
  amount: number;
  currency: string;
  status: string;
  intervalUnit: string;
  interval: number;
  nextPaymentDate?: string | undefined;
}

export interface CancelGoCardlessSubscriptionRequest {
  subscriptionId: string;
  societeId: string;
}

export interface CreateScheduleRequest {
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  /** ISO date string */
  dueDate: string;
  description?: string | undefined;
  autoProcess: boolean;
  metadata: { [key: string]: string };
}

export interface CreateScheduleRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface ScheduleResponse {
  id: string;
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  dueDate: string;
  /** PLANNED, PROCESSING, PENDING, PAID, FAILED, UNPAID, CANCELLED, EXPIRED */
  status: string;
  lastAttemptAt?: string | undefined;
  paidAt?: string | undefined;
  retryCount: number;
  errorMessage?: string | undefined;
}

export interface UpdateScheduleRequest {
  id: string;
  amount?: number | undefined;
  dueDate?: string | undefined;
  status?: string | undefined;
  autoProcess?: boolean | undefined;
}

export interface GetDueSchedulesRequest {
  organisationId: string;
  /** Get schedules due before this date */
  beforeDate?: string | undefined;
}

export interface ScheduleListResponse {
  schedules: ScheduleResponse[];
  total: number;
}

export interface ProcessDuePaymentsRequest {
  organisationId: string;
  /** If true, don't actually process */
  dryRun?: boolean | undefined;
}

export interface ProcessDuePaymentsResponse {
  processedCount: number;
  successCount: number;
  failedCount: number;
  results: ProcessedPayment[];
}

export interface ProcessedPayment {
  scheduleId: string;
  success: boolean;
  paymentId?: string | undefined;
  error?: string | undefined;
}

export interface RenewScheduleRequest {
  id: string;
  newDueDate: string;
  newAmount?: number | undefined;
}

export interface CreatePaymentIntentRequest {
  organisationId: string;
  societeId: string;
  scheduleId?:
    | string
    | undefined;
  /** STRIPE, PAYPAL, GOCARDLESS, etc. */
  pspName: string;
  amount: number;
  currency: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreatePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PaymentIntentResponse {
  id: string;
  organisationId: string;
  societeId: string;
  scheduleId?: string | undefined;
  pspName: string;
  pspPaymentId?: string | undefined;
  amount: number;
  currency: string;
  /** PENDING, PROCESSING, SUCCEEDED, FAILED, CANCELLED */
  status: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface UpdatePaymentIntentRequest {
  id: string;
  status?: string | undefined;
  pspPaymentId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface CreatePaymentEventRequest {
  organisationId: string;
  paymentIntentId: string;
  /** PAYMENT_INITIATED, PAYMENT_CONFIRMED, PAYMENT_FAILED, etc. */
  eventType: string;
  /** JSON string */
  rawPayload: string;
}

export interface PaymentEventResponse {
  id: string;
  organisationId: string;
  paymentIntentId: string;
  eventType: string;
  rawPayload: string;
  receivedAt: string;
  processed: boolean;
  processedAt?: string | undefined;
  errorMessage?: string | undefined;
}

export interface GetUnprocessedEventsRequest {
  organisationId: string;
  limit?: number | undefined;
}

export interface PaymentEventListResponse {
  events: PaymentEventResponse[];
  total: number;
}

export interface MarkEventProcessedRequest {
  id: string;
  /** If processing failed */
  errorMessage?: string | undefined;
}

export interface GetPSPAccountsRequest {
  societeId: string;
}

export interface PSPAccountsSummaryResponse {
  stripe?: PSPAccountInfo | undefined;
  paypal?: PSPAccountInfo | undefined;
  gocardless?: PSPAccountInfo | undefined;
  emerchantpay?: PSPAccountInfo | undefined;
  slimpay?: PSPAccountInfo | undefined;
  multisafepay?: PSPAccountInfo | undefined;
}

export interface PSPAccountInfo {
  id: string;
  name: string;
  isActive: boolean;
  isLiveMode: boolean;
  isConfigured: boolean;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "", societeId: "" };
}

export const GetByIdRequest = {
  encode(message: GetByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetByIdRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
    };
  },

  toJSON(message: GetByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetByIdRequest>, I>>(base?: I): GetByIdRequest {
    return GetByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetByIdRequest>, I>>(object: I): GetByIdRequest {
    const message = createBaseGetByIdRequest();
    message.id = object.id ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse = {
  encode(message: DeleteResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(base?: I): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(object: I): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest(): CreateStripeCheckoutSessionRequest {
  return {
    societeId: "",
    amount: 0,
    currency: "",
    mode: "",
    successUrl: "",
    cancelUrl: "",
    customerId: undefined,
    customerEmail: undefined,
    priceId: undefined,
    metadata: {},
    lineItems: [],
  };
}

export const CreateStripeCheckoutSessionRequest = {
  encode(message: CreateStripeCheckoutSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.mode !== "") {
      writer.uint32(34).string(message.mode);
    }
    if (message.successUrl !== "") {
      writer.uint32(42).string(message.successUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(50).string(message.cancelUrl);
    }
    if (message.customerId !== undefined) {
      writer.uint32(58).string(message.customerId);
    }
    if (message.customerEmail !== undefined) {
      writer.uint32(66).string(message.customerEmail);
    }
    if (message.priceId !== undefined) {
      writer.uint32(74).string(message.priceId);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateStripeCheckoutSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .ldelim();
    });
    for (const v of message.lineItems) {
      LineItem.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.customerEmail = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.priceId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateStripeCheckoutSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lineItems.push(LineItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCheckoutSessionRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      successUrl: isSet(object.successUrl) ? globalThis.String(object.successUrl) : "",
      cancelUrl: isSet(object.cancelUrl) ? globalThis.String(object.cancelUrl) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      customerEmail: isSet(object.customerEmail) ? globalThis.String(object.customerEmail) : undefined,
      priceId: isSet(object.priceId) ? globalThis.String(object.priceId) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      lineItems: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => LineItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateStripeCheckoutSessionRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.successUrl !== "") {
      obj.successUrl = message.successUrl;
    }
    if (message.cancelUrl !== "") {
      obj.cancelUrl = message.cancelUrl;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.customerEmail !== undefined) {
      obj.customerEmail = message.customerEmail;
    }
    if (message.priceId !== undefined) {
      obj.priceId = message.priceId;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.lineItems?.length) {
      obj.lineItems = message.lineItems.map((e) => LineItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest>, I>>(
    base?: I,
  ): CreateStripeCheckoutSessionRequest {
    return CreateStripeCheckoutSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest>, I>>(
    object: I,
  ): CreateStripeCheckoutSessionRequest {
    const message = createBaseCreateStripeCheckoutSessionRequest();
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.mode = object.mode ?? "";
    message.successUrl = object.successUrl ?? "";
    message.cancelUrl = object.cancelUrl ?? "";
    message.customerId = object.customerId ?? undefined;
    message.customerEmail = object.customerEmail ?? undefined;
    message.priceId = object.priceId ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.lineItems = object.lineItems?.map((e) => LineItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest_MetadataEntry(): CreateStripeCheckoutSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCheckoutSessionRequest_MetadataEntry = {
  encode(
    message: CreateStripeCheckoutSessionRequest_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCheckoutSessionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeCheckoutSessionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeCheckoutSessionRequest_MetadataEntry {
    return CreateStripeCheckoutSessionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCheckoutSessionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeCheckoutSessionRequest_MetadataEntry {
    const message = createBaseCreateStripeCheckoutSessionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLineItem(): LineItem {
  return { name: "", description: "", amount: 0, quantity: 0, currency: "" };
}

export const LineItem = {
  encode(message: LineItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LineItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineItem {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: LineItem): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LineItem>, I>>(base?: I): LineItem {
    return LineItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LineItem>, I>>(object: I): LineItem {
    const message = createBaseLineItem();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.amount = object.amount ?? 0;
    message.quantity = object.quantity ?? 0;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseStripeCheckoutSessionResponse(): StripeCheckoutSessionResponse {
  return { id: "", url: "", status: "", paymentStatus: "", customerId: undefined, subscriptionId: undefined };
}

export const StripeCheckoutSessionResponse = {
  encode(message: StripeCheckoutSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.paymentStatus !== "") {
      writer.uint32(34).string(message.paymentStatus);
    }
    if (message.customerId !== undefined) {
      writer.uint32(42).string(message.customerId);
    }
    if (message.subscriptionId !== undefined) {
      writer.uint32(50).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StripeCheckoutSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCheckoutSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.paymentStatus = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeCheckoutSessionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      paymentStatus: isSet(object.paymentStatus) ? globalThis.String(object.paymentStatus) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : undefined,
    };
  },

  toJSON(message: StripeCheckoutSessionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.paymentStatus !== "") {
      obj.paymentStatus = message.paymentStatus;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.subscriptionId !== undefined) {
      obj.subscriptionId = message.subscriptionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeCheckoutSessionResponse>, I>>(base?: I): StripeCheckoutSessionResponse {
    return StripeCheckoutSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeCheckoutSessionResponse>, I>>(
    object: I,
  ): StripeCheckoutSessionResponse {
    const message = createBaseStripeCheckoutSessionResponse();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    message.status = object.status ?? "";
    message.paymentStatus = object.paymentStatus ?? "";
    message.customerId = object.customerId ?? undefined;
    message.subscriptionId = object.subscriptionId ?? undefined;
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest(): CreateStripePaymentIntentRequest {
  return {
    societeId: "",
    amount: 0,
    currency: "",
    customerId: undefined,
    description: undefined,
    paymentMethod: undefined,
    confirm: false,
    automaticPaymentMethods: false,
    metadata: {},
  };
}

export const CreateStripePaymentIntentRequest = {
  encode(message: CreateStripePaymentIntentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(50).string(message.paymentMethod);
    }
    if (message.confirm !== false) {
      writer.uint32(56).bool(message.confirm);
    }
    if (message.automaticPaymentMethods !== false) {
      writer.uint32(64).bool(message.automaticPaymentMethods);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateStripePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripePaymentIntentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.confirm = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.automaticPaymentMethods = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = CreateStripePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripePaymentIntentRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? globalThis.String(object.paymentMethod) : undefined,
      confirm: isSet(object.confirm) ? globalThis.Boolean(object.confirm) : false,
      automaticPaymentMethods: isSet(object.automaticPaymentMethods)
        ? globalThis.Boolean(object.automaticPaymentMethods)
        : false,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateStripePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.confirm !== false) {
      obj.confirm = message.confirm;
    }
    if (message.automaticPaymentMethods !== false) {
      obj.automaticPaymentMethods = message.automaticPaymentMethods;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest>, I>>(
    base?: I,
  ): CreateStripePaymentIntentRequest {
    return CreateStripePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest>, I>>(
    object: I,
  ): CreateStripePaymentIntentRequest {
    const message = createBaseCreateStripePaymentIntentRequest();
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.customerId = object.customerId ?? undefined;
    message.description = object.description ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    message.confirm = object.confirm ?? false;
    message.automaticPaymentMethods = object.automaticPaymentMethods ?? false;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest_MetadataEntry(): CreateStripePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripePaymentIntentRequest_MetadataEntry = {
  encode(
    message: CreateStripePaymentIntentRequest_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripePaymentIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripePaymentIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripePaymentIntentRequest_MetadataEntry {
    return CreateStripePaymentIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripePaymentIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripePaymentIntentRequest_MetadataEntry {
    const message = createBaseCreateStripePaymentIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripePaymentIntentResponse(): StripePaymentIntentResponse {
  return {
    id: "",
    amount: 0,
    currency: "",
    status: "",
    clientSecret: undefined,
    customerId: undefined,
    paymentMethod: undefined,
  };
}

export const StripePaymentIntentResponse = {
  encode(message: StripePaymentIntentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.clientSecret !== undefined) {
      writer.uint32(42).string(message.clientSecret);
    }
    if (message.customerId !== undefined) {
      writer.uint32(50).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(58).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StripePaymentIntentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripePaymentIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : undefined,
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? globalThis.String(object.paymentMethod) : undefined,
    };
  },

  toJSON(message: StripePaymentIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.clientSecret !== undefined) {
      obj.clientSecret = message.clientSecret;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripePaymentIntentResponse>, I>>(base?: I): StripePaymentIntentResponse {
    return StripePaymentIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripePaymentIntentResponse>, I>>(object: I): StripePaymentIntentResponse {
    const message = createBaseStripePaymentIntentResponse();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.clientSecret = object.clientSecret ?? undefined;
    message.customerId = object.customerId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    return message;
  },
};

function createBaseCreateStripeCustomerRequest(): CreateStripeCustomerRequest {
  return { societeId: "", email: "", name: undefined, phone: undefined, description: undefined, metadata: {} };
}

export const CreateStripeCustomerRequest = {
  encode(message: CreateStripeCustomerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateStripeCustomerRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeCustomerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeCustomerRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCustomerRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateStripeCustomerRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCustomerRequest>, I>>(base?: I): CreateStripeCustomerRequest {
    return CreateStripeCustomerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCustomerRequest>, I>>(object: I): CreateStripeCustomerRequest {
    const message = createBaseCreateStripeCustomerRequest();
    message.societeId = object.societeId ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? undefined;
    message.phone = object.phone ?? undefined;
    message.description = object.description ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateStripeCustomerRequest_MetadataEntry(): CreateStripeCustomerRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCustomerRequest_MetadataEntry = {
  encode(message: CreateStripeCustomerRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeCustomerRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeCustomerRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeCustomerRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeCustomerRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeCustomerRequest_MetadataEntry {
    return CreateStripeCustomerRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeCustomerRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeCustomerRequest_MetadataEntry {
    const message = createBaseCreateStripeCustomerRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripeCustomerResponse(): StripeCustomerResponse {
  return { id: "", email: "", name: undefined, phone: undefined, created: 0 };
}

export const StripeCustomerResponse = {
  encode(message: StripeCustomerResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.created !== 0) {
      writer.uint32(40).int64(message.created);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StripeCustomerResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCustomerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.created = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeCustomerResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      created: isSet(object.created) ? globalThis.Number(object.created) : 0,
    };
  },

  toJSON(message: StripeCustomerResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.created !== 0) {
      obj.created = Math.round(message.created);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeCustomerResponse>, I>>(base?: I): StripeCustomerResponse {
    return StripeCustomerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeCustomerResponse>, I>>(object: I): StripeCustomerResponse {
    const message = createBaseStripeCustomerResponse();
    message.id = object.id ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? undefined;
    message.phone = object.phone ?? undefined;
    message.created = object.created ?? 0;
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest(): CreateStripeSubscriptionRequest {
  return {
    societeId: "",
    customerId: "",
    priceId: "",
    paymentMethod: undefined,
    defaultPaymentMethod: undefined,
    metadata: {},
  };
}

export const CreateStripeSubscriptionRequest = {
  encode(message: CreateStripeSubscriptionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.priceId !== "") {
      writer.uint32(26).string(message.priceId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(34).string(message.paymentMethod);
    }
    if (message.defaultPaymentMethod !== undefined) {
      writer.uint32(42).string(message.defaultPaymentMethod);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateStripeSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeSubscriptionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.priceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultPaymentMethod = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSubscriptionRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      priceId: isSet(object.priceId) ? globalThis.String(object.priceId) : "",
      paymentMethod: isSet(object.paymentMethod) ? globalThis.String(object.paymentMethod) : undefined,
      defaultPaymentMethod: isSet(object.defaultPaymentMethod)
        ? globalThis.String(object.defaultPaymentMethod)
        : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateStripeSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.priceId !== "") {
      obj.priceId = message.priceId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    if (message.defaultPaymentMethod !== undefined) {
      obj.defaultPaymentMethod = message.defaultPaymentMethod;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest>, I>>(base?: I): CreateStripeSubscriptionRequest {
    return CreateStripeSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest>, I>>(
    object: I,
  ): CreateStripeSubscriptionRequest {
    const message = createBaseCreateStripeSubscriptionRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.priceId = object.priceId ?? "";
    message.paymentMethod = object.paymentMethod ?? undefined;
    message.defaultPaymentMethod = object.defaultPaymentMethod ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest_MetadataEntry(): CreateStripeSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSubscriptionRequest_MetadataEntry = {
  encode(message: CreateStripeSubscriptionRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeSubscriptionRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSubscriptionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSubscriptionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeSubscriptionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeSubscriptionRequest_MetadataEntry {
    return CreateStripeSubscriptionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSubscriptionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeSubscriptionRequest_MetadataEntry {
    const message = createBaseCreateStripeSubscriptionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripeSubscriptionResponse(): StripeSubscriptionResponse {
  return { id: "", customerId: "", status: "", currentPeriodStart: 0, currentPeriodEnd: 0, cancelAtPeriodEnd: false };
}

export const StripeSubscriptionResponse = {
  encode(message: StripeSubscriptionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.currentPeriodStart !== 0) {
      writer.uint32(32).int64(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== 0) {
      writer.uint32(40).int64(message.currentPeriodEnd);
    }
    if (message.cancelAtPeriodEnd !== false) {
      writer.uint32(48).bool(message.cancelAtPeriodEnd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StripeSubscriptionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.currentPeriodStart = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.currentPeriodEnd = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeSubscriptionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      currentPeriodStart: isSet(object.currentPeriodStart) ? globalThis.Number(object.currentPeriodStart) : 0,
      currentPeriodEnd: isSet(object.currentPeriodEnd) ? globalThis.Number(object.currentPeriodEnd) : 0,
      cancelAtPeriodEnd: isSet(object.cancelAtPeriodEnd) ? globalThis.Boolean(object.cancelAtPeriodEnd) : false,
    };
  },

  toJSON(message: StripeSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.currentPeriodStart !== 0) {
      obj.currentPeriodStart = Math.round(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== 0) {
      obj.currentPeriodEnd = Math.round(message.currentPeriodEnd);
    }
    if (message.cancelAtPeriodEnd !== false) {
      obj.cancelAtPeriodEnd = message.cancelAtPeriodEnd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeSubscriptionResponse>, I>>(base?: I): StripeSubscriptionResponse {
    return StripeSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeSubscriptionResponse>, I>>(object: I): StripeSubscriptionResponse {
    const message = createBaseStripeSubscriptionResponse();
    message.id = object.id ?? "";
    message.customerId = object.customerId ?? "";
    message.status = object.status ?? "";
    message.currentPeriodStart = object.currentPeriodStart ?? 0;
    message.currentPeriodEnd = object.currentPeriodEnd ?? 0;
    message.cancelAtPeriodEnd = object.cancelAtPeriodEnd ?? false;
    return message;
  },
};

function createBaseCreateStripeRefundRequest(): CreateStripeRefundRequest {
  return { societeId: "", paymentIntentId: "", amount: undefined, reason: undefined };
}

export const CreateStripeRefundRequest = {
  encode(message: CreateStripeRefundRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.amount !== undefined) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeRefundRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeRefundRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      paymentIntentId: isSet(object.paymentIntentId) ? globalThis.String(object.paymentIntentId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: CreateStripeRefundRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeRefundRequest>, I>>(base?: I): CreateStripeRefundRequest {
    return CreateStripeRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeRefundRequest>, I>>(object: I): CreateStripeRefundRequest {
    const message = createBaseCreateStripeRefundRequest();
    message.societeId = object.societeId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.amount = object.amount ?? undefined;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseStripeRefundResponse(): StripeRefundResponse {
  return { id: "", amount: 0, currency: "", status: "", paymentIntentId: "" };
}

export const StripeRefundResponse = {
  encode(message: StripeRefundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(42).string(message.paymentIntentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StripeRefundResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeRefundResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      paymentIntentId: isSet(object.paymentIntentId) ? globalThis.String(object.paymentIntentId) : "",
    };
  },

  toJSON(message: StripeRefundResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeRefundResponse>, I>>(base?: I): StripeRefundResponse {
    return StripeRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeRefundResponse>, I>>(object: I): StripeRefundResponse {
    const message = createBaseStripeRefundResponse();
    message.id = object.id ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest(): CreateStripeSetupIntentRequest {
  return { societeId: "", customerId: undefined, paymentMethodTypes: [], metadata: {} };
}

export const CreateStripeSetupIntentRequest = {
  encode(message: CreateStripeSetupIntentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== undefined) {
      writer.uint32(18).string(message.customerId);
    }
    for (const v of message.paymentMethodTypes) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateStripeSetupIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeSetupIntentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paymentMethodTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateStripeSetupIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSetupIntentRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      paymentMethodTypes: globalThis.Array.isArray(object?.paymentMethodTypes)
        ? object.paymentMethodTypes.map((e: any) => globalThis.String(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateStripeSetupIntentRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethodTypes?.length) {
      obj.paymentMethodTypes = message.paymentMethodTypes;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest>, I>>(base?: I): CreateStripeSetupIntentRequest {
    return CreateStripeSetupIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest>, I>>(
    object: I,
  ): CreateStripeSetupIntentRequest {
    const message = createBaseCreateStripeSetupIntentRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? undefined;
    message.paymentMethodTypes = object.paymentMethodTypes?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest_MetadataEntry(): CreateStripeSetupIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSetupIntentRequest_MetadataEntry = {
  encode(message: CreateStripeSetupIntentRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeSetupIntentRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeSetupIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateStripeSetupIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateStripeSetupIntentRequest_MetadataEntry {
    return CreateStripeSetupIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeSetupIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateStripeSetupIntentRequest_MetadataEntry {
    const message = createBaseCreateStripeSetupIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStripeSetupIntentResponse(): StripeSetupIntentResponse {
  return { id: "", clientSecret: "", status: "", customerId: undefined, paymentMethod: undefined };
}

export const StripeSetupIntentResponse = {
  encode(message: StripeSetupIntentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(42).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StripeSetupIntentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSetupIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeSetupIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : undefined,
      paymentMethod: isSet(object.paymentMethod) ? globalThis.String(object.paymentMethod) : undefined,
    };
  },

  toJSON(message: StripeSetupIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.customerId !== undefined) {
      obj.customerId = message.customerId;
    }
    if (message.paymentMethod !== undefined) {
      obj.paymentMethod = message.paymentMethod;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeSetupIntentResponse>, I>>(base?: I): StripeSetupIntentResponse {
    return StripeSetupIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeSetupIntentResponse>, I>>(object: I): StripeSetupIntentResponse {
    const message = createBaseStripeSetupIntentResponse();
    message.id = object.id ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.status = object.status ?? "";
    message.customerId = object.customerId ?? undefined;
    message.paymentMethod = object.paymentMethod ?? undefined;
    return message;
  },
};

function createBaseCreateStripeBillingPortalRequest(): CreateStripeBillingPortalRequest {
  return { societeId: "", customerId: "", returnUrl: "" };
}

export const CreateStripeBillingPortalRequest = {
  encode(message: CreateStripeBillingPortalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.returnUrl !== "") {
      writer.uint32(26).string(message.returnUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStripeBillingPortalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeBillingPortalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeBillingPortalRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      returnUrl: isSet(object.returnUrl) ? globalThis.String(object.returnUrl) : "",
    };
  },

  toJSON(message: CreateStripeBillingPortalRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.returnUrl !== "") {
      obj.returnUrl = message.returnUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeBillingPortalRequest>, I>>(
    base?: I,
  ): CreateStripeBillingPortalRequest {
    return CreateStripeBillingPortalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeBillingPortalRequest>, I>>(
    object: I,
  ): CreateStripeBillingPortalRequest {
    const message = createBaseCreateStripeBillingPortalRequest();
    message.societeId = object.societeId ?? "";
    message.customerId = object.customerId ?? "";
    message.returnUrl = object.returnUrl ?? "";
    return message;
  },
};

function createBaseStripeBillingPortalResponse(): StripeBillingPortalResponse {
  return { id: "", url: "" };
}

export const StripeBillingPortalResponse = {
  encode(message: StripeBillingPortalResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StripeBillingPortalResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeBillingPortalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StripeBillingPortalResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: StripeBillingPortalResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StripeBillingPortalResponse>, I>>(base?: I): StripeBillingPortalResponse {
    return StripeBillingPortalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StripeBillingPortalResponse>, I>>(object: I): StripeBillingPortalResponse {
    const message = createBaseStripeBillingPortalResponse();
    message.id = object.id ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseCreatePayPalOrderRequest(): CreatePayPalOrderRequest {
  return { societeId: "", intent: "", purchaseUnits: [], returnUrl: "", cancelUrl: "", metadata: {} };
}

export const CreatePayPalOrderRequest = {
  encode(message: CreatePayPalOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.intent !== "") {
      writer.uint32(18).string(message.intent);
    }
    for (const v of message.purchaseUnits) {
      PayPalPurchaseUnit.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.returnUrl !== "") {
      writer.uint32(34).string(message.returnUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(42).string(message.cancelUrl);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreatePayPalOrderRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePayPalOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.purchaseUnits.push(PayPalPurchaseUnit.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = CreatePayPalOrderRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePayPalOrderRequest {
    return {
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      purchaseUnits: globalThis.Array.isArray(object?.purchaseUnits)
        ? object.purchaseUnits.map((e: any) => PayPalPurchaseUnit.fromJSON(e))
        : [],
      returnUrl: isSet(object.returnUrl) ? globalThis.String(object.returnUrl) : "",
      cancelUrl: isSet(object.cancelUrl) ? globalThis.String(object.cancelUrl) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreatePayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.purchaseUnits?.length) {
      obj.purchaseUnits = message.purchaseUnits.map((e) => PayPalPurchaseUnit.toJSON(e));
    }
    if (message.returnUrl !== "") {
      obj.returnUrl = message.returnUrl;
    }
    if (message.cancelUrl !== "") {
      obj.cancelUrl = message.cancelUrl;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePayPalOrderRequest>, I>>(base?: I): CreatePayPalOrderRequest {
    return CreatePayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePayPalOrderRequest>, I>>(object: I): CreatePayPalOrderRequest {
    const message = createBaseCreatePayPalOrderRequest();
    message.societeId = object.societeId ?? "";
    message.intent = object.intent ?? "";
    message.purchaseUnits = object.purchaseUnits?.map((e) => PayPalPurchaseUnit.fromPartial(e)) || [];
    message.returnUrl = object.returnUrl ?? "";
    message.cancelUrl = object.cancelUrl ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreatePayPalOrderRequest_MetadataEntry(): CreatePayPalOrderRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePayPalOrderRequest_MetadataEntry = {
  encode(message: CreatePayPalOrderRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePayPalOrderRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePayPalOrderRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePayPalOrderRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePayPalOrderRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePayPalOrderRequest_MetadataEntry {
    return CreatePayPalOrderRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePayPalOrderRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePayPalOrderRequest_MetadataEntry {
    const message = createBaseCreatePayPalOrderRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePayPalPurchaseUnit(): PayPalPurchaseUnit {
  return {
    referenceId: undefined,
    amount: 0,
    currency: "",
    description: undefined,
    customId: undefined,
    invoiceId: undefined,
  };
}

export const PayPalPurchaseUnit = {
  encode(message: PayPalPurchaseUnit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.customId !== undefined) {
      writer.uint32(42).string(message.customId);
    }
    if (message.invoiceId !== undefined) {
      writer.uint32(50).string(message.invoiceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalPurchaseUnit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalPurchaseUnit {
    return {
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      customId: isSet(object.customId) ? globalThis.String(object.customId) : undefined,
      invoiceId: isSet(object.invoiceId) ? globalThis.String(object.invoiceId) : undefined,
    };
  },

  toJSON(message: PayPalPurchaseUnit): unknown {
    const obj: any = {};
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.customId !== undefined) {
      obj.customId = message.customId;
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = message.invoiceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalPurchaseUnit>, I>>(base?: I): PayPalPurchaseUnit {
    return PayPalPurchaseUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalPurchaseUnit>, I>>(object: I): PayPalPurchaseUnit {
    const message = createBasePayPalPurchaseUnit();
    message.referenceId = object.referenceId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.customId = object.customId ?? undefined;
    message.invoiceId = object.invoiceId ?? undefined;
    return message;
  },
};

function createBasePayPalOrderResponse(): PayPalOrderResponse {
  return { id: "", status: "", approveUrl: undefined, captureUrl: undefined, links: [] };
}

export const PayPalOrderResponse = {
  encode(message: PayPalOrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.approveUrl !== undefined) {
      writer.uint32(26).string(message.approveUrl);
    }
    if (message.captureUrl !== undefined) {
      writer.uint32(34).string(message.captureUrl);
    }
    for (const v of message.links) {
      PayPalLink.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalOrderResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.approveUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.captureUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.links.push(PayPalLink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalOrderResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      approveUrl: isSet(object.approveUrl) ? globalThis.String(object.approveUrl) : undefined,
      captureUrl: isSet(object.captureUrl) ? globalThis.String(object.captureUrl) : undefined,
      links: globalThis.Array.isArray(object?.links) ? object.links.map((e: any) => PayPalLink.fromJSON(e)) : [],
    };
  },

  toJSON(message: PayPalOrderResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.approveUrl !== undefined) {
      obj.approveUrl = message.approveUrl;
    }
    if (message.captureUrl !== undefined) {
      obj.captureUrl = message.captureUrl;
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => PayPalLink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalOrderResponse>, I>>(base?: I): PayPalOrderResponse {
    return PayPalOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalOrderResponse>, I>>(object: I): PayPalOrderResponse {
    const message = createBasePayPalOrderResponse();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.approveUrl = object.approveUrl ?? undefined;
    message.captureUrl = object.captureUrl ?? undefined;
    message.links = object.links?.map((e) => PayPalLink.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalLink(): PayPalLink {
  return { href: "", rel: "", method: "" };
}

export const PayPalLink = {
  encode(message: PayPalLink, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.href !== "") {
      writer.uint32(10).string(message.href);
    }
    if (message.rel !== "") {
      writer.uint32(18).string(message.rel);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalLink {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.href = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rel = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalLink {
    return {
      href: isSet(object.href) ? globalThis.String(object.href) : "",
      rel: isSet(object.rel) ? globalThis.String(object.rel) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
    };
  },

  toJSON(message: PayPalLink): unknown {
    const obj: any = {};
    if (message.href !== "") {
      obj.href = message.href;
    }
    if (message.rel !== "") {
      obj.rel = message.rel;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalLink>, I>>(base?: I): PayPalLink {
    return PayPalLink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalLink>, I>>(object: I): PayPalLink {
    const message = createBasePayPalLink();
    message.href = object.href ?? "";
    message.rel = object.rel ?? "";
    message.method = object.method ?? "";
    return message;
  },
};

function createBaseGetPayPalOrderRequest(): GetPayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const GetPayPalOrderRequest = {
  encode(message: GetPayPalOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPayPalOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPayPalOrderRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
    };
  },

  toJSON(message: GetPayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPayPalOrderRequest>, I>>(base?: I): GetPayPalOrderRequest {
    return GetPayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPayPalOrderRequest>, I>>(object: I): GetPayPalOrderRequest {
    const message = createBaseGetPayPalOrderRequest();
    message.orderId = object.orderId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCapturePayPalOrderRequest(): CapturePayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const CapturePayPalOrderRequest = {
  encode(message: CapturePayPalOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CapturePayPalOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapturePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapturePayPalOrderRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
    };
  },

  toJSON(message: CapturePayPalOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CapturePayPalOrderRequest>, I>>(base?: I): CapturePayPalOrderRequest {
    return CapturePayPalOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CapturePayPalOrderRequest>, I>>(object: I): CapturePayPalOrderRequest {
    const message = createBaseCapturePayPalOrderRequest();
    message.orderId = object.orderId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBasePayPalCaptureResponse(): PayPalCaptureResponse {
  return { id: "", status: "", payer: undefined, purchaseUnits: [] };
}

export const PayPalCaptureResponse = {
  encode(message: PayPalCaptureResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.payer !== undefined) {
      PayPalPayer.encode(message.payer, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.purchaseUnits) {
      PayPalCapturedPurchaseUnit.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalCaptureResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCaptureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payer = PayPalPayer.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.purchaseUnits.push(PayPalCapturedPurchaseUnit.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCaptureResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      payer: isSet(object.payer) ? PayPalPayer.fromJSON(object.payer) : undefined,
      purchaseUnits: globalThis.Array.isArray(object?.purchaseUnits)
        ? object.purchaseUnits.map((e: any) => PayPalCapturedPurchaseUnit.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PayPalCaptureResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.payer !== undefined) {
      obj.payer = PayPalPayer.toJSON(message.payer);
    }
    if (message.purchaseUnits?.length) {
      obj.purchaseUnits = message.purchaseUnits.map((e) => PayPalCapturedPurchaseUnit.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCaptureResponse>, I>>(base?: I): PayPalCaptureResponse {
    return PayPalCaptureResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCaptureResponse>, I>>(object: I): PayPalCaptureResponse {
    const message = createBasePayPalCaptureResponse();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.payer = (object.payer !== undefined && object.payer !== null)
      ? PayPalPayer.fromPartial(object.payer)
      : undefined;
    message.purchaseUnits = object.purchaseUnits?.map((e) => PayPalCapturedPurchaseUnit.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalPayer(): PayPalPayer {
  return { emailAddress: undefined, payerId: undefined, givenName: undefined, surname: undefined };
}

export const PayPalPayer = {
  encode(message: PayPalPayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.emailAddress !== undefined) {
      writer.uint32(10).string(message.emailAddress);
    }
    if (message.payerId !== undefined) {
      writer.uint32(18).string(message.payerId);
    }
    if (message.givenName !== undefined) {
      writer.uint32(26).string(message.givenName);
    }
    if (message.surname !== undefined) {
      writer.uint32(34).string(message.surname);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalPayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.givenName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.surname = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalPayer {
    return {
      emailAddress: isSet(object.emailAddress) ? globalThis.String(object.emailAddress) : undefined,
      payerId: isSet(object.payerId) ? globalThis.String(object.payerId) : undefined,
      givenName: isSet(object.givenName) ? globalThis.String(object.givenName) : undefined,
      surname: isSet(object.surname) ? globalThis.String(object.surname) : undefined,
    };
  },

  toJSON(message: PayPalPayer): unknown {
    const obj: any = {};
    if (message.emailAddress !== undefined) {
      obj.emailAddress = message.emailAddress;
    }
    if (message.payerId !== undefined) {
      obj.payerId = message.payerId;
    }
    if (message.givenName !== undefined) {
      obj.givenName = message.givenName;
    }
    if (message.surname !== undefined) {
      obj.surname = message.surname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalPayer>, I>>(base?: I): PayPalPayer {
    return PayPalPayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalPayer>, I>>(object: I): PayPalPayer {
    const message = createBasePayPalPayer();
    message.emailAddress = object.emailAddress ?? undefined;
    message.payerId = object.payerId ?? undefined;
    message.givenName = object.givenName ?? undefined;
    message.surname = object.surname ?? undefined;
    return message;
  },
};

function createBasePayPalCapturedPurchaseUnit(): PayPalCapturedPurchaseUnit {
  return { referenceId: undefined, captures: [] };
}

export const PayPalCapturedPurchaseUnit = {
  encode(message: PayPalCapturedPurchaseUnit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    for (const v of message.captures) {
      PayPalCapture.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalCapturedPurchaseUnit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapturedPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.captures.push(PayPalCapture.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCapturedPurchaseUnit {
    return {
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : undefined,
      captures: globalThis.Array.isArray(object?.captures)
        ? object.captures.map((e: any) => PayPalCapture.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PayPalCapturedPurchaseUnit): unknown {
    const obj: any = {};
    if (message.referenceId !== undefined) {
      obj.referenceId = message.referenceId;
    }
    if (message.captures?.length) {
      obj.captures = message.captures.map((e) => PayPalCapture.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCapturedPurchaseUnit>, I>>(base?: I): PayPalCapturedPurchaseUnit {
    return PayPalCapturedPurchaseUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCapturedPurchaseUnit>, I>>(object: I): PayPalCapturedPurchaseUnit {
    const message = createBasePayPalCapturedPurchaseUnit();
    message.referenceId = object.referenceId ?? undefined;
    message.captures = object.captures?.map((e) => PayPalCapture.fromPartial(e)) || [];
    return message;
  },
};

function createBasePayPalCapture(): PayPalCapture {
  return { id: "", status: "", amount: undefined };
}

export const PayPalCapture = {
  encode(message: PayPalCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.amount !== undefined) {
      PayPalAmount.encode(message.amount, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = PayPalAmount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalCapture {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      amount: isSet(object.amount) ? PayPalAmount.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: PayPalCapture): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.amount !== undefined) {
      obj.amount = PayPalAmount.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalCapture>, I>>(base?: I): PayPalCapture {
    return PayPalCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalCapture>, I>>(object: I): PayPalCapture {
    const message = createBasePayPalCapture();
    message.id = object.id ?? "";
    message.status = object.status ?? "";
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? PayPalAmount.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBasePayPalAmount(): PayPalAmount {
  return { currencyCode: "", value: "" };
}

export const PayPalAmount = {
  encode(message: PayPalAmount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PayPalAmount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PayPalAmount {
    return {
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PayPalAmount): unknown {
    const obj: any = {};
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PayPalAmount>, I>>(base?: I): PayPalAmount {
    return PayPalAmount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PayPalAmount>, I>>(object: I): PayPalAmount {
    const message = createBasePayPalAmount();
    message.currencyCode = object.currencyCode ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetupGoCardlessMandateRequest(): SetupGoCardlessMandateRequest {
  return {
    clientId: "",
    societeId: "",
    scheme: "",
    description: undefined,
    successRedirectUrl: "",
    sessionToken: undefined,
  };
}

export const SetupGoCardlessMandateRequest = {
  encode(message: SetupGoCardlessMandateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheme !== "") {
      writer.uint32(26).string(message.scheme);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.successRedirectUrl !== "") {
      writer.uint32(42).string(message.successRedirectUrl);
    }
    if (message.sessionToken !== undefined) {
      writer.uint32(50).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetupGoCardlessMandateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scheme = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.successRedirectUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetupGoCardlessMandateRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      successRedirectUrl: isSet(object.successRedirectUrl) ? globalThis.String(object.successRedirectUrl) : "",
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : undefined,
    };
  },

  toJSON(message: SetupGoCardlessMandateRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.successRedirectUrl !== "") {
      obj.successRedirectUrl = message.successRedirectUrl;
    }
    if (message.sessionToken !== undefined) {
      obj.sessionToken = message.sessionToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetupGoCardlessMandateRequest>, I>>(base?: I): SetupGoCardlessMandateRequest {
    return SetupGoCardlessMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetupGoCardlessMandateRequest>, I>>(
    object: I,
  ): SetupGoCardlessMandateRequest {
    const message = createBaseSetupGoCardlessMandateRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheme = object.scheme ?? "";
    message.description = object.description ?? undefined;
    message.successRedirectUrl = object.successRedirectUrl ?? "";
    message.sessionToken = object.sessionToken ?? undefined;
    return message;
  },
};

function createBaseGoCardlessMandateResponse(): GoCardlessMandateResponse {
  return {
    id: "",
    clientId: "",
    mandateId: "",
    status: "",
    scheme: "",
    bankName: undefined,
    accountHolderName: undefined,
    accountNumberEnding: undefined,
    redirectUrl: undefined,
  };
}

export const GoCardlessMandateResponse = {
  encode(message: GoCardlessMandateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.mandateId !== "") {
      writer.uint32(26).string(message.mandateId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.scheme !== "") {
      writer.uint32(42).string(message.scheme);
    }
    if (message.bankName !== undefined) {
      writer.uint32(50).string(message.bankName);
    }
    if (message.accountHolderName !== undefined) {
      writer.uint32(58).string(message.accountHolderName);
    }
    if (message.accountNumberEnding !== undefined) {
      writer.uint32(66).string(message.accountNumberEnding);
    }
    if (message.redirectUrl !== undefined) {
      writer.uint32(74).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GoCardlessMandateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessMandateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.scheme = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bankName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.accountHolderName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.accountNumberEnding = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessMandateResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      mandateId: isSet(object.mandateId) ? globalThis.String(object.mandateId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "",
      bankName: isSet(object.bankName) ? globalThis.String(object.bankName) : undefined,
      accountHolderName: isSet(object.accountHolderName) ? globalThis.String(object.accountHolderName) : undefined,
      accountNumberEnding: isSet(object.accountNumberEnding)
        ? globalThis.String(object.accountNumberEnding)
        : undefined,
      redirectUrl: isSet(object.redirectUrl) ? globalThis.String(object.redirectUrl) : undefined,
    };
  },

  toJSON(message: GoCardlessMandateResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.mandateId !== "") {
      obj.mandateId = message.mandateId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    if (message.bankName !== undefined) {
      obj.bankName = message.bankName;
    }
    if (message.accountHolderName !== undefined) {
      obj.accountHolderName = message.accountHolderName;
    }
    if (message.accountNumberEnding !== undefined) {
      obj.accountNumberEnding = message.accountNumberEnding;
    }
    if (message.redirectUrl !== undefined) {
      obj.redirectUrl = message.redirectUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessMandateResponse>, I>>(base?: I): GoCardlessMandateResponse {
    return GoCardlessMandateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessMandateResponse>, I>>(object: I): GoCardlessMandateResponse {
    const message = createBaseGoCardlessMandateResponse();
    message.id = object.id ?? "";
    message.clientId = object.clientId ?? "";
    message.mandateId = object.mandateId ?? "";
    message.status = object.status ?? "";
    message.scheme = object.scheme ?? "";
    message.bankName = object.bankName ?? undefined;
    message.accountHolderName = object.accountHolderName ?? undefined;
    message.accountNumberEnding = object.accountNumberEnding ?? undefined;
    message.redirectUrl = object.redirectUrl ?? undefined;
    return message;
  },
};

function createBaseGetGoCardlessMandateRequest(): GetGoCardlessMandateRequest {
  return { clientId: "", societeId: "" };
}

export const GetGoCardlessMandateRequest = {
  encode(message: GetGoCardlessMandateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetGoCardlessMandateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGoCardlessMandateRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
    };
  },

  toJSON(message: GetGoCardlessMandateRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGoCardlessMandateRequest>, I>>(base?: I): GetGoCardlessMandateRequest {
    return GetGoCardlessMandateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGoCardlessMandateRequest>, I>>(object: I): GetGoCardlessMandateRequest {
    const message = createBaseGetGoCardlessMandateRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest(): CreateGoCardlessPaymentRequest {
  return {
    clientId: "",
    societeId: "",
    amount: 0,
    currency: "",
    description: undefined,
    chargeDate: undefined,
    metadata: {},
  };
}

export const CreateGoCardlessPaymentRequest = {
  encode(message: CreateGoCardlessPaymentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateGoCardlessPaymentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = CreateGoCardlessPaymentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessPaymentRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      chargeDate: isSet(object.chargeDate) ? globalThis.String(object.chargeDate) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateGoCardlessPaymentRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.chargeDate !== undefined) {
      obj.chargeDate = message.chargeDate;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest>, I>>(base?: I): CreateGoCardlessPaymentRequest {
    return CreateGoCardlessPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest>, I>>(
    object: I,
  ): CreateGoCardlessPaymentRequest {
    const message = createBaseCreateGoCardlessPaymentRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.description = object.description ?? undefined;
    message.chargeDate = object.chargeDate ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest_MetadataEntry(): CreateGoCardlessPaymentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessPaymentRequest_MetadataEntry = {
  encode(message: CreateGoCardlessPaymentRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessPaymentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateGoCardlessPaymentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateGoCardlessPaymentRequest_MetadataEntry {
    return CreateGoCardlessPaymentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessPaymentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateGoCardlessPaymentRequest_MetadataEntry {
    const message = createBaseCreateGoCardlessPaymentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGoCardlessPaymentResponse(): GoCardlessPaymentResponse {
  return { id: "", paymentId: "", amount: 0, currency: "", status: "", chargeDate: undefined };
}

export const GoCardlessPaymentResponse = {
  encode(message: GoCardlessPaymentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GoCardlessPaymentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessPaymentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      chargeDate: isSet(object.chargeDate) ? globalThis.String(object.chargeDate) : undefined,
    };
  },

  toJSON(message: GoCardlessPaymentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.chargeDate !== undefined) {
      obj.chargeDate = message.chargeDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessPaymentResponse>, I>>(base?: I): GoCardlessPaymentResponse {
    return GoCardlessPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessPaymentResponse>, I>>(object: I): GoCardlessPaymentResponse {
    const message = createBaseGoCardlessPaymentResponse();
    message.id = object.id ?? "";
    message.paymentId = object.paymentId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.chargeDate = object.chargeDate ?? undefined;
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest(): CreateGoCardlessSubscriptionRequest {
  return {
    clientId: "",
    societeId: "",
    amount: 0,
    currency: "",
    intervalUnit: "",
    interval: 0,
    name: undefined,
    startDate: undefined,
    count: undefined,
    metadata: {},
  };
}

export const CreateGoCardlessSubscriptionRequest = {
  encode(message: CreateGoCardlessSubscriptionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(42).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(48).int32(message.interval);
    }
    if (message.name !== undefined) {
      writer.uint32(58).string(message.name);
    }
    if (message.startDate !== undefined) {
      writer.uint32(66).string(message.startDate);
    }
    if (message.count !== undefined) {
      writer.uint32(72).int32(message.count);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateGoCardlessSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.interval = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateGoCardlessSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessSubscriptionRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      intervalUnit: isSet(object.intervalUnit) ? globalThis.String(object.intervalUnit) : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : undefined,
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateGoCardlessSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.intervalUnit !== "") {
      obj.intervalUnit = message.intervalUnit;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate;
    }
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest>, I>>(
    base?: I,
  ): CreateGoCardlessSubscriptionRequest {
    return CreateGoCardlessSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest>, I>>(
    object: I,
  ): CreateGoCardlessSubscriptionRequest {
    const message = createBaseCreateGoCardlessSubscriptionRequest();
    message.clientId = object.clientId ?? "";
    message.societeId = object.societeId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.intervalUnit = object.intervalUnit ?? "";
    message.interval = object.interval ?? 0;
    message.name = object.name ?? undefined;
    message.startDate = object.startDate ?? undefined;
    message.count = object.count ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry(): CreateGoCardlessSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessSubscriptionRequest_MetadataEntry = {
  encode(
    message: CreateGoCardlessSubscriptionRequest_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateGoCardlessSubscriptionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    return CreateGoCardlessSubscriptionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGoCardlessSubscriptionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    const message = createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGoCardlessSubscriptionResponse(): GoCardlessSubscriptionResponse {
  return {
    id: "",
    subscriptionId: "",
    amount: 0,
    currency: "",
    status: "",
    intervalUnit: "",
    interval: 0,
    nextPaymentDate: undefined,
  };
}

export const GoCardlessSubscriptionResponse = {
  encode(message: GoCardlessSubscriptionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(50).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(56).int32(message.interval);
    }
    if (message.nextPaymentDate !== undefined) {
      writer.uint32(66).string(message.nextPaymentDate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GoCardlessSubscriptionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.interval = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.nextPaymentDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoCardlessSubscriptionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      intervalUnit: isSet(object.intervalUnit) ? globalThis.String(object.intervalUnit) : "",
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      nextPaymentDate: isSet(object.nextPaymentDate) ? globalThis.String(object.nextPaymentDate) : undefined,
    };
  },

  toJSON(message: GoCardlessSubscriptionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.intervalUnit !== "") {
      obj.intervalUnit = message.intervalUnit;
    }
    if (message.interval !== 0) {
      obj.interval = Math.round(message.interval);
    }
    if (message.nextPaymentDate !== undefined) {
      obj.nextPaymentDate = message.nextPaymentDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoCardlessSubscriptionResponse>, I>>(base?: I): GoCardlessSubscriptionResponse {
    return GoCardlessSubscriptionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoCardlessSubscriptionResponse>, I>>(
    object: I,
  ): GoCardlessSubscriptionResponse {
    const message = createBaseGoCardlessSubscriptionResponse();
    message.id = object.id ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.intervalUnit = object.intervalUnit ?? "";
    message.interval = object.interval ?? 0;
    message.nextPaymentDate = object.nextPaymentDate ?? undefined;
    return message;
  },
};

function createBaseCancelGoCardlessSubscriptionRequest(): CancelGoCardlessSubscriptionRequest {
  return { subscriptionId: "", societeId: "" };
}

export const CancelGoCardlessSubscriptionRequest = {
  encode(message: CancelGoCardlessSubscriptionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelGoCardlessSubscriptionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelGoCardlessSubscriptionRequest {
    return {
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
    };
  },

  toJSON(message: CancelGoCardlessSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelGoCardlessSubscriptionRequest>, I>>(
    base?: I,
  ): CancelGoCardlessSubscriptionRequest {
    return CancelGoCardlessSubscriptionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelGoCardlessSubscriptionRequest>, I>>(
    object: I,
  ): CancelGoCardlessSubscriptionRequest {
    const message = createBaseCancelGoCardlessSubscriptionRequest();
    message.subscriptionId = object.subscriptionId ?? "";
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBaseCreateScheduleRequest(): CreateScheduleRequest {
  return {
    organisationId: "",
    societeId: "",
    contratId: undefined,
    factureId: undefined,
    clientId: undefined,
    amount: 0,
    currency: "",
    dueDate: "",
    description: undefined,
    autoProcess: false,
    metadata: {},
  };
}

export const CreateScheduleRequest = {
  encode(message: CreateScheduleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(26).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(34).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(42).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(48).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(66).string(message.dueDate);
    }
    if (message.description !== undefined) {
      writer.uint32(74).string(message.description);
    }
    if (message.autoProcess !== false) {
      writer.uint32(80).bool(message.autoProcess);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateScheduleRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateScheduleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.factureId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = CreateScheduleRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.metadata[entry11.key] = entry11.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateScheduleRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      contratId: isSet(object.contratId) ? globalThis.String(object.contratId) : undefined,
      factureId: isSet(object.factureId) ? globalThis.String(object.factureId) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      dueDate: isSet(object.dueDate) ? globalThis.String(object.dueDate) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      autoProcess: isSet(object.autoProcess) ? globalThis.Boolean(object.autoProcess) : false,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateScheduleRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.dueDate !== "") {
      obj.dueDate = message.dueDate;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.autoProcess !== false) {
      obj.autoProcess = message.autoProcess;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateScheduleRequest>, I>>(base?: I): CreateScheduleRequest {
    return CreateScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateScheduleRequest>, I>>(object: I): CreateScheduleRequest {
    const message = createBaseCreateScheduleRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.contratId = object.contratId ?? undefined;
    message.factureId = object.factureId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.dueDate = object.dueDate ?? "";
    message.description = object.description ?? undefined;
    message.autoProcess = object.autoProcess ?? false;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateScheduleRequest_MetadataEntry(): CreateScheduleRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateScheduleRequest_MetadataEntry = {
  encode(message: CreateScheduleRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateScheduleRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateScheduleRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateScheduleRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateScheduleRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateScheduleRequest_MetadataEntry {
    return CreateScheduleRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateScheduleRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateScheduleRequest_MetadataEntry {
    const message = createBaseCreateScheduleRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseScheduleResponse(): ScheduleResponse {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    contratId: undefined,
    factureId: undefined,
    clientId: undefined,
    amount: 0,
    currency: "",
    dueDate: "",
    status: "",
    lastAttemptAt: undefined,
    paidAt: undefined,
    retryCount: 0,
    errorMessage: undefined,
  };
}

export const ScheduleResponse = {
  encode(message: ScheduleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(42).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(50).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(74).string(message.dueDate);
    }
    if (message.status !== "") {
      writer.uint32(82).string(message.status);
    }
    if (message.lastAttemptAt !== undefined) {
      writer.uint32(90).string(message.lastAttemptAt);
    }
    if (message.paidAt !== undefined) {
      writer.uint32(98).string(message.paidAt);
    }
    if (message.retryCount !== 0) {
      writer.uint32(104).int32(message.retryCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(114).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScheduleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.factureId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.status = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lastAttemptAt = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.paidAt = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      contratId: isSet(object.contratId) ? globalThis.String(object.contratId) : undefined,
      factureId: isSet(object.factureId) ? globalThis.String(object.factureId) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      dueDate: isSet(object.dueDate) ? globalThis.String(object.dueDate) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      lastAttemptAt: isSet(object.lastAttemptAt) ? globalThis.String(object.lastAttemptAt) : undefined,
      paidAt: isSet(object.paidAt) ? globalThis.String(object.paidAt) : undefined,
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: ScheduleResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.contratId !== undefined) {
      obj.contratId = message.contratId;
    }
    if (message.factureId !== undefined) {
      obj.factureId = message.factureId;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.dueDate !== "") {
      obj.dueDate = message.dueDate;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.lastAttemptAt !== undefined) {
      obj.lastAttemptAt = message.lastAttemptAt;
    }
    if (message.paidAt !== undefined) {
      obj.paidAt = message.paidAt;
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleResponse>, I>>(base?: I): ScheduleResponse {
    return ScheduleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleResponse>, I>>(object: I): ScheduleResponse {
    const message = createBaseScheduleResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.contratId = object.contratId ?? undefined;
    message.factureId = object.factureId ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.dueDate = object.dueDate ?? "";
    message.status = object.status ?? "";
    message.lastAttemptAt = object.lastAttemptAt ?? undefined;
    message.paidAt = object.paidAt ?? undefined;
    message.retryCount = object.retryCount ?? 0;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseUpdateScheduleRequest(): UpdateScheduleRequest {
  return { id: "", amount: undefined, dueDate: undefined, status: undefined, autoProcess: undefined };
}

export const UpdateScheduleRequest = {
  encode(message: UpdateScheduleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== undefined) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.dueDate !== undefined) {
      writer.uint32(26).string(message.dueDate);
    }
    if (message.status !== undefined) {
      writer.uint32(34).string(message.status);
    }
    if (message.autoProcess !== undefined) {
      writer.uint32(40).bool(message.autoProcess);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateScheduleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : undefined,
      dueDate: isSet(object.dueDate) ? globalThis.String(object.dueDate) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      autoProcess: isSet(object.autoProcess) ? globalThis.Boolean(object.autoProcess) : undefined,
    };
  },

  toJSON(message: UpdateScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.amount !== undefined) {
      obj.amount = Math.round(message.amount);
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.autoProcess !== undefined) {
      obj.autoProcess = message.autoProcess;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateScheduleRequest>, I>>(base?: I): UpdateScheduleRequest {
    return UpdateScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateScheduleRequest>, I>>(object: I): UpdateScheduleRequest {
    const message = createBaseUpdateScheduleRequest();
    message.id = object.id ?? "";
    message.amount = object.amount ?? undefined;
    message.dueDate = object.dueDate ?? undefined;
    message.status = object.status ?? undefined;
    message.autoProcess = object.autoProcess ?? undefined;
    return message;
  },
};

function createBaseGetDueSchedulesRequest(): GetDueSchedulesRequest {
  return { organisationId: "", beforeDate: undefined };
}

export const GetDueSchedulesRequest = {
  encode(message: GetDueSchedulesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.beforeDate !== undefined) {
      writer.uint32(18).string(message.beforeDate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetDueSchedulesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDueSchedulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.beforeDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDueSchedulesRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      beforeDate: isSet(object.beforeDate) ? globalThis.String(object.beforeDate) : undefined,
    };
  },

  toJSON(message: GetDueSchedulesRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.beforeDate !== undefined) {
      obj.beforeDate = message.beforeDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDueSchedulesRequest>, I>>(base?: I): GetDueSchedulesRequest {
    return GetDueSchedulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDueSchedulesRequest>, I>>(object: I): GetDueSchedulesRequest {
    const message = createBaseGetDueSchedulesRequest();
    message.organisationId = object.organisationId ?? "";
    message.beforeDate = object.beforeDate ?? undefined;
    return message;
  },
};

function createBaseScheduleListResponse(): ScheduleListResponse {
  return { schedules: [], total: 0 };
}

export const ScheduleListResponse = {
  encode(message: ScheduleListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.schedules) {
      ScheduleResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScheduleListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schedules.push(ScheduleResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleListResponse {
    return {
      schedules: globalThis.Array.isArray(object?.schedules)
        ? object.schedules.map((e: any) => ScheduleResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ScheduleListResponse): unknown {
    const obj: any = {};
    if (message.schedules?.length) {
      obj.schedules = message.schedules.map((e) => ScheduleResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleListResponse>, I>>(base?: I): ScheduleListResponse {
    return ScheduleListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleListResponse>, I>>(object: I): ScheduleListResponse {
    const message = createBaseScheduleListResponse();
    message.schedules = object.schedules?.map((e) => ScheduleResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseProcessDuePaymentsRequest(): ProcessDuePaymentsRequest {
  return { organisationId: "", dryRun: undefined };
}

export const ProcessDuePaymentsRequest = {
  encode(message: ProcessDuePaymentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.dryRun !== undefined) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessDuePaymentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDuePaymentsRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : undefined,
    };
  },

  toJSON(message: ProcessDuePaymentsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.dryRun !== undefined) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDuePaymentsRequest>, I>>(base?: I): ProcessDuePaymentsRequest {
    return ProcessDuePaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDuePaymentsRequest>, I>>(object: I): ProcessDuePaymentsRequest {
    const message = createBaseProcessDuePaymentsRequest();
    message.organisationId = object.organisationId ?? "";
    message.dryRun = object.dryRun ?? undefined;
    return message;
  },
};

function createBaseProcessDuePaymentsResponse(): ProcessDuePaymentsResponse {
  return { processedCount: 0, successCount: 0, failedCount: 0, results: [] };
}

export const ProcessDuePaymentsResponse = {
  encode(message: ProcessDuePaymentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.processedCount !== 0) {
      writer.uint32(8).int32(message.processedCount);
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(24).int32(message.failedCount);
    }
    for (const v of message.results) {
      ProcessedPayment.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessDuePaymentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.processedCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.results.push(ProcessedPayment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDuePaymentsResponse {
    return {
      processedCount: isSet(object.processedCount) ? globalThis.Number(object.processedCount) : 0,
      successCount: isSet(object.successCount) ? globalThis.Number(object.successCount) : 0,
      failedCount: isSet(object.failedCount) ? globalThis.Number(object.failedCount) : 0,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ProcessedPayment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessDuePaymentsResponse): unknown {
    const obj: any = {};
    if (message.processedCount !== 0) {
      obj.processedCount = Math.round(message.processedCount);
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failedCount !== 0) {
      obj.failedCount = Math.round(message.failedCount);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => ProcessedPayment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessDuePaymentsResponse>, I>>(base?: I): ProcessDuePaymentsResponse {
    return ProcessDuePaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessDuePaymentsResponse>, I>>(object: I): ProcessDuePaymentsResponse {
    const message = createBaseProcessDuePaymentsResponse();
    message.processedCount = object.processedCount ?? 0;
    message.successCount = object.successCount ?? 0;
    message.failedCount = object.failedCount ?? 0;
    message.results = object.results?.map((e) => ProcessedPayment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessedPayment(): ProcessedPayment {
  return { scheduleId: "", success: false, paymentId: undefined, error: undefined };
}

export const ProcessedPayment = {
  encode(message: ProcessedPayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.scheduleId !== "") {
      writer.uint32(10).string(message.scheduleId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.paymentId !== undefined) {
      writer.uint32(26).string(message.paymentId);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcessedPayment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessedPayment {
    return {
      scheduleId: isSet(object.scheduleId) ? globalThis.String(object.scheduleId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: ProcessedPayment): unknown {
    const obj: any = {};
    if (message.scheduleId !== "") {
      obj.scheduleId = message.scheduleId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.paymentId !== undefined) {
      obj.paymentId = message.paymentId;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessedPayment>, I>>(base?: I): ProcessedPayment {
    return ProcessedPayment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessedPayment>, I>>(object: I): ProcessedPayment {
    const message = createBaseProcessedPayment();
    message.scheduleId = object.scheduleId ?? "";
    message.success = object.success ?? false;
    message.paymentId = object.paymentId ?? undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseRenewScheduleRequest(): RenewScheduleRequest {
  return { id: "", newDueDate: "", newAmount: undefined };
}

export const RenewScheduleRequest = {
  encode(message: RenewScheduleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newDueDate !== "") {
      writer.uint32(18).string(message.newDueDate);
    }
    if (message.newAmount !== undefined) {
      writer.uint32(24).int64(message.newAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RenewScheduleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newDueDate = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.newAmount = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewScheduleRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      newDueDate: isSet(object.newDueDate) ? globalThis.String(object.newDueDate) : "",
      newAmount: isSet(object.newAmount) ? globalThis.Number(object.newAmount) : undefined,
    };
  },

  toJSON(message: RenewScheduleRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.newDueDate !== "") {
      obj.newDueDate = message.newDueDate;
    }
    if (message.newAmount !== undefined) {
      obj.newAmount = Math.round(message.newAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenewScheduleRequest>, I>>(base?: I): RenewScheduleRequest {
    return RenewScheduleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenewScheduleRequest>, I>>(object: I): RenewScheduleRequest {
    const message = createBaseRenewScheduleRequest();
    message.id = object.id ?? "";
    message.newDueDate = object.newDueDate ?? "";
    message.newAmount = object.newAmount ?? undefined;
    return message;
  },
};

function createBaseCreatePaymentIntentRequest(): CreatePaymentIntentRequest {
  return {
    organisationId: "",
    societeId: "",
    scheduleId: undefined,
    pspName: "",
    amount: 0,
    currency: "",
    mandateReference: undefined,
    idempotencyKey: undefined,
    metadata: {},
  };
}

export const CreatePaymentIntentRequest = {
  encode(message: CreatePaymentIntentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(26).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(34).string(message.pspName);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(58).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(66).string(message.idempotencyKey);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreatePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePaymentIntentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pspName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = CreatePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentIntentRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      scheduleId: isSet(object.scheduleId) ? globalThis.String(object.scheduleId) : undefined,
      pspName: isSet(object.pspName) ? globalThis.String(object.pspName) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      mandateReference: isSet(object.mandateReference) ? globalThis.String(object.mandateReference) : undefined,
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreatePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheduleId !== undefined) {
      obj.scheduleId = message.scheduleId;
    }
    if (message.pspName !== "") {
      obj.pspName = message.pspName;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = message.mandateReference;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentIntentRequest>, I>>(base?: I): CreatePaymentIntentRequest {
    return CreatePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentIntentRequest>, I>>(object: I): CreatePaymentIntentRequest {
    const message = createBaseCreatePaymentIntentRequest();
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheduleId = object.scheduleId ?? undefined;
    message.pspName = object.pspName ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.mandateReference = object.mandateReference ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreatePaymentIntentRequest_MetadataEntry(): CreatePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePaymentIntentRequest_MetadataEntry = {
  encode(message: CreatePaymentIntentRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentIntentRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreatePaymentIntentRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentIntentRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreatePaymentIntentRequest_MetadataEntry {
    return CreatePaymentIntentRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentIntentRequest_MetadataEntry>, I>>(
    object: I,
  ): CreatePaymentIntentRequest_MetadataEntry {
    const message = createBaseCreatePaymentIntentRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePaymentIntentResponse(): PaymentIntentResponse {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    scheduleId: undefined,
    pspName: "",
    pspPaymentId: undefined,
    amount: 0,
    currency: "",
    status: "",
    mandateReference: undefined,
    idempotencyKey: undefined,
    errorCode: undefined,
    errorMessage: undefined,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const PaymentIntentResponse = {
  encode(message: PaymentIntentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(34).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(42).string(message.pspName);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(50).string(message.pspPaymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(82).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(90).string(message.idempotencyKey);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(98).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(106).string(message.errorMessage);
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(122).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentIntentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pspName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentIntentResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "",
      scheduleId: isSet(object.scheduleId) ? globalThis.String(object.scheduleId) : undefined,
      pspName: isSet(object.pspName) ? globalThis.String(object.pspName) : "",
      pspPaymentId: isSet(object.pspPaymentId) ? globalThis.String(object.pspPaymentId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      mandateReference: isSet(object.mandateReference) ? globalThis.String(object.mandateReference) : undefined,
      idempotencyKey: isSet(object.idempotencyKey) ? globalThis.String(object.idempotencyKey) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : undefined,
    };
  },

  toJSON(message: PaymentIntentResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    if (message.scheduleId !== undefined) {
      obj.scheduleId = message.scheduleId;
    }
    if (message.pspName !== "") {
      obj.pspName = message.pspName;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = message.mandateReference;
    }
    if (message.idempotencyKey !== undefined) {
      obj.idempotencyKey = message.idempotencyKey;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentIntentResponse>, I>>(base?: I): PaymentIntentResponse {
    return PaymentIntentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentIntentResponse>, I>>(object: I): PaymentIntentResponse {
    const message = createBasePaymentIntentResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.societeId = object.societeId ?? "";
    message.scheduleId = object.scheduleId ?? undefined;
    message.pspName = object.pspName ?? "";
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? "";
    message.mandateReference = object.mandateReference ?? undefined;
    message.idempotencyKey = object.idempotencyKey ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseUpdatePaymentIntentRequest(): UpdatePaymentIntentRequest {
  return { id: "", status: undefined, pspPaymentId: undefined, errorCode: undefined, errorMessage: undefined };
}

export const UpdatePaymentIntentRequest = {
  encode(message: UpdatePaymentIntentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      writer.uint32(18).string(message.status);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(26).string(message.pspPaymentId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdatePaymentIntentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePaymentIntentRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      pspPaymentId: isSet(object.pspPaymentId) ? globalThis.String(object.pspPaymentId) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: UpdatePaymentIntentRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.pspPaymentId !== undefined) {
      obj.pspPaymentId = message.pspPaymentId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePaymentIntentRequest>, I>>(base?: I): UpdatePaymentIntentRequest {
    return UpdatePaymentIntentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePaymentIntentRequest>, I>>(object: I): UpdatePaymentIntentRequest {
    const message = createBaseUpdatePaymentIntentRequest();
    message.id = object.id ?? "";
    message.status = object.status ?? undefined;
    message.pspPaymentId = object.pspPaymentId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseCreatePaymentEventRequest(): CreatePaymentEventRequest {
  return { organisationId: "", paymentIntentId: "", eventType: "", rawPayload: "" };
}

export const CreatePaymentEventRequest = {
  encode(message: CreatePaymentEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(34).string(message.rawPayload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePaymentEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePaymentEventRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      paymentIntentId: isSet(object.paymentIntentId) ? globalThis.String(object.paymentIntentId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      rawPayload: isSet(object.rawPayload) ? globalThis.String(object.rawPayload) : "",
    };
  },

  toJSON(message: CreatePaymentEventRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePaymentEventRequest>, I>>(base?: I): CreatePaymentEventRequest {
    return CreatePaymentEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePaymentEventRequest>, I>>(object: I): CreatePaymentEventRequest {
    const message = createBaseCreatePaymentEventRequest();
    message.organisationId = object.organisationId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.eventType = object.eventType ?? "";
    message.rawPayload = object.rawPayload ?? "";
    return message;
  },
};

function createBasePaymentEventResponse(): PaymentEventResponse {
  return {
    id: "",
    organisationId: "",
    paymentIntentId: "",
    eventType: "",
    rawPayload: "",
    receivedAt: "",
    processed: false,
    processedAt: undefined,
    errorMessage: undefined,
  };
}

export const PaymentEventResponse = {
  encode(message: PaymentEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(26).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(34).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(42).string(message.rawPayload);
    }
    if (message.receivedAt !== "") {
      writer.uint32(50).string(message.receivedAt);
    }
    if (message.processed !== false) {
      writer.uint32(56).bool(message.processed);
    }
    if (message.processedAt !== undefined) {
      writer.uint32(66).string(message.processedAt);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.processed = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.processedAt = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentEventResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      paymentIntentId: isSet(object.paymentIntentId) ? globalThis.String(object.paymentIntentId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      rawPayload: isSet(object.rawPayload) ? globalThis.String(object.rawPayload) : "",
      receivedAt: isSet(object.receivedAt) ? globalThis.String(object.receivedAt) : "",
      processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false,
      processedAt: isSet(object.processedAt) ? globalThis.String(object.processedAt) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: PaymentEventResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.paymentIntentId !== "") {
      obj.paymentIntentId = message.paymentIntentId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.rawPayload !== "") {
      obj.rawPayload = message.rawPayload;
    }
    if (message.receivedAt !== "") {
      obj.receivedAt = message.receivedAt;
    }
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    if (message.processedAt !== undefined) {
      obj.processedAt = message.processedAt;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentEventResponse>, I>>(base?: I): PaymentEventResponse {
    return PaymentEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentEventResponse>, I>>(object: I): PaymentEventResponse {
    const message = createBasePaymentEventResponse();
    message.id = object.id ?? "";
    message.organisationId = object.organisationId ?? "";
    message.paymentIntentId = object.paymentIntentId ?? "";
    message.eventType = object.eventType ?? "";
    message.rawPayload = object.rawPayload ?? "";
    message.receivedAt = object.receivedAt ?? "";
    message.processed = object.processed ?? false;
    message.processedAt = object.processedAt ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseGetUnprocessedEventsRequest(): GetUnprocessedEventsRequest {
  return { organisationId: "", limit: undefined };
}

export const GetUnprocessedEventsRequest = {
  encode(message: GetUnprocessedEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUnprocessedEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnprocessedEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUnprocessedEventsRequest {
    return {
      organisationId: isSet(object.organisationId) ? globalThis.String(object.organisationId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
    };
  },

  toJSON(message: GetUnprocessedEventsRequest): unknown {
    const obj: any = {};
    if (message.organisationId !== "") {
      obj.organisationId = message.organisationId;
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUnprocessedEventsRequest>, I>>(base?: I): GetUnprocessedEventsRequest {
    return GetUnprocessedEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUnprocessedEventsRequest>, I>>(object: I): GetUnprocessedEventsRequest {
    const message = createBaseGetUnprocessedEventsRequest();
    message.organisationId = object.organisationId ?? "";
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBasePaymentEventListResponse(): PaymentEventListResponse {
  return { events: [], total: 0 };
}

export const PaymentEventListResponse = {
  encode(message: PaymentEventListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.events) {
      PaymentEventResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentEventListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(PaymentEventResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentEventListResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => PaymentEventResponse.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: PaymentEventListResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => PaymentEventResponse.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentEventListResponse>, I>>(base?: I): PaymentEventListResponse {
    return PaymentEventListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentEventListResponse>, I>>(object: I): PaymentEventListResponse {
    const message = createBasePaymentEventListResponse();
    message.events = object.events?.map((e) => PaymentEventResponse.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseMarkEventProcessedRequest(): MarkEventProcessedRequest {
  return { id: "", errorMessage: undefined };
}

export const MarkEventProcessedRequest = {
  encode(message: MarkEventProcessedRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarkEventProcessedRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkEventProcessedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkEventProcessedRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: MarkEventProcessedRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkEventProcessedRequest>, I>>(base?: I): MarkEventProcessedRequest {
    return MarkEventProcessedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkEventProcessedRequest>, I>>(object: I): MarkEventProcessedRequest {
    const message = createBaseMarkEventProcessedRequest();
    message.id = object.id ?? "";
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseGetPSPAccountsRequest(): GetPSPAccountsRequest {
  return { societeId: "" };
}

export const GetPSPAccountsRequest = {
  encode(message: GetPSPAccountsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPSPAccountsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPSPAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPSPAccountsRequest {
    return { societeId: isSet(object.societeId) ? globalThis.String(object.societeId) : "" };
  },

  toJSON(message: GetPSPAccountsRequest): unknown {
    const obj: any = {};
    if (message.societeId !== "") {
      obj.societeId = message.societeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPSPAccountsRequest>, I>>(base?: I): GetPSPAccountsRequest {
    return GetPSPAccountsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPSPAccountsRequest>, I>>(object: I): GetPSPAccountsRequest {
    const message = createBaseGetPSPAccountsRequest();
    message.societeId = object.societeId ?? "";
    return message;
  },
};

function createBasePSPAccountsSummaryResponse(): PSPAccountsSummaryResponse {
  return {
    stripe: undefined,
    paypal: undefined,
    gocardless: undefined,
    emerchantpay: undefined,
    slimpay: undefined,
    multisafepay: undefined,
  };
}

export const PSPAccountsSummaryResponse = {
  encode(message: PSPAccountsSummaryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stripe !== undefined) {
      PSPAccountInfo.encode(message.stripe, writer.uint32(10).fork()).ldelim();
    }
    if (message.paypal !== undefined) {
      PSPAccountInfo.encode(message.paypal, writer.uint32(18).fork()).ldelim();
    }
    if (message.gocardless !== undefined) {
      PSPAccountInfo.encode(message.gocardless, writer.uint32(26).fork()).ldelim();
    }
    if (message.emerchantpay !== undefined) {
      PSPAccountInfo.encode(message.emerchantpay, writer.uint32(34).fork()).ldelim();
    }
    if (message.slimpay !== undefined) {
      PSPAccountInfo.encode(message.slimpay, writer.uint32(42).fork()).ldelim();
    }
    if (message.multisafepay !== undefined) {
      PSPAccountInfo.encode(message.multisafepay, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PSPAccountsSummaryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountsSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stripe = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.paypal = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gocardless = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.emerchantpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.slimpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.multisafepay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PSPAccountsSummaryResponse {
    return {
      stripe: isSet(object.stripe) ? PSPAccountInfo.fromJSON(object.stripe) : undefined,
      paypal: isSet(object.paypal) ? PSPAccountInfo.fromJSON(object.paypal) : undefined,
      gocardless: isSet(object.gocardless) ? PSPAccountInfo.fromJSON(object.gocardless) : undefined,
      emerchantpay: isSet(object.emerchantpay) ? PSPAccountInfo.fromJSON(object.emerchantpay) : undefined,
      slimpay: isSet(object.slimpay) ? PSPAccountInfo.fromJSON(object.slimpay) : undefined,
      multisafepay: isSet(object.multisafepay) ? PSPAccountInfo.fromJSON(object.multisafepay) : undefined,
    };
  },

  toJSON(message: PSPAccountsSummaryResponse): unknown {
    const obj: any = {};
    if (message.stripe !== undefined) {
      obj.stripe = PSPAccountInfo.toJSON(message.stripe);
    }
    if (message.paypal !== undefined) {
      obj.paypal = PSPAccountInfo.toJSON(message.paypal);
    }
    if (message.gocardless !== undefined) {
      obj.gocardless = PSPAccountInfo.toJSON(message.gocardless);
    }
    if (message.emerchantpay !== undefined) {
      obj.emerchantpay = PSPAccountInfo.toJSON(message.emerchantpay);
    }
    if (message.slimpay !== undefined) {
      obj.slimpay = PSPAccountInfo.toJSON(message.slimpay);
    }
    if (message.multisafepay !== undefined) {
      obj.multisafepay = PSPAccountInfo.toJSON(message.multisafepay);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PSPAccountsSummaryResponse>, I>>(base?: I): PSPAccountsSummaryResponse {
    return PSPAccountsSummaryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PSPAccountsSummaryResponse>, I>>(object: I): PSPAccountsSummaryResponse {
    const message = createBasePSPAccountsSummaryResponse();
    message.stripe = (object.stripe !== undefined && object.stripe !== null)
      ? PSPAccountInfo.fromPartial(object.stripe)
      : undefined;
    message.paypal = (object.paypal !== undefined && object.paypal !== null)
      ? PSPAccountInfo.fromPartial(object.paypal)
      : undefined;
    message.gocardless = (object.gocardless !== undefined && object.gocardless !== null)
      ? PSPAccountInfo.fromPartial(object.gocardless)
      : undefined;
    message.emerchantpay = (object.emerchantpay !== undefined && object.emerchantpay !== null)
      ? PSPAccountInfo.fromPartial(object.emerchantpay)
      : undefined;
    message.slimpay = (object.slimpay !== undefined && object.slimpay !== null)
      ? PSPAccountInfo.fromPartial(object.slimpay)
      : undefined;
    message.multisafepay = (object.multisafepay !== undefined && object.multisafepay !== null)
      ? PSPAccountInfo.fromPartial(object.multisafepay)
      : undefined;
    return message;
  },
};

function createBasePSPAccountInfo(): PSPAccountInfo {
  return { id: "", name: "", isActive: false, isLiveMode: false, isConfigured: false };
}

export const PSPAccountInfo = {
  encode(message: PSPAccountInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.isLiveMode !== false) {
      writer.uint32(32).bool(message.isLiveMode);
    }
    if (message.isConfigured !== false) {
      writer.uint32(40).bool(message.isConfigured);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PSPAccountInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isLiveMode = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isConfigured = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PSPAccountInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isLiveMode: isSet(object.isLiveMode) ? globalThis.Boolean(object.isLiveMode) : false,
      isConfigured: isSet(object.isConfigured) ? globalThis.Boolean(object.isConfigured) : false,
    };
  },

  toJSON(message: PSPAccountInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isLiveMode !== false) {
      obj.isLiveMode = message.isLiveMode;
    }
    if (message.isConfigured !== false) {
      obj.isConfigured = message.isConfigured;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PSPAccountInfo>, I>>(base?: I): PSPAccountInfo {
    return PSPAccountInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PSPAccountInfo>, I>>(object: I): PSPAccountInfo {
    const message = createBasePSPAccountInfo();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isActive = object.isActive ?? false;
    message.isLiveMode = object.isLiveMode ?? false;
    message.isConfigured = object.isConfigured ?? false;
    return message;
  },
};

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: {
    path: "/payment.PaymentService/CreateStripeCheckoutSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCheckoutSessionRequest) =>
      Buffer.from(CreateStripeCheckoutSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStripeCheckoutSessionRequest.decode(value),
    responseSerialize: (value: StripeCheckoutSessionResponse) =>
      Buffer.from(StripeCheckoutSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeCheckoutSessionResponse.decode(value),
  },
  createStripePaymentIntent: {
    path: "/payment.PaymentService/CreateStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripePaymentIntentRequest) =>
      Buffer.from(CreateStripePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStripePaymentIntentRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse) =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripePaymentIntentResponse.decode(value),
  },
  getStripePaymentIntent: {
    path: "/payment.PaymentService/GetStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse) =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripePaymentIntentResponse.decode(value),
  },
  cancelStripePaymentIntent: {
    path: "/payment.PaymentService/CancelStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse) =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripePaymentIntentResponse.decode(value),
  },
  /** Customers */
  createStripeCustomer: {
    path: "/payment.PaymentService/CreateStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCustomerRequest) =>
      Buffer.from(CreateStripeCustomerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStripeCustomerRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse) => Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeCustomerResponse.decode(value),
  },
  getStripeCustomer: {
    path: "/payment.PaymentService/GetStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse) => Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeCustomerResponse.decode(value),
  },
  /** Subscriptions */
  createStripeSubscription: {
    path: "/payment.PaymentService/CreateStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSubscriptionRequest) =>
      Buffer.from(CreateStripeSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStripeSubscriptionRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse) =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeSubscriptionResponse.decode(value),
  },
  getStripeSubscription: {
    path: "/payment.PaymentService/GetStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse) =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeSubscriptionResponse.decode(value),
  },
  cancelStripeSubscription: {
    path: "/payment.PaymentService/CancelStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse) =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeSubscriptionResponse.decode(value),
  },
  /** Refunds */
  createStripeRefund: {
    path: "/payment.PaymentService/CreateStripeRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeRefundRequest) =>
      Buffer.from(CreateStripeRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStripeRefundRequest.decode(value),
    responseSerialize: (value: StripeRefundResponse) => Buffer.from(StripeRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeRefundResponse.decode(value),
  },
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: {
    path: "/payment.PaymentService/CreateStripeSetupIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSetupIntentRequest) =>
      Buffer.from(CreateStripeSetupIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStripeSetupIntentRequest.decode(value),
    responseSerialize: (value: StripeSetupIntentResponse) =>
      Buffer.from(StripeSetupIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeSetupIntentResponse.decode(value),
  },
  /** Billing Portal */
  createStripeBillingPortalSession: {
    path: "/payment.PaymentService/CreateStripeBillingPortalSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeBillingPortalRequest) =>
      Buffer.from(CreateStripeBillingPortalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStripeBillingPortalRequest.decode(value),
    responseSerialize: (value: StripeBillingPortalResponse) =>
      Buffer.from(StripeBillingPortalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StripeBillingPortalResponse.decode(value),
  },
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: {
    path: "/payment.PaymentService/CreatePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePayPalOrderRequest) => Buffer.from(CreatePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse) => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PayPalOrderResponse.decode(value),
  },
  getPayPalOrder: {
    path: "/payment.PaymentService/GetPayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest) => Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse) => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PayPalOrderResponse.decode(value),
  },
  capturePayPalOrder: {
    path: "/payment.PaymentService/CapturePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CapturePayPalOrderRequest) =>
      Buffer.from(CapturePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CapturePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalCaptureResponse) => Buffer.from(PayPalCaptureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PayPalCaptureResponse.decode(value),
  },
  authorizePayPalOrder: {
    path: "/payment.PaymentService/AuthorizePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest) => Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse) => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PayPalOrderResponse.decode(value),
  },
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: {
    path: "/payment.PaymentService/SetupGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetupGoCardlessMandateRequest) =>
      Buffer.from(SetupGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SetupGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse) =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GoCardlessMandateResponse.decode(value),
  },
  getGoCardlessMandate: {
    path: "/payment.PaymentService/GetGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest) =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse) =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GoCardlessMandateResponse.decode(value),
  },
  cancelGoCardlessMandate: {
    path: "/payment.PaymentService/CancelGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest) =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse) =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GoCardlessMandateResponse.decode(value),
  },
  createGoCardlessPayment: {
    path: "/payment.PaymentService/CreateGoCardlessPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessPaymentRequest) =>
      Buffer.from(CreateGoCardlessPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateGoCardlessPaymentRequest.decode(value),
    responseSerialize: (value: GoCardlessPaymentResponse) =>
      Buffer.from(GoCardlessPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GoCardlessPaymentResponse.decode(value),
  },
  createGoCardlessSubscription: {
    path: "/payment.PaymentService/CreateGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessSubscriptionRequest) =>
      Buffer.from(CreateGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse) =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GoCardlessSubscriptionResponse.decode(value),
  },
  cancelGoCardlessSubscription: {
    path: "/payment.PaymentService/CancelGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelGoCardlessSubscriptionRequest) =>
      Buffer.from(CancelGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse) =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GoCardlessSubscriptionResponse.decode(value),
  },
  /** ==================== SCHEDULES ==================== */
  createSchedule: {
    path: "/payment.PaymentService/CreateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateScheduleRequest) => Buffer.from(CreateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse) => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScheduleResponse.decode(value),
  },
  getSchedule: {
    path: "/payment.PaymentService/GetSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: ScheduleResponse) => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScheduleResponse.decode(value),
  },
  updateSchedule: {
    path: "/payment.PaymentService/UpdateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateScheduleRequest) => Buffer.from(UpdateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse) => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScheduleResponse.decode(value),
  },
  deleteSchedule: {
    path: "/payment.PaymentService/DeleteSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse) => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteResponse.decode(value),
  },
  getDueSchedules: {
    path: "/payment.PaymentService/GetDueSchedules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDueSchedulesRequest) => Buffer.from(GetDueSchedulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetDueSchedulesRequest.decode(value),
    responseSerialize: (value: ScheduleListResponse) => Buffer.from(ScheduleListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScheduleListResponse.decode(value),
  },
  processDuePayments: {
    path: "/payment.PaymentService/ProcessDuePayments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDuePaymentsRequest) =>
      Buffer.from(ProcessDuePaymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ProcessDuePaymentsRequest.decode(value),
    responseSerialize: (value: ProcessDuePaymentsResponse) =>
      Buffer.from(ProcessDuePaymentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProcessDuePaymentsResponse.decode(value),
  },
  renewSchedule: {
    path: "/payment.PaymentService/RenewSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenewScheduleRequest) => Buffer.from(RenewScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RenewScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse) => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ScheduleResponse.decode(value),
  },
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: {
    path: "/payment.PaymentService/CreatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentIntentRequest) =>
      Buffer.from(CreatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse) => Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentIntentResponse.decode(value),
  },
  getPaymentIntent: {
    path: "/payment.PaymentService/GetPaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse) => Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentIntentResponse.decode(value),
  },
  updatePaymentIntent: {
    path: "/payment.PaymentService/UpdatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePaymentIntentRequest) =>
      Buffer.from(UpdatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse) => Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentIntentResponse.decode(value),
  },
  deletePaymentIntent: {
    path: "/payment.PaymentService/DeletePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse) => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteResponse.decode(value),
  },
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: {
    path: "/payment.PaymentService/CreatePaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentEventRequest) =>
      Buffer.from(CreatePaymentEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePaymentEventRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse) => Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentEventResponse.decode(value),
  },
  getPaymentEvent: {
    path: "/payment.PaymentService/GetPaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest) => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse) => Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentEventResponse.decode(value),
  },
  getUnprocessedEvents: {
    path: "/payment.PaymentService/GetUnprocessedEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUnprocessedEventsRequest) =>
      Buffer.from(GetUnprocessedEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUnprocessedEventsRequest.decode(value),
    responseSerialize: (value: PaymentEventListResponse) =>
      Buffer.from(PaymentEventListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentEventListResponse.decode(value),
  },
  markEventProcessed: {
    path: "/payment.PaymentService/MarkEventProcessed",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkEventProcessedRequest) =>
      Buffer.from(MarkEventProcessedRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MarkEventProcessedRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse) => Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentEventResponse.decode(value),
  },
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: {
    path: "/payment.PaymentService/GetPSPAccountsSummary",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPSPAccountsRequest) => Buffer.from(GetPSPAccountsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPSPAccountsRequest.decode(value),
    responseSerialize: (value: PSPAccountsSummaryResponse) =>
      Buffer.from(PSPAccountsSummaryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PSPAccountsSummaryResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: handleUnaryCall<CreateStripeCheckoutSessionRequest, StripeCheckoutSessionResponse>;
  createStripePaymentIntent: handleUnaryCall<CreateStripePaymentIntentRequest, StripePaymentIntentResponse>;
  getStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  cancelStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  /** Customers */
  createStripeCustomer: handleUnaryCall<CreateStripeCustomerRequest, StripeCustomerResponse>;
  getStripeCustomer: handleUnaryCall<GetByIdRequest, StripeCustomerResponse>;
  /** Subscriptions */
  createStripeSubscription: handleUnaryCall<CreateStripeSubscriptionRequest, StripeSubscriptionResponse>;
  getStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  cancelStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  /** Refunds */
  createStripeRefund: handleUnaryCall<CreateStripeRefundRequest, StripeRefundResponse>;
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: handleUnaryCall<CreateStripeSetupIntentRequest, StripeSetupIntentResponse>;
  /** Billing Portal */
  createStripeBillingPortalSession: handleUnaryCall<CreateStripeBillingPortalRequest, StripeBillingPortalResponse>;
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: handleUnaryCall<CreatePayPalOrderRequest, PayPalOrderResponse>;
  getPayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  capturePayPalOrder: handleUnaryCall<CapturePayPalOrderRequest, PayPalCaptureResponse>;
  authorizePayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: handleUnaryCall<SetupGoCardlessMandateRequest, GoCardlessMandateResponse>;
  getGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  cancelGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  createGoCardlessPayment: handleUnaryCall<CreateGoCardlessPaymentRequest, GoCardlessPaymentResponse>;
  createGoCardlessSubscription: handleUnaryCall<CreateGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  cancelGoCardlessSubscription: handleUnaryCall<CancelGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  /** ==================== SCHEDULES ==================== */
  createSchedule: handleUnaryCall<CreateScheduleRequest, ScheduleResponse>;
  getSchedule: handleUnaryCall<GetByIdRequest, ScheduleResponse>;
  updateSchedule: handleUnaryCall<UpdateScheduleRequest, ScheduleResponse>;
  deleteSchedule: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  getDueSchedules: handleUnaryCall<GetDueSchedulesRequest, ScheduleListResponse>;
  processDuePayments: handleUnaryCall<ProcessDuePaymentsRequest, ProcessDuePaymentsResponse>;
  renewSchedule: handleUnaryCall<RenewScheduleRequest, ScheduleResponse>;
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: handleUnaryCall<CreatePaymentIntentRequest, PaymentIntentResponse>;
  getPaymentIntent: handleUnaryCall<GetByIdRequest, PaymentIntentResponse>;
  updatePaymentIntent: handleUnaryCall<UpdatePaymentIntentRequest, PaymentIntentResponse>;
  deletePaymentIntent: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: handleUnaryCall<CreatePaymentEventRequest, PaymentEventResponse>;
  getPaymentEvent: handleUnaryCall<GetByIdRequest, PaymentEventResponse>;
  getUnprocessedEvents: handleUnaryCall<GetUnprocessedEventsRequest, PaymentEventListResponse>;
  markEventProcessed: handleUnaryCall<MarkEventProcessedRequest, PaymentEventResponse>;
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: handleUnaryCall<GetPSPAccountsRequest, PSPAccountsSummaryResponse>;
}

export interface PaymentServiceClient extends Client {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession(
    request: CreateStripeCheckoutSessionRequest,
    callback: (error: ServiceError | null, response: StripeCheckoutSessionResponse) => void,
  ): ClientUnaryCall;
  createStripeCheckoutSession(
    request: CreateStripeCheckoutSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeCheckoutSessionResponse) => void,
  ): ClientUnaryCall;
  createStripeCheckoutSession(
    request: CreateStripeCheckoutSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeCheckoutSessionResponse) => void,
  ): ClientUnaryCall;
  createStripePaymentIntent(
    request: CreateStripePaymentIntentRequest,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  createStripePaymentIntent(
    request: CreateStripePaymentIntentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  createStripePaymentIntent(
    request: CreateStripePaymentIntentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  getStripePaymentIntent(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  getStripePaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  getStripePaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  cancelStripePaymentIntent(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  cancelStripePaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  cancelStripePaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripePaymentIntentResponse) => void,
  ): ClientUnaryCall;
  /** Customers */
  createStripeCustomer(
    request: CreateStripeCustomerRequest,
    callback: (error: ServiceError | null, response: StripeCustomerResponse) => void,
  ): ClientUnaryCall;
  createStripeCustomer(
    request: CreateStripeCustomerRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeCustomerResponse) => void,
  ): ClientUnaryCall;
  createStripeCustomer(
    request: CreateStripeCustomerRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeCustomerResponse) => void,
  ): ClientUnaryCall;
  getStripeCustomer(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: StripeCustomerResponse) => void,
  ): ClientUnaryCall;
  getStripeCustomer(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeCustomerResponse) => void,
  ): ClientUnaryCall;
  getStripeCustomer(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeCustomerResponse) => void,
  ): ClientUnaryCall;
  /** Subscriptions */
  createStripeSubscription(
    request: CreateStripeSubscriptionRequest,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  createStripeSubscription(
    request: CreateStripeSubscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  createStripeSubscription(
    request: CreateStripeSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  getStripeSubscription(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  getStripeSubscription(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  getStripeSubscription(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  cancelStripeSubscription(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  cancelStripeSubscription(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  cancelStripeSubscription(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeSubscriptionResponse) => void,
  ): ClientUnaryCall;
  /** Refunds */
  createStripeRefund(
    request: CreateStripeRefundRequest,
    callback: (error: ServiceError | null, response: StripeRefundResponse) => void,
  ): ClientUnaryCall;
  createStripeRefund(
    request: CreateStripeRefundRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeRefundResponse) => void,
  ): ClientUnaryCall;
  createStripeRefund(
    request: CreateStripeRefundRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeRefundResponse) => void,
  ): ClientUnaryCall;
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent(
    request: CreateStripeSetupIntentRequest,
    callback: (error: ServiceError | null, response: StripeSetupIntentResponse) => void,
  ): ClientUnaryCall;
  createStripeSetupIntent(
    request: CreateStripeSetupIntentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeSetupIntentResponse) => void,
  ): ClientUnaryCall;
  createStripeSetupIntent(
    request: CreateStripeSetupIntentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeSetupIntentResponse) => void,
  ): ClientUnaryCall;
  /** Billing Portal */
  createStripeBillingPortalSession(
    request: CreateStripeBillingPortalRequest,
    callback: (error: ServiceError | null, response: StripeBillingPortalResponse) => void,
  ): ClientUnaryCall;
  createStripeBillingPortalSession(
    request: CreateStripeBillingPortalRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StripeBillingPortalResponse) => void,
  ): ClientUnaryCall;
  createStripeBillingPortalSession(
    request: CreateStripeBillingPortalRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StripeBillingPortalResponse) => void,
  ): ClientUnaryCall;
  /** ==================== PAYPAL ==================== */
  createPayPalOrder(
    request: CreatePayPalOrderRequest,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  createPayPalOrder(
    request: CreatePayPalOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  createPayPalOrder(
    request: CreatePayPalOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  getPayPalOrder(
    request: GetPayPalOrderRequest,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  getPayPalOrder(
    request: GetPayPalOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  getPayPalOrder(
    request: GetPayPalOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  capturePayPalOrder(
    request: CapturePayPalOrderRequest,
    callback: (error: ServiceError | null, response: PayPalCaptureResponse) => void,
  ): ClientUnaryCall;
  capturePayPalOrder(
    request: CapturePayPalOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PayPalCaptureResponse) => void,
  ): ClientUnaryCall;
  capturePayPalOrder(
    request: CapturePayPalOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PayPalCaptureResponse) => void,
  ): ClientUnaryCall;
  authorizePayPalOrder(
    request: GetPayPalOrderRequest,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  authorizePayPalOrder(
    request: GetPayPalOrderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  authorizePayPalOrder(
    request: GetPayPalOrderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PayPalOrderResponse) => void,
  ): ClientUnaryCall;
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate(
    request: SetupGoCardlessMandateRequest,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  setupGoCardlessMandate(
    request: SetupGoCardlessMandateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  setupGoCardlessMandate(
    request: SetupGoCardlessMandateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  getGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  getGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  getGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  cancelGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  cancelGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  cancelGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoCardlessMandateResponse) => void,
  ): ClientUnaryCall;
  createGoCardlessPayment(
    request: CreateGoCardlessPaymentRequest,
    callback: (error: ServiceError | null, response: GoCardlessPaymentResponse) => void,
  ): ClientUnaryCall;
  createGoCardlessPayment(
    request: CreateGoCardlessPaymentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoCardlessPaymentResponse) => void,
  ): ClientUnaryCall;
  createGoCardlessPayment(
    request: CreateGoCardlessPaymentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoCardlessPaymentResponse) => void,
  ): ClientUnaryCall;
  createGoCardlessSubscription(
    request: CreateGoCardlessSubscriptionRequest,
    callback: (error: ServiceError | null, response: GoCardlessSubscriptionResponse) => void,
  ): ClientUnaryCall;
  createGoCardlessSubscription(
    request: CreateGoCardlessSubscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoCardlessSubscriptionResponse) => void,
  ): ClientUnaryCall;
  createGoCardlessSubscription(
    request: CreateGoCardlessSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoCardlessSubscriptionResponse) => void,
  ): ClientUnaryCall;
  cancelGoCardlessSubscription(
    request: CancelGoCardlessSubscriptionRequest,
    callback: (error: ServiceError | null, response: GoCardlessSubscriptionResponse) => void,
  ): ClientUnaryCall;
  cancelGoCardlessSubscription(
    request: CancelGoCardlessSubscriptionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GoCardlessSubscriptionResponse) => void,
  ): ClientUnaryCall;
  cancelGoCardlessSubscription(
    request: CancelGoCardlessSubscriptionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GoCardlessSubscriptionResponse) => void,
  ): ClientUnaryCall;
  /** ==================== SCHEDULES ==================== */
  createSchedule(
    request: CreateScheduleRequest,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  createSchedule(
    request: CreateScheduleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  createSchedule(
    request: CreateScheduleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  getSchedule(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  getSchedule(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  getSchedule(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  updateSchedule(
    request: UpdateScheduleRequest,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  updateSchedule(
    request: UpdateScheduleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  updateSchedule(
    request: UpdateScheduleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  deleteSchedule(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  deleteSchedule(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  deleteSchedule(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  getDueSchedules(
    request: GetDueSchedulesRequest,
    callback: (error: ServiceError | null, response: ScheduleListResponse) => void,
  ): ClientUnaryCall;
  getDueSchedules(
    request: GetDueSchedulesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScheduleListResponse) => void,
  ): ClientUnaryCall;
  getDueSchedules(
    request: GetDueSchedulesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScheduleListResponse) => void,
  ): ClientUnaryCall;
  processDuePayments(
    request: ProcessDuePaymentsRequest,
    callback: (error: ServiceError | null, response: ProcessDuePaymentsResponse) => void,
  ): ClientUnaryCall;
  processDuePayments(
    request: ProcessDuePaymentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ProcessDuePaymentsResponse) => void,
  ): ClientUnaryCall;
  processDuePayments(
    request: ProcessDuePaymentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ProcessDuePaymentsResponse) => void,
  ): ClientUnaryCall;
  renewSchedule(
    request: RenewScheduleRequest,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  renewSchedule(
    request: RenewScheduleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  renewSchedule(
    request: RenewScheduleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScheduleResponse) => void,
  ): ClientUnaryCall;
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent(
    request: CreatePaymentIntentRequest,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  createPaymentIntent(
    request: CreatePaymentIntentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  createPaymentIntent(
    request: CreatePaymentIntentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  getPaymentIntent(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  getPaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  getPaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  updatePaymentIntent(
    request: UpdatePaymentIntentRequest,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  updatePaymentIntent(
    request: UpdatePaymentIntentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  updatePaymentIntent(
    request: UpdatePaymentIntentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentIntentResponse) => void,
  ): ClientUnaryCall;
  deletePaymentIntent(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  deletePaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  deletePaymentIntent(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteResponse) => void,
  ): ClientUnaryCall;
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent(
    request: CreatePaymentEventRequest,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  createPaymentEvent(
    request: CreatePaymentEventRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  createPaymentEvent(
    request: CreatePaymentEventRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  getPaymentEvent(
    request: GetByIdRequest,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  getPaymentEvent(
    request: GetByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  getPaymentEvent(
    request: GetByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  getUnprocessedEvents(
    request: GetUnprocessedEventsRequest,
    callback: (error: ServiceError | null, response: PaymentEventListResponse) => void,
  ): ClientUnaryCall;
  getUnprocessedEvents(
    request: GetUnprocessedEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentEventListResponse) => void,
  ): ClientUnaryCall;
  getUnprocessedEvents(
    request: GetUnprocessedEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentEventListResponse) => void,
  ): ClientUnaryCall;
  markEventProcessed(
    request: MarkEventProcessedRequest,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  markEventProcessed(
    request: MarkEventProcessedRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  markEventProcessed(
    request: MarkEventProcessedRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentEventResponse) => void,
  ): ClientUnaryCall;
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary(
    request: GetPSPAccountsRequest,
    callback: (error: ServiceError | null, response: PSPAccountsSummaryResponse) => void,
  ): ClientUnaryCall;
  getPspAccountsSummary(
    request: GetPSPAccountsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PSPAccountsSummaryResponse) => void,
  ): ClientUnaryCall;
  getPspAccountsSummary(
    request: GetPSPAccountsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PSPAccountsSummaryResponse) => void,
  ): ClientUnaryCall;
}

export const PaymentServiceClient = makeGenericClientConstructor(
  PaymentServiceService,
  "payment.PaymentService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PaymentServiceClient;
  service: typeof PaymentServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
