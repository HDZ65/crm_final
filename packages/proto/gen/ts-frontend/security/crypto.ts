// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: security/crypto.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../google/protobuf/timestamp";

/** Key domain for segmentation */
export enum KeyDomain {
  KEY_DOMAIN_UNSPECIFIED = 0,
  /** KEY_DOMAIN_PII - Personal Identifiable Information */
  KEY_DOMAIN_PII = 1,
  /** KEY_DOMAIN_PAYMENT - Payment-related data */
  KEY_DOMAIN_PAYMENT = 2,
  /** KEY_DOMAIN_AUDIT_SIGNING - Audit log signing */
  KEY_DOMAIN_AUDIT_SIGNING = 3,
  /** KEY_DOMAIN_SECRETS - General secrets */
  KEY_DOMAIN_SECRETS = 4,
}

export function keyDomainFromJSON(object: any): KeyDomain {
  switch (object) {
    case 0:
    case "KEY_DOMAIN_UNSPECIFIED":
      return KeyDomain.KEY_DOMAIN_UNSPECIFIED;
    case 1:
    case "KEY_DOMAIN_PII":
      return KeyDomain.KEY_DOMAIN_PII;
    case 2:
    case "KEY_DOMAIN_PAYMENT":
      return KeyDomain.KEY_DOMAIN_PAYMENT;
    case 3:
    case "KEY_DOMAIN_AUDIT_SIGNING":
      return KeyDomain.KEY_DOMAIN_AUDIT_SIGNING;
    case 4:
    case "KEY_DOMAIN_SECRETS":
      return KeyDomain.KEY_DOMAIN_SECRETS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum KeyDomain");
  }
}

export function keyDomainToJSON(object: KeyDomain): string {
  switch (object) {
    case KeyDomain.KEY_DOMAIN_UNSPECIFIED:
      return "KEY_DOMAIN_UNSPECIFIED";
    case KeyDomain.KEY_DOMAIN_PII:
      return "KEY_DOMAIN_PII";
    case KeyDomain.KEY_DOMAIN_PAYMENT:
      return "KEY_DOMAIN_PAYMENT";
    case KeyDomain.KEY_DOMAIN_AUDIT_SIGNING:
      return "KEY_DOMAIN_AUDIT_SIGNING";
    case KeyDomain.KEY_DOMAIN_SECRETS:
      return "KEY_DOMAIN_SECRETS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum KeyDomain");
  }
}

/** Key status */
export enum KeyStatus {
  KEY_STATUS_UNSPECIFIED = 0,
  /** KEY_STATUS_ACTIVE - Key is active for encryption and decryption */
  KEY_STATUS_ACTIVE = 1,
  /** KEY_STATUS_DECRYPT_ONLY - Key is only valid for decryption (deprecated) */
  KEY_STATUS_DECRYPT_ONLY = 2,
  /** KEY_STATUS_PENDING_DELETION - Key is scheduled for deletion */
  KEY_STATUS_PENDING_DELETION = 3,
  /** KEY_STATUS_DESTROYED - Key has been deleted/destroyed */
  KEY_STATUS_DESTROYED = 4,
}

export function keyStatusFromJSON(object: any): KeyStatus {
  switch (object) {
    case 0:
    case "KEY_STATUS_UNSPECIFIED":
      return KeyStatus.KEY_STATUS_UNSPECIFIED;
    case 1:
    case "KEY_STATUS_ACTIVE":
      return KeyStatus.KEY_STATUS_ACTIVE;
    case 2:
    case "KEY_STATUS_DECRYPT_ONLY":
      return KeyStatus.KEY_STATUS_DECRYPT_ONLY;
    case 3:
    case "KEY_STATUS_PENDING_DELETION":
      return KeyStatus.KEY_STATUS_PENDING_DELETION;
    case 4:
    case "KEY_STATUS_DESTROYED":
      return KeyStatus.KEY_STATUS_DESTROYED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum KeyStatus");
  }
}

export function keyStatusToJSON(object: KeyStatus): string {
  switch (object) {
    case KeyStatus.KEY_STATUS_UNSPECIFIED:
      return "KEY_STATUS_UNSPECIFIED";
    case KeyStatus.KEY_STATUS_ACTIVE:
      return "KEY_STATUS_ACTIVE";
    case KeyStatus.KEY_STATUS_DECRYPT_ONLY:
      return "KEY_STATUS_DECRYPT_ONLY";
    case KeyStatus.KEY_STATUS_PENDING_DELETION:
      return "KEY_STATUS_PENDING_DELETION";
    case KeyStatus.KEY_STATUS_DESTROYED:
      return "KEY_STATUS_DESTROYED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum KeyStatus");
  }
}

export enum BlindIndexType {
  BLIND_INDEX_TYPE_UNSPECIFIED = 0,
  /** BLIND_INDEX_TYPE_EMAIL - Email: lowercase, trim */
  BLIND_INDEX_TYPE_EMAIL = 1,
  /** BLIND_INDEX_TYPE_PHONE - Phone: digits only, normalized */
  BLIND_INDEX_TYPE_PHONE = 2,
  /** BLIND_INDEX_TYPE_IBAN - IBAN: uppercase, no spaces */
  BLIND_INDEX_TYPE_IBAN = 3,
  /** BLIND_INDEX_TYPE_GENERIC - Generic: as-is */
  BLIND_INDEX_TYPE_GENERIC = 4,
}

export function blindIndexTypeFromJSON(object: any): BlindIndexType {
  switch (object) {
    case 0:
    case "BLIND_INDEX_TYPE_UNSPECIFIED":
      return BlindIndexType.BLIND_INDEX_TYPE_UNSPECIFIED;
    case 1:
    case "BLIND_INDEX_TYPE_EMAIL":
      return BlindIndexType.BLIND_INDEX_TYPE_EMAIL;
    case 2:
    case "BLIND_INDEX_TYPE_PHONE":
      return BlindIndexType.BLIND_INDEX_TYPE_PHONE;
    case 3:
    case "BLIND_INDEX_TYPE_IBAN":
      return BlindIndexType.BLIND_INDEX_TYPE_IBAN;
    case 4:
    case "BLIND_INDEX_TYPE_GENERIC":
      return BlindIndexType.BLIND_INDEX_TYPE_GENERIC;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BlindIndexType");
  }
}

export function blindIndexTypeToJSON(object: BlindIndexType): string {
  switch (object) {
    case BlindIndexType.BLIND_INDEX_TYPE_UNSPECIFIED:
      return "BLIND_INDEX_TYPE_UNSPECIFIED";
    case BlindIndexType.BLIND_INDEX_TYPE_EMAIL:
      return "BLIND_INDEX_TYPE_EMAIL";
    case BlindIndexType.BLIND_INDEX_TYPE_PHONE:
      return "BLIND_INDEX_TYPE_PHONE";
    case BlindIndexType.BLIND_INDEX_TYPE_IBAN:
      return "BLIND_INDEX_TYPE_IBAN";
    case BlindIndexType.BLIND_INDEX_TYPE_GENERIC:
      return "BLIND_INDEX_TYPE_GENERIC";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum BlindIndexType");
  }
}

/** Data Encryption Key (DEK) metadata */
export interface DataKey {
  id: string;
  /** Which domain this key belongs to */
  domain: KeyDomain;
  /** Key version (incrementing) */
  version: number;
  /** Environment (dev, staging, prod) */
  environment: string;
  /** Status */
  status: KeyStatus;
  /** Algorithm (e.g., AES-256-GCM) */
  algorithm: string;
  /** Timestamps */
  createdAt?: Date | undefined;
  activatedAt?: Date | undefined;
  deprecatedAt?: Date | undefined;
  scheduledDeletionAt?:
    | Date
    | undefined;
  /** Created by */
  createdBy: string;
  /** Is this the current active key for encryption? */
  isCurrent: boolean;
}

/** Encrypted field metadata (stored alongside ciphertext) */
export interface EncryptedFieldMeta {
  /** Key version used for encryption */
  keyVersion: number;
  /** Key domain */
  domain: KeyDomain;
  /** Algorithm (e.g., AES-256-GCM) */
  algorithm: string;
  /** Nonce/IV (base64 encoded) */
  nonce: Uint8Array;
  /** Additional authenticated data (optional) */
  aad: Uint8Array;
  /** Timestamp of encryption */
  encryptedAt?: Date | undefined;
}

/** Encrypt a value */
export interface EncryptRequest {
  /** Plaintext to encrypt (bytes) */
  plaintext: Uint8Array;
  /** Key domain to use */
  domain: KeyDomain;
  /** Optional: additional authenticated data */
  aad: Uint8Array;
  /** Context (for audit/logging) */
  context: string;
}

export interface EncryptResponse {
  /** Ciphertext (bytes) */
  ciphertext: Uint8Array;
  /** Metadata about the encryption */
  meta?: EncryptedFieldMeta | undefined;
}

/** Decrypt a value */
export interface DecryptRequest {
  /** Ciphertext to decrypt */
  ciphertext: Uint8Array;
  /** Encryption metadata */
  meta?:
    | EncryptedFieldMeta
    | undefined;
  /** Context (for audit/logging) */
  context: string;
}

export interface DecryptResponse {
  /** Decrypted plaintext */
  plaintext: Uint8Array;
}

/** Batch encrypt multiple values */
export interface BatchEncryptRequest {
  items: BatchEncryptRequest_Item[];
  domain: KeyDomain;
  context: string;
}

export interface BatchEncryptRequest_Item {
  id: string;
  plaintext: Uint8Array;
  aad: Uint8Array;
}

export interface BatchEncryptResponse {
  items: BatchEncryptResponse_EncryptedItem[];
  successCount: number;
  failureCount: number;
}

export interface BatchEncryptResponse_EncryptedItem {
  id: string;
  ciphertext: Uint8Array;
  meta?: EncryptedFieldMeta | undefined;
  error: string;
}

/** Batch decrypt multiple values */
export interface BatchDecryptRequest {
  items: BatchDecryptRequest_Item[];
  context: string;
}

export interface BatchDecryptRequest_Item {
  id: string;
  ciphertext: Uint8Array;
  meta?: EncryptedFieldMeta | undefined;
}

export interface BatchDecryptResponse {
  items: BatchDecryptResponse_DecryptedItem[];
  successCount: number;
  failureCount: number;
}

export interface BatchDecryptResponse_DecryptedItem {
  id: string;
  plaintext: Uint8Array;
  error: string;
}

/** Re-encrypt with new key version (for key rotation) */
export interface ReencryptRequest {
  ciphertext: Uint8Array;
  currentMeta?: EncryptedFieldMeta | undefined;
  context: string;
}

export interface ReencryptResponse {
  ciphertext: Uint8Array;
  newMeta?: EncryptedFieldMeta | undefined;
  keyVersionChanged: boolean;
}

/** Generate blind index for searchable encryption */
export interface GenerateBlindIndexRequest {
  /** Value to index (will be normalized) */
  value: string;
  /** Index type (affects normalization) */
  indexType: BlindIndexType;
  /** Key domain for HMAC key */
  domain: KeyDomain;
}

export interface GenerateBlindIndexResponse {
  /** Blind index (HMAC-SHA256, hex encoded) */
  blindIndex: Uint8Array;
  /** Key version used */
  keyVersion: number;
}

/** Batch generate blind indexes */
export interface BatchGenerateBlindIndexRequest {
  items: BatchGenerateBlindIndexRequest_Item[];
  indexType: BlindIndexType;
  domain: KeyDomain;
}

export interface BatchGenerateBlindIndexRequest_Item {
  id: string;
  value: string;
}

export interface BatchGenerateBlindIndexResponse {
  items: BatchGenerateBlindIndexResponse_IndexedItem[];
  keyVersion: number;
}

export interface BatchGenerateBlindIndexResponse_IndexedItem {
  id: string;
  blindIndex: Uint8Array;
  error: string;
}

/** List available keys */
export interface ListKeysRequest {
  domain: KeyDomain;
  environment: string;
  includeDeprecated: boolean;
}

export interface ListKeysResponse {
  keys: DataKey[];
}

/** Get current active key for a domain */
export interface GetCurrentKeyRequest {
  domain: KeyDomain;
  environment: string;
}

export interface GetCurrentKeyResponse {
  key?: DataKey | undefined;
}

/** Rotate key (create new version) */
export interface RotateKeyRequest {
  domain: KeyDomain;
  environment: string;
  reason: string;
}

export interface RotateKeyResponse {
  newKey?: DataKey | undefined;
  oldKey?: DataKey | undefined;
}

/** Schedule key deletion */
export interface ScheduleKeyDeletionRequest {
  keyId: string;
  pendingDays: number;
  reason: string;
}

export interface ScheduleKeyDeletionResponse {
  key?: DataKey | undefined;
}

/** Cancel scheduled deletion */
export interface CancelKeyDeletionRequest {
  keyId: string;
  reason: string;
}

export interface CancelKeyDeletionResponse {
  key?: DataKey | undefined;
}

/** Sign data */
export interface SignRequest {
  data: Uint8Array;
  domain: KeyDomain;
  context: string;
}

export interface SignResponse {
  signature: Uint8Array;
  keyVersion: number;
  algorithm: string;
}

/** Verify signature */
export interface VerifyRequest {
  data: Uint8Array;
  signature: Uint8Array;
  keyVersion: number;
  domain: KeyDomain;
}

export interface VerifyResponse {
  valid: boolean;
}

function createBaseDataKey(): DataKey {
  return {
    id: "",
    domain: 0,
    version: 0,
    environment: "",
    status: 0,
    algorithm: "",
    createdAt: undefined,
    activatedAt: undefined,
    deprecatedAt: undefined,
    scheduledDeletionAt: undefined,
    createdBy: "",
    isCurrent: false,
  };
}

export const DataKey: MessageFns<DataKey> = {
  encode(message: DataKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    if (message.environment !== "") {
      writer.uint32(34).string(message.environment);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.algorithm !== "") {
      writer.uint32(50).string(message.algorithm);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.activatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.activatedAt), writer.uint32(66).fork()).join();
    }
    if (message.deprecatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.deprecatedAt), writer.uint32(74).fork()).join();
    }
    if (message.scheduledDeletionAt !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduledDeletionAt), writer.uint32(82).fork()).join();
    }
    if (message.createdBy !== "") {
      writer.uint32(90).string(message.createdBy);
    }
    if (message.isCurrent !== false) {
      writer.uint32(96).bool(message.isCurrent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.activatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.deprecatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.scheduledDeletionAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isCurrent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataKey {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      status: isSet(object.status) ? keyStatusFromJSON(object.status) : 0,
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      createdAt: isSet(object.createdAt)
        ? fromJsonTimestamp(object.createdAt)
        : isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      activatedAt: isSet(object.activatedAt)
        ? fromJsonTimestamp(object.activatedAt)
        : isSet(object.activated_at)
        ? fromJsonTimestamp(object.activated_at)
        : undefined,
      deprecatedAt: isSet(object.deprecatedAt)
        ? fromJsonTimestamp(object.deprecatedAt)
        : isSet(object.deprecated_at)
        ? fromJsonTimestamp(object.deprecated_at)
        : undefined,
      scheduledDeletionAt: isSet(object.scheduledDeletionAt)
        ? fromJsonTimestamp(object.scheduledDeletionAt)
        : isSet(object.scheduled_deletion_at)
        ? fromJsonTimestamp(object.scheduled_deletion_at)
        : undefined,
      createdBy: isSet(object.createdBy)
        ? globalThis.String(object.createdBy)
        : isSet(object.created_by)
        ? globalThis.String(object.created_by)
        : "",
      isCurrent: isSet(object.isCurrent)
        ? globalThis.Boolean(object.isCurrent)
        : isSet(object.is_current)
        ? globalThis.Boolean(object.is_current)
        : false,
    };
  },

  toJSON(message: DataKey): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.status !== 0) {
      obj.status = keyStatusToJSON(message.status);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.activatedAt !== undefined) {
      obj.activatedAt = message.activatedAt.toISOString();
    }
    if (message.deprecatedAt !== undefined) {
      obj.deprecatedAt = message.deprecatedAt.toISOString();
    }
    if (message.scheduledDeletionAt !== undefined) {
      obj.scheduledDeletionAt = message.scheduledDeletionAt.toISOString();
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.isCurrent !== false) {
      obj.isCurrent = message.isCurrent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataKey>, I>>(base?: I): DataKey {
    return DataKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataKey>, I>>(object: I): DataKey {
    const message = createBaseDataKey();
    message.id = object.id ?? "";
    message.domain = object.domain ?? 0;
    message.version = object.version ?? 0;
    message.environment = object.environment ?? "";
    message.status = object.status ?? 0;
    message.algorithm = object.algorithm ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.activatedAt = object.activatedAt ?? undefined;
    message.deprecatedAt = object.deprecatedAt ?? undefined;
    message.scheduledDeletionAt = object.scheduledDeletionAt ?? undefined;
    message.createdBy = object.createdBy ?? "";
    message.isCurrent = object.isCurrent ?? false;
    return message;
  },
};

function createBaseEncryptedFieldMeta(): EncryptedFieldMeta {
  return {
    keyVersion: 0,
    domain: 0,
    algorithm: "",
    nonce: new Uint8Array(0),
    aad: new Uint8Array(0),
    encryptedAt: undefined,
  };
}

export const EncryptedFieldMeta: MessageFns<EncryptedFieldMeta> = {
  encode(message: EncryptedFieldMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyVersion !== 0) {
      writer.uint32(8).int32(message.keyVersion);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(34).bytes(message.nonce);
    }
    if (message.aad.length !== 0) {
      writer.uint32(42).bytes(message.aad);
    }
    if (message.encryptedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.encryptedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedFieldMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedFieldMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aad = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encryptedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedFieldMeta {
    return {
      keyVersion: isSet(object.keyVersion)
        ? globalThis.Number(object.keyVersion)
        : isSet(object.key_version)
        ? globalThis.Number(object.key_version)
        : 0,
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      aad: isSet(object.aad) ? bytesFromBase64(object.aad) : new Uint8Array(0),
      encryptedAt: isSet(object.encryptedAt)
        ? fromJsonTimestamp(object.encryptedAt)
        : isSet(object.encrypted_at)
        ? fromJsonTimestamp(object.encrypted_at)
        : undefined,
    };
  },

  toJSON(message: EncryptedFieldMeta): unknown {
    const obj: any = {};
    if (message.keyVersion !== 0) {
      obj.keyVersion = Math.round(message.keyVersion);
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.aad.length !== 0) {
      obj.aad = base64FromBytes(message.aad);
    }
    if (message.encryptedAt !== undefined) {
      obj.encryptedAt = message.encryptedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncryptedFieldMeta>, I>>(base?: I): EncryptedFieldMeta {
    return EncryptedFieldMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncryptedFieldMeta>, I>>(object: I): EncryptedFieldMeta {
    const message = createBaseEncryptedFieldMeta();
    message.keyVersion = object.keyVersion ?? 0;
    message.domain = object.domain ?? 0;
    message.algorithm = object.algorithm ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.aad = object.aad ?? new Uint8Array(0);
    message.encryptedAt = object.encryptedAt ?? undefined;
    return message;
  },
};

function createBaseEncryptRequest(): EncryptRequest {
  return { plaintext: new Uint8Array(0), domain: 0, aad: new Uint8Array(0), context: "" };
}

export const EncryptRequest: MessageFns<EncryptRequest> = {
  encode(message: EncryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.aad.length !== 0) {
      writer.uint32(26).bytes(message.aad);
    }
    if (message.context !== "") {
      writer.uint32(34).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aad = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptRequest {
    return {
      plaintext: isSet(object.plaintext) ? bytesFromBase64(object.plaintext) : new Uint8Array(0),
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      aad: isSet(object.aad) ? bytesFromBase64(object.aad) : new Uint8Array(0),
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: EncryptRequest): unknown {
    const obj: any = {};
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.aad.length !== 0) {
      obj.aad = base64FromBytes(message.aad);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncryptRequest>, I>>(base?: I): EncryptRequest {
    return EncryptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncryptRequest>, I>>(object: I): EncryptRequest {
    const message = createBaseEncryptRequest();
    message.plaintext = object.plaintext ?? new Uint8Array(0);
    message.domain = object.domain ?? 0;
    message.aad = object.aad ?? new Uint8Array(0);
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseEncryptResponse(): EncryptResponse {
  return { ciphertext: new Uint8Array(0), meta: undefined };
}

export const EncryptResponse: MessageFns<EncryptResponse> = {
  encode(message: EncryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptResponse {
    return {
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      meta: isSet(object.meta) ? EncryptedFieldMeta.fromJSON(object.meta) : undefined,
    };
  },

  toJSON(message: EncryptResponse): unknown {
    const obj: any = {};
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      obj.meta = EncryptedFieldMeta.toJSON(message.meta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncryptResponse>, I>>(base?: I): EncryptResponse {
    return EncryptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncryptResponse>, I>>(object: I): EncryptResponse {
    const message = createBaseEncryptResponse();
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? EncryptedFieldMeta.fromPartial(object.meta)
      : undefined;
    return message;
  },
};

function createBaseDecryptRequest(): DecryptRequest {
  return { ciphertext: new Uint8Array(0), meta: undefined, context: "" };
}

export const DecryptRequest: MessageFns<DecryptRequest> = {
  encode(message: DecryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(18).fork()).join();
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptRequest {
    return {
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      meta: isSet(object.meta) ? EncryptedFieldMeta.fromJSON(object.meta) : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: DecryptRequest): unknown {
    const obj: any = {};
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      obj.meta = EncryptedFieldMeta.toJSON(message.meta);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptRequest>, I>>(base?: I): DecryptRequest {
    return DecryptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptRequest>, I>>(object: I): DecryptRequest {
    const message = createBaseDecryptRequest();
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? EncryptedFieldMeta.fromPartial(object.meta)
      : undefined;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseDecryptResponse(): DecryptResponse {
  return { plaintext: new Uint8Array(0) };
}

export const DecryptResponse: MessageFns<DecryptResponse> = {
  encode(message: DecryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptResponse {
    return { plaintext: isSet(object.plaintext) ? bytesFromBase64(object.plaintext) : new Uint8Array(0) };
  },

  toJSON(message: DecryptResponse): unknown {
    const obj: any = {};
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecryptResponse>, I>>(base?: I): DecryptResponse {
    return DecryptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecryptResponse>, I>>(object: I): DecryptResponse {
    const message = createBaseDecryptResponse();
    message.plaintext = object.plaintext ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBatchEncryptRequest(): BatchEncryptRequest {
  return { items: [], domain: 0, context: "" };
}

export const BatchEncryptRequest: MessageFns<BatchEncryptRequest> = {
  encode(message: BatchEncryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchEncryptRequest_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchEncryptRequest_Item.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEncryptRequest {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => BatchEncryptRequest_Item.fromJSON(e))
        : [],
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: BatchEncryptRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BatchEncryptRequest_Item.toJSON(e));
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchEncryptRequest>, I>>(base?: I): BatchEncryptRequest {
    return BatchEncryptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchEncryptRequest>, I>>(object: I): BatchEncryptRequest {
    const message = createBaseBatchEncryptRequest();
    message.items = object.items?.map((e) => BatchEncryptRequest_Item.fromPartial(e)) || [];
    message.domain = object.domain ?? 0;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseBatchEncryptRequest_Item(): BatchEncryptRequest_Item {
  return { id: "", plaintext: new Uint8Array(0), aad: new Uint8Array(0) };
}

export const BatchEncryptRequest_Item: MessageFns<BatchEncryptRequest_Item> = {
  encode(message: BatchEncryptRequest_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.plaintext.length !== 0) {
      writer.uint32(18).bytes(message.plaintext);
    }
    if (message.aad.length !== 0) {
      writer.uint32(26).bytes(message.aad);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptRequest_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptRequest_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aad = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEncryptRequest_Item {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      plaintext: isSet(object.plaintext) ? bytesFromBase64(object.plaintext) : new Uint8Array(0),
      aad: isSet(object.aad) ? bytesFromBase64(object.aad) : new Uint8Array(0),
    };
  },

  toJSON(message: BatchEncryptRequest_Item): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.aad.length !== 0) {
      obj.aad = base64FromBytes(message.aad);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchEncryptRequest_Item>, I>>(base?: I): BatchEncryptRequest_Item {
    return BatchEncryptRequest_Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchEncryptRequest_Item>, I>>(object: I): BatchEncryptRequest_Item {
    const message = createBaseBatchEncryptRequest_Item();
    message.id = object.id ?? "";
    message.plaintext = object.plaintext ?? new Uint8Array(0);
    message.aad = object.aad ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBatchEncryptResponse(): BatchEncryptResponse {
  return { items: [], successCount: 0, failureCount: 0 };
}

export const BatchEncryptResponse: MessageFns<BatchEncryptResponse> = {
  encode(message: BatchEncryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchEncryptResponse_EncryptedItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(24).int32(message.failureCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchEncryptResponse_EncryptedItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEncryptResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => BatchEncryptResponse_EncryptedItem.fromJSON(e))
        : [],
      successCount: isSet(object.successCount)
        ? globalThis.Number(object.successCount)
        : isSet(object.success_count)
        ? globalThis.Number(object.success_count)
        : 0,
      failureCount: isSet(object.failureCount)
        ? globalThis.Number(object.failureCount)
        : isSet(object.failure_count)
        ? globalThis.Number(object.failure_count)
        : 0,
    };
  },

  toJSON(message: BatchEncryptResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BatchEncryptResponse_EncryptedItem.toJSON(e));
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failureCount !== 0) {
      obj.failureCount = Math.round(message.failureCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchEncryptResponse>, I>>(base?: I): BatchEncryptResponse {
    return BatchEncryptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchEncryptResponse>, I>>(object: I): BatchEncryptResponse {
    const message = createBaseBatchEncryptResponse();
    message.items = object.items?.map((e) => BatchEncryptResponse_EncryptedItem.fromPartial(e)) || [];
    message.successCount = object.successCount ?? 0;
    message.failureCount = object.failureCount ?? 0;
    return message;
  },
};

function createBaseBatchEncryptResponse_EncryptedItem(): BatchEncryptResponse_EncryptedItem {
  return { id: "", ciphertext: new Uint8Array(0), meta: undefined, error: "" };
}

export const BatchEncryptResponse_EncryptedItem: MessageFns<BatchEncryptResponse_EncryptedItem> = {
  encode(message: BatchEncryptResponse_EncryptedItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(26).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptResponse_EncryptedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptResponse_EncryptedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchEncryptResponse_EncryptedItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      meta: isSet(object.meta) ? EncryptedFieldMeta.fromJSON(object.meta) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BatchEncryptResponse_EncryptedItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      obj.meta = EncryptedFieldMeta.toJSON(message.meta);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchEncryptResponse_EncryptedItem>, I>>(
    base?: I,
  ): BatchEncryptResponse_EncryptedItem {
    return BatchEncryptResponse_EncryptedItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchEncryptResponse_EncryptedItem>, I>>(
    object: I,
  ): BatchEncryptResponse_EncryptedItem {
    const message = createBaseBatchEncryptResponse_EncryptedItem();
    message.id = object.id ?? "";
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? EncryptedFieldMeta.fromPartial(object.meta)
      : undefined;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseBatchDecryptRequest(): BatchDecryptRequest {
  return { items: [], context: "" };
}

export const BatchDecryptRequest: MessageFns<BatchDecryptRequest> = {
  encode(message: BatchDecryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchDecryptRequest_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchDecryptRequest_Item.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDecryptRequest {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => BatchDecryptRequest_Item.fromJSON(e))
        : [],
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: BatchDecryptRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BatchDecryptRequest_Item.toJSON(e));
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchDecryptRequest>, I>>(base?: I): BatchDecryptRequest {
    return BatchDecryptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchDecryptRequest>, I>>(object: I): BatchDecryptRequest {
    const message = createBaseBatchDecryptRequest();
    message.items = object.items?.map((e) => BatchDecryptRequest_Item.fromPartial(e)) || [];
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseBatchDecryptRequest_Item(): BatchDecryptRequest_Item {
  return { id: "", ciphertext: new Uint8Array(0), meta: undefined };
}

export const BatchDecryptRequest_Item: MessageFns<BatchDecryptRequest_Item> = {
  encode(message: BatchDecryptRequest_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptRequest_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptRequest_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDecryptRequest_Item {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      meta: isSet(object.meta) ? EncryptedFieldMeta.fromJSON(object.meta) : undefined,
    };
  },

  toJSON(message: BatchDecryptRequest_Item): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      obj.meta = EncryptedFieldMeta.toJSON(message.meta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchDecryptRequest_Item>, I>>(base?: I): BatchDecryptRequest_Item {
    return BatchDecryptRequest_Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchDecryptRequest_Item>, I>>(object: I): BatchDecryptRequest_Item {
    const message = createBaseBatchDecryptRequest_Item();
    message.id = object.id ?? "";
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.meta = (object.meta !== undefined && object.meta !== null)
      ? EncryptedFieldMeta.fromPartial(object.meta)
      : undefined;
    return message;
  },
};

function createBaseBatchDecryptResponse(): BatchDecryptResponse {
  return { items: [], successCount: 0, failureCount: 0 };
}

export const BatchDecryptResponse: MessageFns<BatchDecryptResponse> = {
  encode(message: BatchDecryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchDecryptResponse_DecryptedItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(24).int32(message.failureCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchDecryptResponse_DecryptedItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDecryptResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => BatchDecryptResponse_DecryptedItem.fromJSON(e))
        : [],
      successCount: isSet(object.successCount)
        ? globalThis.Number(object.successCount)
        : isSet(object.success_count)
        ? globalThis.Number(object.success_count)
        : 0,
      failureCount: isSet(object.failureCount)
        ? globalThis.Number(object.failureCount)
        : isSet(object.failure_count)
        ? globalThis.Number(object.failure_count)
        : 0,
    };
  },

  toJSON(message: BatchDecryptResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BatchDecryptResponse_DecryptedItem.toJSON(e));
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failureCount !== 0) {
      obj.failureCount = Math.round(message.failureCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchDecryptResponse>, I>>(base?: I): BatchDecryptResponse {
    return BatchDecryptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchDecryptResponse>, I>>(object: I): BatchDecryptResponse {
    const message = createBaseBatchDecryptResponse();
    message.items = object.items?.map((e) => BatchDecryptResponse_DecryptedItem.fromPartial(e)) || [];
    message.successCount = object.successCount ?? 0;
    message.failureCount = object.failureCount ?? 0;
    return message;
  },
};

function createBaseBatchDecryptResponse_DecryptedItem(): BatchDecryptResponse_DecryptedItem {
  return { id: "", plaintext: new Uint8Array(0), error: "" };
}

export const BatchDecryptResponse_DecryptedItem: MessageFns<BatchDecryptResponse_DecryptedItem> = {
  encode(message: BatchDecryptResponse_DecryptedItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.plaintext.length !== 0) {
      writer.uint32(18).bytes(message.plaintext);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptResponse_DecryptedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptResponse_DecryptedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDecryptResponse_DecryptedItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      plaintext: isSet(object.plaintext) ? bytesFromBase64(object.plaintext) : new Uint8Array(0),
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BatchDecryptResponse_DecryptedItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchDecryptResponse_DecryptedItem>, I>>(
    base?: I,
  ): BatchDecryptResponse_DecryptedItem {
    return BatchDecryptResponse_DecryptedItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchDecryptResponse_DecryptedItem>, I>>(
    object: I,
  ): BatchDecryptResponse_DecryptedItem {
    const message = createBaseBatchDecryptResponse_DecryptedItem();
    message.id = object.id ?? "";
    message.plaintext = object.plaintext ?? new Uint8Array(0);
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseReencryptRequest(): ReencryptRequest {
  return { ciphertext: new Uint8Array(0), currentMeta: undefined, context: "" };
}

export const ReencryptRequest: MessageFns<ReencryptRequest> = {
  encode(message: ReencryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.currentMeta !== undefined) {
      EncryptedFieldMeta.encode(message.currentMeta, writer.uint32(18).fork()).join();
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReencryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReencryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currentMeta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReencryptRequest {
    return {
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      currentMeta: isSet(object.currentMeta)
        ? EncryptedFieldMeta.fromJSON(object.currentMeta)
        : isSet(object.current_meta)
        ? EncryptedFieldMeta.fromJSON(object.current_meta)
        : undefined,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: ReencryptRequest): unknown {
    const obj: any = {};
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.currentMeta !== undefined) {
      obj.currentMeta = EncryptedFieldMeta.toJSON(message.currentMeta);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReencryptRequest>, I>>(base?: I): ReencryptRequest {
    return ReencryptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReencryptRequest>, I>>(object: I): ReencryptRequest {
    const message = createBaseReencryptRequest();
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.currentMeta = (object.currentMeta !== undefined && object.currentMeta !== null)
      ? EncryptedFieldMeta.fromPartial(object.currentMeta)
      : undefined;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseReencryptResponse(): ReencryptResponse {
  return { ciphertext: new Uint8Array(0), newMeta: undefined, keyVersionChanged: false };
}

export const ReencryptResponse: MessageFns<ReencryptResponse> = {
  encode(message: ReencryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.newMeta !== undefined) {
      EncryptedFieldMeta.encode(message.newMeta, writer.uint32(18).fork()).join();
    }
    if (message.keyVersionChanged !== false) {
      writer.uint32(24).bool(message.keyVersionChanged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReencryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReencryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newMeta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyVersionChanged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReencryptResponse {
    return {
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      newMeta: isSet(object.newMeta)
        ? EncryptedFieldMeta.fromJSON(object.newMeta)
        : isSet(object.new_meta)
        ? EncryptedFieldMeta.fromJSON(object.new_meta)
        : undefined,
      keyVersionChanged: isSet(object.keyVersionChanged)
        ? globalThis.Boolean(object.keyVersionChanged)
        : isSet(object.key_version_changed)
        ? globalThis.Boolean(object.key_version_changed)
        : false,
    };
  },

  toJSON(message: ReencryptResponse): unknown {
    const obj: any = {};
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.newMeta !== undefined) {
      obj.newMeta = EncryptedFieldMeta.toJSON(message.newMeta);
    }
    if (message.keyVersionChanged !== false) {
      obj.keyVersionChanged = message.keyVersionChanged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReencryptResponse>, I>>(base?: I): ReencryptResponse {
    return ReencryptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReencryptResponse>, I>>(object: I): ReencryptResponse {
    const message = createBaseReencryptResponse();
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.newMeta = (object.newMeta !== undefined && object.newMeta !== null)
      ? EncryptedFieldMeta.fromPartial(object.newMeta)
      : undefined;
    message.keyVersionChanged = object.keyVersionChanged ?? false;
    return message;
  },
};

function createBaseGenerateBlindIndexRequest(): GenerateBlindIndexRequest {
  return { value: "", indexType: 0, domain: 0 };
}

export const GenerateBlindIndexRequest: MessageFns<GenerateBlindIndexRequest> = {
  encode(message: GenerateBlindIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.indexType !== 0) {
      writer.uint32(16).int32(message.indexType);
    }
    if (message.domain !== 0) {
      writer.uint32(24).int32(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateBlindIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateBlindIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indexType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateBlindIndexRequest {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      indexType: isSet(object.indexType)
        ? blindIndexTypeFromJSON(object.indexType)
        : isSet(object.index_type)
        ? blindIndexTypeFromJSON(object.index_type)
        : 0,
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
    };
  },

  toJSON(message: GenerateBlindIndexRequest): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.indexType !== 0) {
      obj.indexType = blindIndexTypeToJSON(message.indexType);
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateBlindIndexRequest>, I>>(base?: I): GenerateBlindIndexRequest {
    return GenerateBlindIndexRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateBlindIndexRequest>, I>>(object: I): GenerateBlindIndexRequest {
    const message = createBaseGenerateBlindIndexRequest();
    message.value = object.value ?? "";
    message.indexType = object.indexType ?? 0;
    message.domain = object.domain ?? 0;
    return message;
  },
};

function createBaseGenerateBlindIndexResponse(): GenerateBlindIndexResponse {
  return { blindIndex: new Uint8Array(0), keyVersion: 0 };
}

export const GenerateBlindIndexResponse: MessageFns<GenerateBlindIndexResponse> = {
  encode(message: GenerateBlindIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blindIndex.length !== 0) {
      writer.uint32(10).bytes(message.blindIndex);
    }
    if (message.keyVersion !== 0) {
      writer.uint32(16).int32(message.keyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateBlindIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateBlindIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blindIndex = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateBlindIndexResponse {
    return {
      blindIndex: isSet(object.blindIndex)
        ? bytesFromBase64(object.blindIndex)
        : isSet(object.blind_index)
        ? bytesFromBase64(object.blind_index)
        : new Uint8Array(0),
      keyVersion: isSet(object.keyVersion)
        ? globalThis.Number(object.keyVersion)
        : isSet(object.key_version)
        ? globalThis.Number(object.key_version)
        : 0,
    };
  },

  toJSON(message: GenerateBlindIndexResponse): unknown {
    const obj: any = {};
    if (message.blindIndex.length !== 0) {
      obj.blindIndex = base64FromBytes(message.blindIndex);
    }
    if (message.keyVersion !== 0) {
      obj.keyVersion = Math.round(message.keyVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateBlindIndexResponse>, I>>(base?: I): GenerateBlindIndexResponse {
    return GenerateBlindIndexResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateBlindIndexResponse>, I>>(object: I): GenerateBlindIndexResponse {
    const message = createBaseGenerateBlindIndexResponse();
    message.blindIndex = object.blindIndex ?? new Uint8Array(0);
    message.keyVersion = object.keyVersion ?? 0;
    return message;
  },
};

function createBaseBatchGenerateBlindIndexRequest(): BatchGenerateBlindIndexRequest {
  return { items: [], indexType: 0, domain: 0 };
}

export const BatchGenerateBlindIndexRequest: MessageFns<BatchGenerateBlindIndexRequest> = {
  encode(message: BatchGenerateBlindIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchGenerateBlindIndexRequest_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.indexType !== 0) {
      writer.uint32(16).int32(message.indexType);
    }
    if (message.domain !== 0) {
      writer.uint32(24).int32(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchGenerateBlindIndexRequest_Item.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indexType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGenerateBlindIndexRequest {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => BatchGenerateBlindIndexRequest_Item.fromJSON(e))
        : [],
      indexType: isSet(object.indexType)
        ? blindIndexTypeFromJSON(object.indexType)
        : isSet(object.index_type)
        ? blindIndexTypeFromJSON(object.index_type)
        : 0,
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
    };
  },

  toJSON(message: BatchGenerateBlindIndexRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BatchGenerateBlindIndexRequest_Item.toJSON(e));
    }
    if (message.indexType !== 0) {
      obj.indexType = blindIndexTypeToJSON(message.indexType);
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGenerateBlindIndexRequest>, I>>(base?: I): BatchGenerateBlindIndexRequest {
    return BatchGenerateBlindIndexRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGenerateBlindIndexRequest>, I>>(
    object: I,
  ): BatchGenerateBlindIndexRequest {
    const message = createBaseBatchGenerateBlindIndexRequest();
    message.items = object.items?.map((e) => BatchGenerateBlindIndexRequest_Item.fromPartial(e)) || [];
    message.indexType = object.indexType ?? 0;
    message.domain = object.domain ?? 0;
    return message;
  },
};

function createBaseBatchGenerateBlindIndexRequest_Item(): BatchGenerateBlindIndexRequest_Item {
  return { id: "", value: "" };
}

export const BatchGenerateBlindIndexRequest_Item: MessageFns<BatchGenerateBlindIndexRequest_Item> = {
  encode(message: BatchGenerateBlindIndexRequest_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexRequest_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexRequest_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGenerateBlindIndexRequest_Item {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BatchGenerateBlindIndexRequest_Item): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGenerateBlindIndexRequest_Item>, I>>(
    base?: I,
  ): BatchGenerateBlindIndexRequest_Item {
    return BatchGenerateBlindIndexRequest_Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGenerateBlindIndexRequest_Item>, I>>(
    object: I,
  ): BatchGenerateBlindIndexRequest_Item {
    const message = createBaseBatchGenerateBlindIndexRequest_Item();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBatchGenerateBlindIndexResponse(): BatchGenerateBlindIndexResponse {
  return { items: [], keyVersion: 0 };
}

export const BatchGenerateBlindIndexResponse: MessageFns<BatchGenerateBlindIndexResponse> = {
  encode(message: BatchGenerateBlindIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchGenerateBlindIndexResponse_IndexedItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.keyVersion !== 0) {
      writer.uint32(16).int32(message.keyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchGenerateBlindIndexResponse_IndexedItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGenerateBlindIndexResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => BatchGenerateBlindIndexResponse_IndexedItem.fromJSON(e))
        : [],
      keyVersion: isSet(object.keyVersion)
        ? globalThis.Number(object.keyVersion)
        : isSet(object.key_version)
        ? globalThis.Number(object.key_version)
        : 0,
    };
  },

  toJSON(message: BatchGenerateBlindIndexResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BatchGenerateBlindIndexResponse_IndexedItem.toJSON(e));
    }
    if (message.keyVersion !== 0) {
      obj.keyVersion = Math.round(message.keyVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGenerateBlindIndexResponse>, I>>(base?: I): BatchGenerateBlindIndexResponse {
    return BatchGenerateBlindIndexResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGenerateBlindIndexResponse>, I>>(
    object: I,
  ): BatchGenerateBlindIndexResponse {
    const message = createBaseBatchGenerateBlindIndexResponse();
    message.items = object.items?.map((e) => BatchGenerateBlindIndexResponse_IndexedItem.fromPartial(e)) || [];
    message.keyVersion = object.keyVersion ?? 0;
    return message;
  },
};

function createBaseBatchGenerateBlindIndexResponse_IndexedItem(): BatchGenerateBlindIndexResponse_IndexedItem {
  return { id: "", blindIndex: new Uint8Array(0), error: "" };
}

export const BatchGenerateBlindIndexResponse_IndexedItem: MessageFns<BatchGenerateBlindIndexResponse_IndexedItem> = {
  encode(
    message: BatchGenerateBlindIndexResponse_IndexedItem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blindIndex.length !== 0) {
      writer.uint32(18).bytes(message.blindIndex);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexResponse_IndexedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexResponse_IndexedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blindIndex = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGenerateBlindIndexResponse_IndexedItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blindIndex: isSet(object.blindIndex)
        ? bytesFromBase64(object.blindIndex)
        : isSet(object.blind_index)
        ? bytesFromBase64(object.blind_index)
        : new Uint8Array(0),
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BatchGenerateBlindIndexResponse_IndexedItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blindIndex.length !== 0) {
      obj.blindIndex = base64FromBytes(message.blindIndex);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchGenerateBlindIndexResponse_IndexedItem>, I>>(
    base?: I,
  ): BatchGenerateBlindIndexResponse_IndexedItem {
    return BatchGenerateBlindIndexResponse_IndexedItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchGenerateBlindIndexResponse_IndexedItem>, I>>(
    object: I,
  ): BatchGenerateBlindIndexResponse_IndexedItem {
    const message = createBaseBatchGenerateBlindIndexResponse_IndexedItem();
    message.id = object.id ?? "";
    message.blindIndex = object.blindIndex ?? new Uint8Array(0);
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseListKeysRequest(): ListKeysRequest {
  return { domain: 0, environment: "", includeDeprecated: false };
}

export const ListKeysRequest: MessageFns<ListKeysRequest> = {
  encode(message: ListKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== 0) {
      writer.uint32(8).int32(message.domain);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    if (message.includeDeprecated !== false) {
      writer.uint32(24).bool(message.includeDeprecated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeDeprecated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysRequest {
    return {
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      includeDeprecated: isSet(object.includeDeprecated)
        ? globalThis.Boolean(object.includeDeprecated)
        : isSet(object.include_deprecated)
        ? globalThis.Boolean(object.include_deprecated)
        : false,
    };
  },

  toJSON(message: ListKeysRequest): unknown {
    const obj: any = {};
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.includeDeprecated !== false) {
      obj.includeDeprecated = message.includeDeprecated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKeysRequest>, I>>(base?: I): ListKeysRequest {
    return ListKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKeysRequest>, I>>(object: I): ListKeysRequest {
    const message = createBaseListKeysRequest();
    message.domain = object.domain ?? 0;
    message.environment = object.environment ?? "";
    message.includeDeprecated = object.includeDeprecated ?? false;
    return message;
  },
};

function createBaseListKeysResponse(): ListKeysResponse {
  return { keys: [] };
}

export const ListKeysResponse: MessageFns<ListKeysResponse> = {
  encode(message: ListKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      DataKey.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keys.push(DataKey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysResponse {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => DataKey.fromJSON(e)) : [] };
  },

  toJSON(message: ListKeysResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => DataKey.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListKeysResponse>, I>>(base?: I): ListKeysResponse {
    return ListKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListKeysResponse>, I>>(object: I): ListKeysResponse {
    const message = createBaseListKeysResponse();
    message.keys = object.keys?.map((e) => DataKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetCurrentKeyRequest(): GetCurrentKeyRequest {
  return { domain: 0, environment: "" };
}

export const GetCurrentKeyRequest: MessageFns<GetCurrentKeyRequest> = {
  encode(message: GetCurrentKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== 0) {
      writer.uint32(8).int32(message.domain);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentKeyRequest {
    return {
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
    };
  },

  toJSON(message: GetCurrentKeyRequest): unknown {
    const obj: any = {};
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCurrentKeyRequest>, I>>(base?: I): GetCurrentKeyRequest {
    return GetCurrentKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCurrentKeyRequest>, I>>(object: I): GetCurrentKeyRequest {
    const message = createBaseGetCurrentKeyRequest();
    message.domain = object.domain ?? 0;
    message.environment = object.environment ?? "";
    return message;
  },
};

function createBaseGetCurrentKeyResponse(): GetCurrentKeyResponse {
  return { key: undefined };
}

export const GetCurrentKeyResponse: MessageFns<GetCurrentKeyResponse> = {
  encode(message: GetCurrentKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      DataKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrentKeyResponse {
    return { key: isSet(object.key) ? DataKey.fromJSON(object.key) : undefined };
  },

  toJSON(message: GetCurrentKeyResponse): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = DataKey.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCurrentKeyResponse>, I>>(base?: I): GetCurrentKeyResponse {
    return GetCurrentKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCurrentKeyResponse>, I>>(object: I): GetCurrentKeyResponse {
    const message = createBaseGetCurrentKeyResponse();
    message.key = (object.key !== undefined && object.key !== null) ? DataKey.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseRotateKeyRequest(): RotateKeyRequest {
  return { domain: 0, environment: "", reason: "" };
}

export const RotateKeyRequest: MessageFns<RotateKeyRequest> = {
  encode(message: RotateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== 0) {
      writer.uint32(8).int32(message.domain);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RotateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RotateKeyRequest {
    return {
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: RotateKeyRequest): unknown {
    const obj: any = {};
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(base?: I): RotateKeyRequest {
    return RotateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(object: I): RotateKeyRequest {
    const message = createBaseRotateKeyRequest();
    message.domain = object.domain ?? 0;
    message.environment = object.environment ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseRotateKeyResponse(): RotateKeyResponse {
  return { newKey: undefined, oldKey: undefined };
}

export const RotateKeyResponse: MessageFns<RotateKeyResponse> = {
  encode(message: RotateKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newKey !== undefined) {
      DataKey.encode(message.newKey, writer.uint32(10).fork()).join();
    }
    if (message.oldKey !== undefined) {
      DataKey.encode(message.oldKey, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RotateKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newKey = DataKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldKey = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RotateKeyResponse {
    return {
      newKey: isSet(object.newKey)
        ? DataKey.fromJSON(object.newKey)
        : isSet(object.new_key)
        ? DataKey.fromJSON(object.new_key)
        : undefined,
      oldKey: isSet(object.oldKey)
        ? DataKey.fromJSON(object.oldKey)
        : isSet(object.old_key)
        ? DataKey.fromJSON(object.old_key)
        : undefined,
    };
  },

  toJSON(message: RotateKeyResponse): unknown {
    const obj: any = {};
    if (message.newKey !== undefined) {
      obj.newKey = DataKey.toJSON(message.newKey);
    }
    if (message.oldKey !== undefined) {
      obj.oldKey = DataKey.toJSON(message.oldKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(base?: I): RotateKeyResponse {
    return RotateKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(object: I): RotateKeyResponse {
    const message = createBaseRotateKeyResponse();
    message.newKey = (object.newKey !== undefined && object.newKey !== null)
      ? DataKey.fromPartial(object.newKey)
      : undefined;
    message.oldKey = (object.oldKey !== undefined && object.oldKey !== null)
      ? DataKey.fromPartial(object.oldKey)
      : undefined;
    return message;
  },
};

function createBaseScheduleKeyDeletionRequest(): ScheduleKeyDeletionRequest {
  return { keyId: "", pendingDays: 0, reason: "" };
}

export const ScheduleKeyDeletionRequest: MessageFns<ScheduleKeyDeletionRequest> = {
  encode(message: ScheduleKeyDeletionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    if (message.pendingDays !== 0) {
      writer.uint32(16).int32(message.pendingDays);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleKeyDeletionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleKeyDeletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pendingDays = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleKeyDeletionRequest {
    return {
      keyId: isSet(object.keyId)
        ? globalThis.String(object.keyId)
        : isSet(object.key_id)
        ? globalThis.String(object.key_id)
        : "",
      pendingDays: isSet(object.pendingDays)
        ? globalThis.Number(object.pendingDays)
        : isSet(object.pending_days)
        ? globalThis.Number(object.pending_days)
        : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: ScheduleKeyDeletionRequest): unknown {
    const obj: any = {};
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.pendingDays !== 0) {
      obj.pendingDays = Math.round(message.pendingDays);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleKeyDeletionRequest>, I>>(base?: I): ScheduleKeyDeletionRequest {
    return ScheduleKeyDeletionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleKeyDeletionRequest>, I>>(object: I): ScheduleKeyDeletionRequest {
    const message = createBaseScheduleKeyDeletionRequest();
    message.keyId = object.keyId ?? "";
    message.pendingDays = object.pendingDays ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseScheduleKeyDeletionResponse(): ScheduleKeyDeletionResponse {
  return { key: undefined };
}

export const ScheduleKeyDeletionResponse: MessageFns<ScheduleKeyDeletionResponse> = {
  encode(message: ScheduleKeyDeletionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      DataKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleKeyDeletionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleKeyDeletionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScheduleKeyDeletionResponse {
    return { key: isSet(object.key) ? DataKey.fromJSON(object.key) : undefined };
  },

  toJSON(message: ScheduleKeyDeletionResponse): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = DataKey.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScheduleKeyDeletionResponse>, I>>(base?: I): ScheduleKeyDeletionResponse {
    return ScheduleKeyDeletionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScheduleKeyDeletionResponse>, I>>(object: I): ScheduleKeyDeletionResponse {
    const message = createBaseScheduleKeyDeletionResponse();
    message.key = (object.key !== undefined && object.key !== null) ? DataKey.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseCancelKeyDeletionRequest(): CancelKeyDeletionRequest {
  return { keyId: "", reason: "" };
}

export const CancelKeyDeletionRequest: MessageFns<CancelKeyDeletionRequest> = {
  encode(message: CancelKeyDeletionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelKeyDeletionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelKeyDeletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelKeyDeletionRequest {
    return {
      keyId: isSet(object.keyId)
        ? globalThis.String(object.keyId)
        : isSet(object.key_id)
        ? globalThis.String(object.key_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: CancelKeyDeletionRequest): unknown {
    const obj: any = {};
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelKeyDeletionRequest>, I>>(base?: I): CancelKeyDeletionRequest {
    return CancelKeyDeletionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelKeyDeletionRequest>, I>>(object: I): CancelKeyDeletionRequest {
    const message = createBaseCancelKeyDeletionRequest();
    message.keyId = object.keyId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseCancelKeyDeletionResponse(): CancelKeyDeletionResponse {
  return { key: undefined };
}

export const CancelKeyDeletionResponse: MessageFns<CancelKeyDeletionResponse> = {
  encode(message: CancelKeyDeletionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      DataKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelKeyDeletionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelKeyDeletionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelKeyDeletionResponse {
    return { key: isSet(object.key) ? DataKey.fromJSON(object.key) : undefined };
  },

  toJSON(message: CancelKeyDeletionResponse): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = DataKey.toJSON(message.key);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelKeyDeletionResponse>, I>>(base?: I): CancelKeyDeletionResponse {
    return CancelKeyDeletionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelKeyDeletionResponse>, I>>(object: I): CancelKeyDeletionResponse {
    const message = createBaseCancelKeyDeletionResponse();
    message.key = (object.key !== undefined && object.key !== null) ? DataKey.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseSignRequest(): SignRequest {
  return { data: new Uint8Array(0), domain: 0, context: "" };
}

export const SignRequest: MessageFns<SignRequest> = {
  encode(message: SignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignRequest {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: SignRequest): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignRequest>, I>>(base?: I): SignRequest {
    return SignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignRequest>, I>>(object: I): SignRequest {
    const message = createBaseSignRequest();
    message.data = object.data ?? new Uint8Array(0);
    message.domain = object.domain ?? 0;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseSignResponse(): SignResponse {
  return { signature: new Uint8Array(0), keyVersion: 0, algorithm: "" };
}

export const SignResponse: MessageFns<SignResponse> = {
  encode(message: SignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.keyVersion !== 0) {
      writer.uint32(16).int32(message.keyVersion);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignResponse {
    return {
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      keyVersion: isSet(object.keyVersion)
        ? globalThis.Number(object.keyVersion)
        : isSet(object.key_version)
        ? globalThis.Number(object.key_version)
        : 0,
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
    };
  },

  toJSON(message: SignResponse): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.keyVersion !== 0) {
      obj.keyVersion = Math.round(message.keyVersion);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignResponse>, I>>(base?: I): SignResponse {
    return SignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignResponse>, I>>(object: I): SignResponse {
    const message = createBaseSignResponse();
    message.signature = object.signature ?? new Uint8Array(0);
    message.keyVersion = object.keyVersion ?? 0;
    message.algorithm = object.algorithm ?? "";
    return message;
  },
};

function createBaseVerifyRequest(): VerifyRequest {
  return { data: new Uint8Array(0), signature: new Uint8Array(0), keyVersion: 0, domain: 0 };
}

export const VerifyRequest: MessageFns<VerifyRequest> = {
  encode(message: VerifyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.keyVersion !== 0) {
      writer.uint32(24).int32(message.keyVersion);
    }
    if (message.domain !== 0) {
      writer.uint32(32).int32(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyRequest {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      keyVersion: isSet(object.keyVersion)
        ? globalThis.Number(object.keyVersion)
        : isSet(object.key_version)
        ? globalThis.Number(object.key_version)
        : 0,
      domain: isSet(object.domain) ? keyDomainFromJSON(object.domain) : 0,
    };
  },

  toJSON(message: VerifyRequest): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.keyVersion !== 0) {
      obj.keyVersion = Math.round(message.keyVersion);
    }
    if (message.domain !== 0) {
      obj.domain = keyDomainToJSON(message.domain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyRequest>, I>>(base?: I): VerifyRequest {
    return VerifyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyRequest>, I>>(object: I): VerifyRequest {
    const message = createBaseVerifyRequest();
    message.data = object.data ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.keyVersion = object.keyVersion ?? 0;
    message.domain = object.domain ?? 0;
    return message;
  },
};

function createBaseVerifyResponse(): VerifyResponse {
  return { valid: false };
}

export const VerifyResponse: MessageFns<VerifyResponse> = {
  encode(message: VerifyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyResponse {
    return { valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false };
  },

  toJSON(message: VerifyResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyResponse>, I>>(base?: I): VerifyResponse {
    return VerifyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyResponse>, I>>(object: I): VerifyResponse {
    const message = createBaseVerifyResponse();
    message.valid = object.valid ?? false;
    return message;
  },
};

/** ========== ENCRYPTION ========== */
export type CryptoServiceService = typeof CryptoServiceService;
export const CryptoServiceService = {
  encrypt: {
    path: "/security.CryptoService/Encrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EncryptRequest): Buffer => Buffer.from(EncryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): EncryptRequest => EncryptRequest.decode(value),
    responseSerialize: (value: EncryptResponse): Buffer => Buffer.from(EncryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EncryptResponse => EncryptResponse.decode(value),
  },
  decrypt: {
    path: "/security.CryptoService/Decrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DecryptRequest): Buffer => Buffer.from(DecryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DecryptRequest => DecryptRequest.decode(value),
    responseSerialize: (value: DecryptResponse): Buffer => Buffer.from(DecryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DecryptResponse => DecryptResponse.decode(value),
  },
  batchEncrypt: {
    path: "/security.CryptoService/BatchEncrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchEncryptRequest): Buffer => Buffer.from(BatchEncryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchEncryptRequest => BatchEncryptRequest.decode(value),
    responseSerialize: (value: BatchEncryptResponse): Buffer =>
      Buffer.from(BatchEncryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchEncryptResponse => BatchEncryptResponse.decode(value),
  },
  batchDecrypt: {
    path: "/security.CryptoService/BatchDecrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchDecryptRequest): Buffer => Buffer.from(BatchDecryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchDecryptRequest => BatchDecryptRequest.decode(value),
    responseSerialize: (value: BatchDecryptResponse): Buffer =>
      Buffer.from(BatchDecryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchDecryptResponse => BatchDecryptResponse.decode(value),
  },
  reencrypt: {
    path: "/security.CryptoService/Reencrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReencryptRequest): Buffer => Buffer.from(ReencryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReencryptRequest => ReencryptRequest.decode(value),
    responseSerialize: (value: ReencryptResponse): Buffer => Buffer.from(ReencryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReencryptResponse => ReencryptResponse.decode(value),
  },
  generateBlindIndex: {
    path: "/security.CryptoService/GenerateBlindIndex",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateBlindIndexRequest): Buffer =>
      Buffer.from(GenerateBlindIndexRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GenerateBlindIndexRequest => GenerateBlindIndexRequest.decode(value),
    responseSerialize: (value: GenerateBlindIndexResponse): Buffer =>
      Buffer.from(GenerateBlindIndexResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GenerateBlindIndexResponse => GenerateBlindIndexResponse.decode(value),
  },
  batchGenerateBlindIndex: {
    path: "/security.CryptoService/BatchGenerateBlindIndex",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchGenerateBlindIndexRequest): Buffer =>
      Buffer.from(BatchGenerateBlindIndexRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchGenerateBlindIndexRequest => BatchGenerateBlindIndexRequest.decode(value),
    responseSerialize: (value: BatchGenerateBlindIndexResponse): Buffer =>
      Buffer.from(BatchGenerateBlindIndexResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchGenerateBlindIndexResponse =>
      BatchGenerateBlindIndexResponse.decode(value),
  },
  listKeys: {
    path: "/security.CryptoService/ListKeys",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListKeysRequest): Buffer => Buffer.from(ListKeysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListKeysRequest => ListKeysRequest.decode(value),
    responseSerialize: (value: ListKeysResponse): Buffer => Buffer.from(ListKeysResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListKeysResponse => ListKeysResponse.decode(value),
  },
  getCurrentKey: {
    path: "/security.CryptoService/GetCurrentKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCurrentKeyRequest): Buffer => Buffer.from(GetCurrentKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCurrentKeyRequest => GetCurrentKeyRequest.decode(value),
    responseSerialize: (value: GetCurrentKeyResponse): Buffer =>
      Buffer.from(GetCurrentKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetCurrentKeyResponse => GetCurrentKeyResponse.decode(value),
  },
  rotateKey: {
    path: "/security.CryptoService/RotateKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RotateKeyRequest): Buffer => Buffer.from(RotateKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RotateKeyRequest => RotateKeyRequest.decode(value),
    responseSerialize: (value: RotateKeyResponse): Buffer => Buffer.from(RotateKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RotateKeyResponse => RotateKeyResponse.decode(value),
  },
  scheduleKeyDeletion: {
    path: "/security.CryptoService/ScheduleKeyDeletion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ScheduleKeyDeletionRequest): Buffer =>
      Buffer.from(ScheduleKeyDeletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ScheduleKeyDeletionRequest => ScheduleKeyDeletionRequest.decode(value),
    responseSerialize: (value: ScheduleKeyDeletionResponse): Buffer =>
      Buffer.from(ScheduleKeyDeletionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleKeyDeletionResponse => ScheduleKeyDeletionResponse.decode(value),
  },
  cancelKeyDeletion: {
    path: "/security.CryptoService/CancelKeyDeletion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelKeyDeletionRequest): Buffer =>
      Buffer.from(CancelKeyDeletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelKeyDeletionRequest => CancelKeyDeletionRequest.decode(value),
    responseSerialize: (value: CancelKeyDeletionResponse): Buffer =>
      Buffer.from(CancelKeyDeletionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CancelKeyDeletionResponse => CancelKeyDeletionResponse.decode(value),
  },
  sign: {
    path: "/security.CryptoService/Sign",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignRequest): Buffer => Buffer.from(SignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignRequest => SignRequest.decode(value),
    responseSerialize: (value: SignResponse): Buffer => Buffer.from(SignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignResponse => SignResponse.decode(value),
  },
  verify: {
    path: "/security.CryptoService/Verify",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyRequest): Buffer => Buffer.from(VerifyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyRequest => VerifyRequest.decode(value),
    responseSerialize: (value: VerifyResponse): Buffer => Buffer.from(VerifyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyResponse => VerifyResponse.decode(value),
  },
} as const;

export interface CryptoServiceServer extends UntypedServiceImplementation {
  encrypt: handleUnaryCall<EncryptRequest, EncryptResponse>;
  decrypt: handleUnaryCall<DecryptRequest, DecryptResponse>;
  batchEncrypt: handleUnaryCall<BatchEncryptRequest, BatchEncryptResponse>;
  batchDecrypt: handleUnaryCall<BatchDecryptRequest, BatchDecryptResponse>;
  reencrypt: handleUnaryCall<ReencryptRequest, ReencryptResponse>;
  generateBlindIndex: handleUnaryCall<GenerateBlindIndexRequest, GenerateBlindIndexResponse>;
  batchGenerateBlindIndex: handleUnaryCall<BatchGenerateBlindIndexRequest, BatchGenerateBlindIndexResponse>;
  listKeys: handleUnaryCall<ListKeysRequest, ListKeysResponse>;
  getCurrentKey: handleUnaryCall<GetCurrentKeyRequest, GetCurrentKeyResponse>;
  rotateKey: handleUnaryCall<RotateKeyRequest, RotateKeyResponse>;
  scheduleKeyDeletion: handleUnaryCall<ScheduleKeyDeletionRequest, ScheduleKeyDeletionResponse>;
  cancelKeyDeletion: handleUnaryCall<CancelKeyDeletionRequest, CancelKeyDeletionResponse>;
  sign: handleUnaryCall<SignRequest, SignResponse>;
  verify: handleUnaryCall<VerifyRequest, VerifyResponse>;
}

export interface CryptoServiceClient extends Client {
  encrypt(
    request: EncryptRequest,
    callback: (error: ServiceError | null, response: EncryptResponse) => void,
  ): ClientUnaryCall;
  encrypt(
    request: EncryptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EncryptResponse) => void,
  ): ClientUnaryCall;
  encrypt(
    request: EncryptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EncryptResponse) => void,
  ): ClientUnaryCall;
  decrypt(
    request: DecryptRequest,
    callback: (error: ServiceError | null, response: DecryptResponse) => void,
  ): ClientUnaryCall;
  decrypt(
    request: DecryptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DecryptResponse) => void,
  ): ClientUnaryCall;
  decrypt(
    request: DecryptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DecryptResponse) => void,
  ): ClientUnaryCall;
  batchEncrypt(
    request: BatchEncryptRequest,
    callback: (error: ServiceError | null, response: BatchEncryptResponse) => void,
  ): ClientUnaryCall;
  batchEncrypt(
    request: BatchEncryptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchEncryptResponse) => void,
  ): ClientUnaryCall;
  batchEncrypt(
    request: BatchEncryptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchEncryptResponse) => void,
  ): ClientUnaryCall;
  batchDecrypt(
    request: BatchDecryptRequest,
    callback: (error: ServiceError | null, response: BatchDecryptResponse) => void,
  ): ClientUnaryCall;
  batchDecrypt(
    request: BatchDecryptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchDecryptResponse) => void,
  ): ClientUnaryCall;
  batchDecrypt(
    request: BatchDecryptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchDecryptResponse) => void,
  ): ClientUnaryCall;
  reencrypt(
    request: ReencryptRequest,
    callback: (error: ServiceError | null, response: ReencryptResponse) => void,
  ): ClientUnaryCall;
  reencrypt(
    request: ReencryptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReencryptResponse) => void,
  ): ClientUnaryCall;
  reencrypt(
    request: ReencryptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReencryptResponse) => void,
  ): ClientUnaryCall;
  generateBlindIndex(
    request: GenerateBlindIndexRequest,
    callback: (error: ServiceError | null, response: GenerateBlindIndexResponse) => void,
  ): ClientUnaryCall;
  generateBlindIndex(
    request: GenerateBlindIndexRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GenerateBlindIndexResponse) => void,
  ): ClientUnaryCall;
  generateBlindIndex(
    request: GenerateBlindIndexRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GenerateBlindIndexResponse) => void,
  ): ClientUnaryCall;
  batchGenerateBlindIndex(
    request: BatchGenerateBlindIndexRequest,
    callback: (error: ServiceError | null, response: BatchGenerateBlindIndexResponse) => void,
  ): ClientUnaryCall;
  batchGenerateBlindIndex(
    request: BatchGenerateBlindIndexRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BatchGenerateBlindIndexResponse) => void,
  ): ClientUnaryCall;
  batchGenerateBlindIndex(
    request: BatchGenerateBlindIndexRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BatchGenerateBlindIndexResponse) => void,
  ): ClientUnaryCall;
  listKeys(
    request: ListKeysRequest,
    callback: (error: ServiceError | null, response: ListKeysResponse) => void,
  ): ClientUnaryCall;
  listKeys(
    request: ListKeysRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListKeysResponse) => void,
  ): ClientUnaryCall;
  listKeys(
    request: ListKeysRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListKeysResponse) => void,
  ): ClientUnaryCall;
  getCurrentKey(
    request: GetCurrentKeyRequest,
    callback: (error: ServiceError | null, response: GetCurrentKeyResponse) => void,
  ): ClientUnaryCall;
  getCurrentKey(
    request: GetCurrentKeyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetCurrentKeyResponse) => void,
  ): ClientUnaryCall;
  getCurrentKey(
    request: GetCurrentKeyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetCurrentKeyResponse) => void,
  ): ClientUnaryCall;
  rotateKey(
    request: RotateKeyRequest,
    callback: (error: ServiceError | null, response: RotateKeyResponse) => void,
  ): ClientUnaryCall;
  rotateKey(
    request: RotateKeyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RotateKeyResponse) => void,
  ): ClientUnaryCall;
  rotateKey(
    request: RotateKeyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RotateKeyResponse) => void,
  ): ClientUnaryCall;
  scheduleKeyDeletion(
    request: ScheduleKeyDeletionRequest,
    callback: (error: ServiceError | null, response: ScheduleKeyDeletionResponse) => void,
  ): ClientUnaryCall;
  scheduleKeyDeletion(
    request: ScheduleKeyDeletionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ScheduleKeyDeletionResponse) => void,
  ): ClientUnaryCall;
  scheduleKeyDeletion(
    request: ScheduleKeyDeletionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ScheduleKeyDeletionResponse) => void,
  ): ClientUnaryCall;
  cancelKeyDeletion(
    request: CancelKeyDeletionRequest,
    callback: (error: ServiceError | null, response: CancelKeyDeletionResponse) => void,
  ): ClientUnaryCall;
  cancelKeyDeletion(
    request: CancelKeyDeletionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CancelKeyDeletionResponse) => void,
  ): ClientUnaryCall;
  cancelKeyDeletion(
    request: CancelKeyDeletionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CancelKeyDeletionResponse) => void,
  ): ClientUnaryCall;
  sign(request: SignRequest, callback: (error: ServiceError | null, response: SignResponse) => void): ClientUnaryCall;
  sign(
    request: SignRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignResponse) => void,
  ): ClientUnaryCall;
  sign(
    request: SignRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignResponse) => void,
  ): ClientUnaryCall;
  verify(
    request: VerifyRequest,
    callback: (error: ServiceError | null, response: VerifyResponse) => void,
  ): ClientUnaryCall;
  verify(
    request: VerifyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyResponse) => void,
  ): ClientUnaryCall;
  verify(
    request: VerifyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyResponse) => void,
  ): ClientUnaryCall;
}

export const CryptoServiceClient = makeGenericClientConstructor(
  CryptoServiceService,
  "security.CryptoService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CryptoServiceClient;
  service: typeof CryptoServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
