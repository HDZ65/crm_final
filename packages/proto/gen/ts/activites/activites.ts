// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: activites/activites.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface TypeActivite {
  id: string;
  code: string;
  nom: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateTypeActiviteRequest {
  code: string;
  nom: string;
  description: string;
}

export interface UpdateTypeActiviteRequest {
  id: string;
  code: string;
  nom: string;
  description: string;
}

export interface GetTypeActiviteRequest {
  id: string;
}

export interface GetTypeActiviteByCodeRequest {
  code: string;
}

export interface ListTypeActiviteRequest {
  pagination?: Pagination | undefined;
}

export interface ListTypeActiviteResponse {
  types: TypeActivite[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteTypeActiviteRequest {
  id: string;
}

export interface Activite {
  id: string;
  typeId: string;
  dateActivite: string;
  sujet: string;
  commentaire: string;
  echeance: string;
  clientBaseId: string;
  contratId: string;
  clientPartenaireId: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateActiviteRequest {
  typeId: string;
  dateActivite: string;
  sujet: string;
  commentaire: string;
  echeance: string;
  clientBaseId: string;
  contratId: string;
  clientPartenaireId: string;
}

export interface UpdateActiviteRequest {
  id: string;
  typeId: string;
  dateActivite: string;
  sujet: string;
  commentaire: string;
  echeance: string;
}

export interface GetActiviteRequest {
  id: string;
}

export interface ListActiviteByClientRequest {
  clientBaseId: string;
  pagination?: Pagination | undefined;
}

export interface ListActiviteByContratRequest {
  contratId: string;
  pagination?: Pagination | undefined;
}

export interface ListActiviteRequest {
  search: string;
  typeId: string;
  pagination?: Pagination | undefined;
}

export interface ListActiviteResponse {
  activites: Activite[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteActiviteRequest {
  id: string;
}

export interface Tache {
  id: string;
  organisationId: string;
  titre: string;
  description: string;
  type: string;
  priorite: string;
  statut: string;
  dateEcheance: string;
  dateCompletion: string;
  assigneA: string;
  creePar: string;
  clientId: string;
  contratId: string;
  factureId: string;
  regleRelanceId: string;
  metadata: string;
  enRetard: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface TacheStats {
  aFaire: number;
  enCours: number;
  terminee: number;
  annulee: number;
  enRetard: number;
  total: number;
}

export interface TacheAlertes {
  enRetard: Tache[];
  echeanceDemain: Tache[];
}

export interface CreateTacheRequest {
  organisationId: string;
  titre: string;
  description: string;
  type: string;
  priorite: string;
  dateEcheance: string;
  assigneA: string;
  creePar: string;
  clientId: string;
  contratId: string;
  factureId: string;
  regleRelanceId: string;
  metadata: string;
}

export interface UpdateTacheRequest {
  id: string;
  titre: string;
  description: string;
  type: string;
  priorite: string;
  statut: string;
  dateEcheance: string;
  assigneA: string;
  clientId: string;
  contratId: string;
  factureId: string;
  metadata: string;
}

export interface GetTacheRequest {
  id: string;
}

export interface ListTacheRequest {
  organisationId: string;
  statut: string;
  type: string;
  priorite: string;
  search: string;
  enRetard: boolean;
  pagination?: Pagination | undefined;
}

export interface ListTacheByAssigneRequest {
  assigneA: string;
  periode: string;
  pagination?: Pagination | undefined;
}

export interface ListTacheByClientRequest {
  clientId: string;
  pagination?: Pagination | undefined;
}

export interface ListTacheByContratRequest {
  contratId: string;
  pagination?: Pagination | undefined;
}

export interface ListTacheByFactureRequest {
  factureId: string;
  pagination?: Pagination | undefined;
}

export interface ListTacheEnRetardRequest {
  organisationId: string;
  pagination?: Pagination | undefined;
}

export interface GetTacheStatsRequest {
  organisationId: string;
}

export interface GetTacheAlertesRequest {
  organisationId: string;
}

export interface MarquerTacheRequest {
  id: string;
}

export interface ListTacheResponse {
  taches: Tache[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteTacheRequest {
  id: string;
}

export interface EvenementSuivi {
  id: string;
  expeditionId: string;
  code: string;
  label: string;
  dateEvenement: string;
  lieu: string;
  raw: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateEvenementSuiviRequest {
  expeditionId: string;
  code: string;
  label: string;
  dateEvenement: string;
  lieu: string;
  raw: string;
}

export interface UpdateEvenementSuiviRequest {
  id: string;
  code: string;
  label: string;
  dateEvenement: string;
  lieu: string;
  raw: string;
}

export interface GetEvenementSuiviRequest {
  id: string;
}

export interface ListEvenementByExpeditionRequest {
  expeditionId: string;
  pagination?: Pagination | undefined;
}

export interface ListEvenementSuiviRequest {
  search: string;
  pagination?: Pagination | undefined;
}

export interface ListEvenementSuiviResponse {
  evenements: EvenementSuivi[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteEvenementSuiviRequest {
  id: string;
}

/** ========== COMMON MESSAGES ========== */
export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
}

function createBaseTypeActivite(): TypeActivite {
  return { id: "", code: "", nom: "", description: "", createdAt: "", updatedAt: "" };
}

export const TypeActivite: MessageFns<TypeActivite> = {
  encode(message: TypeActivite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypeActivite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypeActivite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateTypeActiviteRequest(): CreateTypeActiviteRequest {
  return { code: "", nom: "", description: "" };
}

export const CreateTypeActiviteRequest: MessageFns<CreateTypeActiviteRequest> = {
  encode(message: CreateTypeActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTypeActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTypeActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateTypeActiviteRequest(): UpdateTypeActiviteRequest {
  return { id: "", code: "", nom: "", description: "" };
}

export const UpdateTypeActiviteRequest: MessageFns<UpdateTypeActiviteRequest> = {
  encode(message: UpdateTypeActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTypeActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTypeActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTypeActiviteRequest(): GetTypeActiviteRequest {
  return { id: "" };
}

export const GetTypeActiviteRequest: MessageFns<GetTypeActiviteRequest> = {
  encode(message: GetTypeActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTypeActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTypeActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTypeActiviteByCodeRequest(): GetTypeActiviteByCodeRequest {
  return { code: "" };
}

export const GetTypeActiviteByCodeRequest: MessageFns<GetTypeActiviteByCodeRequest> = {
  encode(message: GetTypeActiviteByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTypeActiviteByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTypeActiviteByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTypeActiviteRequest(): ListTypeActiviteRequest {
  return {};
}

export const ListTypeActiviteRequest: MessageFns<ListTypeActiviteRequest> = {
  encode(message: ListTypeActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTypeActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTypeActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTypeActiviteResponse(): ListTypeActiviteResponse {
  return { types: [] };
}

export const ListTypeActiviteResponse: MessageFns<ListTypeActiviteResponse> = {
  encode(message: ListTypeActiviteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.types) {
      TypeActivite.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTypeActiviteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTypeActiviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.types.push(TypeActivite.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteTypeActiviteRequest(): DeleteTypeActiviteRequest {
  return { id: "" };
}

export const DeleteTypeActiviteRequest: MessageFns<DeleteTypeActiviteRequest> = {
  encode(message: DeleteTypeActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTypeActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTypeActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseActivite(): Activite {
  return {
    id: "",
    typeId: "",
    dateActivite: "",
    sujet: "",
    commentaire: "",
    echeance: "",
    clientBaseId: "",
    contratId: "",
    clientPartenaireId: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Activite: MessageFns<Activite> = {
  encode(message: Activite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.typeId !== "") {
      writer.uint32(18).string(message.typeId);
    }
    if (message.dateActivite !== "") {
      writer.uint32(26).string(message.dateActivite);
    }
    if (message.sujet !== "") {
      writer.uint32(34).string(message.sujet);
    }
    if (message.commentaire !== "") {
      writer.uint32(42).string(message.commentaire);
    }
    if (message.echeance !== "") {
      writer.uint32(50).string(message.echeance);
    }
    if (message.clientBaseId !== "") {
      writer.uint32(58).string(message.clientBaseId);
    }
    if (message.contratId !== "") {
      writer.uint32(66).string(message.contratId);
    }
    if (message.clientPartenaireId !== "") {
      writer.uint32(74).string(message.clientPartenaireId);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Activite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dateActivite = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sujet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.echeance = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clientPartenaireId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateActiviteRequest(): CreateActiviteRequest {
  return {
    typeId: "",
    dateActivite: "",
    sujet: "",
    commentaire: "",
    echeance: "",
    clientBaseId: "",
    contratId: "",
    clientPartenaireId: "",
  };
}

export const CreateActiviteRequest: MessageFns<CreateActiviteRequest> = {
  encode(message: CreateActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeId !== "") {
      writer.uint32(10).string(message.typeId);
    }
    if (message.dateActivite !== "") {
      writer.uint32(18).string(message.dateActivite);
    }
    if (message.sujet !== "") {
      writer.uint32(26).string(message.sujet);
    }
    if (message.commentaire !== "") {
      writer.uint32(34).string(message.commentaire);
    }
    if (message.echeance !== "") {
      writer.uint32(42).string(message.echeance);
    }
    if (message.clientBaseId !== "") {
      writer.uint32(50).string(message.clientBaseId);
    }
    if (message.contratId !== "") {
      writer.uint32(58).string(message.contratId);
    }
    if (message.clientPartenaireId !== "") {
      writer.uint32(66).string(message.clientPartenaireId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.typeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dateActivite = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sujet = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.echeance = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clientPartenaireId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateActiviteRequest(): UpdateActiviteRequest {
  return { id: "", typeId: "", dateActivite: "", sujet: "", commentaire: "", echeance: "" };
}

export const UpdateActiviteRequest: MessageFns<UpdateActiviteRequest> = {
  encode(message: UpdateActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.typeId !== "") {
      writer.uint32(18).string(message.typeId);
    }
    if (message.dateActivite !== "") {
      writer.uint32(26).string(message.dateActivite);
    }
    if (message.sujet !== "") {
      writer.uint32(34).string(message.sujet);
    }
    if (message.commentaire !== "") {
      writer.uint32(42).string(message.commentaire);
    }
    if (message.echeance !== "") {
      writer.uint32(50).string(message.echeance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dateActivite = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sujet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.echeance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetActiviteRequest(): GetActiviteRequest {
  return { id: "" };
}

export const GetActiviteRequest: MessageFns<GetActiviteRequest> = {
  encode(message: GetActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListActiviteByClientRequest(): ListActiviteByClientRequest {
  return { clientBaseId: "" };
}

export const ListActiviteByClientRequest: MessageFns<ListActiviteByClientRequest> = {
  encode(message: ListActiviteByClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientBaseId !== "") {
      writer.uint32(10).string(message.clientBaseId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiviteByClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiviteByClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListActiviteByContratRequest(): ListActiviteByContratRequest {
  return { contratId: "" };
}

export const ListActiviteByContratRequest: MessageFns<ListActiviteByContratRequest> = {
  encode(message: ListActiviteByContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiviteByContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiviteByContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListActiviteRequest(): ListActiviteRequest {
  return { search: "", typeId: "" };
}

export const ListActiviteRequest: MessageFns<ListActiviteRequest> = {
  encode(message: ListActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.typeId !== "") {
      writer.uint32(18).string(message.typeId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListActiviteResponse(): ListActiviteResponse {
  return { activites: [] };
}

export const ListActiviteResponse: MessageFns<ListActiviteResponse> = {
  encode(message: ListActiviteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.activites) {
      Activite.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListActiviteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListActiviteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.activites.push(Activite.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteActiviteRequest(): DeleteActiviteRequest {
  return { id: "" };
}

export const DeleteActiviteRequest: MessageFns<DeleteActiviteRequest> = {
  encode(message: DeleteActiviteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteActiviteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteActiviteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTache(): Tache {
  return {
    id: "",
    organisationId: "",
    titre: "",
    description: "",
    type: "",
    priorite: "",
    statut: "",
    dateEcheance: "",
    dateCompletion: "",
    assigneA: "",
    creePar: "",
    clientId: "",
    contratId: "",
    factureId: "",
    regleRelanceId: "",
    metadata: "",
    enRetard: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Tache: MessageFns<Tache> = {
  encode(message: Tache, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.titre !== "") {
      writer.uint32(26).string(message.titre);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.priorite !== "") {
      writer.uint32(50).string(message.priorite);
    }
    if (message.statut !== "") {
      writer.uint32(58).string(message.statut);
    }
    if (message.dateEcheance !== "") {
      writer.uint32(66).string(message.dateEcheance);
    }
    if (message.dateCompletion !== "") {
      writer.uint32(74).string(message.dateCompletion);
    }
    if (message.assigneA !== "") {
      writer.uint32(82).string(message.assigneA);
    }
    if (message.creePar !== "") {
      writer.uint32(90).string(message.creePar);
    }
    if (message.clientId !== "") {
      writer.uint32(98).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(106).string(message.contratId);
    }
    if (message.factureId !== "") {
      writer.uint32(114).string(message.factureId);
    }
    if (message.regleRelanceId !== "") {
      writer.uint32(122).string(message.regleRelanceId);
    }
    if (message.metadata !== "") {
      writer.uint32(130).string(message.metadata);
    }
    if (message.enRetard !== false) {
      writer.uint32(136).bool(message.enRetard);
    }
    if (message.createdAt !== "") {
      writer.uint32(146).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(154).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tache {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTache();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.priorite = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.statut = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateEcheance = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dateCompletion = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.assigneA = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.creePar = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.regleRelanceId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.enRetard = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTacheStats(): TacheStats {
  return { aFaire: 0, enCours: 0, terminee: 0, annulee: 0, enRetard: 0, total: 0 };
}

export const TacheStats: MessageFns<TacheStats> = {
  encode(message: TacheStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aFaire !== 0) {
      writer.uint32(8).int32(message.aFaire);
    }
    if (message.enCours !== 0) {
      writer.uint32(16).int32(message.enCours);
    }
    if (message.terminee !== 0) {
      writer.uint32(24).int32(message.terminee);
    }
    if (message.annulee !== 0) {
      writer.uint32(32).int32(message.annulee);
    }
    if (message.enRetard !== 0) {
      writer.uint32(40).int32(message.enRetard);
    }
    if (message.total !== 0) {
      writer.uint32(48).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TacheStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTacheStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.aFaire = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enCours = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.terminee = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.annulee = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enRetard = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTacheAlertes(): TacheAlertes {
  return { enRetard: [], echeanceDemain: [] };
}

export const TacheAlertes: MessageFns<TacheAlertes> = {
  encode(message: TacheAlertes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.enRetard) {
      Tache.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.echeanceDemain) {
      Tache.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TacheAlertes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTacheAlertes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enRetard.push(Tache.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.echeanceDemain.push(Tache.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateTacheRequest(): CreateTacheRequest {
  return {
    organisationId: "",
    titre: "",
    description: "",
    type: "",
    priorite: "",
    dateEcheance: "",
    assigneA: "",
    creePar: "",
    clientId: "",
    contratId: "",
    factureId: "",
    regleRelanceId: "",
    metadata: "",
  };
}

export const CreateTacheRequest: MessageFns<CreateTacheRequest> = {
  encode(message: CreateTacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.titre !== "") {
      writer.uint32(18).string(message.titre);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.priorite !== "") {
      writer.uint32(42).string(message.priorite);
    }
    if (message.dateEcheance !== "") {
      writer.uint32(50).string(message.dateEcheance);
    }
    if (message.assigneA !== "") {
      writer.uint32(58).string(message.assigneA);
    }
    if (message.creePar !== "") {
      writer.uint32(66).string(message.creePar);
    }
    if (message.clientId !== "") {
      writer.uint32(74).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(82).string(message.contratId);
    }
    if (message.factureId !== "") {
      writer.uint32(90).string(message.factureId);
    }
    if (message.regleRelanceId !== "") {
      writer.uint32(98).string(message.regleRelanceId);
    }
    if (message.metadata !== "") {
      writer.uint32(106).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.priorite = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dateEcheance = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.assigneA = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.creePar = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.regleRelanceId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateTacheRequest(): UpdateTacheRequest {
  return {
    id: "",
    titre: "",
    description: "",
    type: "",
    priorite: "",
    statut: "",
    dateEcheance: "",
    assigneA: "",
    clientId: "",
    contratId: "",
    factureId: "",
    metadata: "",
  };
}

export const UpdateTacheRequest: MessageFns<UpdateTacheRequest> = {
  encode(message: UpdateTacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.titre !== "") {
      writer.uint32(18).string(message.titre);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.priorite !== "") {
      writer.uint32(42).string(message.priorite);
    }
    if (message.statut !== "") {
      writer.uint32(50).string(message.statut);
    }
    if (message.dateEcheance !== "") {
      writer.uint32(58).string(message.dateEcheance);
    }
    if (message.assigneA !== "") {
      writer.uint32(66).string(message.assigneA);
    }
    if (message.clientId !== "") {
      writer.uint32(74).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(82).string(message.contratId);
    }
    if (message.factureId !== "") {
      writer.uint32(90).string(message.factureId);
    }
    if (message.metadata !== "") {
      writer.uint32(98).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.priorite = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.statut = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateEcheance = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.assigneA = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTacheRequest(): GetTacheRequest {
  return { id: "" };
}

export const GetTacheRequest: MessageFns<GetTacheRequest> = {
  encode(message: GetTacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTacheRequest(): ListTacheRequest {
  return { organisationId: "", statut: "", type: "", priorite: "", search: "", enRetard: false };
}

export const ListTacheRequest: MessageFns<ListTacheRequest> = {
  encode(message: ListTacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.statut !== "") {
      writer.uint32(18).string(message.statut);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.priorite !== "") {
      writer.uint32(34).string(message.priorite);
    }
    if (message.search !== "") {
      writer.uint32(42).string(message.search);
    }
    if (message.enRetard !== false) {
      writer.uint32(48).bool(message.enRetard);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statut = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.priorite = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.enRetard = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTacheByAssigneRequest(): ListTacheByAssigneRequest {
  return { assigneA: "", periode: "" };
}

export const ListTacheByAssigneRequest: MessageFns<ListTacheByAssigneRequest> = {
  encode(message: ListTacheByAssigneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assigneA !== "") {
      writer.uint32(10).string(message.assigneA);
    }
    if (message.periode !== "") {
      writer.uint32(18).string(message.periode);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTacheByAssigneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTacheByAssigneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assigneA = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTacheByClientRequest(): ListTacheByClientRequest {
  return { clientId: "" };
}

export const ListTacheByClientRequest: MessageFns<ListTacheByClientRequest> = {
  encode(message: ListTacheByClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTacheByClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTacheByClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTacheByContratRequest(): ListTacheByContratRequest {
  return { contratId: "" };
}

export const ListTacheByContratRequest: MessageFns<ListTacheByContratRequest> = {
  encode(message: ListTacheByContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTacheByContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTacheByContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTacheByFactureRequest(): ListTacheByFactureRequest {
  return { factureId: "" };
}

export const ListTacheByFactureRequest: MessageFns<ListTacheByFactureRequest> = {
  encode(message: ListTacheByFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.factureId !== "") {
      writer.uint32(10).string(message.factureId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTacheByFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTacheByFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTacheEnRetardRequest(): ListTacheEnRetardRequest {
  return { organisationId: "" };
}

export const ListTacheEnRetardRequest: MessageFns<ListTacheEnRetardRequest> = {
  encode(message: ListTacheEnRetardRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTacheEnRetardRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTacheEnRetardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTacheStatsRequest(): GetTacheStatsRequest {
  return { organisationId: "" };
}

export const GetTacheStatsRequest: MessageFns<GetTacheStatsRequest> = {
  encode(message: GetTacheStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTacheStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTacheStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTacheAlertesRequest(): GetTacheAlertesRequest {
  return { organisationId: "" };
}

export const GetTacheAlertesRequest: MessageFns<GetTacheAlertesRequest> = {
  encode(message: GetTacheAlertesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTacheAlertesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTacheAlertesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMarquerTacheRequest(): MarquerTacheRequest {
  return { id: "" };
}

export const MarquerTacheRequest: MessageFns<MarquerTacheRequest> = {
  encode(message: MarquerTacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarquerTacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarquerTacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTacheResponse(): ListTacheResponse {
  return { taches: [] };
}

export const ListTacheResponse: MessageFns<ListTacheResponse> = {
  encode(message: ListTacheResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.taches) {
      Tache.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTacheResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTacheResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taches.push(Tache.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteTacheRequest(): DeleteTacheRequest {
  return { id: "" };
}

export const DeleteTacheRequest: MessageFns<DeleteTacheRequest> = {
  encode(message: DeleteTacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEvenementSuivi(): EvenementSuivi {
  return {
    id: "",
    expeditionId: "",
    code: "",
    label: "",
    dateEvenement: "",
    lieu: "",
    raw: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const EvenementSuivi: MessageFns<EvenementSuivi> = {
  encode(message: EvenementSuivi, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.expeditionId !== "") {
      writer.uint32(18).string(message.expeditionId);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(42).string(message.dateEvenement);
    }
    if (message.lieu !== "") {
      writer.uint32(50).string(message.lieu);
    }
    if (message.raw !== "") {
      writer.uint32(58).string(message.raw);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvenementSuivi {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvenementSuivi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lieu = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.raw = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateEvenementSuiviRequest(): CreateEvenementSuiviRequest {
  return { expeditionId: "", code: "", label: "", dateEvenement: "", lieu: "", raw: "" };
}

export const CreateEvenementSuiviRequest: MessageFns<CreateEvenementSuiviRequest> = {
  encode(message: CreateEvenementSuiviRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expeditionId !== "") {
      writer.uint32(10).string(message.expeditionId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(34).string(message.dateEvenement);
    }
    if (message.lieu !== "") {
      writer.uint32(42).string(message.lieu);
    }
    if (message.raw !== "") {
      writer.uint32(50).string(message.raw);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEvenementSuiviRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEvenementSuiviRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lieu = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.raw = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateEvenementSuiviRequest(): UpdateEvenementSuiviRequest {
  return { id: "", code: "", label: "", dateEvenement: "", lieu: "", raw: "" };
}

export const UpdateEvenementSuiviRequest: MessageFns<UpdateEvenementSuiviRequest> = {
  encode(message: UpdateEvenementSuiviRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(34).string(message.dateEvenement);
    }
    if (message.lieu !== "") {
      writer.uint32(42).string(message.lieu);
    }
    if (message.raw !== "") {
      writer.uint32(50).string(message.raw);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEvenementSuiviRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEvenementSuiviRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lieu = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.raw = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetEvenementSuiviRequest(): GetEvenementSuiviRequest {
  return { id: "" };
}

export const GetEvenementSuiviRequest: MessageFns<GetEvenementSuiviRequest> = {
  encode(message: GetEvenementSuiviRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEvenementSuiviRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEvenementSuiviRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListEvenementByExpeditionRequest(): ListEvenementByExpeditionRequest {
  return { expeditionId: "" };
}

export const ListEvenementByExpeditionRequest: MessageFns<ListEvenementByExpeditionRequest> = {
  encode(message: ListEvenementByExpeditionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expeditionId !== "") {
      writer.uint32(10).string(message.expeditionId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEvenementByExpeditionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvenementByExpeditionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListEvenementSuiviRequest(): ListEvenementSuiviRequest {
  return { search: "" };
}

export const ListEvenementSuiviRequest: MessageFns<ListEvenementSuiviRequest> = {
  encode(message: ListEvenementSuiviRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEvenementSuiviRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvenementSuiviRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListEvenementSuiviResponse(): ListEvenementSuiviResponse {
  return { evenements: [] };
}

export const ListEvenementSuiviResponse: MessageFns<ListEvenementSuiviResponse> = {
  encode(message: ListEvenementSuiviResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.evenements) {
      EvenementSuivi.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEvenementSuiviResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEvenementSuiviResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evenements.push(EvenementSuivi.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteEvenementSuiviRequest(): DeleteEvenementSuiviRequest {
  return { id: "" };
}

export const DeleteEvenementSuiviRequest: MessageFns<DeleteEvenementSuiviRequest> = {
  encode(message: DeleteEvenementSuiviRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEvenementSuiviRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEvenementSuiviRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ========== TYPE ACTIVITE SERVICE ========== */

export interface TypeActiviteServiceClient {
  create(request: CreateTypeActiviteRequest, metadata?: Metadata): Observable<TypeActivite>;

  update(request: UpdateTypeActiviteRequest, metadata?: Metadata): Observable<TypeActivite>;

  get(request: GetTypeActiviteRequest, metadata?: Metadata): Observable<TypeActivite>;

  getByCode(request: GetTypeActiviteByCodeRequest, metadata?: Metadata): Observable<TypeActivite>;

  list(request: ListTypeActiviteRequest, metadata?: Metadata): Observable<ListTypeActiviteResponse>;

  delete(request: DeleteTypeActiviteRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== TYPE ACTIVITE SERVICE ========== */

export interface TypeActiviteServiceController {
  create(
    request: CreateTypeActiviteRequest,
    metadata?: Metadata,
  ): Promise<TypeActivite> | Observable<TypeActivite> | TypeActivite;

  update(
    request: UpdateTypeActiviteRequest,
    metadata?: Metadata,
  ): Promise<TypeActivite> | Observable<TypeActivite> | TypeActivite;

  get(
    request: GetTypeActiviteRequest,
    metadata?: Metadata,
  ): Promise<TypeActivite> | Observable<TypeActivite> | TypeActivite;

  getByCode(
    request: GetTypeActiviteByCodeRequest,
    metadata?: Metadata,
  ): Promise<TypeActivite> | Observable<TypeActivite> | TypeActivite;

  list(
    request: ListTypeActiviteRequest,
    metadata?: Metadata,
  ): Promise<ListTypeActiviteResponse> | Observable<ListTypeActiviteResponse> | ListTypeActiviteResponse;

  delete(
    request: DeleteTypeActiviteRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function TypeActiviteServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("TypeActiviteService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("TypeActiviteService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const TYPE_ACTIVITE_SERVICE_NAME = "TypeActiviteService";

/** ========== TYPE ACTIVITE SERVICE ========== */
export type TypeActiviteServiceService = typeof TypeActiviteServiceService;
export const TypeActiviteServiceService = {
  create: {
    path: "/activites.TypeActiviteService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTypeActiviteRequest): Buffer =>
      Buffer.from(CreateTypeActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateTypeActiviteRequest => CreateTypeActiviteRequest.decode(value),
    responseSerialize: (value: TypeActivite): Buffer => Buffer.from(TypeActivite.encode(value).finish()),
    responseDeserialize: (value: Buffer): TypeActivite => TypeActivite.decode(value),
  },
  update: {
    path: "/activites.TypeActiviteService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateTypeActiviteRequest): Buffer =>
      Buffer.from(UpdateTypeActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateTypeActiviteRequest => UpdateTypeActiviteRequest.decode(value),
    responseSerialize: (value: TypeActivite): Buffer => Buffer.from(TypeActivite.encode(value).finish()),
    responseDeserialize: (value: Buffer): TypeActivite => TypeActivite.decode(value),
  },
  get: {
    path: "/activites.TypeActiviteService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTypeActiviteRequest): Buffer =>
      Buffer.from(GetTypeActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTypeActiviteRequest => GetTypeActiviteRequest.decode(value),
    responseSerialize: (value: TypeActivite): Buffer => Buffer.from(TypeActivite.encode(value).finish()),
    responseDeserialize: (value: Buffer): TypeActivite => TypeActivite.decode(value),
  },
  getByCode: {
    path: "/activites.TypeActiviteService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTypeActiviteByCodeRequest): Buffer =>
      Buffer.from(GetTypeActiviteByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTypeActiviteByCodeRequest => GetTypeActiviteByCodeRequest.decode(value),
    responseSerialize: (value: TypeActivite): Buffer => Buffer.from(TypeActivite.encode(value).finish()),
    responseDeserialize: (value: Buffer): TypeActivite => TypeActivite.decode(value),
  },
  list: {
    path: "/activites.TypeActiviteService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTypeActiviteRequest): Buffer =>
      Buffer.from(ListTypeActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTypeActiviteRequest => ListTypeActiviteRequest.decode(value),
    responseSerialize: (value: ListTypeActiviteResponse): Buffer =>
      Buffer.from(ListTypeActiviteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTypeActiviteResponse => ListTypeActiviteResponse.decode(value),
  },
  delete: {
    path: "/activites.TypeActiviteService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteTypeActiviteRequest): Buffer =>
      Buffer.from(DeleteTypeActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteTypeActiviteRequest => DeleteTypeActiviteRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface TypeActiviteServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateTypeActiviteRequest, TypeActivite>;
  update: handleUnaryCall<UpdateTypeActiviteRequest, TypeActivite>;
  get: handleUnaryCall<GetTypeActiviteRequest, TypeActivite>;
  getByCode: handleUnaryCall<GetTypeActiviteByCodeRequest, TypeActivite>;
  list: handleUnaryCall<ListTypeActiviteRequest, ListTypeActiviteResponse>;
  delete: handleUnaryCall<DeleteTypeActiviteRequest, DeleteResponse>;
}

/** ========== ACTIVITE SERVICE ========== */

export interface ActiviteServiceClient {
  create(request: CreateActiviteRequest, metadata?: Metadata): Observable<Activite>;

  update(request: UpdateActiviteRequest, metadata?: Metadata): Observable<Activite>;

  get(request: GetActiviteRequest, metadata?: Metadata): Observable<Activite>;

  listByClient(request: ListActiviteByClientRequest, metadata?: Metadata): Observable<ListActiviteResponse>;

  listByContrat(request: ListActiviteByContratRequest, metadata?: Metadata): Observable<ListActiviteResponse>;

  list(request: ListActiviteRequest, metadata?: Metadata): Observable<ListActiviteResponse>;

  delete(request: DeleteActiviteRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== ACTIVITE SERVICE ========== */

export interface ActiviteServiceController {
  create(request: CreateActiviteRequest, metadata?: Metadata): Promise<Activite> | Observable<Activite> | Activite;

  update(request: UpdateActiviteRequest, metadata?: Metadata): Promise<Activite> | Observable<Activite> | Activite;

  get(request: GetActiviteRequest, metadata?: Metadata): Promise<Activite> | Observable<Activite> | Activite;

  listByClient(
    request: ListActiviteByClientRequest,
    metadata?: Metadata,
  ): Promise<ListActiviteResponse> | Observable<ListActiviteResponse> | ListActiviteResponse;

  listByContrat(
    request: ListActiviteByContratRequest,
    metadata?: Metadata,
  ): Promise<ListActiviteResponse> | Observable<ListActiviteResponse> | ListActiviteResponse;

  list(
    request: ListActiviteRequest,
    metadata?: Metadata,
  ): Promise<ListActiviteResponse> | Observable<ListActiviteResponse> | ListActiviteResponse;

  delete(
    request: DeleteActiviteRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function ActiviteServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "listByClient", "listByContrat", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ActiviteService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ActiviteService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ACTIVITE_SERVICE_NAME = "ActiviteService";

/** ========== ACTIVITE SERVICE ========== */
export type ActiviteServiceService = typeof ActiviteServiceService;
export const ActiviteServiceService = {
  create: {
    path: "/activites.ActiviteService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateActiviteRequest): Buffer =>
      Buffer.from(CreateActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateActiviteRequest => CreateActiviteRequest.decode(value),
    responseSerialize: (value: Activite): Buffer => Buffer.from(Activite.encode(value).finish()),
    responseDeserialize: (value: Buffer): Activite => Activite.decode(value),
  },
  update: {
    path: "/activites.ActiviteService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateActiviteRequest): Buffer =>
      Buffer.from(UpdateActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateActiviteRequest => UpdateActiviteRequest.decode(value),
    responseSerialize: (value: Activite): Buffer => Buffer.from(Activite.encode(value).finish()),
    responseDeserialize: (value: Buffer): Activite => Activite.decode(value),
  },
  get: {
    path: "/activites.ActiviteService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetActiviteRequest): Buffer => Buffer.from(GetActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetActiviteRequest => GetActiviteRequest.decode(value),
    responseSerialize: (value: Activite): Buffer => Buffer.from(Activite.encode(value).finish()),
    responseDeserialize: (value: Buffer): Activite => Activite.decode(value),
  },
  listByClient: {
    path: "/activites.ActiviteService/ListByClient",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListActiviteByClientRequest): Buffer =>
      Buffer.from(ListActiviteByClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListActiviteByClientRequest => ListActiviteByClientRequest.decode(value),
    responseSerialize: (value: ListActiviteResponse): Buffer =>
      Buffer.from(ListActiviteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListActiviteResponse => ListActiviteResponse.decode(value),
  },
  listByContrat: {
    path: "/activites.ActiviteService/ListByContrat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListActiviteByContratRequest): Buffer =>
      Buffer.from(ListActiviteByContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListActiviteByContratRequest => ListActiviteByContratRequest.decode(value),
    responseSerialize: (value: ListActiviteResponse): Buffer =>
      Buffer.from(ListActiviteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListActiviteResponse => ListActiviteResponse.decode(value),
  },
  list: {
    path: "/activites.ActiviteService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListActiviteRequest): Buffer => Buffer.from(ListActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListActiviteRequest => ListActiviteRequest.decode(value),
    responseSerialize: (value: ListActiviteResponse): Buffer =>
      Buffer.from(ListActiviteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListActiviteResponse => ListActiviteResponse.decode(value),
  },
  delete: {
    path: "/activites.ActiviteService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteActiviteRequest): Buffer =>
      Buffer.from(DeleteActiviteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteActiviteRequest => DeleteActiviteRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface ActiviteServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateActiviteRequest, Activite>;
  update: handleUnaryCall<UpdateActiviteRequest, Activite>;
  get: handleUnaryCall<GetActiviteRequest, Activite>;
  listByClient: handleUnaryCall<ListActiviteByClientRequest, ListActiviteResponse>;
  listByContrat: handleUnaryCall<ListActiviteByContratRequest, ListActiviteResponse>;
  list: handleUnaryCall<ListActiviteRequest, ListActiviteResponse>;
  delete: handleUnaryCall<DeleteActiviteRequest, DeleteResponse>;
}

/** ========== TACHE SERVICE ========== */

export interface TacheServiceClient {
  create(request: CreateTacheRequest, metadata?: Metadata): Observable<Tache>;

  update(request: UpdateTacheRequest, metadata?: Metadata): Observable<Tache>;

  get(request: GetTacheRequest, metadata?: Metadata): Observable<Tache>;

  list(request: ListTacheRequest, metadata?: Metadata): Observable<ListTacheResponse>;

  listByAssigne(request: ListTacheByAssigneRequest, metadata?: Metadata): Observable<ListTacheResponse>;

  listByClient(request: ListTacheByClientRequest, metadata?: Metadata): Observable<ListTacheResponse>;

  listByContrat(request: ListTacheByContratRequest, metadata?: Metadata): Observable<ListTacheResponse>;

  listByFacture(request: ListTacheByFactureRequest, metadata?: Metadata): Observable<ListTacheResponse>;

  listEnRetard(request: ListTacheEnRetardRequest, metadata?: Metadata): Observable<ListTacheResponse>;

  getStats(request: GetTacheStatsRequest, metadata?: Metadata): Observable<TacheStats>;

  getAlertes(request: GetTacheAlertesRequest, metadata?: Metadata): Observable<TacheAlertes>;

  marquerEnCours(request: MarquerTacheRequest, metadata?: Metadata): Observable<Tache>;

  marquerTerminee(request: MarquerTacheRequest, metadata?: Metadata): Observable<Tache>;

  marquerAnnulee(request: MarquerTacheRequest, metadata?: Metadata): Observable<Tache>;

  delete(request: DeleteTacheRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== TACHE SERVICE ========== */

export interface TacheServiceController {
  create(request: CreateTacheRequest, metadata?: Metadata): Promise<Tache> | Observable<Tache> | Tache;

  update(request: UpdateTacheRequest, metadata?: Metadata): Promise<Tache> | Observable<Tache> | Tache;

  get(request: GetTacheRequest, metadata?: Metadata): Promise<Tache> | Observable<Tache> | Tache;

  list(
    request: ListTacheRequest,
    metadata?: Metadata,
  ): Promise<ListTacheResponse> | Observable<ListTacheResponse> | ListTacheResponse;

  listByAssigne(
    request: ListTacheByAssigneRequest,
    metadata?: Metadata,
  ): Promise<ListTacheResponse> | Observable<ListTacheResponse> | ListTacheResponse;

  listByClient(
    request: ListTacheByClientRequest,
    metadata?: Metadata,
  ): Promise<ListTacheResponse> | Observable<ListTacheResponse> | ListTacheResponse;

  listByContrat(
    request: ListTacheByContratRequest,
    metadata?: Metadata,
  ): Promise<ListTacheResponse> | Observable<ListTacheResponse> | ListTacheResponse;

  listByFacture(
    request: ListTacheByFactureRequest,
    metadata?: Metadata,
  ): Promise<ListTacheResponse> | Observable<ListTacheResponse> | ListTacheResponse;

  listEnRetard(
    request: ListTacheEnRetardRequest,
    metadata?: Metadata,
  ): Promise<ListTacheResponse> | Observable<ListTacheResponse> | ListTacheResponse;

  getStats(
    request: GetTacheStatsRequest,
    metadata?: Metadata,
  ): Promise<TacheStats> | Observable<TacheStats> | TacheStats;

  getAlertes(
    request: GetTacheAlertesRequest,
    metadata?: Metadata,
  ): Promise<TacheAlertes> | Observable<TacheAlertes> | TacheAlertes;

  marquerEnCours(request: MarquerTacheRequest, metadata?: Metadata): Promise<Tache> | Observable<Tache> | Tache;

  marquerTerminee(request: MarquerTacheRequest, metadata?: Metadata): Promise<Tache> | Observable<Tache> | Tache;

  marquerAnnulee(request: MarquerTacheRequest, metadata?: Metadata): Promise<Tache> | Observable<Tache> | Tache;

  delete(
    request: DeleteTacheRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function TacheServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "create",
      "update",
      "get",
      "list",
      "listByAssigne",
      "listByClient",
      "listByContrat",
      "listByFacture",
      "listEnRetard",
      "getStats",
      "getAlertes",
      "marquerEnCours",
      "marquerTerminee",
      "marquerAnnulee",
      "delete",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("TacheService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("TacheService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const TACHE_SERVICE_NAME = "TacheService";

/** ========== TACHE SERVICE ========== */
export type TacheServiceService = typeof TacheServiceService;
export const TacheServiceService = {
  create: {
    path: "/activites.TacheService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTacheRequest): Buffer => Buffer.from(CreateTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateTacheRequest => CreateTacheRequest.decode(value),
    responseSerialize: (value: Tache): Buffer => Buffer.from(Tache.encode(value).finish()),
    responseDeserialize: (value: Buffer): Tache => Tache.decode(value),
  },
  update: {
    path: "/activites.TacheService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateTacheRequest): Buffer => Buffer.from(UpdateTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateTacheRequest => UpdateTacheRequest.decode(value),
    responseSerialize: (value: Tache): Buffer => Buffer.from(Tache.encode(value).finish()),
    responseDeserialize: (value: Buffer): Tache => Tache.decode(value),
  },
  get: {
    path: "/activites.TacheService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTacheRequest): Buffer => Buffer.from(GetTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTacheRequest => GetTacheRequest.decode(value),
    responseSerialize: (value: Tache): Buffer => Buffer.from(Tache.encode(value).finish()),
    responseDeserialize: (value: Buffer): Tache => Tache.decode(value),
  },
  list: {
    path: "/activites.TacheService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTacheRequest): Buffer => Buffer.from(ListTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTacheRequest => ListTacheRequest.decode(value),
    responseSerialize: (value: ListTacheResponse): Buffer => Buffer.from(ListTacheResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTacheResponse => ListTacheResponse.decode(value),
  },
  listByAssigne: {
    path: "/activites.TacheService/ListByAssigne",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTacheByAssigneRequest): Buffer =>
      Buffer.from(ListTacheByAssigneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTacheByAssigneRequest => ListTacheByAssigneRequest.decode(value),
    responseSerialize: (value: ListTacheResponse): Buffer => Buffer.from(ListTacheResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTacheResponse => ListTacheResponse.decode(value),
  },
  listByClient: {
    path: "/activites.TacheService/ListByClient",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTacheByClientRequest): Buffer =>
      Buffer.from(ListTacheByClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTacheByClientRequest => ListTacheByClientRequest.decode(value),
    responseSerialize: (value: ListTacheResponse): Buffer => Buffer.from(ListTacheResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTacheResponse => ListTacheResponse.decode(value),
  },
  listByContrat: {
    path: "/activites.TacheService/ListByContrat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTacheByContratRequest): Buffer =>
      Buffer.from(ListTacheByContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTacheByContratRequest => ListTacheByContratRequest.decode(value),
    responseSerialize: (value: ListTacheResponse): Buffer => Buffer.from(ListTacheResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTacheResponse => ListTacheResponse.decode(value),
  },
  listByFacture: {
    path: "/activites.TacheService/ListByFacture",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTacheByFactureRequest): Buffer =>
      Buffer.from(ListTacheByFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTacheByFactureRequest => ListTacheByFactureRequest.decode(value),
    responseSerialize: (value: ListTacheResponse): Buffer => Buffer.from(ListTacheResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTacheResponse => ListTacheResponse.decode(value),
  },
  listEnRetard: {
    path: "/activites.TacheService/ListEnRetard",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTacheEnRetardRequest): Buffer =>
      Buffer.from(ListTacheEnRetardRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTacheEnRetardRequest => ListTacheEnRetardRequest.decode(value),
    responseSerialize: (value: ListTacheResponse): Buffer => Buffer.from(ListTacheResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTacheResponse => ListTacheResponse.decode(value),
  },
  getStats: {
    path: "/activites.TacheService/GetStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTacheStatsRequest): Buffer => Buffer.from(GetTacheStatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTacheStatsRequest => GetTacheStatsRequest.decode(value),
    responseSerialize: (value: TacheStats): Buffer => Buffer.from(TacheStats.encode(value).finish()),
    responseDeserialize: (value: Buffer): TacheStats => TacheStats.decode(value),
  },
  getAlertes: {
    path: "/activites.TacheService/GetAlertes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTacheAlertesRequest): Buffer =>
      Buffer.from(GetTacheAlertesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTacheAlertesRequest => GetTacheAlertesRequest.decode(value),
    responseSerialize: (value: TacheAlertes): Buffer => Buffer.from(TacheAlertes.encode(value).finish()),
    responseDeserialize: (value: Buffer): TacheAlertes => TacheAlertes.decode(value),
  },
  marquerEnCours: {
    path: "/activites.TacheService/MarquerEnCours",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarquerTacheRequest): Buffer => Buffer.from(MarquerTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarquerTacheRequest => MarquerTacheRequest.decode(value),
    responseSerialize: (value: Tache): Buffer => Buffer.from(Tache.encode(value).finish()),
    responseDeserialize: (value: Buffer): Tache => Tache.decode(value),
  },
  marquerTerminee: {
    path: "/activites.TacheService/MarquerTerminee",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarquerTacheRequest): Buffer => Buffer.from(MarquerTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarquerTacheRequest => MarquerTacheRequest.decode(value),
    responseSerialize: (value: Tache): Buffer => Buffer.from(Tache.encode(value).finish()),
    responseDeserialize: (value: Buffer): Tache => Tache.decode(value),
  },
  marquerAnnulee: {
    path: "/activites.TacheService/MarquerAnnulee",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarquerTacheRequest): Buffer => Buffer.from(MarquerTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarquerTacheRequest => MarquerTacheRequest.decode(value),
    responseSerialize: (value: Tache): Buffer => Buffer.from(Tache.encode(value).finish()),
    responseDeserialize: (value: Buffer): Tache => Tache.decode(value),
  },
  delete: {
    path: "/activites.TacheService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteTacheRequest): Buffer => Buffer.from(DeleteTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteTacheRequest => DeleteTacheRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface TacheServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateTacheRequest, Tache>;
  update: handleUnaryCall<UpdateTacheRequest, Tache>;
  get: handleUnaryCall<GetTacheRequest, Tache>;
  list: handleUnaryCall<ListTacheRequest, ListTacheResponse>;
  listByAssigne: handleUnaryCall<ListTacheByAssigneRequest, ListTacheResponse>;
  listByClient: handleUnaryCall<ListTacheByClientRequest, ListTacheResponse>;
  listByContrat: handleUnaryCall<ListTacheByContratRequest, ListTacheResponse>;
  listByFacture: handleUnaryCall<ListTacheByFactureRequest, ListTacheResponse>;
  listEnRetard: handleUnaryCall<ListTacheEnRetardRequest, ListTacheResponse>;
  getStats: handleUnaryCall<GetTacheStatsRequest, TacheStats>;
  getAlertes: handleUnaryCall<GetTacheAlertesRequest, TacheAlertes>;
  marquerEnCours: handleUnaryCall<MarquerTacheRequest, Tache>;
  marquerTerminee: handleUnaryCall<MarquerTacheRequest, Tache>;
  marquerAnnulee: handleUnaryCall<MarquerTacheRequest, Tache>;
  delete: handleUnaryCall<DeleteTacheRequest, DeleteResponse>;
}

/** ========== EVENEMENT SUIVI SERVICE ========== */

export interface EvenementSuiviServiceClient {
  create(request: CreateEvenementSuiviRequest, metadata?: Metadata): Observable<EvenementSuivi>;

  update(request: UpdateEvenementSuiviRequest, metadata?: Metadata): Observable<EvenementSuivi>;

  get(request: GetEvenementSuiviRequest, metadata?: Metadata): Observable<EvenementSuivi>;

  listByExpedition(
    request: ListEvenementByExpeditionRequest,
    metadata?: Metadata,
  ): Observable<ListEvenementSuiviResponse>;

  list(request: ListEvenementSuiviRequest, metadata?: Metadata): Observable<ListEvenementSuiviResponse>;

  delete(request: DeleteEvenementSuiviRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== EVENEMENT SUIVI SERVICE ========== */

export interface EvenementSuiviServiceController {
  create(
    request: CreateEvenementSuiviRequest,
    metadata?: Metadata,
  ): Promise<EvenementSuivi> | Observable<EvenementSuivi> | EvenementSuivi;

  update(
    request: UpdateEvenementSuiviRequest,
    metadata?: Metadata,
  ): Promise<EvenementSuivi> | Observable<EvenementSuivi> | EvenementSuivi;

  get(
    request: GetEvenementSuiviRequest,
    metadata?: Metadata,
  ): Promise<EvenementSuivi> | Observable<EvenementSuivi> | EvenementSuivi;

  listByExpedition(
    request: ListEvenementByExpeditionRequest,
    metadata?: Metadata,
  ): Promise<ListEvenementSuiviResponse> | Observable<ListEvenementSuiviResponse> | ListEvenementSuiviResponse;

  list(
    request: ListEvenementSuiviRequest,
    metadata?: Metadata,
  ): Promise<ListEvenementSuiviResponse> | Observable<ListEvenementSuiviResponse> | ListEvenementSuiviResponse;

  delete(
    request: DeleteEvenementSuiviRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function EvenementSuiviServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "listByExpedition", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("EvenementSuiviService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("EvenementSuiviService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const EVENEMENT_SUIVI_SERVICE_NAME = "EvenementSuiviService";

/** ========== EVENEMENT SUIVI SERVICE ========== */
export type EvenementSuiviServiceService = typeof EvenementSuiviServiceService;
export const EvenementSuiviServiceService = {
  create: {
    path: "/activites.EvenementSuiviService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateEvenementSuiviRequest): Buffer =>
      Buffer.from(CreateEvenementSuiviRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateEvenementSuiviRequest => CreateEvenementSuiviRequest.decode(value),
    responseSerialize: (value: EvenementSuivi): Buffer => Buffer.from(EvenementSuivi.encode(value).finish()),
    responseDeserialize: (value: Buffer): EvenementSuivi => EvenementSuivi.decode(value),
  },
  update: {
    path: "/activites.EvenementSuiviService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEvenementSuiviRequest): Buffer =>
      Buffer.from(UpdateEvenementSuiviRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateEvenementSuiviRequest => UpdateEvenementSuiviRequest.decode(value),
    responseSerialize: (value: EvenementSuivi): Buffer => Buffer.from(EvenementSuivi.encode(value).finish()),
    responseDeserialize: (value: Buffer): EvenementSuivi => EvenementSuivi.decode(value),
  },
  get: {
    path: "/activites.EvenementSuiviService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEvenementSuiviRequest): Buffer =>
      Buffer.from(GetEvenementSuiviRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEvenementSuiviRequest => GetEvenementSuiviRequest.decode(value),
    responseSerialize: (value: EvenementSuivi): Buffer => Buffer.from(EvenementSuivi.encode(value).finish()),
    responseDeserialize: (value: Buffer): EvenementSuivi => EvenementSuivi.decode(value),
  },
  listByExpedition: {
    path: "/activites.EvenementSuiviService/ListByExpedition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListEvenementByExpeditionRequest): Buffer =>
      Buffer.from(ListEvenementByExpeditionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListEvenementByExpeditionRequest =>
      ListEvenementByExpeditionRequest.decode(value),
    responseSerialize: (value: ListEvenementSuiviResponse): Buffer =>
      Buffer.from(ListEvenementSuiviResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListEvenementSuiviResponse => ListEvenementSuiviResponse.decode(value),
  },
  list: {
    path: "/activites.EvenementSuiviService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListEvenementSuiviRequest): Buffer =>
      Buffer.from(ListEvenementSuiviRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListEvenementSuiviRequest => ListEvenementSuiviRequest.decode(value),
    responseSerialize: (value: ListEvenementSuiviResponse): Buffer =>
      Buffer.from(ListEvenementSuiviResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListEvenementSuiviResponse => ListEvenementSuiviResponse.decode(value),
  },
  delete: {
    path: "/activites.EvenementSuiviService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteEvenementSuiviRequest): Buffer =>
      Buffer.from(DeleteEvenementSuiviRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteEvenementSuiviRequest => DeleteEvenementSuiviRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface EvenementSuiviServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateEvenementSuiviRequest, EvenementSuivi>;
  update: handleUnaryCall<UpdateEvenementSuiviRequest, EvenementSuivi>;
  get: handleUnaryCall<GetEvenementSuiviRequest, EvenementSuivi>;
  listByExpedition: handleUnaryCall<ListEvenementByExpeditionRequest, ListEvenementSuiviResponse>;
  list: handleUnaryCall<ListEvenementSuiviRequest, ListEvenementSuiviResponse>;
  delete: handleUnaryCall<DeleteEvenementSuiviRequest, DeleteResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
