// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: calendar/calendar.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

/**
 * Définition des lots de prélèvement (fenêtres d'émission)
 * L1 = Semaine 1 du mois (jours 1-7)
 * L2 = Semaine 2 du mois (jours 8-14)
 * L3 = Semaine 3 du mois (jours 15-21)
 * L4 = Semaine 4 du mois (jours 22-fin)
 */
export enum DebitBatch {
  DEBIT_BATCH_UNSPECIFIED = 0,
  /** DEBIT_BATCH_L1 - Semaine 1: jours 1-7 */
  DEBIT_BATCH_L1 = 1,
  /** DEBIT_BATCH_L2 - Semaine 2: jours 8-14 */
  DEBIT_BATCH_L2 = 2,
  /** DEBIT_BATCH_L3 - Semaine 3: jours 15-21 */
  DEBIT_BATCH_L3 = 3,
  /** DEBIT_BATCH_L4 - Semaine 4: jours 22-fin du mois */
  DEBIT_BATCH_L4 = 4,
}

/** Mode de calcul de la date de prélèvement */
export enum DebitDateMode {
  DEBIT_DATE_MODE_UNSPECIFIED = 0,
  /** DEBIT_DATE_MODE_BATCH - Utilise le lot L1-L4 (premier jour ouvré du lot) */
  DEBIT_DATE_MODE_BATCH = 1,
  /** DEBIT_DATE_MODE_FIXED_DAY - Utilise un jour fixe du mois (ex: le 5) */
  DEBIT_DATE_MODE_FIXED_DAY = 2,
}

/** Stratégie de report si date non éligible (weekend/férié) */
export enum DateShiftStrategy {
  DATE_SHIFT_STRATEGY_UNSPECIFIED = 0,
  /** DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY - Reporter au prochain jour ouvré */
  DATE_SHIFT_STRATEGY_NEXT_BUSINESS_DAY = 1,
  /** DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY - Anticiper au jour ouvré précédent */
  DATE_SHIFT_STRATEGY_PREVIOUS_BUSINESS_DAY = 2,
  /** DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY - Reporter à la semaine suivante, même jour */
  DATE_SHIFT_STRATEGY_NEXT_WEEK_SAME_DAY = 3,
}

/** Niveau de configuration (pour la priorité) */
export enum ConfigurationLevel {
  CONFIGURATION_LEVEL_UNSPECIFIED = 0,
  /** CONFIGURATION_LEVEL_SYSTEM_DEFAULT - Priorité la plus basse */
  CONFIGURATION_LEVEL_SYSTEM_DEFAULT = 1,
  /** CONFIGURATION_LEVEL_COMPANY - Niveau société */
  CONFIGURATION_LEVEL_COMPANY = 2,
  /** CONFIGURATION_LEVEL_CLIENT - Niveau client */
  CONFIGURATION_LEVEL_CLIENT = 3,
  /** CONFIGURATION_LEVEL_CONTRACT - Priorité la plus haute */
  CONFIGURATION_LEVEL_CONTRACT = 4,
}

/** Statut d'une date planifiée */
export enum PlannedDateStatus {
  PLANNED_DATE_STATUS_UNSPECIFIED = 0,
  /** PLANNED_DATE_STATUS_PLANNED - Date calculée, en attente */
  PLANNED_DATE_STATUS_PLANNED = 1,
  /** PLANNED_DATE_STATUS_CONFIRMED - Date confirmée pour émission */
  PLANNED_DATE_STATUS_CONFIRMED = 2,
  /** PLANNED_DATE_STATUS_PROCESSING - En cours de traitement */
  PLANNED_DATE_STATUS_PROCESSING = 3,
  /** PLANNED_DATE_STATUS_EXECUTED - Prélèvement exécuté */
  PLANNED_DATE_STATUS_EXECUTED = 4,
  /** PLANNED_DATE_STATUS_FAILED - Échec du prélèvement */
  PLANNED_DATE_STATUS_FAILED = 5,
  /** PLANNED_DATE_STATUS_CANCELLED - Annulé */
  PLANNED_DATE_STATUS_CANCELLED = 6,
}

/** Type de jour férié */
export enum HolidayType {
  HOLIDAY_TYPE_UNSPECIFIED = 0,
  /** HOLIDAY_TYPE_PUBLIC - Jour férié légal */
  HOLIDAY_TYPE_PUBLIC = 1,
  /** HOLIDAY_TYPE_BANK - Jour de fermeture bancaire */
  HOLIDAY_TYPE_BANK = 2,
  /** HOLIDAY_TYPE_REGIONAL - Jour férié régional */
  HOLIDAY_TYPE_REGIONAL = 3,
  /** HOLIDAY_TYPE_COMPANY - Jour de fermeture société */
  HOLIDAY_TYPE_COMPANY = 4,
}

/** Source de modification pour audit */
export enum AuditSource {
  AUDIT_SOURCE_UNSPECIFIED = 0,
  /** AUDIT_SOURCE_UI - Interface admin */
  AUDIT_SOURCE_UI = 1,
  /** AUDIT_SOURCE_CSV_IMPORT - Import CSV */
  AUDIT_SOURCE_CSV_IMPORT = 2,
  /** AUDIT_SOURCE_API - Appel API */
  AUDIT_SOURCE_API = 3,
  /** AUDIT_SOURCE_SYSTEM - Calcul automatique système */
  AUDIT_SOURCE_SYSTEM = 4,
}

/** Configuration des jours fériés par zone/pays */
export interface HolidayZone {
  id: string;
  organisationId: string;
  /** Ex: "FR", "FR-ALS" (Alsace), "DE", "BE" */
  code: string;
  /** Ex: "France", "Alsace-Moselle" */
  name: string;
  /** ISO 3166-1 alpha-2: "FR", "DE", "BE" */
  countryCode: string;
  /** Code région optionnel (ex: "ALS", "IDF") */
  regionCode: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Jour férié individuel */
export interface Holiday {
  id: string;
  holidayZoneId: string;
  /** Format ISO: "2026-01-01" */
  date: string;
  /** Ex: "Jour de l'An", "Lundi de Pâques" */
  name: string;
  holidayType: HolidayType;
  /** True si récurrent chaque année (même jour/mois) */
  isRecurring: boolean;
  /** 1-12 si récurrent */
  recurringMonth: number;
  /** 1-31 si récurrent */
  recurringDay: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration du cutoff horaire */
export interface CutoffConfiguration {
  id: string;
  organisationId: string;
  /** Ex: "Cutoff SEPA Standard" */
  name: string;
  /** Format HH:mm en timezone locale, ex: "14:00" */
  cutoffTime: string;
  /** Ex: "Europe/Paris" */
  timezone: string;
  /** J-X avant la date de valeur (ex: 2 pour SEPA) */
  daysBeforeValueDate: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot par défaut système */
export interface SystemDebitConfiguration {
  id: string;
  organisationId: string;
  defaultMode: DebitDateMode;
  /** Si mode = BATCH */
  defaultBatch: DebitBatch;
  /** Si mode = FIXED_DAY (1-28) */
  defaultFixedDay: number;
  shiftStrategy: DateShiftStrategy;
  /** Zone de jours fériés par défaut */
  holidayZoneId: string;
  /** Configuration cutoff par défaut */
  cutoffConfigId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau société */
export interface CompanyDebitConfiguration {
  id: string;
  organisationId: string;
  societeId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau client */
export interface ClientDebitConfiguration {
  id: string;
  organisationId: string;
  clientId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration de lot au niveau contrat (priorité maximale) */
export interface ContractDebitConfiguration {
  id: string;
  organisationId: string;
  contratId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Configuration résolue (après application de la priorité) */
export interface ResolvedDebitConfiguration {
  /** Niveau qui a été appliqué */
  appliedLevel: ConfigurationLevel;
  /** ID de la config appliquée */
  appliedConfigId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

/** Entrée pour le calcul de date de prélèvement */
export interface CalculatePlannedDateRequest {
  organisationId: string;
  /** Optionnel - si fourni, utilise config contrat */
  contratId: string;
  /** Optionnel - si fourni, utilise config client */
  clientId: string;
  /** Optionnel - si fourni, utilise config société */
  societeId: string;
  /** Date de référence pour le calcul (ISO format) */
  referenceDate: string;
  /** Mois cible (1-12) */
  targetMonth: number;
  /** Année cible */
  targetYear: number;
  /** Inclure le détail de la résolution */
  includeResolutionTrace: boolean;
}

/** Résultat du calcul de date de prélèvement */
export interface CalculatePlannedDateResponse {
  /** Date calculée (ISO format) */
  plannedDebitDate: string;
  /** Date cible avant ajustement */
  originalTargetDate: string;
  /** True si la date a été décalée */
  wasShifted: boolean;
  /** Raison du décalage (weekend, férié, etc.) */
  shiftReason: string;
  resolvedConfig?:
    | ResolvedDebitConfiguration
    | undefined;
  /** Trace de résolution si demandée */
  resolutionTrace: DateResolutionStep[];
}

/** Étape de résolution de date (pour debug/audit) */
export interface DateResolutionStep {
  stepOrder: number;
  description: string;
  inputDate: string;
  outputDate: string;
  appliedRule: string;
}

/** Calcul en lot pour plusieurs entités */
export interface CalculatePlannedDatesBatchRequest {
  organisationId: string;
  inputs: PlannedDateCalculationInput[];
  targetMonth: number;
  targetYear: number;
}

export interface PlannedDateCalculationInput {
  contratId: string;
  clientId: string;
  societeId: string;
  /** Montant en centimes */
  amountCents: number;
  currency: string;
}

export interface CalculatePlannedDatesBatchResponse {
  results: PlannedDateCalculationResult[];
  totalCount: number;
  successCount: number;
  errorCount: number;
}

export interface PlannedDateCalculationResult {
  contratId: string;
  success: boolean;
  plannedDebitDate: string;
  errorCode: string;
  errorMessage: string;
  resolvedConfig?: ResolvedDebitConfiguration | undefined;
}

/** Vérification d'éligibilité d'une date */
export interface CheckDateEligibilityRequest {
  organisationId: string;
  /** Date à vérifier (ISO format) */
  date: string;
  /** Zone de jours fériés */
  holidayZoneId: string;
}

export interface CheckDateEligibilityResponse {
  isEligible: boolean;
  isWeekend: boolean;
  isHoliday: boolean;
  /** Nom du jour férié si applicable */
  holidayName: string;
  /** Prochaine date éligible */
  nextEligibleDate: string;
  /** Date éligible précédente */
  previousEligibleDate: string;
}

/** Prélèvement planifié */
export interface PlannedDebit {
  id: string;
  organisationId: string;
  societeId: string;
  clientId: string;
  contratId: string;
  /** Référence vers payment.Schedule */
  scheduleId: string;
  /** Référence vers facture si applicable */
  factureId: string;
  /** Date de prélèvement planifiée */
  plannedDebitDate: string;
  /** Date cible avant ajustement */
  originalTargetDate: string;
  status: PlannedDateStatus;
  /** Lot assigné */
  batch: DebitBatch;
  /** Montant en centimes */
  amountCents: number;
  currency: string;
  resolvedConfig?: ResolvedDebitConfiguration | undefined;
  createdAt: string;
  updatedAt: string;
}

/** Volume agrégé par date/lot */
export interface DebitVolumeAggregate {
  /** Date (ISO format) */
  date: string;
  batch: DebitBatch;
  /** Optionnel, si agrégation par société */
  societeId: string;
  transactionCount: number;
  totalAmountCents: number;
  currency: string;
}

/** Prévision de volume (pour la heatmap) */
export interface VolumeForecast {
  id: string;
  organisationId: string;
  societeId: string;
  year: number;
  month: number;
  day: number;
  batch: DebitBatch;
  expectedTransactionCount: number;
  expectedAmountCents: number;
  currency: string;
  /** Rempli après exécution */
  actualTransactionCount: number;
  actualAmountCents: number;
  createdAt: string;
  updatedAt: string;
}

/** Seuil d'alerte pour les volumes */
export interface VolumeThreshold {
  id: string;
  organisationId: string;
  /** Optionnel */
  societeId: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

/** Requête d'import CSV (dry-run obligatoire) */
export interface ImportCsvRequest {
  organisationId: string;
  /** Contenu du fichier CSV */
  csvContent: Uint8Array;
  /** "DEBIT_CONFIG", "HOLIDAYS", "VOLUME_FORECAST" */
  importType: string;
  /** OBLIGATOIRE: true pour prévisualisation */
  dryRun: boolean;
  uploadedByUserId: string;
}

export interface ImportCsvResponse {
  importId: string;
  success: boolean;
  isDryRun: boolean;
  totalRows: number;
  validRows: number;
  errorRows: number;
  errors: CsvValidationError[];
  /** Aperçu des changements */
  preview: CsvImportPreview[];
}

export interface CsvValidationError {
  rowNumber: number;
  columnName: string;
  value: string;
  errorCode: string;
  errorMessage: string;
}

export interface CsvImportPreview {
  rowNumber: number;
  /** "CREATE", "UPDATE", "SKIP" */
  action: string;
  entityType: string;
  /** Existant si UPDATE */
  entityId: string;
  /** Données à importer */
  data: { [key: string]: string };
  /** Résumé des changements */
  changeSummary: string;
}

export interface CsvImportPreview_DataEntry {
  key: string;
  value: string;
}

/** Confirmation d'import (après dry-run) */
export interface ConfirmCsvImportRequest {
  importId: string;
  organisationId: string;
  confirmedByUserId: string;
}

export interface ConfirmCsvImportResponse {
  success: boolean;
  createdCount: number;
  updatedCount: number;
  skippedCount: number;
  auditLogId: string;
}

/** Entrée de log d'audit */
export interface CalendarAuditLog {
  id: string;
  organisationId: string;
  /** Type d'entité modifiée */
  entityType: string;
  /** ID de l'entité modifiée */
  entityId: string;
  /** "CREATE", "UPDATE", "DELETE" */
  action: string;
  /** Utilisateur ayant effectué l'action */
  actorUserId: string;
  /** Source de la modification */
  source: AuditSource;
  /** État avant (JSON) */
  beforeState: string;
  /** État après (JSON) */
  afterState: string;
  /** Résumé lisible des changements */
  changeSummary: string;
  ipAddress: string;
  userAgent: string;
  createdAt: string;
}

/** Requête de calendrier avec filtres */
export interface GetCalendarViewRequest {
  organisationId: string;
  /** Date début (ISO format) */
  startDate: string;
  /** Date fin (ISO format) */
  endDate: string;
  /** Filtrer par sociétés */
  societeIds: string[];
  /** Filtrer par lots */
  batches: DebitBatch[];
  /** Filtrer par statut */
  statuses: PlannedDateStatus[];
  /** Inclure les volumes agrégés */
  includeVolumes: boolean;
}

export interface GetCalendarViewResponse {
  days: CalendarDay[];
  volumes: DebitVolumeAggregate[];
}

export interface CalendarDay {
  date: string;
  isWeekend: boolean;
  isHoliday: boolean;
  holidayName: string;
  isEligible: boolean;
  debits: PlannedDebitSummary[];
}

export interface PlannedDebitSummary {
  id: string;
  contratId: string;
  clientName: string;
  amountCents: number;
  currency: string;
  status: PlannedDateStatus;
  batch: DebitBatch;
}

/** Requête drill-down (détail d'une date) */
export interface GetDateDetailsRequest {
  organisationId: string;
  date: string;
  societeId: string;
  batch: DebitBatch;
  pagination?: Pagination | undefined;
}

export interface GetDateDetailsResponse {
  debits: PlannedDebit[];
  pagination?: PaginationResult | undefined;
  aggregate?: DebitVolumeAggregate | undefined;
}

/** Requête heatmap */
export interface GetVolumeHeatmapRequest {
  organisationId: string;
  year: number;
  /** Optionnel, si non fourni: année entière */
  month: number;
  societeIds: string[];
  batches: DebitBatch[];
  includeForecast: boolean;
}

export interface GetVolumeHeatmapResponse {
  cells: HeatmapCell[];
  exceededThresholds: VolumeThreshold[];
}

export interface HeatmapCell {
  date: string;
  /** 0=Lundi, 6=Dimanche */
  dayOfWeek: number;
  weekOfMonth: number;
  transactionCount: number;
  totalAmountCents: number;
  currency: string;
  /** "LOW", "MEDIUM", "HIGH", "CRITICAL" */
  intensityLevel: string;
  exceedsThreshold: boolean;
  /** Prévision si demandée */
  forecast?: VolumeForecast | undefined;
}

/** Export CSV */
export interface ExportCalendarCsvRequest {
  organisationId: string;
  startDate: string;
  endDate: string;
  societeIds: string[];
  batches: DebitBatch[];
  /** "PLANNED_DEBITS", "VOLUMES", "HEATMAP" */
  exportType: string;
}

export interface ExportCalendarCsvResponse {
  csvContent: Uint8Array;
  filename: string;
  rowCount: number;
}

export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

/** System Config */
export interface GetSystemConfigRequest {
  organisationId: string;
}

export interface UpdateSystemConfigRequest {
  organisationId: string;
  defaultMode: DebitDateMode;
  defaultBatch: DebitBatch;
  defaultFixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

/** Company Config */
export interface CreateCompanyConfigRequest {
  organisationId: string;
  societeId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
}

export interface UpdateCompanyConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  cutoffConfigId: string;
  isActive: boolean;
}

export interface GetCompanyConfigRequest {
  id: string;
}

export interface ListCompanyConfigsRequest {
  organisationId: string;
  societeId: string;
  pagination?: Pagination | undefined;
}

export interface ListCompanyConfigsResponse {
  configs: CompanyDebitConfiguration[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteCompanyConfigRequest {
  id: string;
}

/** Client Config */
export interface CreateClientConfigRequest {
  organisationId: string;
  clientId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
}

export interface UpdateClientConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
}

export interface GetClientConfigRequest {
  id: string;
}

export interface ListClientConfigsRequest {
  organisationId: string;
  clientId: string;
  pagination?: Pagination | undefined;
}

export interface ListClientConfigsResponse {
  configs: ClientDebitConfiguration[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteClientConfigRequest {
  id: string;
}

/** Contract Config */
export interface CreateContractConfigRequest {
  organisationId: string;
  contratId: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
}

export interface UpdateContractConfigRequest {
  id: string;
  mode: DebitDateMode;
  batch: DebitBatch;
  fixedDay: number;
  shiftStrategy: DateShiftStrategy;
  holidayZoneId: string;
  isActive: boolean;
}

export interface GetContractConfigRequest {
  id: string;
}

export interface ListContractConfigsRequest {
  organisationId: string;
  contratId: string;
  pagination?: Pagination | undefined;
}

export interface ListContractConfigsResponse {
  configs: ContractDebitConfiguration[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteContractConfigRequest {
  id: string;
}

/** Resolve Configuration */
export interface ResolveConfigurationRequest {
  organisationId: string;
  contratId: string;
  clientId: string;
  societeId: string;
}

/** Holiday Zone CRUD */
export interface CreateHolidayZoneRequest {
  organisationId: string;
  code: string;
  name: string;
  countryCode: string;
  regionCode: string;
}

export interface UpdateHolidayZoneRequest {
  id: string;
  code: string;
  name: string;
  countryCode: string;
  regionCode: string;
  isActive: boolean;
}

export interface GetHolidayZoneRequest {
  id: string;
}

export interface ListHolidayZonesRequest {
  organisationId: string;
  countryCode: string;
  pagination?: Pagination | undefined;
}

export interface ListHolidayZonesResponse {
  zones: HolidayZone[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteHolidayZoneRequest {
  id: string;
}

/** Holiday CRUD */
export interface CreateHolidayRequest {
  holidayZoneId: string;
  date: string;
  name: string;
  holidayType: HolidayType;
  isRecurring: boolean;
  recurringMonth: number;
  recurringDay: number;
}

export interface UpdateHolidayRequest {
  id: string;
  date: string;
  name: string;
  holidayType: HolidayType;
  isRecurring: boolean;
  recurringMonth: number;
  recurringDay: number;
  isActive: boolean;
}

export interface GetHolidayRequest {
  id: string;
}

export interface ListHolidaysRequest {
  holidayZoneId: string;
  year: number;
  pagination?: Pagination | undefined;
}

export interface ListHolidaysResponse {
  holidays: Holiday[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteHolidayRequest {
  id: string;
}

export interface ImportHolidaysByCountryRequest {
  organisationId: string;
  countryCode: string;
  year: number;
  includeRegional: boolean;
}

export interface ImportHolidaysByCountryResponse {
  success: boolean;
  importedCount: number;
  holidayZoneId: string;
}

/** Volume Threshold CRUD */
export interface CreateVolumeThresholdRequest {
  organisationId: string;
  societeId: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
}

export interface UpdateVolumeThresholdRequest {
  id: string;
  maxTransactionCount: number;
  maxAmountCents: number;
  currency: string;
  alertOnExceed: boolean;
  alertEmail: string;
  isActive: boolean;
}

export interface GetVolumeThresholdRequest {
  id: string;
}

export interface ListVolumeThresholdsRequest {
  organisationId: string;
  societeId: string;
  pagination?: Pagination | undefined;
}

export interface ListVolumeThresholdsResponse {
  thresholds: VolumeThreshold[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteVolumeThresholdRequest {
  id: string;
}

/** Audit */
export interface GetAuditLogsRequest {
  organisationId: string;
  entityType: string;
  entityId: string;
  actorUserId: string;
  source: AuditSource;
  startDate: string;
  endDate: string;
  pagination?: Pagination | undefined;
}

export interface GetAuditLogsResponse {
  logs: CalendarAuditLog[];
  pagination?: PaginationResult | undefined;
}

function createBaseHolidayZone(): HolidayZone {
  return {
    id: "",
    organisationId: "",
    code: "",
    name: "",
    countryCode: "",
    regionCode: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const HolidayZone: MessageFns<HolidayZone> = {
  encode(message: HolidayZone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(42).string(message.countryCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(50).string(message.regionCode);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HolidayZone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHolidayZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHoliday(): Holiday {
  return {
    id: "",
    holidayZoneId: "",
    date: "",
    name: "",
    holidayType: 0,
    isRecurring: false,
    recurringMonth: 0,
    recurringDay: 0,
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Holiday: MessageFns<Holiday> = {
  encode(message: Holiday, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(18).string(message.holidayZoneId);
    }
    if (message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.holidayType !== 0) {
      writer.uint32(40).int32(message.holidayType);
    }
    if (message.isRecurring !== false) {
      writer.uint32(48).bool(message.isRecurring);
    }
    if (message.recurringMonth !== 0) {
      writer.uint32(56).int32(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      writer.uint32(64).int32(message.recurringDay);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Holiday {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHoliday();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.holidayType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isRecurring = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recurringMonth = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.recurringDay = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCutoffConfiguration(): CutoffConfiguration {
  return {
    id: "",
    organisationId: "",
    name: "",
    cutoffTime: "",
    timezone: "",
    daysBeforeValueDate: 0,
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const CutoffConfiguration: MessageFns<CutoffConfiguration> = {
  encode(message: CutoffConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(34).string(message.cutoffTime);
    }
    if (message.timezone !== "") {
      writer.uint32(42).string(message.timezone);
    }
    if (message.daysBeforeValueDate !== 0) {
      writer.uint32(48).int32(message.daysBeforeValueDate);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CutoffConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCutoffConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.daysBeforeValueDate = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSystemDebitConfiguration(): SystemDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    defaultMode: 0,
    defaultBatch: 0,
    defaultFixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const SystemDebitConfiguration: MessageFns<SystemDebitConfiguration> = {
  encode(message: SystemDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.defaultMode !== 0) {
      writer.uint32(24).int32(message.defaultMode);
    }
    if (message.defaultBatch !== 0) {
      writer.uint32(32).int32(message.defaultBatch);
    }
    if (message.defaultFixedDay !== 0) {
      writer.uint32(40).int32(message.defaultFixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(66).string(message.cutoffConfigId);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.defaultMode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.defaultBatch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.defaultFixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCompanyDebitConfiguration(): CompanyDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const CompanyDebitConfiguration: MessageFns<CompanyDebitConfiguration> = {
  encode(message: CompanyDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(40).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(48).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(56).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(66).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(74).string(message.cutoffConfigId);
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(90).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(98).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompanyDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseClientDebitConfiguration(): ClientDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    clientId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const ClientDebitConfiguration: MessageFns<ClientDebitConfiguration> = {
  encode(message: ClientDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(40).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(48).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(56).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(66).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseContractDebitConfiguration(): ContractDebitConfiguration {
  return {
    id: "",
    organisationId: "",
    contratId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const ContractDebitConfiguration: MessageFns<ContractDebitConfiguration> = {
  encode(message: ContractDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(26).string(message.contratId);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(40).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(48).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(56).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(66).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContractDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResolvedDebitConfiguration(): ResolvedDebitConfiguration {
  return {
    appliedLevel: 0,
    appliedConfigId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
  };
}

export const ResolvedDebitConfiguration: MessageFns<ResolvedDebitConfiguration> = {
  encode(message: ResolvedDebitConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appliedLevel !== 0) {
      writer.uint32(8).int32(message.appliedLevel);
    }
    if (message.appliedConfigId !== "") {
      writer.uint32(18).string(message.appliedConfigId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(66).string(message.cutoffConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolvedDebitConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolvedDebitConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appliedLevel = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appliedConfigId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculatePlannedDateRequest(): CalculatePlannedDateRequest {
  return {
    organisationId: "",
    contratId: "",
    clientId: "",
    societeId: "",
    referenceDate: "",
    targetMonth: 0,
    targetYear: 0,
    includeResolutionTrace: false,
  };
}

export const CalculatePlannedDateRequest: MessageFns<CalculatePlannedDateRequest> = {
  encode(message: CalculatePlannedDateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(34).string(message.societeId);
    }
    if (message.referenceDate !== "") {
      writer.uint32(42).string(message.referenceDate);
    }
    if (message.targetMonth !== 0) {
      writer.uint32(48).int32(message.targetMonth);
    }
    if (message.targetYear !== 0) {
      writer.uint32(56).int32(message.targetYear);
    }
    if (message.includeResolutionTrace !== false) {
      writer.uint32(64).bool(message.includeResolutionTrace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referenceDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.targetMonth = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.targetYear = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.includeResolutionTrace = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculatePlannedDateResponse(): CalculatePlannedDateResponse {
  return { plannedDebitDate: "", originalTargetDate: "", wasShifted: false, shiftReason: "", resolutionTrace: [] };
}

export const CalculatePlannedDateResponse: MessageFns<CalculatePlannedDateResponse> = {
  encode(message: CalculatePlannedDateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannedDebitDate !== "") {
      writer.uint32(10).string(message.plannedDebitDate);
    }
    if (message.originalTargetDate !== "") {
      writer.uint32(18).string(message.originalTargetDate);
    }
    if (message.wasShifted !== false) {
      writer.uint32(24).bool(message.wasShifted);
    }
    if (message.shiftReason !== "") {
      writer.uint32(34).string(message.shiftReason);
    }
    if (message.resolvedConfig !== undefined) {
      ResolvedDebitConfiguration.encode(message.resolvedConfig, writer.uint32(42).fork()).join();
    }
    for (const v of message.resolutionTrace) {
      DateResolutionStep.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plannedDebitDate = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originalTargetDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.wasShifted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.shiftReason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resolvedConfig = ResolvedDebitConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resolutionTrace.push(DateResolutionStep.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDateResolutionStep(): DateResolutionStep {
  return { stepOrder: 0, description: "", inputDate: "", outputDate: "", appliedRule: "" };
}

export const DateResolutionStep: MessageFns<DateResolutionStep> = {
  encode(message: DateResolutionStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepOrder !== 0) {
      writer.uint32(8).int32(message.stepOrder);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.inputDate !== "") {
      writer.uint32(26).string(message.inputDate);
    }
    if (message.outputDate !== "") {
      writer.uint32(34).string(message.outputDate);
    }
    if (message.appliedRule !== "") {
      writer.uint32(42).string(message.appliedRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateResolutionStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateResolutionStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stepOrder = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.appliedRule = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculatePlannedDatesBatchRequest(): CalculatePlannedDatesBatchRequest {
  return { organisationId: "", inputs: [], targetMonth: 0, targetYear: 0 };
}

export const CalculatePlannedDatesBatchRequest: MessageFns<CalculatePlannedDatesBatchRequest> = {
  encode(message: CalculatePlannedDatesBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    for (const v of message.inputs) {
      PlannedDateCalculationInput.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.targetMonth !== 0) {
      writer.uint32(24).int32(message.targetMonth);
    }
    if (message.targetYear !== 0) {
      writer.uint32(32).int32(message.targetYear);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDatesBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDatesBatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputs.push(PlannedDateCalculationInput.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetMonth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.targetYear = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlannedDateCalculationInput(): PlannedDateCalculationInput {
  return { contratId: "", clientId: "", societeId: "", amountCents: 0, currency: "" };
}

export const PlannedDateCalculationInput: MessageFns<PlannedDateCalculationInput> = {
  encode(message: PlannedDateCalculationInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDateCalculationInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDateCalculationInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculatePlannedDatesBatchResponse(): CalculatePlannedDatesBatchResponse {
  return { results: [], totalCount: 0, successCount: 0, errorCount: 0 };
}

export const CalculatePlannedDatesBatchResponse: MessageFns<CalculatePlannedDatesBatchResponse> = {
  encode(message: CalculatePlannedDatesBatchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      PlannedDateCalculationResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.successCount !== 0) {
      writer.uint32(24).int32(message.successCount);
    }
    if (message.errorCount !== 0) {
      writer.uint32(32).int32(message.errorCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePlannedDatesBatchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePlannedDatesBatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(PlannedDateCalculationResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlannedDateCalculationResult(): PlannedDateCalculationResult {
  return { contratId: "", success: false, plannedDebitDate: "", errorCode: "", errorMessage: "" };
}

export const PlannedDateCalculationResult: MessageFns<PlannedDateCalculationResult> = {
  encode(message: PlannedDateCalculationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.plannedDebitDate !== "") {
      writer.uint32(26).string(message.plannedDebitDate);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    if (message.resolvedConfig !== undefined) {
      ResolvedDebitConfiguration.encode(message.resolvedConfig, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDateCalculationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDateCalculationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.plannedDebitDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resolvedConfig = ResolvedDebitConfiguration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckDateEligibilityRequest(): CheckDateEligibilityRequest {
  return { organisationId: "", date: "", holidayZoneId: "" };
}

export const CheckDateEligibilityRequest: MessageFns<CheckDateEligibilityRequest> = {
  encode(message: CheckDateEligibilityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(26).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckDateEligibilityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckDateEligibilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckDateEligibilityResponse(): CheckDateEligibilityResponse {
  return {
    isEligible: false,
    isWeekend: false,
    isHoliday: false,
    holidayName: "",
    nextEligibleDate: "",
    previousEligibleDate: "",
  };
}

export const CheckDateEligibilityResponse: MessageFns<CheckDateEligibilityResponse> = {
  encode(message: CheckDateEligibilityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isEligible !== false) {
      writer.uint32(8).bool(message.isEligible);
    }
    if (message.isWeekend !== false) {
      writer.uint32(16).bool(message.isWeekend);
    }
    if (message.isHoliday !== false) {
      writer.uint32(24).bool(message.isHoliday);
    }
    if (message.holidayName !== "") {
      writer.uint32(34).string(message.holidayName);
    }
    if (message.nextEligibleDate !== "") {
      writer.uint32(42).string(message.nextEligibleDate);
    }
    if (message.previousEligibleDate !== "") {
      writer.uint32(50).string(message.previousEligibleDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckDateEligibilityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckDateEligibilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isEligible = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isWeekend = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isHoliday = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.holidayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nextEligibleDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.previousEligibleDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlannedDebit(): PlannedDebit {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    clientId: "",
    contratId: "",
    scheduleId: "",
    factureId: "",
    plannedDebitDate: "",
    originalTargetDate: "",
    status: 0,
    batch: 0,
    amountCents: 0,
    currency: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const PlannedDebit: MessageFns<PlannedDebit> = {
  encode(message: PlannedDebit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.clientId !== "") {
      writer.uint32(34).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(42).string(message.contratId);
    }
    if (message.scheduleId !== "") {
      writer.uint32(50).string(message.scheduleId);
    }
    if (message.factureId !== "") {
      writer.uint32(58).string(message.factureId);
    }
    if (message.plannedDebitDate !== "") {
      writer.uint32(66).string(message.plannedDebitDate);
    }
    if (message.originalTargetDate !== "") {
      writer.uint32(74).string(message.originalTargetDate);
    }
    if (message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    if (message.batch !== 0) {
      writer.uint32(88).int32(message.batch);
    }
    if (message.amountCents !== 0) {
      writer.uint32(96).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(106).string(message.currency);
    }
    if (message.resolvedConfig !== undefined) {
      ResolvedDebitConfiguration.encode(message.resolvedConfig, writer.uint32(114).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDebit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDebit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.plannedDebitDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.originalTargetDate = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.resolvedConfig = ResolvedDebitConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDebitVolumeAggregate(): DebitVolumeAggregate {
  return { date: "", batch: 0, societeId: "", transactionCount: 0, totalAmountCents: 0, currency: "" };
}

export const DebitVolumeAggregate: MessageFns<DebitVolumeAggregate> = {
  encode(message: DebitVolumeAggregate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.batch !== 0) {
      writer.uint32(16).int32(message.batch);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.transactionCount !== 0) {
      writer.uint32(32).int32(message.transactionCount);
    }
    if (message.totalAmountCents !== 0) {
      writer.uint32(40).int64(message.totalAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebitVolumeAggregate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebitVolumeAggregate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.transactionCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVolumeForecast(): VolumeForecast {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    year: 0,
    month: 0,
    day: 0,
    batch: 0,
    expectedTransactionCount: 0,
    expectedAmountCents: 0,
    currency: "",
    actualTransactionCount: 0,
    actualAmountCents: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const VolumeForecast: MessageFns<VolumeForecast> = {
  encode(message: VolumeForecast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.year !== 0) {
      writer.uint32(32).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(40).int32(message.month);
    }
    if (message.day !== 0) {
      writer.uint32(48).int32(message.day);
    }
    if (message.batch !== 0) {
      writer.uint32(56).int32(message.batch);
    }
    if (message.expectedTransactionCount !== 0) {
      writer.uint32(64).int32(message.expectedTransactionCount);
    }
    if (message.expectedAmountCents !== 0) {
      writer.uint32(72).int64(message.expectedAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(82).string(message.currency);
    }
    if (message.actualTransactionCount !== 0) {
      writer.uint32(88).int32(message.actualTransactionCount);
    }
    if (message.actualAmountCents !== 0) {
      writer.uint32(96).int64(message.actualAmountCents);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeForecast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeForecast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.month = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.day = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.expectedTransactionCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expectedAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.actualTransactionCount = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.actualAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVolumeThreshold(): VolumeThreshold {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    maxTransactionCount: 0,
    maxAmountCents: 0,
    currency: "",
    alertOnExceed: false,
    alertEmail: "",
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const VolumeThreshold: MessageFns<VolumeThreshold> = {
  encode(message: VolumeThreshold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.maxTransactionCount !== 0) {
      writer.uint32(32).int32(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      writer.uint32(40).int64(message.maxAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.alertOnExceed !== false) {
      writer.uint32(56).bool(message.alertOnExceed);
    }
    if (message.alertEmail !== "") {
      writer.uint32(66).string(message.alertEmail);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeThreshold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxTransactionCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.alertOnExceed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.alertEmail = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImportCsvRequest(): ImportCsvRequest {
  return { organisationId: "", csvContent: new Uint8Array(0), importType: "", dryRun: false, uploadedByUserId: "" };
}

export const ImportCsvRequest: MessageFns<ImportCsvRequest> = {
  encode(message: ImportCsvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.csvContent.length !== 0) {
      writer.uint32(18).bytes(message.csvContent);
    }
    if (message.importType !== "") {
      writer.uint32(26).string(message.importType);
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    if (message.uploadedByUserId !== "") {
      writer.uint32(42).string(message.uploadedByUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportCsvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportCsvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.csvContent = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.importType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.uploadedByUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImportCsvResponse(): ImportCsvResponse {
  return {
    importId: "",
    success: false,
    isDryRun: false,
    totalRows: 0,
    validRows: 0,
    errorRows: 0,
    errors: [],
    preview: [],
  };
}

export const ImportCsvResponse: MessageFns<ImportCsvResponse> = {
  encode(message: ImportCsvResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importId !== "") {
      writer.uint32(10).string(message.importId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.isDryRun !== false) {
      writer.uint32(24).bool(message.isDryRun);
    }
    if (message.totalRows !== 0) {
      writer.uint32(32).int32(message.totalRows);
    }
    if (message.validRows !== 0) {
      writer.uint32(40).int32(message.validRows);
    }
    if (message.errorRows !== 0) {
      writer.uint32(48).int32(message.errorRows);
    }
    for (const v of message.errors) {
      CsvValidationError.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.preview) {
      CsvImportPreview.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportCsvResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportCsvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isDryRun = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalRows = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validRows = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.errorRows = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.errors.push(CsvValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.preview.push(CsvImportPreview.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCsvValidationError(): CsvValidationError {
  return { rowNumber: 0, columnName: "", value: "", errorCode: "", errorMessage: "" };
}

export const CsvValidationError: MessageFns<CsvValidationError> = {
  encode(message: CsvValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rowNumber !== 0) {
      writer.uint32(8).int32(message.rowNumber);
    }
    if (message.columnName !== "") {
      writer.uint32(18).string(message.columnName);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CsvValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsvValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.columnName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCsvImportPreview(): CsvImportPreview {
  return { rowNumber: 0, action: "", entityType: "", entityId: "", data: {}, changeSummary: "" };
}

export const CsvImportPreview: MessageFns<CsvImportPreview> = {
  encode(message: CsvImportPreview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rowNumber !== 0) {
      writer.uint32(8).int32(message.rowNumber);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    globalThis.Object.entries(message.data).forEach(([key, value]: [string, string]) => {
      CsvImportPreview_DataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.changeSummary !== "") {
      writer.uint32(50).string(message.changeSummary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CsvImportPreview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsvImportPreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.rowNumber = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = CsvImportPreview_DataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.data[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.changeSummary = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCsvImportPreview_DataEntry(): CsvImportPreview_DataEntry {
  return { key: "", value: "" };
}

export const CsvImportPreview_DataEntry: MessageFns<CsvImportPreview_DataEntry> = {
  encode(message: CsvImportPreview_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CsvImportPreview_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCsvImportPreview_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseConfirmCsvImportRequest(): ConfirmCsvImportRequest {
  return { importId: "", organisationId: "", confirmedByUserId: "" };
}

export const ConfirmCsvImportRequest: MessageFns<ConfirmCsvImportRequest> = {
  encode(message: ConfirmCsvImportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importId !== "") {
      writer.uint32(10).string(message.importId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.confirmedByUserId !== "") {
      writer.uint32(26).string(message.confirmedByUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfirmCsvImportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmCsvImportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.importId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.confirmedByUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseConfirmCsvImportResponse(): ConfirmCsvImportResponse {
  return { success: false, createdCount: 0, updatedCount: 0, skippedCount: 0, auditLogId: "" };
}

export const ConfirmCsvImportResponse: MessageFns<ConfirmCsvImportResponse> = {
  encode(message: ConfirmCsvImportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.createdCount !== 0) {
      writer.uint32(16).int32(message.createdCount);
    }
    if (message.updatedCount !== 0) {
      writer.uint32(24).int32(message.updatedCount);
    }
    if (message.skippedCount !== 0) {
      writer.uint32(32).int32(message.skippedCount);
    }
    if (message.auditLogId !== "") {
      writer.uint32(42).string(message.auditLogId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfirmCsvImportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmCsvImportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.createdCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.updatedCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skippedCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.auditLogId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalendarAuditLog(): CalendarAuditLog {
  return {
    id: "",
    organisationId: "",
    entityType: "",
    entityId: "",
    action: "",
    actorUserId: "",
    source: 0,
    beforeState: "",
    afterState: "",
    changeSummary: "",
    ipAddress: "",
    userAgent: "",
    createdAt: "",
  };
}

export const CalendarAuditLog: MessageFns<CalendarAuditLog> = {
  encode(message: CalendarAuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.actorUserId !== "") {
      writer.uint32(50).string(message.actorUserId);
    }
    if (message.source !== 0) {
      writer.uint32(56).int32(message.source);
    }
    if (message.beforeState !== "") {
      writer.uint32(66).string(message.beforeState);
    }
    if (message.afterState !== "") {
      writer.uint32(74).string(message.afterState);
    }
    if (message.changeSummary !== "") {
      writer.uint32(82).string(message.changeSummary);
    }
    if (message.ipAddress !== "") {
      writer.uint32(90).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(98).string(message.userAgent);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalendarAuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalendarAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actorUserId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.beforeState = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.afterState = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.changeSummary = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCalendarViewRequest(): GetCalendarViewRequest {
  return {
    organisationId: "",
    startDate: "",
    endDate: "",
    societeIds: [],
    batches: [],
    statuses: [],
    includeVolumes: false,
  };
}

export const GetCalendarViewRequest: MessageFns<GetCalendarViewRequest> = {
  encode(message: GetCalendarViewRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.startDate !== "") {
      writer.uint32(18).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(26).string(message.endDate);
    }
    for (const v of message.societeIds) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.batches) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeVolumes !== false) {
      writer.uint32(56).bool(message.includeVolumes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCalendarViewRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCalendarViewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.batches.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.batches.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag === 48) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.includeVolumes = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCalendarViewResponse(): GetCalendarViewResponse {
  return { days: [], volumes: [] };
}

export const GetCalendarViewResponse: MessageFns<GetCalendarViewResponse> = {
  encode(message: GetCalendarViewResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.days) {
      CalendarDay.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.volumes) {
      DebitVolumeAggregate.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCalendarViewResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCalendarViewResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.days.push(CalendarDay.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.volumes.push(DebitVolumeAggregate.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalendarDay(): CalendarDay {
  return { date: "", isWeekend: false, isHoliday: false, holidayName: "", isEligible: false, debits: [] };
}

export const CalendarDay: MessageFns<CalendarDay> = {
  encode(message: CalendarDay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.isWeekend !== false) {
      writer.uint32(16).bool(message.isWeekend);
    }
    if (message.isHoliday !== false) {
      writer.uint32(24).bool(message.isHoliday);
    }
    if (message.holidayName !== "") {
      writer.uint32(34).string(message.holidayName);
    }
    if (message.isEligible !== false) {
      writer.uint32(40).bool(message.isEligible);
    }
    for (const v of message.debits) {
      PlannedDebitSummary.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalendarDay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalendarDay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isWeekend = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isHoliday = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.holidayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isEligible = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.debits.push(PlannedDebitSummary.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlannedDebitSummary(): PlannedDebitSummary {
  return { id: "", contratId: "", clientName: "", amountCents: 0, currency: "", status: 0, batch: 0 };
}

export const PlannedDebitSummary: MessageFns<PlannedDebitSummary> = {
  encode(message: PlannedDebitSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.clientName !== "") {
      writer.uint32(26).string(message.clientName);
    }
    if (message.amountCents !== 0) {
      writer.uint32(32).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.batch !== 0) {
      writer.uint32(56).int32(message.batch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlannedDebitSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlannedDebitSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetDateDetailsRequest(): GetDateDetailsRequest {
  return { organisationId: "", date: "", societeId: "", batch: 0 };
}

export const GetDateDetailsRequest: MessageFns<GetDateDetailsRequest> = {
  encode(message: GetDateDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDateDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDateDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetDateDetailsResponse(): GetDateDetailsResponse {
  return { debits: [] };
}

export const GetDateDetailsResponse: MessageFns<GetDateDetailsResponse> = {
  encode(message: GetDateDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.debits) {
      PlannedDebit.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.aggregate !== undefined) {
      DebitVolumeAggregate.encode(message.aggregate, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDateDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDateDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.debits.push(PlannedDebit.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aggregate = DebitVolumeAggregate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetVolumeHeatmapRequest(): GetVolumeHeatmapRequest {
  return { organisationId: "", year: 0, month: 0, societeIds: [], batches: [], includeForecast: false };
}

export const GetVolumeHeatmapRequest: MessageFns<GetVolumeHeatmapRequest> = {
  encode(message: GetVolumeHeatmapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    if (message.month !== 0) {
      writer.uint32(24).int32(message.month);
    }
    for (const v of message.societeIds) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.batches) {
      writer.int32(v);
    }
    writer.join();
    if (message.includeForecast !== false) {
      writer.uint32(48).bool(message.includeForecast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeHeatmapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeHeatmapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.month = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.batches.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.batches.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.includeForecast = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetVolumeHeatmapResponse(): GetVolumeHeatmapResponse {
  return { cells: [], exceededThresholds: [] };
}

export const GetVolumeHeatmapResponse: MessageFns<GetVolumeHeatmapResponse> = {
  encode(message: GetVolumeHeatmapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      HeatmapCell.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.exceededThresholds) {
      VolumeThreshold.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeHeatmapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeHeatmapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cells.push(HeatmapCell.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exceededThresholds.push(VolumeThreshold.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHeatmapCell(): HeatmapCell {
  return {
    date: "",
    dayOfWeek: 0,
    weekOfMonth: 0,
    transactionCount: 0,
    totalAmountCents: 0,
    currency: "",
    intensityLevel: "",
    exceedsThreshold: false,
  };
}

export const HeatmapCell: MessageFns<HeatmapCell> = {
  encode(message: HeatmapCell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(16).int32(message.dayOfWeek);
    }
    if (message.weekOfMonth !== 0) {
      writer.uint32(24).int32(message.weekOfMonth);
    }
    if (message.transactionCount !== 0) {
      writer.uint32(32).int32(message.transactionCount);
    }
    if (message.totalAmountCents !== 0) {
      writer.uint32(40).int64(message.totalAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.intensityLevel !== "") {
      writer.uint32(58).string(message.intensityLevel);
    }
    if (message.exceedsThreshold !== false) {
      writer.uint32(64).bool(message.exceedsThreshold);
    }
    if (message.forecast !== undefined) {
      VolumeForecast.encode(message.forecast, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeatmapCell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeatmapCell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dayOfWeek = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.weekOfMonth = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.transactionCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.intensityLevel = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.exceedsThreshold = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.forecast = VolumeForecast.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExportCalendarCsvRequest(): ExportCalendarCsvRequest {
  return { organisationId: "", startDate: "", endDate: "", societeIds: [], batches: [], exportType: "" };
}

export const ExportCalendarCsvRequest: MessageFns<ExportCalendarCsvRequest> = {
  encode(message: ExportCalendarCsvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.startDate !== "") {
      writer.uint32(18).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(26).string(message.endDate);
    }
    for (const v of message.societeIds) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.batches) {
      writer.int32(v);
    }
    writer.join();
    if (message.exportType !== "") {
      writer.uint32(50).string(message.exportType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportCalendarCsvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportCalendarCsvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.batches.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.batches.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.exportType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExportCalendarCsvResponse(): ExportCalendarCsvResponse {
  return { csvContent: new Uint8Array(0), filename: "", rowCount: 0 };
}

export const ExportCalendarCsvResponse: MessageFns<ExportCalendarCsvResponse> = {
  encode(message: ExportCalendarCsvResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.csvContent.length !== 0) {
      writer.uint32(10).bytes(message.csvContent);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    if (message.rowCount !== 0) {
      writer.uint32(24).int32(message.rowCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportCalendarCsvResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportCalendarCsvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.csvContent = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetSystemConfigRequest(): GetSystemConfigRequest {
  return { organisationId: "" };
}

export const GetSystemConfigRequest: MessageFns<GetSystemConfigRequest> = {
  encode(message: GetSystemConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSystemConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSystemConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateSystemConfigRequest(): UpdateSystemConfigRequest {
  return {
    organisationId: "",
    defaultMode: 0,
    defaultBatch: 0,
    defaultFixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
  };
}

export const UpdateSystemConfigRequest: MessageFns<UpdateSystemConfigRequest> = {
  encode(message: UpdateSystemConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.defaultMode !== 0) {
      writer.uint32(16).int32(message.defaultMode);
    }
    if (message.defaultBatch !== 0) {
      writer.uint32(24).int32(message.defaultBatch);
    }
    if (message.defaultFixedDay !== 0) {
      writer.uint32(32).int32(message.defaultFixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(58).string(message.cutoffConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSystemConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSystemConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.defaultMode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.defaultBatch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.defaultFixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCompanyConfigRequest(): CreateCompanyConfigRequest {
  return {
    organisationId: "",
    societeId: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
  };
}

export const CreateCompanyConfigRequest: MessageFns<CreateCompanyConfigRequest> = {
  encode(message: CreateCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(66).string(message.cutoffConfigId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateCompanyConfigRequest(): UpdateCompanyConfigRequest {
  return {
    id: "",
    mode: 0,
    batch: 0,
    fixedDay: 0,
    shiftStrategy: 0,
    holidayZoneId: "",
    cutoffConfigId: "",
    isActive: false,
  };
}

export const UpdateCompanyConfigRequest: MessageFns<UpdateCompanyConfigRequest> = {
  encode(message: UpdateCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(24).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(32).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.cutoffConfigId !== "") {
      writer.uint32(58).string(message.cutoffConfigId);
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cutoffConfigId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCompanyConfigRequest(): GetCompanyConfigRequest {
  return { id: "" };
}

export const GetCompanyConfigRequest: MessageFns<GetCompanyConfigRequest> = {
  encode(message: GetCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListCompanyConfigsRequest(): ListCompanyConfigsRequest {
  return { organisationId: "", societeId: "" };
}

export const ListCompanyConfigsRequest: MessageFns<ListCompanyConfigsRequest> = {
  encode(message: ListCompanyConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCompanyConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCompanyConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListCompanyConfigsResponse(): ListCompanyConfigsResponse {
  return { configs: [] };
}

export const ListCompanyConfigsResponse: MessageFns<ListCompanyConfigsResponse> = {
  encode(message: ListCompanyConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      CompanyDebitConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCompanyConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCompanyConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(CompanyDebitConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteCompanyConfigRequest(): DeleteCompanyConfigRequest {
  return { id: "" };
}

export const DeleteCompanyConfigRequest: MessageFns<DeleteCompanyConfigRequest> = {
  encode(message: DeleteCompanyConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCompanyConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCompanyConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateClientConfigRequest(): CreateClientConfigRequest {
  return { organisationId: "", clientId: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "" };
}

export const CreateClientConfigRequest: MessageFns<CreateClientConfigRequest> = {
  encode(message: CreateClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateClientConfigRequest(): UpdateClientConfigRequest {
  return { id: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "", isActive: false };
}

export const UpdateClientConfigRequest: MessageFns<UpdateClientConfigRequest> = {
  encode(message: UpdateClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(24).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(32).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetClientConfigRequest(): GetClientConfigRequest {
  return { id: "" };
}

export const GetClientConfigRequest: MessageFns<GetClientConfigRequest> = {
  encode(message: GetClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListClientConfigsRequest(): ListClientConfigsRequest {
  return { organisationId: "", clientId: "" };
}

export const ListClientConfigsRequest: MessageFns<ListClientConfigsRequest> = {
  encode(message: ListClientConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClientConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClientConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListClientConfigsResponse(): ListClientConfigsResponse {
  return { configs: [] };
}

export const ListClientConfigsResponse: MessageFns<ListClientConfigsResponse> = {
  encode(message: ListClientConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      ClientDebitConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClientConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClientConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(ClientDebitConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteClientConfigRequest(): DeleteClientConfigRequest {
  return { id: "" };
}

export const DeleteClientConfigRequest: MessageFns<DeleteClientConfigRequest> = {
  encode(message: DeleteClientConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClientConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClientConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateContractConfigRequest(): CreateContractConfigRequest {
  return { organisationId: "", contratId: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "" };
}

export const CreateContractConfigRequest: MessageFns<CreateContractConfigRequest> = {
  encode(message: CreateContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(32).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(40).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(48).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(58).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateContractConfigRequest(): UpdateContractConfigRequest {
  return { id: "", mode: 0, batch: 0, fixedDay: 0, shiftStrategy: 0, holidayZoneId: "", isActive: false };
}

export const UpdateContractConfigRequest: MessageFns<UpdateContractConfigRequest> = {
  encode(message: UpdateContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    if (message.batch !== 0) {
      writer.uint32(24).int32(message.batch);
    }
    if (message.fixedDay !== 0) {
      writer.uint32(32).int32(message.fixedDay);
    }
    if (message.shiftStrategy !== 0) {
      writer.uint32(40).int32(message.shiftStrategy);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(50).string(message.holidayZoneId);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.batch = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fixedDay = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shiftStrategy = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetContractConfigRequest(): GetContractConfigRequest {
  return { id: "" };
}

export const GetContractConfigRequest: MessageFns<GetContractConfigRequest> = {
  encode(message: GetContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListContractConfigsRequest(): ListContractConfigsRequest {
  return { organisationId: "", contratId: "" };
}

export const ListContractConfigsRequest: MessageFns<ListContractConfigsRequest> = {
  encode(message: ListContractConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContractConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContractConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListContractConfigsResponse(): ListContractConfigsResponse {
  return { configs: [] };
}

export const ListContractConfigsResponse: MessageFns<ListContractConfigsResponse> = {
  encode(message: ListContractConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      ContractDebitConfiguration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContractConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContractConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.configs.push(ContractDebitConfiguration.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteContractConfigRequest(): DeleteContractConfigRequest {
  return { id: "" };
}

export const DeleteContractConfigRequest: MessageFns<DeleteContractConfigRequest> = {
  encode(message: DeleteContractConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteContractConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteContractConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResolveConfigurationRequest(): ResolveConfigurationRequest {
  return { organisationId: "", contratId: "", clientId: "", societeId: "" };
}

export const ResolveConfigurationRequest: MessageFns<ResolveConfigurationRequest> = {
  encode(message: ResolveConfigurationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(34).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResolveConfigurationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResolveConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateHolidayZoneRequest(): CreateHolidayZoneRequest {
  return { organisationId: "", code: "", name: "", countryCode: "", regionCode: "" };
}

export const CreateHolidayZoneRequest: MessageFns<CreateHolidayZoneRequest> = {
  encode(message: CreateHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(34).string(message.countryCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(42).string(message.regionCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateHolidayZoneRequest(): UpdateHolidayZoneRequest {
  return { id: "", code: "", name: "", countryCode: "", regionCode: "", isActive: false };
}

export const UpdateHolidayZoneRequest: MessageFns<UpdateHolidayZoneRequest> = {
  encode(message: UpdateHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(34).string(message.countryCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(42).string(message.regionCode);
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetHolidayZoneRequest(): GetHolidayZoneRequest {
  return { id: "" };
}

export const GetHolidayZoneRequest: MessageFns<GetHolidayZoneRequest> = {
  encode(message: GetHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHolidayZonesRequest(): ListHolidayZonesRequest {
  return { organisationId: "", countryCode: "" };
}

export const ListHolidayZonesRequest: MessageFns<ListHolidayZonesRequest> = {
  encode(message: ListHolidayZonesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.countryCode !== "") {
      writer.uint32(18).string(message.countryCode);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidayZonesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidayZonesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHolidayZonesResponse(): ListHolidayZonesResponse {
  return { zones: [] };
}

export const ListHolidayZonesResponse: MessageFns<ListHolidayZonesResponse> = {
  encode(message: ListHolidayZonesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.zones) {
      HolidayZone.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidayZonesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidayZonesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.zones.push(HolidayZone.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteHolidayZoneRequest(): DeleteHolidayZoneRequest {
  return { id: "" };
}

export const DeleteHolidayZoneRequest: MessageFns<DeleteHolidayZoneRequest> = {
  encode(message: DeleteHolidayZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHolidayZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHolidayZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateHolidayRequest(): CreateHolidayRequest {
  return {
    holidayZoneId: "",
    date: "",
    name: "",
    holidayType: 0,
    isRecurring: false,
    recurringMonth: 0,
    recurringDay: 0,
  };
}

export const CreateHolidayRequest: MessageFns<CreateHolidayRequest> = {
  encode(message: CreateHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.holidayZoneId !== "") {
      writer.uint32(10).string(message.holidayZoneId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.holidayType !== 0) {
      writer.uint32(32).int32(message.holidayType);
    }
    if (message.isRecurring !== false) {
      writer.uint32(40).bool(message.isRecurring);
    }
    if (message.recurringMonth !== 0) {
      writer.uint32(48).int32(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      writer.uint32(56).int32(message.recurringDay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.holidayType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRecurring = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.recurringMonth = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recurringDay = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateHolidayRequest(): UpdateHolidayRequest {
  return {
    id: "",
    date: "",
    name: "",
    holidayType: 0,
    isRecurring: false,
    recurringMonth: 0,
    recurringDay: 0,
    isActive: false,
  };
}

export const UpdateHolidayRequest: MessageFns<UpdateHolidayRequest> = {
  encode(message: UpdateHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.holidayType !== 0) {
      writer.uint32(32).int32(message.holidayType);
    }
    if (message.isRecurring !== false) {
      writer.uint32(40).bool(message.isRecurring);
    }
    if (message.recurringMonth !== 0) {
      writer.uint32(48).int32(message.recurringMonth);
    }
    if (message.recurringDay !== 0) {
      writer.uint32(56).int32(message.recurringDay);
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.holidayType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isRecurring = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.recurringMonth = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recurringDay = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetHolidayRequest(): GetHolidayRequest {
  return { id: "" };
}

export const GetHolidayRequest: MessageFns<GetHolidayRequest> = {
  encode(message: GetHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHolidaysRequest(): ListHolidaysRequest {
  return { holidayZoneId: "", year: 0 };
}

export const ListHolidaysRequest: MessageFns<ListHolidaysRequest> = {
  encode(message: ListHolidaysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.holidayZoneId !== "") {
      writer.uint32(10).string(message.holidayZoneId);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidaysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidaysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHolidaysResponse(): ListHolidaysResponse {
  return { holidays: [] };
}

export const ListHolidaysResponse: MessageFns<ListHolidaysResponse> = {
  encode(message: ListHolidaysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.holidays) {
      Holiday.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHolidaysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHolidaysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holidays.push(Holiday.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteHolidayRequest(): DeleteHolidayRequest {
  return { id: "" };
}

export const DeleteHolidayRequest: MessageFns<DeleteHolidayRequest> = {
  encode(message: DeleteHolidayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHolidayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHolidayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImportHolidaysByCountryRequest(): ImportHolidaysByCountryRequest {
  return { organisationId: "", countryCode: "", year: 0, includeRegional: false };
}

export const ImportHolidaysByCountryRequest: MessageFns<ImportHolidaysByCountryRequest> = {
  encode(message: ImportHolidaysByCountryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.countryCode !== "") {
      writer.uint32(18).string(message.countryCode);
    }
    if (message.year !== 0) {
      writer.uint32(24).int32(message.year);
    }
    if (message.includeRegional !== false) {
      writer.uint32(32).bool(message.includeRegional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportHolidaysByCountryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportHolidaysByCountryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeRegional = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseImportHolidaysByCountryResponse(): ImportHolidaysByCountryResponse {
  return { success: false, importedCount: 0, holidayZoneId: "" };
}

export const ImportHolidaysByCountryResponse: MessageFns<ImportHolidaysByCountryResponse> = {
  encode(message: ImportHolidaysByCountryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.importedCount !== 0) {
      writer.uint32(16).int32(message.importedCount);
    }
    if (message.holidayZoneId !== "") {
      writer.uint32(26).string(message.holidayZoneId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportHolidaysByCountryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportHolidaysByCountryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.importedCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.holidayZoneId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateVolumeThresholdRequest(): CreateVolumeThresholdRequest {
  return {
    organisationId: "",
    societeId: "",
    maxTransactionCount: 0,
    maxAmountCents: 0,
    currency: "",
    alertOnExceed: false,
    alertEmail: "",
  };
}

export const CreateVolumeThresholdRequest: MessageFns<CreateVolumeThresholdRequest> = {
  encode(message: CreateVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.maxTransactionCount !== 0) {
      writer.uint32(24).int32(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      writer.uint32(32).int64(message.maxAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.alertOnExceed !== false) {
      writer.uint32(48).bool(message.alertOnExceed);
    }
    if (message.alertEmail !== "") {
      writer.uint32(58).string(message.alertEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxTransactionCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.alertOnExceed = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.alertEmail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateVolumeThresholdRequest(): UpdateVolumeThresholdRequest {
  return {
    id: "",
    maxTransactionCount: 0,
    maxAmountCents: 0,
    currency: "",
    alertOnExceed: false,
    alertEmail: "",
    isActive: false,
  };
}

export const UpdateVolumeThresholdRequest: MessageFns<UpdateVolumeThresholdRequest> = {
  encode(message: UpdateVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.maxTransactionCount !== 0) {
      writer.uint32(16).int32(message.maxTransactionCount);
    }
    if (message.maxAmountCents !== 0) {
      writer.uint32(24).int64(message.maxAmountCents);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.alertOnExceed !== false) {
      writer.uint32(40).bool(message.alertOnExceed);
    }
    if (message.alertEmail !== "") {
      writer.uint32(50).string(message.alertEmail);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxTransactionCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxAmountCents = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.alertOnExceed = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.alertEmail = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetVolumeThresholdRequest(): GetVolumeThresholdRequest {
  return { id: "" };
}

export const GetVolumeThresholdRequest: MessageFns<GetVolumeThresholdRequest> = {
  encode(message: GetVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListVolumeThresholdsRequest(): ListVolumeThresholdsRequest {
  return { organisationId: "", societeId: "" };
}

export const ListVolumeThresholdsRequest: MessageFns<ListVolumeThresholdsRequest> = {
  encode(message: ListVolumeThresholdsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumeThresholdsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumeThresholdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListVolumeThresholdsResponse(): ListVolumeThresholdsResponse {
  return { thresholds: [] };
}

export const ListVolumeThresholdsResponse: MessageFns<ListVolumeThresholdsResponse> = {
  encode(message: ListVolumeThresholdsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.thresholds) {
      VolumeThreshold.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumeThresholdsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumeThresholdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.thresholds.push(VolumeThreshold.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteVolumeThresholdRequest(): DeleteVolumeThresholdRequest {
  return { id: "" };
}

export const DeleteVolumeThresholdRequest: MessageFns<DeleteVolumeThresholdRequest> = {
  encode(message: DeleteVolumeThresholdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVolumeThresholdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVolumeThresholdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuditLogsRequest(): GetAuditLogsRequest {
  return { organisationId: "", entityType: "", entityId: "", actorUserId: "", source: 0, startDate: "", endDate: "" };
}

export const GetAuditLogsRequest: MessageFns<GetAuditLogsRequest> = {
  encode(message: GetAuditLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(26).string(message.entityId);
    }
    if (message.actorUserId !== "") {
      writer.uint32(34).string(message.actorUserId);
    }
    if (message.source !== 0) {
      writer.uint32(40).int32(message.source);
    }
    if (message.startDate !== "") {
      writer.uint32(50).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(58).string(message.endDate);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actorUserId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endDate = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuditLogsResponse(): GetAuditLogsResponse {
  return { logs: [] };
}

export const GetAuditLogsResponse: MessageFns<GetAuditLogsResponse> = {
  encode(message: GetAuditLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      CalendarAuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(CalendarAuditLog.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** Service de calcul du Calendar Engine */

export interface CalendarEngineServiceClient {
  /** Calcul de date unique */

  calculatePlannedDate(
    request: CalculatePlannedDateRequest,
    metadata?: Metadata,
  ): Observable<CalculatePlannedDateResponse>;

  /** Calcul en lot */

  calculatePlannedDatesBatch(
    request: CalculatePlannedDatesBatchRequest,
    metadata?: Metadata,
  ): Observable<CalculatePlannedDatesBatchResponse>;

  /** Vérification d'éligibilité */

  checkDateEligibility(
    request: CheckDateEligibilityRequest,
    metadata?: Metadata,
  ): Observable<CheckDateEligibilityResponse>;
}

/** Service de calcul du Calendar Engine */

export interface CalendarEngineServiceController {
  /** Calcul de date unique */

  calculatePlannedDate(
    request: CalculatePlannedDateRequest,
    metadata?: Metadata,
  ): Promise<CalculatePlannedDateResponse> | Observable<CalculatePlannedDateResponse> | CalculatePlannedDateResponse;

  /** Calcul en lot */

  calculatePlannedDatesBatch(
    request: CalculatePlannedDatesBatchRequest,
    metadata?: Metadata,
  ):
    | Promise<CalculatePlannedDatesBatchResponse>
    | Observable<CalculatePlannedDatesBatchResponse>
    | CalculatePlannedDatesBatchResponse;

  /** Vérification d'éligibilité */

  checkDateEligibility(
    request: CheckDateEligibilityRequest,
    metadata?: Metadata,
  ): Promise<CheckDateEligibilityResponse> | Observable<CheckDateEligibilityResponse> | CheckDateEligibilityResponse;
}

export function CalendarEngineServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["calculatePlannedDate", "calculatePlannedDatesBatch", "checkDateEligibility"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("CalendarEngineService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("CalendarEngineService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CALENDAR_ENGINE_SERVICE_NAME = "CalendarEngineService";

/** Service de calcul du Calendar Engine */
export type CalendarEngineServiceService = typeof CalendarEngineServiceService;
export const CalendarEngineServiceService = {
  /** Calcul de date unique */
  calculatePlannedDate: {
    path: "/calendar.CalendarEngineService/CalculatePlannedDate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CalculatePlannedDateRequest): Buffer =>
      Buffer.from(CalculatePlannedDateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CalculatePlannedDateRequest => CalculatePlannedDateRequest.decode(value),
    responseSerialize: (value: CalculatePlannedDateResponse): Buffer =>
      Buffer.from(CalculatePlannedDateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalculatePlannedDateResponse => CalculatePlannedDateResponse.decode(value),
  },
  /** Calcul en lot */
  calculatePlannedDatesBatch: {
    path: "/calendar.CalendarEngineService/CalculatePlannedDatesBatch",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CalculatePlannedDatesBatchRequest): Buffer =>
      Buffer.from(CalculatePlannedDatesBatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CalculatePlannedDatesBatchRequest =>
      CalculatePlannedDatesBatchRequest.decode(value),
    responseSerialize: (value: CalculatePlannedDatesBatchResponse): Buffer =>
      Buffer.from(CalculatePlannedDatesBatchResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalculatePlannedDatesBatchResponse =>
      CalculatePlannedDatesBatchResponse.decode(value),
  },
  /** Vérification d'éligibilité */
  checkDateEligibility: {
    path: "/calendar.CalendarEngineService/CheckDateEligibility",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckDateEligibilityRequest): Buffer =>
      Buffer.from(CheckDateEligibilityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckDateEligibilityRequest => CheckDateEligibilityRequest.decode(value),
    responseSerialize: (value: CheckDateEligibilityResponse): Buffer =>
      Buffer.from(CheckDateEligibilityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckDateEligibilityResponse => CheckDateEligibilityResponse.decode(value),
  },
} as const;

export interface CalendarEngineServiceServer extends UntypedServiceImplementation {
  /** Calcul de date unique */
  calculatePlannedDate: handleUnaryCall<CalculatePlannedDateRequest, CalculatePlannedDateResponse>;
  /** Calcul en lot */
  calculatePlannedDatesBatch: handleUnaryCall<CalculatePlannedDatesBatchRequest, CalculatePlannedDatesBatchResponse>;
  /** Vérification d'éligibilité */
  checkDateEligibility: handleUnaryCall<CheckDateEligibilityRequest, CheckDateEligibilityResponse>;
}

/** Service de gestion des configurations */

export interface DebitConfigurationServiceClient {
  /** Configuration système */

  getSystemConfig(request: GetSystemConfigRequest, metadata?: Metadata): Observable<SystemDebitConfiguration>;

  updateSystemConfig(request: UpdateSystemConfigRequest, metadata?: Metadata): Observable<SystemDebitConfiguration>;

  /** Configuration société */

  createCompanyConfig(request: CreateCompanyConfigRequest, metadata?: Metadata): Observable<CompanyDebitConfiguration>;

  updateCompanyConfig(request: UpdateCompanyConfigRequest, metadata?: Metadata): Observable<CompanyDebitConfiguration>;

  getCompanyConfig(request: GetCompanyConfigRequest, metadata?: Metadata): Observable<CompanyDebitConfiguration>;

  listCompanyConfigs(request: ListCompanyConfigsRequest, metadata?: Metadata): Observable<ListCompanyConfigsResponse>;

  deleteCompanyConfig(request: DeleteCompanyConfigRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** Configuration client */

  createClientConfig(request: CreateClientConfigRequest, metadata?: Metadata): Observable<ClientDebitConfiguration>;

  updateClientConfig(request: UpdateClientConfigRequest, metadata?: Metadata): Observable<ClientDebitConfiguration>;

  getClientConfig(request: GetClientConfigRequest, metadata?: Metadata): Observable<ClientDebitConfiguration>;

  listClientConfigs(request: ListClientConfigsRequest, metadata?: Metadata): Observable<ListClientConfigsResponse>;

  deleteClientConfig(request: DeleteClientConfigRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** Configuration contrat */

  createContractConfig(
    request: CreateContractConfigRequest,
    metadata?: Metadata,
  ): Observable<ContractDebitConfiguration>;

  updateContractConfig(
    request: UpdateContractConfigRequest,
    metadata?: Metadata,
  ): Observable<ContractDebitConfiguration>;

  getContractConfig(request: GetContractConfigRequest, metadata?: Metadata): Observable<ContractDebitConfiguration>;

  listContractConfigs(
    request: ListContractConfigsRequest,
    metadata?: Metadata,
  ): Observable<ListContractConfigsResponse>;

  deleteContractConfig(request: DeleteContractConfigRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** Résolution de configuration */

  resolveConfiguration(
    request: ResolveConfigurationRequest,
    metadata?: Metadata,
  ): Observable<ResolvedDebitConfiguration>;
}

/** Service de gestion des configurations */

export interface DebitConfigurationServiceController {
  /** Configuration système */

  getSystemConfig(
    request: GetSystemConfigRequest,
    metadata?: Metadata,
  ): Promise<SystemDebitConfiguration> | Observable<SystemDebitConfiguration> | SystemDebitConfiguration;

  updateSystemConfig(
    request: UpdateSystemConfigRequest,
    metadata?: Metadata,
  ): Promise<SystemDebitConfiguration> | Observable<SystemDebitConfiguration> | SystemDebitConfiguration;

  /** Configuration société */

  createCompanyConfig(
    request: CreateCompanyConfigRequest,
    metadata?: Metadata,
  ): Promise<CompanyDebitConfiguration> | Observable<CompanyDebitConfiguration> | CompanyDebitConfiguration;

  updateCompanyConfig(
    request: UpdateCompanyConfigRequest,
    metadata?: Metadata,
  ): Promise<CompanyDebitConfiguration> | Observable<CompanyDebitConfiguration> | CompanyDebitConfiguration;

  getCompanyConfig(
    request: GetCompanyConfigRequest,
    metadata?: Metadata,
  ): Promise<CompanyDebitConfiguration> | Observable<CompanyDebitConfiguration> | CompanyDebitConfiguration;

  listCompanyConfigs(
    request: ListCompanyConfigsRequest,
    metadata?: Metadata,
  ): Promise<ListCompanyConfigsResponse> | Observable<ListCompanyConfigsResponse> | ListCompanyConfigsResponse;

  deleteCompanyConfig(
    request: DeleteCompanyConfigRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** Configuration client */

  createClientConfig(
    request: CreateClientConfigRequest,
    metadata?: Metadata,
  ): Promise<ClientDebitConfiguration> | Observable<ClientDebitConfiguration> | ClientDebitConfiguration;

  updateClientConfig(
    request: UpdateClientConfigRequest,
    metadata?: Metadata,
  ): Promise<ClientDebitConfiguration> | Observable<ClientDebitConfiguration> | ClientDebitConfiguration;

  getClientConfig(
    request: GetClientConfigRequest,
    metadata?: Metadata,
  ): Promise<ClientDebitConfiguration> | Observable<ClientDebitConfiguration> | ClientDebitConfiguration;

  listClientConfigs(
    request: ListClientConfigsRequest,
    metadata?: Metadata,
  ): Promise<ListClientConfigsResponse> | Observable<ListClientConfigsResponse> | ListClientConfigsResponse;

  deleteClientConfig(
    request: DeleteClientConfigRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** Configuration contrat */

  createContractConfig(
    request: CreateContractConfigRequest,
    metadata?: Metadata,
  ): Promise<ContractDebitConfiguration> | Observable<ContractDebitConfiguration> | ContractDebitConfiguration;

  updateContractConfig(
    request: UpdateContractConfigRequest,
    metadata?: Metadata,
  ): Promise<ContractDebitConfiguration> | Observable<ContractDebitConfiguration> | ContractDebitConfiguration;

  getContractConfig(
    request: GetContractConfigRequest,
    metadata?: Metadata,
  ): Promise<ContractDebitConfiguration> | Observable<ContractDebitConfiguration> | ContractDebitConfiguration;

  listContractConfigs(
    request: ListContractConfigsRequest,
    metadata?: Metadata,
  ): Promise<ListContractConfigsResponse> | Observable<ListContractConfigsResponse> | ListContractConfigsResponse;

  deleteContractConfig(
    request: DeleteContractConfigRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** Résolution de configuration */

  resolveConfiguration(
    request: ResolveConfigurationRequest,
    metadata?: Metadata,
  ): Promise<ResolvedDebitConfiguration> | Observable<ResolvedDebitConfiguration> | ResolvedDebitConfiguration;
}

export function DebitConfigurationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getSystemConfig",
      "updateSystemConfig",
      "createCompanyConfig",
      "updateCompanyConfig",
      "getCompanyConfig",
      "listCompanyConfigs",
      "deleteCompanyConfig",
      "createClientConfig",
      "updateClientConfig",
      "getClientConfig",
      "listClientConfigs",
      "deleteClientConfig",
      "createContractConfig",
      "updateContractConfig",
      "getContractConfig",
      "listContractConfigs",
      "deleteContractConfig",
      "resolveConfiguration",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("DebitConfigurationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("DebitConfigurationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const DEBIT_CONFIGURATION_SERVICE_NAME = "DebitConfigurationService";

/** Service de gestion des configurations */
export type DebitConfigurationServiceService = typeof DebitConfigurationServiceService;
export const DebitConfigurationServiceService = {
  /** Configuration système */
  getSystemConfig: {
    path: "/calendar.DebitConfigurationService/GetSystemConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSystemConfigRequest): Buffer =>
      Buffer.from(GetSystemConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSystemConfigRequest => GetSystemConfigRequest.decode(value),
    responseSerialize: (value: SystemDebitConfiguration): Buffer =>
      Buffer.from(SystemDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): SystemDebitConfiguration => SystemDebitConfiguration.decode(value),
  },
  updateSystemConfig: {
    path: "/calendar.DebitConfigurationService/UpdateSystemConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSystemConfigRequest): Buffer =>
      Buffer.from(UpdateSystemConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSystemConfigRequest => UpdateSystemConfigRequest.decode(value),
    responseSerialize: (value: SystemDebitConfiguration): Buffer =>
      Buffer.from(SystemDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): SystemDebitConfiguration => SystemDebitConfiguration.decode(value),
  },
  /** Configuration société */
  createCompanyConfig: {
    path: "/calendar.DebitConfigurationService/CreateCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCompanyConfigRequest): Buffer =>
      Buffer.from(CreateCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCompanyConfigRequest => CreateCompanyConfigRequest.decode(value),
    responseSerialize: (value: CompanyDebitConfiguration): Buffer =>
      Buffer.from(CompanyDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): CompanyDebitConfiguration => CompanyDebitConfiguration.decode(value),
  },
  updateCompanyConfig: {
    path: "/calendar.DebitConfigurationService/UpdateCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCompanyConfigRequest): Buffer =>
      Buffer.from(UpdateCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateCompanyConfigRequest => UpdateCompanyConfigRequest.decode(value),
    responseSerialize: (value: CompanyDebitConfiguration): Buffer =>
      Buffer.from(CompanyDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): CompanyDebitConfiguration => CompanyDebitConfiguration.decode(value),
  },
  getCompanyConfig: {
    path: "/calendar.DebitConfigurationService/GetCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCompanyConfigRequest): Buffer =>
      Buffer.from(GetCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCompanyConfigRequest => GetCompanyConfigRequest.decode(value),
    responseSerialize: (value: CompanyDebitConfiguration): Buffer =>
      Buffer.from(CompanyDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): CompanyDebitConfiguration => CompanyDebitConfiguration.decode(value),
  },
  listCompanyConfigs: {
    path: "/calendar.DebitConfigurationService/ListCompanyConfigs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCompanyConfigsRequest): Buffer =>
      Buffer.from(ListCompanyConfigsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListCompanyConfigsRequest => ListCompanyConfigsRequest.decode(value),
    responseSerialize: (value: ListCompanyConfigsResponse): Buffer =>
      Buffer.from(ListCompanyConfigsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCompanyConfigsResponse => ListCompanyConfigsResponse.decode(value),
  },
  deleteCompanyConfig: {
    path: "/calendar.DebitConfigurationService/DeleteCompanyConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCompanyConfigRequest): Buffer =>
      Buffer.from(DeleteCompanyConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCompanyConfigRequest => DeleteCompanyConfigRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Configuration client */
  createClientConfig: {
    path: "/calendar.DebitConfigurationService/CreateClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateClientConfigRequest): Buffer =>
      Buffer.from(CreateClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateClientConfigRequest => CreateClientConfigRequest.decode(value),
    responseSerialize: (value: ClientDebitConfiguration): Buffer =>
      Buffer.from(ClientDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClientDebitConfiguration => ClientDebitConfiguration.decode(value),
  },
  updateClientConfig: {
    path: "/calendar.DebitConfigurationService/UpdateClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateClientConfigRequest): Buffer =>
      Buffer.from(UpdateClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateClientConfigRequest => UpdateClientConfigRequest.decode(value),
    responseSerialize: (value: ClientDebitConfiguration): Buffer =>
      Buffer.from(ClientDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClientDebitConfiguration => ClientDebitConfiguration.decode(value),
  },
  getClientConfig: {
    path: "/calendar.DebitConfigurationService/GetClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetClientConfigRequest): Buffer =>
      Buffer.from(GetClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetClientConfigRequest => GetClientConfigRequest.decode(value),
    responseSerialize: (value: ClientDebitConfiguration): Buffer =>
      Buffer.from(ClientDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClientDebitConfiguration => ClientDebitConfiguration.decode(value),
  },
  listClientConfigs: {
    path: "/calendar.DebitConfigurationService/ListClientConfigs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListClientConfigsRequest): Buffer =>
      Buffer.from(ListClientConfigsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListClientConfigsRequest => ListClientConfigsRequest.decode(value),
    responseSerialize: (value: ListClientConfigsResponse): Buffer =>
      Buffer.from(ListClientConfigsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListClientConfigsResponse => ListClientConfigsResponse.decode(value),
  },
  deleteClientConfig: {
    path: "/calendar.DebitConfigurationService/DeleteClientConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteClientConfigRequest): Buffer =>
      Buffer.from(DeleteClientConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteClientConfigRequest => DeleteClientConfigRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Configuration contrat */
  createContractConfig: {
    path: "/calendar.DebitConfigurationService/CreateContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateContractConfigRequest): Buffer =>
      Buffer.from(CreateContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateContractConfigRequest => CreateContractConfigRequest.decode(value),
    responseSerialize: (value: ContractDebitConfiguration): Buffer =>
      Buffer.from(ContractDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ContractDebitConfiguration => ContractDebitConfiguration.decode(value),
  },
  updateContractConfig: {
    path: "/calendar.DebitConfigurationService/UpdateContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateContractConfigRequest): Buffer =>
      Buffer.from(UpdateContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateContractConfigRequest => UpdateContractConfigRequest.decode(value),
    responseSerialize: (value: ContractDebitConfiguration): Buffer =>
      Buffer.from(ContractDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ContractDebitConfiguration => ContractDebitConfiguration.decode(value),
  },
  getContractConfig: {
    path: "/calendar.DebitConfigurationService/GetContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContractConfigRequest): Buffer =>
      Buffer.from(GetContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContractConfigRequest => GetContractConfigRequest.decode(value),
    responseSerialize: (value: ContractDebitConfiguration): Buffer =>
      Buffer.from(ContractDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ContractDebitConfiguration => ContractDebitConfiguration.decode(value),
  },
  listContractConfigs: {
    path: "/calendar.DebitConfigurationService/ListContractConfigs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListContractConfigsRequest): Buffer =>
      Buffer.from(ListContractConfigsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListContractConfigsRequest => ListContractConfigsRequest.decode(value),
    responseSerialize: (value: ListContractConfigsResponse): Buffer =>
      Buffer.from(ListContractConfigsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListContractConfigsResponse => ListContractConfigsResponse.decode(value),
  },
  deleteContractConfig: {
    path: "/calendar.DebitConfigurationService/DeleteContractConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteContractConfigRequest): Buffer =>
      Buffer.from(DeleteContractConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteContractConfigRequest => DeleteContractConfigRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Résolution de configuration */
  resolveConfiguration: {
    path: "/calendar.DebitConfigurationService/ResolveConfiguration",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResolveConfigurationRequest): Buffer =>
      Buffer.from(ResolveConfigurationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResolveConfigurationRequest => ResolveConfigurationRequest.decode(value),
    responseSerialize: (value: ResolvedDebitConfiguration): Buffer =>
      Buffer.from(ResolvedDebitConfiguration.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResolvedDebitConfiguration => ResolvedDebitConfiguration.decode(value),
  },
} as const;

export interface DebitConfigurationServiceServer extends UntypedServiceImplementation {
  /** Configuration système */
  getSystemConfig: handleUnaryCall<GetSystemConfigRequest, SystemDebitConfiguration>;
  updateSystemConfig: handleUnaryCall<UpdateSystemConfigRequest, SystemDebitConfiguration>;
  /** Configuration société */
  createCompanyConfig: handleUnaryCall<CreateCompanyConfigRequest, CompanyDebitConfiguration>;
  updateCompanyConfig: handleUnaryCall<UpdateCompanyConfigRequest, CompanyDebitConfiguration>;
  getCompanyConfig: handleUnaryCall<GetCompanyConfigRequest, CompanyDebitConfiguration>;
  listCompanyConfigs: handleUnaryCall<ListCompanyConfigsRequest, ListCompanyConfigsResponse>;
  deleteCompanyConfig: handleUnaryCall<DeleteCompanyConfigRequest, DeleteResponse>;
  /** Configuration client */
  createClientConfig: handleUnaryCall<CreateClientConfigRequest, ClientDebitConfiguration>;
  updateClientConfig: handleUnaryCall<UpdateClientConfigRequest, ClientDebitConfiguration>;
  getClientConfig: handleUnaryCall<GetClientConfigRequest, ClientDebitConfiguration>;
  listClientConfigs: handleUnaryCall<ListClientConfigsRequest, ListClientConfigsResponse>;
  deleteClientConfig: handleUnaryCall<DeleteClientConfigRequest, DeleteResponse>;
  /** Configuration contrat */
  createContractConfig: handleUnaryCall<CreateContractConfigRequest, ContractDebitConfiguration>;
  updateContractConfig: handleUnaryCall<UpdateContractConfigRequest, ContractDebitConfiguration>;
  getContractConfig: handleUnaryCall<GetContractConfigRequest, ContractDebitConfiguration>;
  listContractConfigs: handleUnaryCall<ListContractConfigsRequest, ListContractConfigsResponse>;
  deleteContractConfig: handleUnaryCall<DeleteContractConfigRequest, DeleteResponse>;
  /** Résolution de configuration */
  resolveConfiguration: handleUnaryCall<ResolveConfigurationRequest, ResolvedDebitConfiguration>;
}

/** Service de gestion des jours fériés */

export interface HolidayServiceClient {
  /** Zones */

  createHolidayZone(request: CreateHolidayZoneRequest, metadata?: Metadata): Observable<HolidayZone>;

  updateHolidayZone(request: UpdateHolidayZoneRequest, metadata?: Metadata): Observable<HolidayZone>;

  getHolidayZone(request: GetHolidayZoneRequest, metadata?: Metadata): Observable<HolidayZone>;

  listHolidayZones(request: ListHolidayZonesRequest, metadata?: Metadata): Observable<ListHolidayZonesResponse>;

  deleteHolidayZone(request: DeleteHolidayZoneRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** Jours fériés */

  createHoliday(request: CreateHolidayRequest, metadata?: Metadata): Observable<Holiday>;

  updateHoliday(request: UpdateHolidayRequest, metadata?: Metadata): Observable<Holiday>;

  getHoliday(request: GetHolidayRequest, metadata?: Metadata): Observable<Holiday>;

  listHolidays(request: ListHolidaysRequest, metadata?: Metadata): Observable<ListHolidaysResponse>;

  deleteHoliday(request: DeleteHolidayRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** Import jours fériés par pays */

  importHolidaysByCountry(
    request: ImportHolidaysByCountryRequest,
    metadata?: Metadata,
  ): Observable<ImportHolidaysByCountryResponse>;
}

/** Service de gestion des jours fériés */

export interface HolidayServiceController {
  /** Zones */

  createHolidayZone(
    request: CreateHolidayZoneRequest,
    metadata?: Metadata,
  ): Promise<HolidayZone> | Observable<HolidayZone> | HolidayZone;

  updateHolidayZone(
    request: UpdateHolidayZoneRequest,
    metadata?: Metadata,
  ): Promise<HolidayZone> | Observable<HolidayZone> | HolidayZone;

  getHolidayZone(
    request: GetHolidayZoneRequest,
    metadata?: Metadata,
  ): Promise<HolidayZone> | Observable<HolidayZone> | HolidayZone;

  listHolidayZones(
    request: ListHolidayZonesRequest,
    metadata?: Metadata,
  ): Promise<ListHolidayZonesResponse> | Observable<ListHolidayZonesResponse> | ListHolidayZonesResponse;

  deleteHolidayZone(
    request: DeleteHolidayZoneRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** Jours fériés */

  createHoliday(request: CreateHolidayRequest, metadata?: Metadata): Promise<Holiday> | Observable<Holiday> | Holiday;

  updateHoliday(request: UpdateHolidayRequest, metadata?: Metadata): Promise<Holiday> | Observable<Holiday> | Holiday;

  getHoliday(request: GetHolidayRequest, metadata?: Metadata): Promise<Holiday> | Observable<Holiday> | Holiday;

  listHolidays(
    request: ListHolidaysRequest,
    metadata?: Metadata,
  ): Promise<ListHolidaysResponse> | Observable<ListHolidaysResponse> | ListHolidaysResponse;

  deleteHoliday(
    request: DeleteHolidayRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** Import jours fériés par pays */

  importHolidaysByCountry(
    request: ImportHolidaysByCountryRequest,
    metadata?: Metadata,
  ):
    | Promise<ImportHolidaysByCountryResponse>
    | Observable<ImportHolidaysByCountryResponse>
    | ImportHolidaysByCountryResponse;
}

export function HolidayServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createHolidayZone",
      "updateHolidayZone",
      "getHolidayZone",
      "listHolidayZones",
      "deleteHolidayZone",
      "createHoliday",
      "updateHoliday",
      "getHoliday",
      "listHolidays",
      "deleteHoliday",
      "importHolidaysByCountry",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("HolidayService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("HolidayService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const HOLIDAY_SERVICE_NAME = "HolidayService";

/** Service de gestion des jours fériés */
export type HolidayServiceService = typeof HolidayServiceService;
export const HolidayServiceService = {
  /** Zones */
  createHolidayZone: {
    path: "/calendar.HolidayService/CreateHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateHolidayZoneRequest): Buffer =>
      Buffer.from(CreateHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateHolidayZoneRequest => CreateHolidayZoneRequest.decode(value),
    responseSerialize: (value: HolidayZone): Buffer => Buffer.from(HolidayZone.encode(value).finish()),
    responseDeserialize: (value: Buffer): HolidayZone => HolidayZone.decode(value),
  },
  updateHolidayZone: {
    path: "/calendar.HolidayService/UpdateHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateHolidayZoneRequest): Buffer =>
      Buffer.from(UpdateHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateHolidayZoneRequest => UpdateHolidayZoneRequest.decode(value),
    responseSerialize: (value: HolidayZone): Buffer => Buffer.from(HolidayZone.encode(value).finish()),
    responseDeserialize: (value: Buffer): HolidayZone => HolidayZone.decode(value),
  },
  getHolidayZone: {
    path: "/calendar.HolidayService/GetHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHolidayZoneRequest): Buffer =>
      Buffer.from(GetHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetHolidayZoneRequest => GetHolidayZoneRequest.decode(value),
    responseSerialize: (value: HolidayZone): Buffer => Buffer.from(HolidayZone.encode(value).finish()),
    responseDeserialize: (value: Buffer): HolidayZone => HolidayZone.decode(value),
  },
  listHolidayZones: {
    path: "/calendar.HolidayService/ListHolidayZones",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListHolidayZonesRequest): Buffer =>
      Buffer.from(ListHolidayZonesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListHolidayZonesRequest => ListHolidayZonesRequest.decode(value),
    responseSerialize: (value: ListHolidayZonesResponse): Buffer =>
      Buffer.from(ListHolidayZonesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHolidayZonesResponse => ListHolidayZonesResponse.decode(value),
  },
  deleteHolidayZone: {
    path: "/calendar.HolidayService/DeleteHolidayZone",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteHolidayZoneRequest): Buffer =>
      Buffer.from(DeleteHolidayZoneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteHolidayZoneRequest => DeleteHolidayZoneRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Jours fériés */
  createHoliday: {
    path: "/calendar.HolidayService/CreateHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateHolidayRequest): Buffer => Buffer.from(CreateHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateHolidayRequest => CreateHolidayRequest.decode(value),
    responseSerialize: (value: Holiday): Buffer => Buffer.from(Holiday.encode(value).finish()),
    responseDeserialize: (value: Buffer): Holiday => Holiday.decode(value),
  },
  updateHoliday: {
    path: "/calendar.HolidayService/UpdateHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateHolidayRequest): Buffer => Buffer.from(UpdateHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateHolidayRequest => UpdateHolidayRequest.decode(value),
    responseSerialize: (value: Holiday): Buffer => Buffer.from(Holiday.encode(value).finish()),
    responseDeserialize: (value: Buffer): Holiday => Holiday.decode(value),
  },
  getHoliday: {
    path: "/calendar.HolidayService/GetHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHolidayRequest): Buffer => Buffer.from(GetHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetHolidayRequest => GetHolidayRequest.decode(value),
    responseSerialize: (value: Holiday): Buffer => Buffer.from(Holiday.encode(value).finish()),
    responseDeserialize: (value: Buffer): Holiday => Holiday.decode(value),
  },
  listHolidays: {
    path: "/calendar.HolidayService/ListHolidays",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListHolidaysRequest): Buffer => Buffer.from(ListHolidaysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListHolidaysRequest => ListHolidaysRequest.decode(value),
    responseSerialize: (value: ListHolidaysResponse): Buffer =>
      Buffer.from(ListHolidaysResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHolidaysResponse => ListHolidaysResponse.decode(value),
  },
  deleteHoliday: {
    path: "/calendar.HolidayService/DeleteHoliday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteHolidayRequest): Buffer => Buffer.from(DeleteHolidayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteHolidayRequest => DeleteHolidayRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Import jours fériés par pays */
  importHolidaysByCountry: {
    path: "/calendar.HolidayService/ImportHolidaysByCountry",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportHolidaysByCountryRequest): Buffer =>
      Buffer.from(ImportHolidaysByCountryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImportHolidaysByCountryRequest => ImportHolidaysByCountryRequest.decode(value),
    responseSerialize: (value: ImportHolidaysByCountryResponse): Buffer =>
      Buffer.from(ImportHolidaysByCountryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ImportHolidaysByCountryResponse =>
      ImportHolidaysByCountryResponse.decode(value),
  },
} as const;

export interface HolidayServiceServer extends UntypedServiceImplementation {
  /** Zones */
  createHolidayZone: handleUnaryCall<CreateHolidayZoneRequest, HolidayZone>;
  updateHolidayZone: handleUnaryCall<UpdateHolidayZoneRequest, HolidayZone>;
  getHolidayZone: handleUnaryCall<GetHolidayZoneRequest, HolidayZone>;
  listHolidayZones: handleUnaryCall<ListHolidayZonesRequest, ListHolidayZonesResponse>;
  deleteHolidayZone: handleUnaryCall<DeleteHolidayZoneRequest, DeleteResponse>;
  /** Jours fériés */
  createHoliday: handleUnaryCall<CreateHolidayRequest, Holiday>;
  updateHoliday: handleUnaryCall<UpdateHolidayRequest, Holiday>;
  getHoliday: handleUnaryCall<GetHolidayRequest, Holiday>;
  listHolidays: handleUnaryCall<ListHolidaysRequest, ListHolidaysResponse>;
  deleteHoliday: handleUnaryCall<DeleteHolidayRequest, DeleteResponse>;
  /** Import jours fériés par pays */
  importHolidaysByCountry: handleUnaryCall<ImportHolidaysByCountryRequest, ImportHolidaysByCountryResponse>;
}

/** Service Admin UI */

export interface CalendarAdminServiceClient {
  /** Vue calendrier */

  getCalendarView(request: GetCalendarViewRequest, metadata?: Metadata): Observable<GetCalendarViewResponse>;

  getDateDetails(request: GetDateDetailsRequest, metadata?: Metadata): Observable<GetDateDetailsResponse>;

  /** Heatmap volumes */

  getVolumeHeatmap(request: GetVolumeHeatmapRequest, metadata?: Metadata): Observable<GetVolumeHeatmapResponse>;

  /** Import/Export CSV */

  importCsv(request: ImportCsvRequest, metadata?: Metadata): Observable<ImportCsvResponse>;

  confirmCsvImport(request: ConfirmCsvImportRequest, metadata?: Metadata): Observable<ConfirmCsvImportResponse>;

  exportCalendarCsv(request: ExportCalendarCsvRequest, metadata?: Metadata): Observable<ExportCalendarCsvResponse>;

  /** Seuils */

  createVolumeThreshold(request: CreateVolumeThresholdRequest, metadata?: Metadata): Observable<VolumeThreshold>;

  updateVolumeThreshold(request: UpdateVolumeThresholdRequest, metadata?: Metadata): Observable<VolumeThreshold>;

  getVolumeThreshold(request: GetVolumeThresholdRequest, metadata?: Metadata): Observable<VolumeThreshold>;

  listVolumeThresholds(
    request: ListVolumeThresholdsRequest,
    metadata?: Metadata,
  ): Observable<ListVolumeThresholdsResponse>;

  deleteVolumeThreshold(request: DeleteVolumeThresholdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** Audit */

  getAuditLogs(request: GetAuditLogsRequest, metadata?: Metadata): Observable<GetAuditLogsResponse>;
}

/** Service Admin UI */

export interface CalendarAdminServiceController {
  /** Vue calendrier */

  getCalendarView(
    request: GetCalendarViewRequest,
    metadata?: Metadata,
  ): Promise<GetCalendarViewResponse> | Observable<GetCalendarViewResponse> | GetCalendarViewResponse;

  getDateDetails(
    request: GetDateDetailsRequest,
    metadata?: Metadata,
  ): Promise<GetDateDetailsResponse> | Observable<GetDateDetailsResponse> | GetDateDetailsResponse;

  /** Heatmap volumes */

  getVolumeHeatmap(
    request: GetVolumeHeatmapRequest,
    metadata?: Metadata,
  ): Promise<GetVolumeHeatmapResponse> | Observable<GetVolumeHeatmapResponse> | GetVolumeHeatmapResponse;

  /** Import/Export CSV */

  importCsv(
    request: ImportCsvRequest,
    metadata?: Metadata,
  ): Promise<ImportCsvResponse> | Observable<ImportCsvResponse> | ImportCsvResponse;

  confirmCsvImport(
    request: ConfirmCsvImportRequest,
    metadata?: Metadata,
  ): Promise<ConfirmCsvImportResponse> | Observable<ConfirmCsvImportResponse> | ConfirmCsvImportResponse;

  exportCalendarCsv(
    request: ExportCalendarCsvRequest,
    metadata?: Metadata,
  ): Promise<ExportCalendarCsvResponse> | Observable<ExportCalendarCsvResponse> | ExportCalendarCsvResponse;

  /** Seuils */

  createVolumeThreshold(
    request: CreateVolumeThresholdRequest,
    metadata?: Metadata,
  ): Promise<VolumeThreshold> | Observable<VolumeThreshold> | VolumeThreshold;

  updateVolumeThreshold(
    request: UpdateVolumeThresholdRequest,
    metadata?: Metadata,
  ): Promise<VolumeThreshold> | Observable<VolumeThreshold> | VolumeThreshold;

  getVolumeThreshold(
    request: GetVolumeThresholdRequest,
    metadata?: Metadata,
  ): Promise<VolumeThreshold> | Observable<VolumeThreshold> | VolumeThreshold;

  listVolumeThresholds(
    request: ListVolumeThresholdsRequest,
    metadata?: Metadata,
  ): Promise<ListVolumeThresholdsResponse> | Observable<ListVolumeThresholdsResponse> | ListVolumeThresholdsResponse;

  deleteVolumeThreshold(
    request: DeleteVolumeThresholdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** Audit */

  getAuditLogs(
    request: GetAuditLogsRequest,
    metadata?: Metadata,
  ): Promise<GetAuditLogsResponse> | Observable<GetAuditLogsResponse> | GetAuditLogsResponse;
}

export function CalendarAdminServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getCalendarView",
      "getDateDetails",
      "getVolumeHeatmap",
      "importCsv",
      "confirmCsvImport",
      "exportCalendarCsv",
      "createVolumeThreshold",
      "updateVolumeThreshold",
      "getVolumeThreshold",
      "listVolumeThresholds",
      "deleteVolumeThreshold",
      "getAuditLogs",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("CalendarAdminService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("CalendarAdminService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CALENDAR_ADMIN_SERVICE_NAME = "CalendarAdminService";

/** Service Admin UI */
export type CalendarAdminServiceService = typeof CalendarAdminServiceService;
export const CalendarAdminServiceService = {
  /** Vue calendrier */
  getCalendarView: {
    path: "/calendar.CalendarAdminService/GetCalendarView",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCalendarViewRequest): Buffer =>
      Buffer.from(GetCalendarViewRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCalendarViewRequest => GetCalendarViewRequest.decode(value),
    responseSerialize: (value: GetCalendarViewResponse): Buffer =>
      Buffer.from(GetCalendarViewResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetCalendarViewResponse => GetCalendarViewResponse.decode(value),
  },
  getDateDetails: {
    path: "/calendar.CalendarAdminService/GetDateDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDateDetailsRequest): Buffer =>
      Buffer.from(GetDateDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDateDetailsRequest => GetDateDetailsRequest.decode(value),
    responseSerialize: (value: GetDateDetailsResponse): Buffer =>
      Buffer.from(GetDateDetailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetDateDetailsResponse => GetDateDetailsResponse.decode(value),
  },
  /** Heatmap volumes */
  getVolumeHeatmap: {
    path: "/calendar.CalendarAdminService/GetVolumeHeatmap",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVolumeHeatmapRequest): Buffer =>
      Buffer.from(GetVolumeHeatmapRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetVolumeHeatmapRequest => GetVolumeHeatmapRequest.decode(value),
    responseSerialize: (value: GetVolumeHeatmapResponse): Buffer =>
      Buffer.from(GetVolumeHeatmapResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetVolumeHeatmapResponse => GetVolumeHeatmapResponse.decode(value),
  },
  /** Import/Export CSV */
  importCsv: {
    path: "/calendar.CalendarAdminService/ImportCsv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportCsvRequest): Buffer => Buffer.from(ImportCsvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ImportCsvRequest => ImportCsvRequest.decode(value),
    responseSerialize: (value: ImportCsvResponse): Buffer => Buffer.from(ImportCsvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ImportCsvResponse => ImportCsvResponse.decode(value),
  },
  confirmCsvImport: {
    path: "/calendar.CalendarAdminService/ConfirmCsvImport",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConfirmCsvImportRequest): Buffer =>
      Buffer.from(ConfirmCsvImportRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ConfirmCsvImportRequest => ConfirmCsvImportRequest.decode(value),
    responseSerialize: (value: ConfirmCsvImportResponse): Buffer =>
      Buffer.from(ConfirmCsvImportResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConfirmCsvImportResponse => ConfirmCsvImportResponse.decode(value),
  },
  exportCalendarCsv: {
    path: "/calendar.CalendarAdminService/ExportCalendarCsv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExportCalendarCsvRequest): Buffer =>
      Buffer.from(ExportCalendarCsvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExportCalendarCsvRequest => ExportCalendarCsvRequest.decode(value),
    responseSerialize: (value: ExportCalendarCsvResponse): Buffer =>
      Buffer.from(ExportCalendarCsvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExportCalendarCsvResponse => ExportCalendarCsvResponse.decode(value),
  },
  /** Seuils */
  createVolumeThreshold: {
    path: "/calendar.CalendarAdminService/CreateVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateVolumeThresholdRequest): Buffer =>
      Buffer.from(CreateVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateVolumeThresholdRequest => CreateVolumeThresholdRequest.decode(value),
    responseSerialize: (value: VolumeThreshold): Buffer => Buffer.from(VolumeThreshold.encode(value).finish()),
    responseDeserialize: (value: Buffer): VolumeThreshold => VolumeThreshold.decode(value),
  },
  updateVolumeThreshold: {
    path: "/calendar.CalendarAdminService/UpdateVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateVolumeThresholdRequest): Buffer =>
      Buffer.from(UpdateVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateVolumeThresholdRequest => UpdateVolumeThresholdRequest.decode(value),
    responseSerialize: (value: VolumeThreshold): Buffer => Buffer.from(VolumeThreshold.encode(value).finish()),
    responseDeserialize: (value: Buffer): VolumeThreshold => VolumeThreshold.decode(value),
  },
  getVolumeThreshold: {
    path: "/calendar.CalendarAdminService/GetVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetVolumeThresholdRequest): Buffer =>
      Buffer.from(GetVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetVolumeThresholdRequest => GetVolumeThresholdRequest.decode(value),
    responseSerialize: (value: VolumeThreshold): Buffer => Buffer.from(VolumeThreshold.encode(value).finish()),
    responseDeserialize: (value: Buffer): VolumeThreshold => VolumeThreshold.decode(value),
  },
  listVolumeThresholds: {
    path: "/calendar.CalendarAdminService/ListVolumeThresholds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListVolumeThresholdsRequest): Buffer =>
      Buffer.from(ListVolumeThresholdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListVolumeThresholdsRequest => ListVolumeThresholdsRequest.decode(value),
    responseSerialize: (value: ListVolumeThresholdsResponse): Buffer =>
      Buffer.from(ListVolumeThresholdsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListVolumeThresholdsResponse => ListVolumeThresholdsResponse.decode(value),
  },
  deleteVolumeThreshold: {
    path: "/calendar.CalendarAdminService/DeleteVolumeThreshold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteVolumeThresholdRequest): Buffer =>
      Buffer.from(DeleteVolumeThresholdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteVolumeThresholdRequest => DeleteVolumeThresholdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** Audit */
  getAuditLogs: {
    path: "/calendar.CalendarAdminService/GetAuditLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditLogsRequest): Buffer => Buffer.from(GetAuditLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuditLogsRequest => GetAuditLogsRequest.decode(value),
    responseSerialize: (value: GetAuditLogsResponse): Buffer =>
      Buffer.from(GetAuditLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAuditLogsResponse => GetAuditLogsResponse.decode(value),
  },
} as const;

export interface CalendarAdminServiceServer extends UntypedServiceImplementation {
  /** Vue calendrier */
  getCalendarView: handleUnaryCall<GetCalendarViewRequest, GetCalendarViewResponse>;
  getDateDetails: handleUnaryCall<GetDateDetailsRequest, GetDateDetailsResponse>;
  /** Heatmap volumes */
  getVolumeHeatmap: handleUnaryCall<GetVolumeHeatmapRequest, GetVolumeHeatmapResponse>;
  /** Import/Export CSV */
  importCsv: handleUnaryCall<ImportCsvRequest, ImportCsvResponse>;
  confirmCsvImport: handleUnaryCall<ConfirmCsvImportRequest, ConfirmCsvImportResponse>;
  exportCalendarCsv: handleUnaryCall<ExportCalendarCsvRequest, ExportCalendarCsvResponse>;
  /** Seuils */
  createVolumeThreshold: handleUnaryCall<CreateVolumeThresholdRequest, VolumeThreshold>;
  updateVolumeThreshold: handleUnaryCall<UpdateVolumeThresholdRequest, VolumeThreshold>;
  getVolumeThreshold: handleUnaryCall<GetVolumeThresholdRequest, VolumeThreshold>;
  listVolumeThresholds: handleUnaryCall<ListVolumeThresholdsRequest, ListVolumeThresholdsResponse>;
  deleteVolumeThreshold: handleUnaryCall<DeleteVolumeThresholdRequest, DeleteResponse>;
  /** Audit */
  getAuditLogs: handleUnaryCall<GetAuditLogsRequest, GetAuditLogsResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
