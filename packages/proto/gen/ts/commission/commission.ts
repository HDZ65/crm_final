// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: commission/commission.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export enum TypeCalcul {
  TYPE_CALCUL_UNSPECIFIED = 0,
  TYPE_CALCUL_FIXE = 1,
  TYPE_CALCUL_POURCENTAGE = 2,
  TYPE_CALCUL_PALIER = 3,
  TYPE_CALCUL_MIXTE = 4,
}

export enum BaseCalcul {
  BASE_CALCUL_UNSPECIFIED = 0,
  BASE_CALCUL_COTISATION_HT = 1,
  BASE_CALCUL_CA_HT = 2,
  BASE_CALCUL_FORFAIT = 3,
}

export enum TypePalier {
  TYPE_PALIER_UNSPECIFIED = 0,
  TYPE_PALIER_VOLUME = 1,
  TYPE_PALIER_CA = 2,
  TYPE_PALIER_PRIME_PRODUIT = 3,
}

export enum StatutBordereau {
  STATUT_BORDEREAU_UNSPECIFIED = 0,
  STATUT_BORDEREAU_BROUILLON = 1,
  STATUT_BORDEREAU_VALIDE = 2,
  STATUT_BORDEREAU_EXPORTE = 3,
  STATUT_BORDEREAU_ARCHIVE = 4,
}

export enum TypeLigne {
  TYPE_LIGNE_UNSPECIFIED = 0,
  TYPE_LIGNE_COMMISSION = 1,
  TYPE_LIGNE_REPRISE = 2,
  TYPE_LIGNE_ACOMPTE = 3,
  TYPE_LIGNE_PRIME = 4,
  TYPE_LIGNE_REGULARISATION = 5,
}

export enum StatutLigne {
  STATUT_LIGNE_UNSPECIFIED = 0,
  STATUT_LIGNE_SELECTIONNEE = 1,
  STATUT_LIGNE_DESELECTIONNEE = 2,
  STATUT_LIGNE_VALIDEE = 3,
  STATUT_LIGNE_REJETEE = 4,
}

export enum TypeReprise {
  TYPE_REPRISE_UNSPECIFIED = 0,
  TYPE_REPRISE_RESILIATION = 1,
  TYPE_REPRISE_IMPAYE = 2,
  TYPE_REPRISE_ANNULATION = 3,
  TYPE_REPRISE_REGULARISATION = 4,
}

export enum StatutReprise {
  STATUT_REPRISE_UNSPECIFIED = 0,
  STATUT_REPRISE_EN_ATTENTE = 1,
  STATUT_REPRISE_APPLIQUEE = 2,
  STATUT_REPRISE_ANNULEE = 3,
}

export enum StatutRecurrence {
  STATUT_RECURRENCE_UNSPECIFIED = 0,
  STATUT_RECURRENCE_ACTIVE = 1,
  STATUT_RECURRENCE_SUSPENDUE = 2,
  STATUT_RECURRENCE_TERMINEE = 3,
  STATUT_RECURRENCE_ANNULEE = 4,
}

export enum StatutReport {
  STATUT_REPORT_UNSPECIFIED = 0,
  STATUT_REPORT_EN_COURS = 1,
  STATUT_REPORT_APURE = 2,
  STATUT_REPORT_ANNULE = 3,
}

export enum AuditScope {
  AUDIT_SCOPE_UNSPECIFIED = 0,
  AUDIT_SCOPE_COMMISSION = 1,
  AUDIT_SCOPE_RECURRENCE = 2,
  AUDIT_SCOPE_REPRISE = 3,
  AUDIT_SCOPE_REPORT = 4,
  AUDIT_SCOPE_BORDEREAU = 5,
  AUDIT_SCOPE_LIGNE = 6,
  AUDIT_SCOPE_BAREME = 7,
  AUDIT_SCOPE_PALIER = 8,
  AUDIT_SCOPE_ENGINE = 9,
}

export enum AuditAction {
  AUDIT_ACTION_UNSPECIFIED = 0,
  AUDIT_ACTION_COMMISSION_CALCULATED = 1,
  AUDIT_ACTION_COMMISSION_CREATED = 2,
  AUDIT_ACTION_COMMISSION_UPDATED = 3,
  AUDIT_ACTION_COMMISSION_DELETED = 4,
  AUDIT_ACTION_COMMISSION_STATUS_CHANGED = 5,
  AUDIT_ACTION_RECURRENCE_GENERATED = 6,
  AUDIT_ACTION_RECURRENCE_STOPPED = 7,
  AUDIT_ACTION_REPRISE_CREATED = 8,
  AUDIT_ACTION_REPRISE_APPLIED = 9,
  AUDIT_ACTION_REPRISE_CANCELLED = 10,
  AUDIT_ACTION_REPRISE_REGULARIZED = 11,
  AUDIT_ACTION_REPORT_NEGATIF_CREATED = 12,
  AUDIT_ACTION_REPORT_NEGATIF_APPLIED = 13,
  AUDIT_ACTION_REPORT_NEGATIF_CLEARED = 14,
  AUDIT_ACTION_BORDEREAU_CREATED = 15,
  AUDIT_ACTION_BORDEREAU_VALIDATED = 16,
  AUDIT_ACTION_BORDEREAU_EXPORTED = 17,
  AUDIT_ACTION_BORDEREAU_ARCHIVED = 18,
  AUDIT_ACTION_LIGNE_SELECTED = 19,
  AUDIT_ACTION_LIGNE_DESELECTED = 20,
  AUDIT_ACTION_LIGNE_VALIDATED = 21,
  AUDIT_ACTION_LIGNE_REJECTED = 22,
  AUDIT_ACTION_BAREME_CREATED = 23,
  AUDIT_ACTION_BAREME_UPDATED = 24,
  AUDIT_ACTION_BAREME_ACTIVATED = 25,
  AUDIT_ACTION_BAREME_DEACTIVATED = 26,
  AUDIT_ACTION_BAREME_VERSION_CREATED = 27,
  AUDIT_ACTION_PALIER_CREATED = 28,
  AUDIT_ACTION_PALIER_UPDATED = 29,
  AUDIT_ACTION_PALIER_DELETED = 30,
}

export interface GetByIdRequest {
  id: string;
}

export interface GetByBaremeRequest {
  baremeId: string;
}

export interface GetByBordereauRequest {
  bordereauId: string;
}

export interface GetByCommissionRequest {
  commissionId: string;
}

export interface GetByApporteurRequest {
  organisationId: string;
  apporteurId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetByPeriodeRequest {
  organisationId: string;
  periode: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface Commission {
  id: string;
  organisationId: string;
  reference: string;
  apporteurId: string;
  contratId: string;
  produitId?: string | undefined;
  compagnie: string;
  typeBase: string;
  montantBrut: string;
  montantReprises: string;
  montantAcomptes: string;
  montantNetAPayer: string;
  statutId: string;
  periode: string;
  dateCreation: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateCommissionRequest {
  organisationId: string;
  reference: string;
  apporteurId: string;
  contratId: string;
  produitId?: string | undefined;
  compagnie: string;
  typeBase: string;
  montantBrut: string;
  montantReprises: string;
  montantAcomptes: string;
  montantNetAPayer: string;
  statutId: string;
  periode: string;
  dateCreation: string;
}

export interface GetCommissionsRequest {
  organisationId: string;
  apporteurId?: string | undefined;
  periode?: string | undefined;
  statutId?: string | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface UpdateCommissionRequest {
  id: string;
  reference?: string | undefined;
  compagnie?: string | undefined;
  typeBase?: string | undefined;
  montantBrut?: string | undefined;
  montantReprises?: string | undefined;
  montantAcomptes?: string | undefined;
  montantNetAPayer?: string | undefined;
  statutId?: string | undefined;
}

export interface CommissionResponse {
  commission?: Commission | undefined;
}

export interface CommissionListResponse {
  commissions: Commission[];
  total: number;
}

export interface Bareme {
  id: string;
  organisationId: string;
  code: string;
  nom: string;
  description?: string | undefined;
  typeCalcul: TypeCalcul;
  baseCalcul: BaseCalcul;
  montantFixe?: string | undefined;
  tauxPourcentage?: string | undefined;
  recurrenceActive: boolean;
  tauxRecurrence?: string | undefined;
  dureeRecurrenceMois?: number | undefined;
  dureeReprisesMois: number;
  tauxReprise: string;
  typeProduit?: string | undefined;
  profilRemuneration?: string | undefined;
  societeId?: string | undefined;
  canalVente?: string | undefined;
  repartitionCommercial: string;
  repartitionManager: string;
  repartitionAgence: string;
  repartitionEntreprise: string;
  version: number;
  dateEffet: string;
  dateFin?: string | undefined;
  actif: boolean;
  createdAt: string;
  updatedAt: string;
  paliers: Palier[];
}

export interface CreateBaremeRequest {
  organisationId: string;
  code: string;
  nom: string;
  description?: string | undefined;
  typeCalcul: TypeCalcul;
  baseCalcul: BaseCalcul;
  montantFixe?: string | undefined;
  tauxPourcentage?: string | undefined;
  recurrenceActive: boolean;
  tauxRecurrence?: string | undefined;
  dureeRecurrenceMois?: number | undefined;
  dureeReprisesMois: number;
  tauxReprise: string;
  typeProduit?: string | undefined;
  profilRemuneration?: string | undefined;
  societeId?: string | undefined;
  canalVente?: string | undefined;
  repartitionCommercial: string;
  repartitionManager: string;
  repartitionAgence: string;
  repartitionEntreprise: string;
  dateEffet: string;
  dateFin?: string | undefined;
}

export interface GetBaremesRequest {
  organisationId: string;
  actifOnly?: boolean | undefined;
  typeProduit?: string | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetBaremeApplicableRequest {
  organisationId: string;
  typeProduit?: string | undefined;
  profilRemuneration?: string | undefined;
  societeId?: string | undefined;
  canalVente?: string | undefined;
  date: string;
}

export interface UpdateBaremeRequest {
  id: string;
  nom?: string | undefined;
  description?: string | undefined;
  typeCalcul?: TypeCalcul | undefined;
  baseCalcul?: BaseCalcul | undefined;
  montantFixe?: string | undefined;
  tauxPourcentage?: string | undefined;
  recurrenceActive?: boolean | undefined;
  tauxRecurrence?: string | undefined;
  dureeRecurrenceMois?: number | undefined;
  dureeReprisesMois?: number | undefined;
  tauxReprise?: string | undefined;
  dateFin?: string | undefined;
  actif?: boolean | undefined;
}

export interface BaremeResponse {
  bareme?: Bareme | undefined;
}

export interface BaremeListResponse {
  baremes: Bareme[];
  total: number;
}

export interface Palier {
  id: string;
  organisationId: string;
  baremeId: string;
  code: string;
  nom: string;
  description?: string | undefined;
  typePalier: TypePalier;
  seuilMin: string;
  seuilMax?: string | undefined;
  montantPrime: string;
  tauxBonus?: string | undefined;
  cumulable: boolean;
  parPeriode: boolean;
  typeProduit?: string | undefined;
  ordre: number;
  actif: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreatePalierRequest {
  organisationId: string;
  baremeId: string;
  code: string;
  nom: string;
  description?: string | undefined;
  typePalier: TypePalier;
  seuilMin: string;
  seuilMax?: string | undefined;
  montantPrime: string;
  tauxBonus?: string | undefined;
  cumulable: boolean;
  parPeriode: boolean;
  typeProduit?: string | undefined;
  ordre: number;
}

export interface UpdatePalierRequest {
  id: string;
  nom?: string | undefined;
  description?: string | undefined;
  seuilMin?: string | undefined;
  seuilMax?: string | undefined;
  montantPrime?: string | undefined;
  tauxBonus?: string | undefined;
  cumulable?: boolean | undefined;
  parPeriode?: boolean | undefined;
  ordre?: number | undefined;
  actif?: boolean | undefined;
}

export interface PalierResponse {
  palier?: Palier | undefined;
}

export interface PalierListResponse {
  paliers: Palier[];
  total: number;
}

export interface Bordereau {
  id: string;
  organisationId: string;
  reference: string;
  periode: string;
  apporteurId: string;
  totalBrut: string;
  totalReprises: string;
  totalAcomptes: string;
  totalNetAPayer: string;
  nombreLignes: number;
  statutBordereau: StatutBordereau;
  dateValidation?: string | undefined;
  validateurId?: string | undefined;
  dateExport?: string | undefined;
  fichierPdfUrl?: string | undefined;
  fichierExcelUrl?: string | undefined;
  commentaire?: string | undefined;
  createdAt: string;
  updatedAt: string;
  lignes: LigneBordereau[];
}

export interface CreateBordereauRequest {
  organisationId: string;
  reference: string;
  periode: string;
  apporteurId: string;
  commentaire?: string | undefined;
  creePar?: string | undefined;
}

export interface GetBordereauxRequest {
  organisationId: string;
  apporteurId?: string | undefined;
  periode?: string | undefined;
  statut?: StatutBordereau | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetBordereauByApporteurPeriodeRequest {
  organisationId: string;
  apporteurId: string;
  periode: string;
}

export interface UpdateBordereauRequest {
  id: string;
  commentaire?: string | undefined;
  statutBordereau?: StatutBordereau | undefined;
}

export interface ValidateBordereauRequest {
  id: string;
  validateurId: string;
}

export interface ExportBordereauResponse {
  success: boolean;
  pdfUrl: string;
  excelUrl: string;
}

export interface BordereauResponse {
  bordereau?: Bordereau | undefined;
}

export interface BordereauListResponse {
  bordereaux: Bordereau[];
  total: number;
}

export interface LigneBordereau {
  id: string;
  organisationId: string;
  bordereauId: string;
  commissionId?: string | undefined;
  repriseId?: string | undefined;
  typeLigne: TypeLigne;
  contratId: string;
  contratReference: string;
  clientNom?: string | undefined;
  produitNom?: string | undefined;
  montantBrut: string;
  montantReprise: string;
  montantNet: string;
  baseCalcul?: string | undefined;
  tauxApplique?: string | undefined;
  baremeId?: string | undefined;
  statutLigne: StatutLigne;
  selectionne: boolean;
  motifDeselection?: string | undefined;
  validateurId?: string | undefined;
  dateValidation?: string | undefined;
  ordre: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateLigneBordereauRequest {
  organisationId: string;
  bordereauId: string;
  commissionId?: string | undefined;
  repriseId?: string | undefined;
  typeLigne: TypeLigne;
  contratId: string;
  contratReference: string;
  clientNom?: string | undefined;
  produitNom?: string | undefined;
  montantBrut: string;
  montantReprise: string;
  montantNet: string;
  baseCalcul?: string | undefined;
  tauxApplique?: string | undefined;
  baremeId?: string | undefined;
  ordre: number;
}

export interface UpdateLigneBordereauRequest {
  id: string;
  montantBrut?: string | undefined;
  montantReprise?: string | undefined;
  montantNet?: string | undefined;
  selectionne?: boolean | undefined;
  motifDeselection?: string | undefined;
  ordre?: number | undefined;
}

export interface ValidateLigneRequest {
  id: string;
  validateurId: string;
  statut: StatutLigne;
  motif?: string | undefined;
}

export interface LigneBordereauResponse {
  ligne?: LigneBordereau | undefined;
}

export interface LigneBordereauListResponse {
  lignes: LigneBordereau[];
  total: number;
}

export interface Reprise {
  id: string;
  organisationId: string;
  commissionOriginaleId: string;
  contratId: string;
  apporteurId: string;
  reference: string;
  typeReprise: TypeReprise;
  montantReprise: string;
  tauxReprise: string;
  montantOriginal: string;
  periodeOrigine: string;
  periodeApplication: string;
  dateEvenement: string;
  dateLimite: string;
  dateApplication?: string | undefined;
  statutReprise: StatutReprise;
  bordereauId?: string | undefined;
  motif?: string | undefined;
  commentaire?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface CreateRepriseRequest {
  organisationId: string;
  commissionOriginaleId: string;
  contratId: string;
  apporteurId: string;
  reference: string;
  typeReprise: TypeReprise;
  montantReprise: string;
  tauxReprise: string;
  montantOriginal: string;
  periodeOrigine: string;
  periodeApplication: string;
  dateEvenement: string;
  dateLimite: string;
  motif?: string | undefined;
  commentaire?: string | undefined;
}

export interface GetReprisesRequest {
  organisationId: string;
  apporteurId?: string | undefined;
  statut?: StatutReprise | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface ApplyRepriseRequest {
  id: string;
  bordereauId: string;
}

export interface RepriseResponse {
  reprise?: Reprise | undefined;
}

export interface RepriseListResponse {
  reprises: Reprise[];
  total: number;
}

export interface RecurrenceCommission {
  id: string;
  organisationId: string;
  commissionInitialeId: string;
  contratId: string;
  echeanceId?: string | undefined;
  apporteurId: string;
  baremeId: string;
  baremeVersion: number;
  periode: string;
  numeroMois: number;
  montantBase: string;
  tauxRecurrence: string;
  montantCalcule: string;
  statutRecurrence: StatutRecurrence;
  bordereauId?: string | undefined;
  dateEncaissement?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface GetRecurrencesRequest {
  organisationId: string;
  apporteurId?: string | undefined;
  periode?: string | undefined;
  statut?: StatutRecurrence | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetRecurrencesByContratRequest {
  organisationId: string;
  contratId: string;
}

export interface RecurrenceListResponse {
  recurrences: RecurrenceCommission[];
  total: number;
}

export interface ReportNegatif {
  id: string;
  organisationId: string;
  apporteurId: string;
  periodeOrigine: string;
  montantInitial: string;
  montantRestant: string;
  statutReport: StatutReport;
  bordereauOrigineId?: string | undefined;
  dernierePeriodeApplication?: string | undefined;
  motif?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface GetReportsNegatifsRequest {
  organisationId: string;
  apporteurId?: string | undefined;
  statut?: StatutReport | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface ReportNegatifListResponse {
  reports: ReportNegatif[];
  total: number;
}

export interface StatutCommission {
  id: string;
  code: string;
  nom: string;
  description?: string | undefined;
  ordreAffichage: number;
}

export interface CreateStatutRequest {
  code: string;
  nom: string;
  description?: string | undefined;
  ordreAffichage: number;
}

export interface GetStatutsRequest {
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetStatutByCodeRequest {
  code: string;
}

export interface UpdateStatutRequest {
  id: string;
  nom?: string | undefined;
  description?: string | undefined;
  ordreAffichage?: number | undefined;
}

export interface StatutResponse {
  statut?: StatutCommission | undefined;
}

export interface StatutListResponse {
  statuts: StatutCommission[];
  total: number;
}

export interface CalculerCommissionRequest {
  organisationId: string;
  apporteurId: string;
  contratId: string;
  produitId?: string | undefined;
  typeProduit: string;
  profilRemuneration: string;
  societeId?: string | undefined;
  canalVente?: string | undefined;
  montantBase: string;
  periode: string;
}

export interface PrimeApplicable {
  palierId: string;
  palierNom: string;
  montant: string;
  type: string;
}

export interface CalculerCommissionResponse {
  commission?: Commission | undefined;
  baremeApplique?: Bareme | undefined;
  primes: PrimeApplicable[];
  montantTotal: string;
}

export interface GenererBordereauRequest {
  organisationId: string;
  apporteurId: string;
  periode: string;
  creePar?: string | undefined;
}

export interface BordereauSummary {
  nombreCommissions: number;
  nombreReprises: number;
  nombrePrimes: number;
  totalBrut: string;
  totalReprises: string;
  totalNet: string;
}

export interface GenererBordereauResponse {
  bordereau?: Bordereau | undefined;
  summary?: BordereauSummary | undefined;
}

export interface DeclencherRepriseRequest {
  commissionId: string;
  typeReprise: TypeReprise;
  dateEvenement: string;
  motif?: string | undefined;
}

export interface AuditLog {
  id: string;
  organisationId: string;
  scope: AuditScope;
  refId?: string | undefined;
  action: AuditAction;
  beforeData?: string | undefined;
  afterData?: string | undefined;
  metadata?: string | undefined;
  userId?: string | undefined;
  userName?: string | undefined;
  ipAddress?: string | undefined;
  motif?: string | undefined;
  baremeId?: string | undefined;
  baremeVersion?: number | undefined;
  contratId?: string | undefined;
  apporteurId?: string | undefined;
  periode?: string | undefined;
  montantCalcule?: string | undefined;
  createdAt: string;
}

export interface GetAuditLogsRequest {
  organisationId: string;
  scope?: AuditScope | undefined;
  action?: AuditAction | undefined;
  refId?: string | undefined;
  userId?: string | undefined;
  apporteurId?: string | undefined;
  contratId?: string | undefined;
  baremeId?: string | undefined;
  periode?: string | undefined;
  dateFrom?: string | undefined;
  dateTo?: string | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetAuditLogsByRefRequest {
  organisationId: string;
  scope: AuditScope;
  refId: string;
}

export interface AuditLogListResponse {
  logs: AuditLog[];
  total: number;
}

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "" };
}

export const GetByIdRequest: MessageFns<GetByIdRequest> = {
  encode(message: GetByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByBaremeRequest(): GetByBaremeRequest {
  return { baremeId: "" };
}

export const GetByBaremeRequest: MessageFns<GetByBaremeRequest> = {
  encode(message: GetByBaremeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baremeId !== "") {
      writer.uint32(10).string(message.baremeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByBaremeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByBaremeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByBordereauRequest(): GetByBordereauRequest {
  return { bordereauId: "" };
}

export const GetByBordereauRequest: MessageFns<GetByBordereauRequest> = {
  encode(message: GetByBordereauRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bordereauId !== "") {
      writer.uint32(10).string(message.bordereauId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByBordereauRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByBordereauRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bordereauId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByCommissionRequest(): GetByCommissionRequest {
  return { commissionId: "" };
}

export const GetByCommissionRequest: MessageFns<GetByCommissionRequest> = {
  encode(message: GetByCommissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commissionId !== "") {
      writer.uint32(10).string(message.commissionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByCommissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByCommissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commissionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByApporteurRequest(): GetByApporteurRequest {
  return { organisationId: "", apporteurId: "" };
}

export const GetByApporteurRequest: MessageFns<GetByApporteurRequest> = {
  encode(message: GetByApporteurRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.limit !== undefined) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByApporteurRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByApporteurRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByPeriodeRequest(): GetByPeriodeRequest {
  return { organisationId: "", periode: "" };
}

export const GetByPeriodeRequest: MessageFns<GetByPeriodeRequest> = {
  encode(message: GetByPeriodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.periode !== "") {
      writer.uint32(18).string(message.periode);
    }
    if (message.limit !== undefined) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByPeriodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByPeriodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCommission(): Commission {
  return {
    id: "",
    organisationId: "",
    reference: "",
    apporteurId: "",
    contratId: "",
    compagnie: "",
    typeBase: "",
    montantBrut: "",
    montantReprises: "",
    montantAcomptes: "",
    montantNetAPayer: "",
    statutId: "",
    periode: "",
    dateCreation: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Commission: MessageFns<Commission> = {
  encode(message: Commission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.reference !== "") {
      writer.uint32(26).string(message.reference);
    }
    if (message.apporteurId !== "") {
      writer.uint32(34).string(message.apporteurId);
    }
    if (message.contratId !== "") {
      writer.uint32(42).string(message.contratId);
    }
    if (message.produitId !== undefined) {
      writer.uint32(50).string(message.produitId);
    }
    if (message.compagnie !== "") {
      writer.uint32(58).string(message.compagnie);
    }
    if (message.typeBase !== "") {
      writer.uint32(66).string(message.typeBase);
    }
    if (message.montantBrut !== "") {
      writer.uint32(74).string(message.montantBrut);
    }
    if (message.montantReprises !== "") {
      writer.uint32(82).string(message.montantReprises);
    }
    if (message.montantAcomptes !== "") {
      writer.uint32(90).string(message.montantAcomptes);
    }
    if (message.montantNetAPayer !== "") {
      writer.uint32(98).string(message.montantNetAPayer);
    }
    if (message.statutId !== "") {
      writer.uint32(106).string(message.statutId);
    }
    if (message.periode !== "") {
      writer.uint32(114).string(message.periode);
    }
    if (message.dateCreation !== "") {
      writer.uint32(122).string(message.dateCreation);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(138).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Commission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.compagnie = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.typeBase = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.montantBrut = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.montantReprises = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.montantAcomptes = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.montantNetAPayer = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.dateCreation = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCommissionRequest(): CreateCommissionRequest {
  return {
    organisationId: "",
    reference: "",
    apporteurId: "",
    contratId: "",
    compagnie: "",
    typeBase: "",
    montantBrut: "",
    montantReprises: "",
    montantAcomptes: "",
    montantNetAPayer: "",
    statutId: "",
    periode: "",
    dateCreation: "",
  };
}

export const CreateCommissionRequest: MessageFns<CreateCommissionRequest> = {
  encode(message: CreateCommissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.reference !== "") {
      writer.uint32(18).string(message.reference);
    }
    if (message.apporteurId !== "") {
      writer.uint32(26).string(message.apporteurId);
    }
    if (message.contratId !== "") {
      writer.uint32(34).string(message.contratId);
    }
    if (message.produitId !== undefined) {
      writer.uint32(42).string(message.produitId);
    }
    if (message.compagnie !== "") {
      writer.uint32(50).string(message.compagnie);
    }
    if (message.typeBase !== "") {
      writer.uint32(58).string(message.typeBase);
    }
    if (message.montantBrut !== "") {
      writer.uint32(66).string(message.montantBrut);
    }
    if (message.montantReprises !== "") {
      writer.uint32(74).string(message.montantReprises);
    }
    if (message.montantAcomptes !== "") {
      writer.uint32(82).string(message.montantAcomptes);
    }
    if (message.montantNetAPayer !== "") {
      writer.uint32(90).string(message.montantNetAPayer);
    }
    if (message.statutId !== "") {
      writer.uint32(98).string(message.statutId);
    }
    if (message.periode !== "") {
      writer.uint32(106).string(message.periode);
    }
    if (message.dateCreation !== "") {
      writer.uint32(114).string(message.dateCreation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCommissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCommissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.compagnie = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.typeBase = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.montantBrut = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.montantReprises = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.montantAcomptes = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.montantNetAPayer = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dateCreation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCommissionsRequest(): GetCommissionsRequest {
  return { organisationId: "" };
}

export const GetCommissionsRequest: MessageFns<GetCommissionsRequest> = {
  encode(message: GetCommissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== undefined) {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.periode !== undefined) {
      writer.uint32(26).string(message.periode);
    }
    if (message.statutId !== undefined) {
      writer.uint32(34).string(message.statutId);
    }
    if (message.limit !== undefined) {
      writer.uint32(40).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(48).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCommissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCommissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateCommissionRequest(): UpdateCommissionRequest {
  return { id: "" };
}

export const UpdateCommissionRequest: MessageFns<UpdateCommissionRequest> = {
  encode(message: UpdateCommissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reference !== undefined) {
      writer.uint32(18).string(message.reference);
    }
    if (message.compagnie !== undefined) {
      writer.uint32(26).string(message.compagnie);
    }
    if (message.typeBase !== undefined) {
      writer.uint32(34).string(message.typeBase);
    }
    if (message.montantBrut !== undefined) {
      writer.uint32(42).string(message.montantBrut);
    }
    if (message.montantReprises !== undefined) {
      writer.uint32(50).string(message.montantReprises);
    }
    if (message.montantAcomptes !== undefined) {
      writer.uint32(58).string(message.montantAcomptes);
    }
    if (message.montantNetAPayer !== undefined) {
      writer.uint32(66).string(message.montantNetAPayer);
    }
    if (message.statutId !== undefined) {
      writer.uint32(74).string(message.statutId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCommissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCommissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.compagnie = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typeBase = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.montantBrut = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.montantReprises = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.montantAcomptes = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.montantNetAPayer = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCommissionResponse(): CommissionResponse {
  return {};
}

export const CommissionResponse: MessageFns<CommissionResponse> = {
  encode(message: CommissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commission !== undefined) {
      Commission.encode(message.commission, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commission = Commission.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCommissionListResponse(): CommissionListResponse {
  return { commissions: [], total: 0 };
}

export const CommissionListResponse: MessageFns<CommissionListResponse> = {
  encode(message: CommissionListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.commissions) {
      Commission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommissionListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommissionListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commissions.push(Commission.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBareme(): Bareme {
  return {
    id: "",
    organisationId: "",
    code: "",
    nom: "",
    typeCalcul: 0,
    baseCalcul: 0,
    recurrenceActive: false,
    dureeReprisesMois: 0,
    tauxReprise: "",
    repartitionCommercial: "",
    repartitionManager: "",
    repartitionAgence: "",
    repartitionEntreprise: "",
    version: 0,
    dateEffet: "",
    actif: false,
    createdAt: "",
    updatedAt: "",
    paliers: [],
  };
}

export const Bareme: MessageFns<Bareme> = {
  encode(message: Bareme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(34).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.typeCalcul !== 0) {
      writer.uint32(48).int32(message.typeCalcul);
    }
    if (message.baseCalcul !== 0) {
      writer.uint32(56).int32(message.baseCalcul);
    }
    if (message.montantFixe !== undefined) {
      writer.uint32(66).string(message.montantFixe);
    }
    if (message.tauxPourcentage !== undefined) {
      writer.uint32(74).string(message.tauxPourcentage);
    }
    if (message.recurrenceActive !== false) {
      writer.uint32(80).bool(message.recurrenceActive);
    }
    if (message.tauxRecurrence !== undefined) {
      writer.uint32(90).string(message.tauxRecurrence);
    }
    if (message.dureeRecurrenceMois !== undefined) {
      writer.uint32(96).int32(message.dureeRecurrenceMois);
    }
    if (message.dureeReprisesMois !== 0) {
      writer.uint32(104).int32(message.dureeReprisesMois);
    }
    if (message.tauxReprise !== "") {
      writer.uint32(114).string(message.tauxReprise);
    }
    if (message.typeProduit !== undefined) {
      writer.uint32(122).string(message.typeProduit);
    }
    if (message.profilRemuneration !== undefined) {
      writer.uint32(130).string(message.profilRemuneration);
    }
    if (message.societeId !== undefined) {
      writer.uint32(138).string(message.societeId);
    }
    if (message.canalVente !== undefined) {
      writer.uint32(146).string(message.canalVente);
    }
    if (message.repartitionCommercial !== "") {
      writer.uint32(154).string(message.repartitionCommercial);
    }
    if (message.repartitionManager !== "") {
      writer.uint32(162).string(message.repartitionManager);
    }
    if (message.repartitionAgence !== "") {
      writer.uint32(170).string(message.repartitionAgence);
    }
    if (message.repartitionEntreprise !== "") {
      writer.uint32(178).string(message.repartitionEntreprise);
    }
    if (message.version !== 0) {
      writer.uint32(184).int32(message.version);
    }
    if (message.dateEffet !== "") {
      writer.uint32(194).string(message.dateEffet);
    }
    if (message.dateFin !== undefined) {
      writer.uint32(202).string(message.dateFin);
    }
    if (message.actif !== false) {
      writer.uint32(208).bool(message.actif);
    }
    if (message.createdAt !== "") {
      writer.uint32(218).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(226).string(message.updatedAt);
    }
    for (const v of message.paliers) {
      Palier.encode(v!, writer.uint32(234).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bareme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBareme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.typeCalcul = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.baseCalcul = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.montantFixe = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tauxPourcentage = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.recurrenceActive = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tauxRecurrence = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.dureeRecurrenceMois = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.dureeReprisesMois = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.tauxReprise = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.typeProduit = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.profilRemuneration = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.canalVente = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.repartitionCommercial = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.repartitionManager = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.repartitionAgence = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.repartitionEntreprise = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.dateEffet = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.paliers.push(Palier.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateBaremeRequest(): CreateBaremeRequest {
  return {
    organisationId: "",
    code: "",
    nom: "",
    typeCalcul: 0,
    baseCalcul: 0,
    recurrenceActive: false,
    dureeReprisesMois: 0,
    tauxReprise: "",
    repartitionCommercial: "",
    repartitionManager: "",
    repartitionAgence: "",
    repartitionEntreprise: "",
    dateEffet: "",
  };
}

export const CreateBaremeRequest: MessageFns<CreateBaremeRequest> = {
  encode(message: CreateBaremeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.typeCalcul !== 0) {
      writer.uint32(40).int32(message.typeCalcul);
    }
    if (message.baseCalcul !== 0) {
      writer.uint32(48).int32(message.baseCalcul);
    }
    if (message.montantFixe !== undefined) {
      writer.uint32(58).string(message.montantFixe);
    }
    if (message.tauxPourcentage !== undefined) {
      writer.uint32(66).string(message.tauxPourcentage);
    }
    if (message.recurrenceActive !== false) {
      writer.uint32(72).bool(message.recurrenceActive);
    }
    if (message.tauxRecurrence !== undefined) {
      writer.uint32(82).string(message.tauxRecurrence);
    }
    if (message.dureeRecurrenceMois !== undefined) {
      writer.uint32(88).int32(message.dureeRecurrenceMois);
    }
    if (message.dureeReprisesMois !== 0) {
      writer.uint32(96).int32(message.dureeReprisesMois);
    }
    if (message.tauxReprise !== "") {
      writer.uint32(106).string(message.tauxReprise);
    }
    if (message.typeProduit !== undefined) {
      writer.uint32(114).string(message.typeProduit);
    }
    if (message.profilRemuneration !== undefined) {
      writer.uint32(122).string(message.profilRemuneration);
    }
    if (message.societeId !== undefined) {
      writer.uint32(130).string(message.societeId);
    }
    if (message.canalVente !== undefined) {
      writer.uint32(138).string(message.canalVente);
    }
    if (message.repartitionCommercial !== "") {
      writer.uint32(146).string(message.repartitionCommercial);
    }
    if (message.repartitionManager !== "") {
      writer.uint32(154).string(message.repartitionManager);
    }
    if (message.repartitionAgence !== "") {
      writer.uint32(162).string(message.repartitionAgence);
    }
    if (message.repartitionEntreprise !== "") {
      writer.uint32(170).string(message.repartitionEntreprise);
    }
    if (message.dateEffet !== "") {
      writer.uint32(178).string(message.dateEffet);
    }
    if (message.dateFin !== undefined) {
      writer.uint32(186).string(message.dateFin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBaremeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBaremeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.typeCalcul = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.baseCalcul = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.montantFixe = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tauxPourcentage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.recurrenceActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tauxRecurrence = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.dureeRecurrenceMois = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.dureeReprisesMois = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.tauxReprise = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.typeProduit = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.profilRemuneration = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.canalVente = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.repartitionCommercial = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.repartitionManager = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.repartitionAgence = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.repartitionEntreprise = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.dateEffet = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetBaremesRequest(): GetBaremesRequest {
  return { organisationId: "" };
}

export const GetBaremesRequest: MessageFns<GetBaremesRequest> = {
  encode(message: GetBaremesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.actifOnly !== undefined) {
      writer.uint32(16).bool(message.actifOnly);
    }
    if (message.typeProduit !== undefined) {
      writer.uint32(26).string(message.typeProduit);
    }
    if (message.limit !== undefined) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(40).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBaremesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBaremesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actifOnly = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.typeProduit = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetBaremeApplicableRequest(): GetBaremeApplicableRequest {
  return { organisationId: "", date: "" };
}

export const GetBaremeApplicableRequest: MessageFns<GetBaremeApplicableRequest> = {
  encode(message: GetBaremeApplicableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.typeProduit !== undefined) {
      writer.uint32(18).string(message.typeProduit);
    }
    if (message.profilRemuneration !== undefined) {
      writer.uint32(26).string(message.profilRemuneration);
    }
    if (message.societeId !== undefined) {
      writer.uint32(34).string(message.societeId);
    }
    if (message.canalVente !== undefined) {
      writer.uint32(42).string(message.canalVente);
    }
    if (message.date !== "") {
      writer.uint32(50).string(message.date);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBaremeApplicableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBaremeApplicableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeProduit = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.profilRemuneration = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.canalVente = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.date = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateBaremeRequest(): UpdateBaremeRequest {
  return { id: "" };
}

export const UpdateBaremeRequest: MessageFns<UpdateBaremeRequest> = {
  encode(message: UpdateBaremeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.typeCalcul !== undefined) {
      writer.uint32(32).int32(message.typeCalcul);
    }
    if (message.baseCalcul !== undefined) {
      writer.uint32(40).int32(message.baseCalcul);
    }
    if (message.montantFixe !== undefined) {
      writer.uint32(50).string(message.montantFixe);
    }
    if (message.tauxPourcentage !== undefined) {
      writer.uint32(58).string(message.tauxPourcentage);
    }
    if (message.recurrenceActive !== undefined) {
      writer.uint32(64).bool(message.recurrenceActive);
    }
    if (message.tauxRecurrence !== undefined) {
      writer.uint32(74).string(message.tauxRecurrence);
    }
    if (message.dureeRecurrenceMois !== undefined) {
      writer.uint32(80).int32(message.dureeRecurrenceMois);
    }
    if (message.dureeReprisesMois !== undefined) {
      writer.uint32(88).int32(message.dureeReprisesMois);
    }
    if (message.tauxReprise !== undefined) {
      writer.uint32(98).string(message.tauxReprise);
    }
    if (message.dateFin !== undefined) {
      writer.uint32(106).string(message.dateFin);
    }
    if (message.actif !== undefined) {
      writer.uint32(112).bool(message.actif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBaremeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBaremeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.typeCalcul = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.baseCalcul = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.montantFixe = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tauxPourcentage = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.recurrenceActive = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tauxRecurrence = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.dureeRecurrenceMois = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.dureeReprisesMois = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tauxReprise = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBaremeResponse(): BaremeResponse {
  return {};
}

export const BaremeResponse: MessageFns<BaremeResponse> = {
  encode(message: BaremeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bareme !== undefined) {
      Bareme.encode(message.bareme, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaremeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaremeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bareme = Bareme.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBaremeListResponse(): BaremeListResponse {
  return { baremes: [], total: 0 };
}

export const BaremeListResponse: MessageFns<BaremeListResponse> = {
  encode(message: BaremeListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.baremes) {
      Bareme.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaremeListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaremeListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baremes.push(Bareme.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePalier(): Palier {
  return {
    id: "",
    organisationId: "",
    baremeId: "",
    code: "",
    nom: "",
    typePalier: 0,
    seuilMin: "",
    montantPrime: "",
    cumulable: false,
    parPeriode: false,
    ordre: 0,
    actif: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Palier: MessageFns<Palier> = {
  encode(message: Palier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.baremeId !== "") {
      writer.uint32(26).string(message.baremeId);
    }
    if (message.code !== "") {
      writer.uint32(34).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(42).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    if (message.typePalier !== 0) {
      writer.uint32(56).int32(message.typePalier);
    }
    if (message.seuilMin !== "") {
      writer.uint32(66).string(message.seuilMin);
    }
    if (message.seuilMax !== undefined) {
      writer.uint32(74).string(message.seuilMax);
    }
    if (message.montantPrime !== "") {
      writer.uint32(82).string(message.montantPrime);
    }
    if (message.tauxBonus !== undefined) {
      writer.uint32(90).string(message.tauxBonus);
    }
    if (message.cumulable !== false) {
      writer.uint32(96).bool(message.cumulable);
    }
    if (message.parPeriode !== false) {
      writer.uint32(104).bool(message.parPeriode);
    }
    if (message.typeProduit !== undefined) {
      writer.uint32(114).string(message.typeProduit);
    }
    if (message.ordre !== 0) {
      writer.uint32(120).int32(message.ordre);
    }
    if (message.actif !== false) {
      writer.uint32(128).bool(message.actif);
    }
    if (message.createdAt !== "") {
      writer.uint32(138).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(146).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Palier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePalier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.typePalier = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.seuilMin = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.seuilMax = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.montantPrime = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tauxBonus = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.cumulable = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.parPeriode = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.typeProduit = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePalierRequest(): CreatePalierRequest {
  return {
    organisationId: "",
    baremeId: "",
    code: "",
    nom: "",
    typePalier: 0,
    seuilMin: "",
    montantPrime: "",
    cumulable: false,
    parPeriode: false,
    ordre: 0,
  };
}

export const CreatePalierRequest: MessageFns<CreatePalierRequest> = {
  encode(message: CreatePalierRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.baremeId !== "") {
      writer.uint32(18).string(message.baremeId);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(34).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.typePalier !== 0) {
      writer.uint32(48).int32(message.typePalier);
    }
    if (message.seuilMin !== "") {
      writer.uint32(58).string(message.seuilMin);
    }
    if (message.seuilMax !== undefined) {
      writer.uint32(66).string(message.seuilMax);
    }
    if (message.montantPrime !== "") {
      writer.uint32(74).string(message.montantPrime);
    }
    if (message.tauxBonus !== undefined) {
      writer.uint32(82).string(message.tauxBonus);
    }
    if (message.cumulable !== false) {
      writer.uint32(88).bool(message.cumulable);
    }
    if (message.parPeriode !== false) {
      writer.uint32(96).bool(message.parPeriode);
    }
    if (message.typeProduit !== undefined) {
      writer.uint32(106).string(message.typeProduit);
    }
    if (message.ordre !== 0) {
      writer.uint32(112).int32(message.ordre);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePalierRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePalierRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.typePalier = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.seuilMin = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.seuilMax = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.montantPrime = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tauxBonus = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.cumulable = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.parPeriode = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.typeProduit = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePalierRequest(): UpdatePalierRequest {
  return { id: "" };
}

export const UpdatePalierRequest: MessageFns<UpdatePalierRequest> = {
  encode(message: UpdatePalierRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.seuilMin !== undefined) {
      writer.uint32(34).string(message.seuilMin);
    }
    if (message.seuilMax !== undefined) {
      writer.uint32(42).string(message.seuilMax);
    }
    if (message.montantPrime !== undefined) {
      writer.uint32(50).string(message.montantPrime);
    }
    if (message.tauxBonus !== undefined) {
      writer.uint32(58).string(message.tauxBonus);
    }
    if (message.cumulable !== undefined) {
      writer.uint32(64).bool(message.cumulable);
    }
    if (message.parPeriode !== undefined) {
      writer.uint32(72).bool(message.parPeriode);
    }
    if (message.ordre !== undefined) {
      writer.uint32(80).int32(message.ordre);
    }
    if (message.actif !== undefined) {
      writer.uint32(88).bool(message.actif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePalierRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePalierRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.seuilMin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.seuilMax = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.montantPrime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tauxBonus = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cumulable = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.parPeriode = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePalierResponse(): PalierResponse {
  return {};
}

export const PalierResponse: MessageFns<PalierResponse> = {
  encode(message: PalierResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.palier !== undefined) {
      Palier.encode(message.palier, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PalierResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePalierResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.palier = Palier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePalierListResponse(): PalierListResponse {
  return { paliers: [], total: 0 };
}

export const PalierListResponse: MessageFns<PalierListResponse> = {
  encode(message: PalierListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.paliers) {
      Palier.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PalierListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePalierListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paliers.push(Palier.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBordereau(): Bordereau {
  return {
    id: "",
    organisationId: "",
    reference: "",
    periode: "",
    apporteurId: "",
    totalBrut: "",
    totalReprises: "",
    totalAcomptes: "",
    totalNetAPayer: "",
    nombreLignes: 0,
    statutBordereau: 0,
    createdAt: "",
    updatedAt: "",
    lignes: [],
  };
}

export const Bordereau: MessageFns<Bordereau> = {
  encode(message: Bordereau, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.reference !== "") {
      writer.uint32(26).string(message.reference);
    }
    if (message.periode !== "") {
      writer.uint32(34).string(message.periode);
    }
    if (message.apporteurId !== "") {
      writer.uint32(42).string(message.apporteurId);
    }
    if (message.totalBrut !== "") {
      writer.uint32(50).string(message.totalBrut);
    }
    if (message.totalReprises !== "") {
      writer.uint32(58).string(message.totalReprises);
    }
    if (message.totalAcomptes !== "") {
      writer.uint32(66).string(message.totalAcomptes);
    }
    if (message.totalNetAPayer !== "") {
      writer.uint32(74).string(message.totalNetAPayer);
    }
    if (message.nombreLignes !== 0) {
      writer.uint32(80).int32(message.nombreLignes);
    }
    if (message.statutBordereau !== 0) {
      writer.uint32(88).int32(message.statutBordereau);
    }
    if (message.dateValidation !== undefined) {
      writer.uint32(98).string(message.dateValidation);
    }
    if (message.validateurId !== undefined) {
      writer.uint32(106).string(message.validateurId);
    }
    if (message.dateExport !== undefined) {
      writer.uint32(114).string(message.dateExport);
    }
    if (message.fichierPdfUrl !== undefined) {
      writer.uint32(122).string(message.fichierPdfUrl);
    }
    if (message.fichierExcelUrl !== undefined) {
      writer.uint32(130).string(message.fichierExcelUrl);
    }
    if (message.commentaire !== undefined) {
      writer.uint32(138).string(message.commentaire);
    }
    if (message.createdAt !== "") {
      writer.uint32(146).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(154).string(message.updatedAt);
    }
    for (const v of message.lignes) {
      LigneBordereau.encode(v!, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bordereau {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBordereau();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.totalBrut = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.totalReprises = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.totalAcomptes = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.totalNetAPayer = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.nombreLignes = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.statutBordereau = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dateValidation = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.validateurId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dateExport = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.fichierPdfUrl = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.fichierExcelUrl = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.lignes.push(LigneBordereau.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateBordereauRequest(): CreateBordereauRequest {
  return { organisationId: "", reference: "", periode: "", apporteurId: "" };
}

export const CreateBordereauRequest: MessageFns<CreateBordereauRequest> = {
  encode(message: CreateBordereauRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.reference !== "") {
      writer.uint32(18).string(message.reference);
    }
    if (message.periode !== "") {
      writer.uint32(26).string(message.periode);
    }
    if (message.apporteurId !== "") {
      writer.uint32(34).string(message.apporteurId);
    }
    if (message.commentaire !== undefined) {
      writer.uint32(42).string(message.commentaire);
    }
    if (message.creePar !== undefined) {
      writer.uint32(50).string(message.creePar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBordereauRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBordereauRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.creePar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetBordereauxRequest(): GetBordereauxRequest {
  return { organisationId: "" };
}

export const GetBordereauxRequest: MessageFns<GetBordereauxRequest> = {
  encode(message: GetBordereauxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== undefined) {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.periode !== undefined) {
      writer.uint32(26).string(message.periode);
    }
    if (message.statut !== undefined) {
      writer.uint32(32).int32(message.statut);
    }
    if (message.limit !== undefined) {
      writer.uint32(40).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(48).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBordereauxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBordereauxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.statut = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetBordereauByApporteurPeriodeRequest(): GetBordereauByApporteurPeriodeRequest {
  return { organisationId: "", apporteurId: "", periode: "" };
}

export const GetBordereauByApporteurPeriodeRequest: MessageFns<GetBordereauByApporteurPeriodeRequest> = {
  encode(message: GetBordereauByApporteurPeriodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.periode !== "") {
      writer.uint32(26).string(message.periode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBordereauByApporteurPeriodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBordereauByApporteurPeriodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateBordereauRequest(): UpdateBordereauRequest {
  return { id: "" };
}

export const UpdateBordereauRequest: MessageFns<UpdateBordereauRequest> = {
  encode(message: UpdateBordereauRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.commentaire !== undefined) {
      writer.uint32(18).string(message.commentaire);
    }
    if (message.statutBordereau !== undefined) {
      writer.uint32(24).int32(message.statutBordereau);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBordereauRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBordereauRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statutBordereau = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidateBordereauRequest(): ValidateBordereauRequest {
  return { id: "", validateurId: "" };
}

export const ValidateBordereauRequest: MessageFns<ValidateBordereauRequest> = {
  encode(message: ValidateBordereauRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.validateurId !== "") {
      writer.uint32(18).string(message.validateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateBordereauRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateBordereauRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExportBordereauResponse(): ExportBordereauResponse {
  return { success: false, pdfUrl: "", excelUrl: "" };
}

export const ExportBordereauResponse: MessageFns<ExportBordereauResponse> = {
  encode(message: ExportBordereauResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.pdfUrl !== "") {
      writer.uint32(18).string(message.pdfUrl);
    }
    if (message.excelUrl !== "") {
      writer.uint32(26).string(message.excelUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportBordereauResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportBordereauResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pdfUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.excelUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBordereauResponse(): BordereauResponse {
  return {};
}

export const BordereauResponse: MessageFns<BordereauResponse> = {
  encode(message: BordereauResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bordereau !== undefined) {
      Bordereau.encode(message.bordereau, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BordereauResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBordereauResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bordereau = Bordereau.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBordereauListResponse(): BordereauListResponse {
  return { bordereaux: [], total: 0 };
}

export const BordereauListResponse: MessageFns<BordereauListResponse> = {
  encode(message: BordereauListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bordereaux) {
      Bordereau.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BordereauListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBordereauListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bordereaux.push(Bordereau.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLigneBordereau(): LigneBordereau {
  return {
    id: "",
    organisationId: "",
    bordereauId: "",
    typeLigne: 0,
    contratId: "",
    contratReference: "",
    montantBrut: "",
    montantReprise: "",
    montantNet: "",
    statutLigne: 0,
    selectionne: false,
    ordre: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const LigneBordereau: MessageFns<LigneBordereau> = {
  encode(message: LigneBordereau, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.bordereauId !== "") {
      writer.uint32(26).string(message.bordereauId);
    }
    if (message.commissionId !== undefined) {
      writer.uint32(34).string(message.commissionId);
    }
    if (message.repriseId !== undefined) {
      writer.uint32(42).string(message.repriseId);
    }
    if (message.typeLigne !== 0) {
      writer.uint32(48).int32(message.typeLigne);
    }
    if (message.contratId !== "") {
      writer.uint32(58).string(message.contratId);
    }
    if (message.contratReference !== "") {
      writer.uint32(66).string(message.contratReference);
    }
    if (message.clientNom !== undefined) {
      writer.uint32(74).string(message.clientNom);
    }
    if (message.produitNom !== undefined) {
      writer.uint32(82).string(message.produitNom);
    }
    if (message.montantBrut !== "") {
      writer.uint32(90).string(message.montantBrut);
    }
    if (message.montantReprise !== "") {
      writer.uint32(98).string(message.montantReprise);
    }
    if (message.montantNet !== "") {
      writer.uint32(106).string(message.montantNet);
    }
    if (message.baseCalcul !== undefined) {
      writer.uint32(114).string(message.baseCalcul);
    }
    if (message.tauxApplique !== undefined) {
      writer.uint32(122).string(message.tauxApplique);
    }
    if (message.baremeId !== undefined) {
      writer.uint32(130).string(message.baremeId);
    }
    if (message.statutLigne !== 0) {
      writer.uint32(136).int32(message.statutLigne);
    }
    if (message.selectionne !== false) {
      writer.uint32(144).bool(message.selectionne);
    }
    if (message.motifDeselection !== undefined) {
      writer.uint32(154).string(message.motifDeselection);
    }
    if (message.validateurId !== undefined) {
      writer.uint32(162).string(message.validateurId);
    }
    if (message.dateValidation !== undefined) {
      writer.uint32(170).string(message.dateValidation);
    }
    if (message.ordre !== 0) {
      writer.uint32(176).int32(message.ordre);
    }
    if (message.createdAt !== "") {
      writer.uint32(186).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(194).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LigneBordereau {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLigneBordereau();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bordereauId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commissionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.repriseId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.typeLigne = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.contratReference = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clientNom = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.produitNom = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.montantBrut = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.montantReprise = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.montantNet = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.baseCalcul = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tauxApplique = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.statutLigne = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.selectionne = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.motifDeselection = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.validateurId = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.dateValidation = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateLigneBordereauRequest(): CreateLigneBordereauRequest {
  return {
    organisationId: "",
    bordereauId: "",
    typeLigne: 0,
    contratId: "",
    contratReference: "",
    montantBrut: "",
    montantReprise: "",
    montantNet: "",
    ordre: 0,
  };
}

export const CreateLigneBordereauRequest: MessageFns<CreateLigneBordereauRequest> = {
  encode(message: CreateLigneBordereauRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.bordereauId !== "") {
      writer.uint32(18).string(message.bordereauId);
    }
    if (message.commissionId !== undefined) {
      writer.uint32(26).string(message.commissionId);
    }
    if (message.repriseId !== undefined) {
      writer.uint32(34).string(message.repriseId);
    }
    if (message.typeLigne !== 0) {
      writer.uint32(40).int32(message.typeLigne);
    }
    if (message.contratId !== "") {
      writer.uint32(50).string(message.contratId);
    }
    if (message.contratReference !== "") {
      writer.uint32(58).string(message.contratReference);
    }
    if (message.clientNom !== undefined) {
      writer.uint32(66).string(message.clientNom);
    }
    if (message.produitNom !== undefined) {
      writer.uint32(74).string(message.produitNom);
    }
    if (message.montantBrut !== "") {
      writer.uint32(82).string(message.montantBrut);
    }
    if (message.montantReprise !== "") {
      writer.uint32(90).string(message.montantReprise);
    }
    if (message.montantNet !== "") {
      writer.uint32(98).string(message.montantNet);
    }
    if (message.baseCalcul !== undefined) {
      writer.uint32(106).string(message.baseCalcul);
    }
    if (message.tauxApplique !== undefined) {
      writer.uint32(114).string(message.tauxApplique);
    }
    if (message.baremeId !== undefined) {
      writer.uint32(122).string(message.baremeId);
    }
    if (message.ordre !== 0) {
      writer.uint32(128).int32(message.ordre);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLigneBordereauRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLigneBordereauRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bordereauId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commissionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.repriseId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.typeLigne = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contratReference = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clientNom = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.produitNom = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.montantBrut = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.montantReprise = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.montantNet = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.baseCalcul = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.tauxApplique = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateLigneBordereauRequest(): UpdateLigneBordereauRequest {
  return { id: "" };
}

export const UpdateLigneBordereauRequest: MessageFns<UpdateLigneBordereauRequest> = {
  encode(message: UpdateLigneBordereauRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.montantBrut !== undefined) {
      writer.uint32(18).string(message.montantBrut);
    }
    if (message.montantReprise !== undefined) {
      writer.uint32(26).string(message.montantReprise);
    }
    if (message.montantNet !== undefined) {
      writer.uint32(34).string(message.montantNet);
    }
    if (message.selectionne !== undefined) {
      writer.uint32(40).bool(message.selectionne);
    }
    if (message.motifDeselection !== undefined) {
      writer.uint32(50).string(message.motifDeselection);
    }
    if (message.ordre !== undefined) {
      writer.uint32(56).int32(message.ordre);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLigneBordereauRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLigneBordereauRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.montantBrut = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.montantReprise = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.montantNet = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.selectionne = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.motifDeselection = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidateLigneRequest(): ValidateLigneRequest {
  return { id: "", validateurId: "", statut: 0 };
}

export const ValidateLigneRequest: MessageFns<ValidateLigneRequest> = {
  encode(message: ValidateLigneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.validateurId !== "") {
      writer.uint32(18).string(message.validateurId);
    }
    if (message.statut !== 0) {
      writer.uint32(24).int32(message.statut);
    }
    if (message.motif !== undefined) {
      writer.uint32(34).string(message.motif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateLigneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateLigneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statut = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.motif = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLigneBordereauResponse(): LigneBordereauResponse {
  return {};
}

export const LigneBordereauResponse: MessageFns<LigneBordereauResponse> = {
  encode(message: LigneBordereauResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ligne !== undefined) {
      LigneBordereau.encode(message.ligne, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LigneBordereauResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLigneBordereauResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ligne = LigneBordereau.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLigneBordereauListResponse(): LigneBordereauListResponse {
  return { lignes: [], total: 0 };
}

export const LigneBordereauListResponse: MessageFns<LigneBordereauListResponse> = {
  encode(message: LigneBordereauListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lignes) {
      LigneBordereau.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LigneBordereauListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLigneBordereauListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lignes.push(LigneBordereau.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReprise(): Reprise {
  return {
    id: "",
    organisationId: "",
    commissionOriginaleId: "",
    contratId: "",
    apporteurId: "",
    reference: "",
    typeReprise: 0,
    montantReprise: "",
    tauxReprise: "",
    montantOriginal: "",
    periodeOrigine: "",
    periodeApplication: "",
    dateEvenement: "",
    dateLimite: "",
    statutReprise: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const Reprise: MessageFns<Reprise> = {
  encode(message: Reprise, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.commissionOriginaleId !== "") {
      writer.uint32(26).string(message.commissionOriginaleId);
    }
    if (message.contratId !== "") {
      writer.uint32(34).string(message.contratId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(42).string(message.apporteurId);
    }
    if (message.reference !== "") {
      writer.uint32(50).string(message.reference);
    }
    if (message.typeReprise !== 0) {
      writer.uint32(56).int32(message.typeReprise);
    }
    if (message.montantReprise !== "") {
      writer.uint32(66).string(message.montantReprise);
    }
    if (message.tauxReprise !== "") {
      writer.uint32(74).string(message.tauxReprise);
    }
    if (message.montantOriginal !== "") {
      writer.uint32(82).string(message.montantOriginal);
    }
    if (message.periodeOrigine !== "") {
      writer.uint32(90).string(message.periodeOrigine);
    }
    if (message.periodeApplication !== "") {
      writer.uint32(98).string(message.periodeApplication);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(106).string(message.dateEvenement);
    }
    if (message.dateLimite !== "") {
      writer.uint32(114).string(message.dateLimite);
    }
    if (message.dateApplication !== undefined) {
      writer.uint32(122).string(message.dateApplication);
    }
    if (message.statutReprise !== 0) {
      writer.uint32(128).int32(message.statutReprise);
    }
    if (message.bordereauId !== undefined) {
      writer.uint32(138).string(message.bordereauId);
    }
    if (message.motif !== undefined) {
      writer.uint32(146).string(message.motif);
    }
    if (message.commentaire !== undefined) {
      writer.uint32(154).string(message.commentaire);
    }
    if (message.createdAt !== "") {
      writer.uint32(162).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(170).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reprise {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReprise();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commissionOriginaleId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.typeReprise = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.montantReprise = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tauxReprise = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.montantOriginal = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.periodeOrigine = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.periodeApplication = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dateLimite = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.dateApplication = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.statutReprise = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.bordereauId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.motif = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateRepriseRequest(): CreateRepriseRequest {
  return {
    organisationId: "",
    commissionOriginaleId: "",
    contratId: "",
    apporteurId: "",
    reference: "",
    typeReprise: 0,
    montantReprise: "",
    tauxReprise: "",
    montantOriginal: "",
    periodeOrigine: "",
    periodeApplication: "",
    dateEvenement: "",
    dateLimite: "",
  };
}

export const CreateRepriseRequest: MessageFns<CreateRepriseRequest> = {
  encode(message: CreateRepriseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.commissionOriginaleId !== "") {
      writer.uint32(18).string(message.commissionOriginaleId);
    }
    if (message.contratId !== "") {
      writer.uint32(26).string(message.contratId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(34).string(message.apporteurId);
    }
    if (message.reference !== "") {
      writer.uint32(42).string(message.reference);
    }
    if (message.typeReprise !== 0) {
      writer.uint32(48).int32(message.typeReprise);
    }
    if (message.montantReprise !== "") {
      writer.uint32(58).string(message.montantReprise);
    }
    if (message.tauxReprise !== "") {
      writer.uint32(66).string(message.tauxReprise);
    }
    if (message.montantOriginal !== "") {
      writer.uint32(74).string(message.montantOriginal);
    }
    if (message.periodeOrigine !== "") {
      writer.uint32(82).string(message.periodeOrigine);
    }
    if (message.periodeApplication !== "") {
      writer.uint32(90).string(message.periodeApplication);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(98).string(message.dateEvenement);
    }
    if (message.dateLimite !== "") {
      writer.uint32(106).string(message.dateLimite);
    }
    if (message.motif !== undefined) {
      writer.uint32(114).string(message.motif);
    }
    if (message.commentaire !== undefined) {
      writer.uint32(122).string(message.commentaire);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRepriseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRepriseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commissionOriginaleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.typeReprise = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.montantReprise = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tauxReprise = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.montantOriginal = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.periodeOrigine = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.periodeApplication = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.dateLimite = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.motif = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.commentaire = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetReprisesRequest(): GetReprisesRequest {
  return { organisationId: "" };
}

export const GetReprisesRequest: MessageFns<GetReprisesRequest> = {
  encode(message: GetReprisesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== undefined) {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.statut !== undefined) {
      writer.uint32(24).int32(message.statut);
    }
    if (message.limit !== undefined) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(40).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReprisesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReprisesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statut = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseApplyRepriseRequest(): ApplyRepriseRequest {
  return { id: "", bordereauId: "" };
}

export const ApplyRepriseRequest: MessageFns<ApplyRepriseRequest> = {
  encode(message: ApplyRepriseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.bordereauId !== "") {
      writer.uint32(18).string(message.bordereauId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyRepriseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyRepriseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bordereauId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRepriseResponse(): RepriseResponse {
  return {};
}

export const RepriseResponse: MessageFns<RepriseResponse> = {
  encode(message: RepriseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reprise !== undefined) {
      Reprise.encode(message.reprise, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepriseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepriseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reprise = Reprise.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRepriseListResponse(): RepriseListResponse {
  return { reprises: [], total: 0 };
}

export const RepriseListResponse: MessageFns<RepriseListResponse> = {
  encode(message: RepriseListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reprises) {
      Reprise.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepriseListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepriseListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reprises.push(Reprise.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRecurrenceCommission(): RecurrenceCommission {
  return {
    id: "",
    organisationId: "",
    commissionInitialeId: "",
    contratId: "",
    apporteurId: "",
    baremeId: "",
    baremeVersion: 0,
    periode: "",
    numeroMois: 0,
    montantBase: "",
    tauxRecurrence: "",
    montantCalcule: "",
    statutRecurrence: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const RecurrenceCommission: MessageFns<RecurrenceCommission> = {
  encode(message: RecurrenceCommission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.commissionInitialeId !== "") {
      writer.uint32(26).string(message.commissionInitialeId);
    }
    if (message.contratId !== "") {
      writer.uint32(34).string(message.contratId);
    }
    if (message.echeanceId !== undefined) {
      writer.uint32(42).string(message.echeanceId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(50).string(message.apporteurId);
    }
    if (message.baremeId !== "") {
      writer.uint32(58).string(message.baremeId);
    }
    if (message.baremeVersion !== 0) {
      writer.uint32(64).int32(message.baremeVersion);
    }
    if (message.periode !== "") {
      writer.uint32(74).string(message.periode);
    }
    if (message.numeroMois !== 0) {
      writer.uint32(80).int32(message.numeroMois);
    }
    if (message.montantBase !== "") {
      writer.uint32(90).string(message.montantBase);
    }
    if (message.tauxRecurrence !== "") {
      writer.uint32(98).string(message.tauxRecurrence);
    }
    if (message.montantCalcule !== "") {
      writer.uint32(106).string(message.montantCalcule);
    }
    if (message.statutRecurrence !== 0) {
      writer.uint32(112).int32(message.statutRecurrence);
    }
    if (message.bordereauId !== undefined) {
      writer.uint32(122).string(message.bordereauId);
    }
    if (message.dateEncaissement !== undefined) {
      writer.uint32(130).string(message.dateEncaissement);
    }
    if (message.createdAt !== "") {
      writer.uint32(138).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(146).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecurrenceCommission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecurrenceCommission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commissionInitialeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.echeanceId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.baremeVersion = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.numeroMois = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.montantBase = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.tauxRecurrence = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.montantCalcule = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.statutRecurrence = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.bordereauId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dateEncaissement = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRecurrencesRequest(): GetRecurrencesRequest {
  return { organisationId: "" };
}

export const GetRecurrencesRequest: MessageFns<GetRecurrencesRequest> = {
  encode(message: GetRecurrencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== undefined) {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.periode !== undefined) {
      writer.uint32(26).string(message.periode);
    }
    if (message.statut !== undefined) {
      writer.uint32(32).int32(message.statut);
    }
    if (message.limit !== undefined) {
      writer.uint32(40).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(48).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRecurrencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRecurrencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.statut = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRecurrencesByContratRequest(): GetRecurrencesByContratRequest {
  return { organisationId: "", contratId: "" };
}

export const GetRecurrencesByContratRequest: MessageFns<GetRecurrencesByContratRequest> = {
  encode(message: GetRecurrencesByContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRecurrencesByContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRecurrencesByContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRecurrenceListResponse(): RecurrenceListResponse {
  return { recurrences: [], total: 0 };
}

export const RecurrenceListResponse: MessageFns<RecurrenceListResponse> = {
  encode(message: RecurrenceListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recurrences) {
      RecurrenceCommission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecurrenceListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecurrenceListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recurrences.push(RecurrenceCommission.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReportNegatif(): ReportNegatif {
  return {
    id: "",
    organisationId: "",
    apporteurId: "",
    periodeOrigine: "",
    montantInitial: "",
    montantRestant: "",
    statutReport: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const ReportNegatif: MessageFns<ReportNegatif> = {
  encode(message: ReportNegatif, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(26).string(message.apporteurId);
    }
    if (message.periodeOrigine !== "") {
      writer.uint32(34).string(message.periodeOrigine);
    }
    if (message.montantInitial !== "") {
      writer.uint32(42).string(message.montantInitial);
    }
    if (message.montantRestant !== "") {
      writer.uint32(50).string(message.montantRestant);
    }
    if (message.statutReport !== 0) {
      writer.uint32(56).int32(message.statutReport);
    }
    if (message.bordereauOrigineId !== undefined) {
      writer.uint32(66).string(message.bordereauOrigineId);
    }
    if (message.dernierePeriodeApplication !== undefined) {
      writer.uint32(74).string(message.dernierePeriodeApplication);
    }
    if (message.motif !== undefined) {
      writer.uint32(82).string(message.motif);
    }
    if (message.createdAt !== "") {
      writer.uint32(90).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(98).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportNegatif {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportNegatif();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.periodeOrigine = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.montantInitial = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.montantRestant = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.statutReport = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.bordereauOrigineId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dernierePeriodeApplication = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.motif = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetReportsNegatifsRequest(): GetReportsNegatifsRequest {
  return { organisationId: "" };
}

export const GetReportsNegatifsRequest: MessageFns<GetReportsNegatifsRequest> = {
  encode(message: GetReportsNegatifsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== undefined) {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.statut !== undefined) {
      writer.uint32(24).int32(message.statut);
    }
    if (message.limit !== undefined) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(40).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReportsNegatifsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReportsNegatifsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statut = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReportNegatifListResponse(): ReportNegatifListResponse {
  return { reports: [], total: 0 };
}

export const ReportNegatifListResponse: MessageFns<ReportNegatifListResponse> = {
  encode(message: ReportNegatifListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reports) {
      ReportNegatif.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportNegatifListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportNegatifListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reports.push(ReportNegatif.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatutCommission(): StatutCommission {
  return { id: "", code: "", nom: "", ordreAffichage: 0 };
}

export const StatutCommission: MessageFns<StatutCommission> = {
  encode(message: StatutCommission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(40).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatutCommission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatutCommission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStatutRequest(): CreateStatutRequest {
  return { code: "", nom: "", ordreAffichage: 0 };
}

export const CreateStatutRequest: MessageFns<CreateStatutRequest> = {
  encode(message: CreateStatutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(32).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStatutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStatutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutsRequest(): GetStatutsRequest {
  return {};
}

export const GetStatutsRequest: MessageFns<GetStatutsRequest> = {
  encode(message: GetStatutsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limit !== undefined) {
      writer.uint32(8).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(16).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutByCodeRequest(): GetStatutByCodeRequest {
  return { code: "" };
}

export const GetStatutByCodeRequest: MessageFns<GetStatutByCodeRequest> = {
  encode(message: GetStatutByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateStatutRequest(): UpdateStatutRequest {
  return { id: "" };
}

export const UpdateStatutRequest: MessageFns<UpdateStatutRequest> = {
  encode(message: UpdateStatutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.ordreAffichage !== undefined) {
      writer.uint32(32).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStatutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStatutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatutResponse(): StatutResponse {
  return {};
}

export const StatutResponse: MessageFns<StatutResponse> = {
  encode(message: StatutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statut !== undefined) {
      StatutCommission.encode(message.statut, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statut = StatutCommission.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatutListResponse(): StatutListResponse {
  return { statuts: [], total: 0 };
}

export const StatutListResponse: MessageFns<StatutListResponse> = {
  encode(message: StatutListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.statuts) {
      StatutCommission.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatutListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatutListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statuts.push(StatutCommission.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculerCommissionRequest(): CalculerCommissionRequest {
  return {
    organisationId: "",
    apporteurId: "",
    contratId: "",
    typeProduit: "",
    profilRemuneration: "",
    montantBase: "",
    periode: "",
  };
}

export const CalculerCommissionRequest: MessageFns<CalculerCommissionRequest> = {
  encode(message: CalculerCommissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.contratId !== "") {
      writer.uint32(26).string(message.contratId);
    }
    if (message.produitId !== undefined) {
      writer.uint32(34).string(message.produitId);
    }
    if (message.typeProduit !== "") {
      writer.uint32(42).string(message.typeProduit);
    }
    if (message.profilRemuneration !== "") {
      writer.uint32(50).string(message.profilRemuneration);
    }
    if (message.societeId !== undefined) {
      writer.uint32(58).string(message.societeId);
    }
    if (message.canalVente !== undefined) {
      writer.uint32(66).string(message.canalVente);
    }
    if (message.montantBase !== "") {
      writer.uint32(74).string(message.montantBase);
    }
    if (message.periode !== "") {
      writer.uint32(82).string(message.periode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculerCommissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculerCommissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.typeProduit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.profilRemuneration = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.canalVente = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.montantBase = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePrimeApplicable(): PrimeApplicable {
  return { palierId: "", palierNom: "", montant: "", type: "" };
}

export const PrimeApplicable: MessageFns<PrimeApplicable> = {
  encode(message: PrimeApplicable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.palierId !== "") {
      writer.uint32(10).string(message.palierId);
    }
    if (message.palierNom !== "") {
      writer.uint32(18).string(message.palierNom);
    }
    if (message.montant !== "") {
      writer.uint32(26).string(message.montant);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrimeApplicable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrimeApplicable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.palierId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.palierNom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.montant = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculerCommissionResponse(): CalculerCommissionResponse {
  return { primes: [], montantTotal: "" };
}

export const CalculerCommissionResponse: MessageFns<CalculerCommissionResponse> = {
  encode(message: CalculerCommissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commission !== undefined) {
      Commission.encode(message.commission, writer.uint32(10).fork()).join();
    }
    if (message.baremeApplique !== undefined) {
      Bareme.encode(message.baremeApplique, writer.uint32(18).fork()).join();
    }
    for (const v of message.primes) {
      PrimeApplicable.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.montantTotal !== "") {
      writer.uint32(34).string(message.montantTotal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculerCommissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculerCommissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commission = Commission.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baremeApplique = Bareme.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.primes.push(PrimeApplicable.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.montantTotal = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGenererBordereauRequest(): GenererBordereauRequest {
  return { organisationId: "", apporteurId: "", periode: "" };
}

export const GenererBordereauRequest: MessageFns<GenererBordereauRequest> = {
  encode(message: GenererBordereauRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.apporteurId !== "") {
      writer.uint32(18).string(message.apporteurId);
    }
    if (message.periode !== "") {
      writer.uint32(26).string(message.periode);
    }
    if (message.creePar !== undefined) {
      writer.uint32(34).string(message.creePar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenererBordereauRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenererBordereauRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.creePar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBordereauSummary(): BordereauSummary {
  return { nombreCommissions: 0, nombreReprises: 0, nombrePrimes: 0, totalBrut: "", totalReprises: "", totalNet: "" };
}

export const BordereauSummary: MessageFns<BordereauSummary> = {
  encode(message: BordereauSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nombreCommissions !== 0) {
      writer.uint32(8).int32(message.nombreCommissions);
    }
    if (message.nombreReprises !== 0) {
      writer.uint32(16).int32(message.nombreReprises);
    }
    if (message.nombrePrimes !== 0) {
      writer.uint32(24).int32(message.nombrePrimes);
    }
    if (message.totalBrut !== "") {
      writer.uint32(34).string(message.totalBrut);
    }
    if (message.totalReprises !== "") {
      writer.uint32(42).string(message.totalReprises);
    }
    if (message.totalNet !== "") {
      writer.uint32(50).string(message.totalNet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BordereauSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBordereauSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nombreCommissions = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nombreReprises = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nombrePrimes = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.totalBrut = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalReprises = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.totalNet = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGenererBordereauResponse(): GenererBordereauResponse {
  return {};
}

export const GenererBordereauResponse: MessageFns<GenererBordereauResponse> = {
  encode(message: GenererBordereauResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bordereau !== undefined) {
      Bordereau.encode(message.bordereau, writer.uint32(10).fork()).join();
    }
    if (message.summary !== undefined) {
      BordereauSummary.encode(message.summary, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenererBordereauResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenererBordereauResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bordereau = Bordereau.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = BordereauSummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeclencherRepriseRequest(): DeclencherRepriseRequest {
  return { commissionId: "", typeReprise: 0, dateEvenement: "" };
}

export const DeclencherRepriseRequest: MessageFns<DeclencherRepriseRequest> = {
  encode(message: DeclencherRepriseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commissionId !== "") {
      writer.uint32(10).string(message.commissionId);
    }
    if (message.typeReprise !== 0) {
      writer.uint32(16).int32(message.typeReprise);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(26).string(message.dateEvenement);
    }
    if (message.motif !== undefined) {
      writer.uint32(34).string(message.motif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeclencherRepriseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclencherRepriseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commissionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.typeReprise = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.motif = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuditLog(): AuditLog {
  return { id: "", organisationId: "", scope: 0, action: 0, createdAt: "" };
}

export const AuditLog: MessageFns<AuditLog> = {
  encode(message: AuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.scope !== 0) {
      writer.uint32(24).int32(message.scope);
    }
    if (message.refId !== undefined) {
      writer.uint32(34).string(message.refId);
    }
    if (message.action !== 0) {
      writer.uint32(40).int32(message.action);
    }
    if (message.beforeData !== undefined) {
      writer.uint32(50).string(message.beforeData);
    }
    if (message.afterData !== undefined) {
      writer.uint32(58).string(message.afterData);
    }
    if (message.metadata !== undefined) {
      writer.uint32(66).string(message.metadata);
    }
    if (message.userId !== undefined) {
      writer.uint32(74).string(message.userId);
    }
    if (message.userName !== undefined) {
      writer.uint32(82).string(message.userName);
    }
    if (message.ipAddress !== undefined) {
      writer.uint32(90).string(message.ipAddress);
    }
    if (message.motif !== undefined) {
      writer.uint32(98).string(message.motif);
    }
    if (message.baremeId !== undefined) {
      writer.uint32(106).string(message.baremeId);
    }
    if (message.baremeVersion !== undefined) {
      writer.uint32(112).int32(message.baremeVersion);
    }
    if (message.contratId !== undefined) {
      writer.uint32(122).string(message.contratId);
    }
    if (message.apporteurId !== undefined) {
      writer.uint32(130).string(message.apporteurId);
    }
    if (message.periode !== undefined) {
      writer.uint32(138).string(message.periode);
    }
    if (message.montantCalcule !== undefined) {
      writer.uint32(146).string(message.montantCalcule);
    }
    if (message.createdAt !== "") {
      writer.uint32(154).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.beforeData = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.afterData = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.motif = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.baremeVersion = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.montantCalcule = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuditLogsRequest(): GetAuditLogsRequest {
  return { organisationId: "" };
}

export const GetAuditLogsRequest: MessageFns<GetAuditLogsRequest> = {
  encode(message: GetAuditLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.scope !== undefined) {
      writer.uint32(16).int32(message.scope);
    }
    if (message.action !== undefined) {
      writer.uint32(24).int32(message.action);
    }
    if (message.refId !== undefined) {
      writer.uint32(34).string(message.refId);
    }
    if (message.userId !== undefined) {
      writer.uint32(42).string(message.userId);
    }
    if (message.apporteurId !== undefined) {
      writer.uint32(50).string(message.apporteurId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(58).string(message.contratId);
    }
    if (message.baremeId !== undefined) {
      writer.uint32(66).string(message.baremeId);
    }
    if (message.periode !== undefined) {
      writer.uint32(74).string(message.periode);
    }
    if (message.dateFrom !== undefined) {
      writer.uint32(82).string(message.dateFrom);
    }
    if (message.dateTo !== undefined) {
      writer.uint32(90).string(message.dateTo);
    }
    if (message.limit !== undefined) {
      writer.uint32(96).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(104).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.refId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.apporteurId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.baremeId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.periode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dateFrom = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dateTo = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuditLogsByRefRequest(): GetAuditLogsByRefRequest {
  return { organisationId: "", scope: 0, refId: "" };
}

export const GetAuditLogsByRefRequest: MessageFns<GetAuditLogsByRefRequest> = {
  encode(message: GetAuditLogsByRefRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.scope !== 0) {
      writer.uint32(16).int32(message.scope);
    }
    if (message.refId !== "") {
      writer.uint32(26).string(message.refId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsByRefRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsByRefRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuditLogListResponse(): AuditLogListResponse {
  return { logs: [], total: 0 };
}

export const AuditLogListResponse: MessageFns<AuditLogListResponse> = {
  encode(message: AuditLogListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      AuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(AuditLog.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface CommissionServiceClient {
  /** ===== Commission CRUD ===== */

  createCommission(request: CreateCommissionRequest, metadata?: Metadata): Observable<CommissionResponse>;

  getCommission(request: GetByIdRequest, metadata?: Metadata): Observable<CommissionResponse>;

  getCommissions(request: GetCommissionsRequest, metadata?: Metadata): Observable<CommissionListResponse>;

  getCommissionsByApporteur(request: GetByApporteurRequest, metadata?: Metadata): Observable<CommissionListResponse>;

  getCommissionsByPeriode(request: GetByPeriodeRequest, metadata?: Metadata): Observable<CommissionListResponse>;

  updateCommission(request: UpdateCommissionRequest, metadata?: Metadata): Observable<CommissionResponse>;

  deleteCommission(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== Bareme CRUD ===== */

  createBareme(request: CreateBaremeRequest, metadata?: Metadata): Observable<BaremeResponse>;

  getBareme(request: GetByIdRequest, metadata?: Metadata): Observable<BaremeResponse>;

  getBaremes(request: GetBaremesRequest, metadata?: Metadata): Observable<BaremeListResponse>;

  getBaremeApplicable(request: GetBaremeApplicableRequest, metadata?: Metadata): Observable<BaremeResponse>;

  updateBareme(request: UpdateBaremeRequest, metadata?: Metadata): Observable<BaremeResponse>;

  deleteBareme(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== Palier CRUD ===== */

  createPalier(request: CreatePalierRequest, metadata?: Metadata): Observable<PalierResponse>;

  getPalier(request: GetByIdRequest, metadata?: Metadata): Observable<PalierResponse>;

  getPaliersByBareme(request: GetByBaremeRequest, metadata?: Metadata): Observable<PalierListResponse>;

  updatePalier(request: UpdatePalierRequest, metadata?: Metadata): Observable<PalierResponse>;

  deletePalier(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== Bordereau CRUD ===== */

  createBordereau(request: CreateBordereauRequest, metadata?: Metadata): Observable<BordereauResponse>;

  getBordereau(request: GetByIdRequest, metadata?: Metadata): Observable<BordereauResponse>;

  getBordereaux(request: GetBordereauxRequest, metadata?: Metadata): Observable<BordereauListResponse>;

  getBordereauByApporteurPeriode(
    request: GetBordereauByApporteurPeriodeRequest,
    metadata?: Metadata,
  ): Observable<BordereauResponse>;

  updateBordereau(request: UpdateBordereauRequest, metadata?: Metadata): Observable<BordereauResponse>;

  validateBordereau(request: ValidateBordereauRequest, metadata?: Metadata): Observable<BordereauResponse>;

  exportBordereau(request: GetByIdRequest, metadata?: Metadata): Observable<ExportBordereauResponse>;

  deleteBordereau(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== LigneBordereau CRUD ===== */

  createLigneBordereau(request: CreateLigneBordereauRequest, metadata?: Metadata): Observable<LigneBordereauResponse>;

  getLigneBordereau(request: GetByIdRequest, metadata?: Metadata): Observable<LigneBordereauResponse>;

  getLignesByBordereau(request: GetByBordereauRequest, metadata?: Metadata): Observable<LigneBordereauListResponse>;

  updateLigneBordereau(request: UpdateLigneBordereauRequest, metadata?: Metadata): Observable<LigneBordereauResponse>;

  validateLigne(request: ValidateLigneRequest, metadata?: Metadata): Observable<LigneBordereauResponse>;

  deleteLigneBordereau(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== Reprise CRUD ===== */

  createReprise(request: CreateRepriseRequest, metadata?: Metadata): Observable<RepriseResponse>;

  getReprise(request: GetByIdRequest, metadata?: Metadata): Observable<RepriseResponse>;

  getReprises(request: GetReprisesRequest, metadata?: Metadata): Observable<RepriseListResponse>;

  getReprisesByCommission(request: GetByCommissionRequest, metadata?: Metadata): Observable<RepriseListResponse>;

  applyReprise(request: ApplyRepriseRequest, metadata?: Metadata): Observable<RepriseResponse>;

  cancelReprise(request: GetByIdRequest, metadata?: Metadata): Observable<RepriseResponse>;

  deleteReprise(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== StatutCommission CRUD ===== */

  createStatut(request: CreateStatutRequest, metadata?: Metadata): Observable<StatutResponse>;

  getStatut(request: GetByIdRequest, metadata?: Metadata): Observable<StatutResponse>;

  getStatuts(request: GetStatutsRequest, metadata?: Metadata): Observable<StatutListResponse>;

  getStatutByCode(request: GetStatutByCodeRequest, metadata?: Metadata): Observable<StatutResponse>;

  updateStatut(request: UpdateStatutRequest, metadata?: Metadata): Observable<StatutResponse>;

  deleteStatut(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== Commission Engine ===== */

  calculerCommission(request: CalculerCommissionRequest, metadata?: Metadata): Observable<CalculerCommissionResponse>;

  genererBordereau(request: GenererBordereauRequest, metadata?: Metadata): Observable<GenererBordereauResponse>;

  declencherReprise(request: DeclencherRepriseRequest, metadata?: Metadata): Observable<RepriseResponse>;

  /** ===== Audit Logs ===== */

  getAuditLogs(request: GetAuditLogsRequest, metadata?: Metadata): Observable<AuditLogListResponse>;

  getAuditLogsByRef(request: GetAuditLogsByRefRequest, metadata?: Metadata): Observable<AuditLogListResponse>;

  getAuditLogsByCommission(request: GetByCommissionRequest, metadata?: Metadata): Observable<AuditLogListResponse>;

  /** ===== Recurrences ===== */

  getRecurrences(request: GetRecurrencesRequest, metadata?: Metadata): Observable<RecurrenceListResponse>;

  getRecurrencesByContrat(
    request: GetRecurrencesByContratRequest,
    metadata?: Metadata,
  ): Observable<RecurrenceListResponse>;

  /** ===== Reports Negatifs ===== */

  getReportsNegatifs(request: GetReportsNegatifsRequest, metadata?: Metadata): Observable<ReportNegatifListResponse>;
}

export interface CommissionServiceController {
  /** ===== Commission CRUD ===== */

  createCommission(
    request: CreateCommissionRequest,
    metadata?: Metadata,
  ): Promise<CommissionResponse> | Observable<CommissionResponse> | CommissionResponse;

  getCommission(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<CommissionResponse> | Observable<CommissionResponse> | CommissionResponse;

  getCommissions(
    request: GetCommissionsRequest,
    metadata?: Metadata,
  ): Promise<CommissionListResponse> | Observable<CommissionListResponse> | CommissionListResponse;

  getCommissionsByApporteur(
    request: GetByApporteurRequest,
    metadata?: Metadata,
  ): Promise<CommissionListResponse> | Observable<CommissionListResponse> | CommissionListResponse;

  getCommissionsByPeriode(
    request: GetByPeriodeRequest,
    metadata?: Metadata,
  ): Promise<CommissionListResponse> | Observable<CommissionListResponse> | CommissionListResponse;

  updateCommission(
    request: UpdateCommissionRequest,
    metadata?: Metadata,
  ): Promise<CommissionResponse> | Observable<CommissionResponse> | CommissionResponse;

  deleteCommission(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== Bareme CRUD ===== */

  createBareme(
    request: CreateBaremeRequest,
    metadata?: Metadata,
  ): Promise<BaremeResponse> | Observable<BaremeResponse> | BaremeResponse;

  getBareme(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<BaremeResponse> | Observable<BaremeResponse> | BaremeResponse;

  getBaremes(
    request: GetBaremesRequest,
    metadata?: Metadata,
  ): Promise<BaremeListResponse> | Observable<BaremeListResponse> | BaremeListResponse;

  getBaremeApplicable(
    request: GetBaremeApplicableRequest,
    metadata?: Metadata,
  ): Promise<BaremeResponse> | Observable<BaremeResponse> | BaremeResponse;

  updateBareme(
    request: UpdateBaremeRequest,
    metadata?: Metadata,
  ): Promise<BaremeResponse> | Observable<BaremeResponse> | BaremeResponse;

  deleteBareme(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== Palier CRUD ===== */

  createPalier(
    request: CreatePalierRequest,
    metadata?: Metadata,
  ): Promise<PalierResponse> | Observable<PalierResponse> | PalierResponse;

  getPalier(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<PalierResponse> | Observable<PalierResponse> | PalierResponse;

  getPaliersByBareme(
    request: GetByBaremeRequest,
    metadata?: Metadata,
  ): Promise<PalierListResponse> | Observable<PalierListResponse> | PalierListResponse;

  updatePalier(
    request: UpdatePalierRequest,
    metadata?: Metadata,
  ): Promise<PalierResponse> | Observable<PalierResponse> | PalierResponse;

  deletePalier(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== Bordereau CRUD ===== */

  createBordereau(
    request: CreateBordereauRequest,
    metadata?: Metadata,
  ): Promise<BordereauResponse> | Observable<BordereauResponse> | BordereauResponse;

  getBordereau(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<BordereauResponse> | Observable<BordereauResponse> | BordereauResponse;

  getBordereaux(
    request: GetBordereauxRequest,
    metadata?: Metadata,
  ): Promise<BordereauListResponse> | Observable<BordereauListResponse> | BordereauListResponse;

  getBordereauByApporteurPeriode(
    request: GetBordereauByApporteurPeriodeRequest,
    metadata?: Metadata,
  ): Promise<BordereauResponse> | Observable<BordereauResponse> | BordereauResponse;

  updateBordereau(
    request: UpdateBordereauRequest,
    metadata?: Metadata,
  ): Promise<BordereauResponse> | Observable<BordereauResponse> | BordereauResponse;

  validateBordereau(
    request: ValidateBordereauRequest,
    metadata?: Metadata,
  ): Promise<BordereauResponse> | Observable<BordereauResponse> | BordereauResponse;

  exportBordereau(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<ExportBordereauResponse> | Observable<ExportBordereauResponse> | ExportBordereauResponse;

  deleteBordereau(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== LigneBordereau CRUD ===== */

  createLigneBordereau(
    request: CreateLigneBordereauRequest,
    metadata?: Metadata,
  ): Promise<LigneBordereauResponse> | Observable<LigneBordereauResponse> | LigneBordereauResponse;

  getLigneBordereau(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<LigneBordereauResponse> | Observable<LigneBordereauResponse> | LigneBordereauResponse;

  getLignesByBordereau(
    request: GetByBordereauRequest,
    metadata?: Metadata,
  ): Promise<LigneBordereauListResponse> | Observable<LigneBordereauListResponse> | LigneBordereauListResponse;

  updateLigneBordereau(
    request: UpdateLigneBordereauRequest,
    metadata?: Metadata,
  ): Promise<LigneBordereauResponse> | Observable<LigneBordereauResponse> | LigneBordereauResponse;

  validateLigne(
    request: ValidateLigneRequest,
    metadata?: Metadata,
  ): Promise<LigneBordereauResponse> | Observable<LigneBordereauResponse> | LigneBordereauResponse;

  deleteLigneBordereau(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== Reprise CRUD ===== */

  createReprise(
    request: CreateRepriseRequest,
    metadata?: Metadata,
  ): Promise<RepriseResponse> | Observable<RepriseResponse> | RepriseResponse;

  getReprise(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<RepriseResponse> | Observable<RepriseResponse> | RepriseResponse;

  getReprises(
    request: GetReprisesRequest,
    metadata?: Metadata,
  ): Promise<RepriseListResponse> | Observable<RepriseListResponse> | RepriseListResponse;

  getReprisesByCommission(
    request: GetByCommissionRequest,
    metadata?: Metadata,
  ): Promise<RepriseListResponse> | Observable<RepriseListResponse> | RepriseListResponse;

  applyReprise(
    request: ApplyRepriseRequest,
    metadata?: Metadata,
  ): Promise<RepriseResponse> | Observable<RepriseResponse> | RepriseResponse;

  cancelReprise(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<RepriseResponse> | Observable<RepriseResponse> | RepriseResponse;

  deleteReprise(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== StatutCommission CRUD ===== */

  createStatut(
    request: CreateStatutRequest,
    metadata?: Metadata,
  ): Promise<StatutResponse> | Observable<StatutResponse> | StatutResponse;

  getStatut(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<StatutResponse> | Observable<StatutResponse> | StatutResponse;

  getStatuts(
    request: GetStatutsRequest,
    metadata?: Metadata,
  ): Promise<StatutListResponse> | Observable<StatutListResponse> | StatutListResponse;

  getStatutByCode(
    request: GetStatutByCodeRequest,
    metadata?: Metadata,
  ): Promise<StatutResponse> | Observable<StatutResponse> | StatutResponse;

  updateStatut(
    request: UpdateStatutRequest,
    metadata?: Metadata,
  ): Promise<StatutResponse> | Observable<StatutResponse> | StatutResponse;

  deleteStatut(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== Commission Engine ===== */

  calculerCommission(
    request: CalculerCommissionRequest,
    metadata?: Metadata,
  ): Promise<CalculerCommissionResponse> | Observable<CalculerCommissionResponse> | CalculerCommissionResponse;

  genererBordereau(
    request: GenererBordereauRequest,
    metadata?: Metadata,
  ): Promise<GenererBordereauResponse> | Observable<GenererBordereauResponse> | GenererBordereauResponse;

  declencherReprise(
    request: DeclencherRepriseRequest,
    metadata?: Metadata,
  ): Promise<RepriseResponse> | Observable<RepriseResponse> | RepriseResponse;

  /** ===== Audit Logs ===== */

  getAuditLogs(
    request: GetAuditLogsRequest,
    metadata?: Metadata,
  ): Promise<AuditLogListResponse> | Observable<AuditLogListResponse> | AuditLogListResponse;

  getAuditLogsByRef(
    request: GetAuditLogsByRefRequest,
    metadata?: Metadata,
  ): Promise<AuditLogListResponse> | Observable<AuditLogListResponse> | AuditLogListResponse;

  getAuditLogsByCommission(
    request: GetByCommissionRequest,
    metadata?: Metadata,
  ): Promise<AuditLogListResponse> | Observable<AuditLogListResponse> | AuditLogListResponse;

  /** ===== Recurrences ===== */

  getRecurrences(
    request: GetRecurrencesRequest,
    metadata?: Metadata,
  ): Promise<RecurrenceListResponse> | Observable<RecurrenceListResponse> | RecurrenceListResponse;

  getRecurrencesByContrat(
    request: GetRecurrencesByContratRequest,
    metadata?: Metadata,
  ): Promise<RecurrenceListResponse> | Observable<RecurrenceListResponse> | RecurrenceListResponse;

  /** ===== Reports Negatifs ===== */

  getReportsNegatifs(
    request: GetReportsNegatifsRequest,
    metadata?: Metadata,
  ): Promise<ReportNegatifListResponse> | Observable<ReportNegatifListResponse> | ReportNegatifListResponse;
}

export function CommissionServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createCommission",
      "getCommission",
      "getCommissions",
      "getCommissionsByApporteur",
      "getCommissionsByPeriode",
      "updateCommission",
      "deleteCommission",
      "createBareme",
      "getBareme",
      "getBaremes",
      "getBaremeApplicable",
      "updateBareme",
      "deleteBareme",
      "createPalier",
      "getPalier",
      "getPaliersByBareme",
      "updatePalier",
      "deletePalier",
      "createBordereau",
      "getBordereau",
      "getBordereaux",
      "getBordereauByApporteurPeriode",
      "updateBordereau",
      "validateBordereau",
      "exportBordereau",
      "deleteBordereau",
      "createLigneBordereau",
      "getLigneBordereau",
      "getLignesByBordereau",
      "updateLigneBordereau",
      "validateLigne",
      "deleteLigneBordereau",
      "createReprise",
      "getReprise",
      "getReprises",
      "getReprisesByCommission",
      "applyReprise",
      "cancelReprise",
      "deleteReprise",
      "createStatut",
      "getStatut",
      "getStatuts",
      "getStatutByCode",
      "updateStatut",
      "deleteStatut",
      "calculerCommission",
      "genererBordereau",
      "declencherReprise",
      "getAuditLogs",
      "getAuditLogsByRef",
      "getAuditLogsByCommission",
      "getRecurrences",
      "getRecurrencesByContrat",
      "getReportsNegatifs",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("CommissionService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("CommissionService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const COMMISSION_SERVICE_NAME = "CommissionService";

export type CommissionServiceService = typeof CommissionServiceService;
export const CommissionServiceService = {
  /** ===== Commission CRUD ===== */
  createCommission: {
    path: "/commission.CommissionService/CreateCommission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCommissionRequest): Buffer =>
      Buffer.from(CreateCommissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCommissionRequest => CreateCommissionRequest.decode(value),
    responseSerialize: (value: CommissionResponse): Buffer => Buffer.from(CommissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommissionResponse => CommissionResponse.decode(value),
  },
  getCommission: {
    path: "/commission.CommissionService/GetCommission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: CommissionResponse): Buffer => Buffer.from(CommissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommissionResponse => CommissionResponse.decode(value),
  },
  getCommissions: {
    path: "/commission.CommissionService/GetCommissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCommissionsRequest): Buffer =>
      Buffer.from(GetCommissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCommissionsRequest => GetCommissionsRequest.decode(value),
    responseSerialize: (value: CommissionListResponse): Buffer =>
      Buffer.from(CommissionListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommissionListResponse => CommissionListResponse.decode(value),
  },
  getCommissionsByApporteur: {
    path: "/commission.CommissionService/GetCommissionsByApporteur",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByApporteurRequest): Buffer =>
      Buffer.from(GetByApporteurRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByApporteurRequest => GetByApporteurRequest.decode(value),
    responseSerialize: (value: CommissionListResponse): Buffer =>
      Buffer.from(CommissionListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommissionListResponse => CommissionListResponse.decode(value),
  },
  getCommissionsByPeriode: {
    path: "/commission.CommissionService/GetCommissionsByPeriode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByPeriodeRequest): Buffer => Buffer.from(GetByPeriodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByPeriodeRequest => GetByPeriodeRequest.decode(value),
    responseSerialize: (value: CommissionListResponse): Buffer =>
      Buffer.from(CommissionListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommissionListResponse => CommissionListResponse.decode(value),
  },
  updateCommission: {
    path: "/commission.CommissionService/UpdateCommission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCommissionRequest): Buffer =>
      Buffer.from(UpdateCommissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateCommissionRequest => UpdateCommissionRequest.decode(value),
    responseSerialize: (value: CommissionResponse): Buffer => Buffer.from(CommissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CommissionResponse => CommissionResponse.decode(value),
  },
  deleteCommission: {
    path: "/commission.CommissionService/DeleteCommission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== Bareme CRUD ===== */
  createBareme: {
    path: "/commission.CommissionService/CreateBareme",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBaremeRequest): Buffer => Buffer.from(CreateBaremeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateBaremeRequest => CreateBaremeRequest.decode(value),
    responseSerialize: (value: BaremeResponse): Buffer => Buffer.from(BaremeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaremeResponse => BaremeResponse.decode(value),
  },
  getBareme: {
    path: "/commission.CommissionService/GetBareme",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: BaremeResponse): Buffer => Buffer.from(BaremeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaremeResponse => BaremeResponse.decode(value),
  },
  getBaremes: {
    path: "/commission.CommissionService/GetBaremes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBaremesRequest): Buffer => Buffer.from(GetBaremesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBaremesRequest => GetBaremesRequest.decode(value),
    responseSerialize: (value: BaremeListResponse): Buffer => Buffer.from(BaremeListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaremeListResponse => BaremeListResponse.decode(value),
  },
  getBaremeApplicable: {
    path: "/commission.CommissionService/GetBaremeApplicable",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBaremeApplicableRequest): Buffer =>
      Buffer.from(GetBaremeApplicableRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBaremeApplicableRequest => GetBaremeApplicableRequest.decode(value),
    responseSerialize: (value: BaremeResponse): Buffer => Buffer.from(BaremeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaremeResponse => BaremeResponse.decode(value),
  },
  updateBareme: {
    path: "/commission.CommissionService/UpdateBareme",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBaremeRequest): Buffer => Buffer.from(UpdateBaremeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateBaremeRequest => UpdateBaremeRequest.decode(value),
    responseSerialize: (value: BaremeResponse): Buffer => Buffer.from(BaremeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BaremeResponse => BaremeResponse.decode(value),
  },
  deleteBareme: {
    path: "/commission.CommissionService/DeleteBareme",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== Palier CRUD ===== */
  createPalier: {
    path: "/commission.CommissionService/CreatePalier",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePalierRequest): Buffer => Buffer.from(CreatePalierRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePalierRequest => CreatePalierRequest.decode(value),
    responseSerialize: (value: PalierResponse): Buffer => Buffer.from(PalierResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PalierResponse => PalierResponse.decode(value),
  },
  getPalier: {
    path: "/commission.CommissionService/GetPalier",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PalierResponse): Buffer => Buffer.from(PalierResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PalierResponse => PalierResponse.decode(value),
  },
  getPaliersByBareme: {
    path: "/commission.CommissionService/GetPaliersByBareme",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByBaremeRequest): Buffer => Buffer.from(GetByBaremeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByBaremeRequest => GetByBaremeRequest.decode(value),
    responseSerialize: (value: PalierListResponse): Buffer => Buffer.from(PalierListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PalierListResponse => PalierListResponse.decode(value),
  },
  updatePalier: {
    path: "/commission.CommissionService/UpdatePalier",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePalierRequest): Buffer => Buffer.from(UpdatePalierRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePalierRequest => UpdatePalierRequest.decode(value),
    responseSerialize: (value: PalierResponse): Buffer => Buffer.from(PalierResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PalierResponse => PalierResponse.decode(value),
  },
  deletePalier: {
    path: "/commission.CommissionService/DeletePalier",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== Bordereau CRUD ===== */
  createBordereau: {
    path: "/commission.CommissionService/CreateBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBordereauRequest): Buffer =>
      Buffer.from(CreateBordereauRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateBordereauRequest => CreateBordereauRequest.decode(value),
    responseSerialize: (value: BordereauResponse): Buffer => Buffer.from(BordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BordereauResponse => BordereauResponse.decode(value),
  },
  getBordereau: {
    path: "/commission.CommissionService/GetBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: BordereauResponse): Buffer => Buffer.from(BordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BordereauResponse => BordereauResponse.decode(value),
  },
  getBordereaux: {
    path: "/commission.CommissionService/GetBordereaux",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBordereauxRequest): Buffer => Buffer.from(GetBordereauxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBordereauxRequest => GetBordereauxRequest.decode(value),
    responseSerialize: (value: BordereauListResponse): Buffer =>
      Buffer.from(BordereauListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BordereauListResponse => BordereauListResponse.decode(value),
  },
  getBordereauByApporteurPeriode: {
    path: "/commission.CommissionService/GetBordereauByApporteurPeriode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBordereauByApporteurPeriodeRequest): Buffer =>
      Buffer.from(GetBordereauByApporteurPeriodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBordereauByApporteurPeriodeRequest =>
      GetBordereauByApporteurPeriodeRequest.decode(value),
    responseSerialize: (value: BordereauResponse): Buffer => Buffer.from(BordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BordereauResponse => BordereauResponse.decode(value),
  },
  updateBordereau: {
    path: "/commission.CommissionService/UpdateBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBordereauRequest): Buffer =>
      Buffer.from(UpdateBordereauRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateBordereauRequest => UpdateBordereauRequest.decode(value),
    responseSerialize: (value: BordereauResponse): Buffer => Buffer.from(BordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BordereauResponse => BordereauResponse.decode(value),
  },
  validateBordereau: {
    path: "/commission.CommissionService/ValidateBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateBordereauRequest): Buffer =>
      Buffer.from(ValidateBordereauRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ValidateBordereauRequest => ValidateBordereauRequest.decode(value),
    responseSerialize: (value: BordereauResponse): Buffer => Buffer.from(BordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BordereauResponse => BordereauResponse.decode(value),
  },
  exportBordereau: {
    path: "/commission.CommissionService/ExportBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: ExportBordereauResponse): Buffer =>
      Buffer.from(ExportBordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExportBordereauResponse => ExportBordereauResponse.decode(value),
  },
  deleteBordereau: {
    path: "/commission.CommissionService/DeleteBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== LigneBordereau CRUD ===== */
  createLigneBordereau: {
    path: "/commission.CommissionService/CreateLigneBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateLigneBordereauRequest): Buffer =>
      Buffer.from(CreateLigneBordereauRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateLigneBordereauRequest => CreateLigneBordereauRequest.decode(value),
    responseSerialize: (value: LigneBordereauResponse): Buffer =>
      Buffer.from(LigneBordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneBordereauResponse => LigneBordereauResponse.decode(value),
  },
  getLigneBordereau: {
    path: "/commission.CommissionService/GetLigneBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: LigneBordereauResponse): Buffer =>
      Buffer.from(LigneBordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneBordereauResponse => LigneBordereauResponse.decode(value),
  },
  getLignesByBordereau: {
    path: "/commission.CommissionService/GetLignesByBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByBordereauRequest): Buffer =>
      Buffer.from(GetByBordereauRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByBordereauRequest => GetByBordereauRequest.decode(value),
    responseSerialize: (value: LigneBordereauListResponse): Buffer =>
      Buffer.from(LigneBordereauListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneBordereauListResponse => LigneBordereauListResponse.decode(value),
  },
  updateLigneBordereau: {
    path: "/commission.CommissionService/UpdateLigneBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateLigneBordereauRequest): Buffer =>
      Buffer.from(UpdateLigneBordereauRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateLigneBordereauRequest => UpdateLigneBordereauRequest.decode(value),
    responseSerialize: (value: LigneBordereauResponse): Buffer =>
      Buffer.from(LigneBordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneBordereauResponse => LigneBordereauResponse.decode(value),
  },
  validateLigne: {
    path: "/commission.CommissionService/ValidateLigne",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateLigneRequest): Buffer => Buffer.from(ValidateLigneRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ValidateLigneRequest => ValidateLigneRequest.decode(value),
    responseSerialize: (value: LigneBordereauResponse): Buffer =>
      Buffer.from(LigneBordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneBordereauResponse => LigneBordereauResponse.decode(value),
  },
  deleteLigneBordereau: {
    path: "/commission.CommissionService/DeleteLigneBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== Reprise CRUD ===== */
  createReprise: {
    path: "/commission.CommissionService/CreateReprise",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRepriseRequest): Buffer => Buffer.from(CreateRepriseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateRepriseRequest => CreateRepriseRequest.decode(value),
    responseSerialize: (value: RepriseResponse): Buffer => Buffer.from(RepriseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepriseResponse => RepriseResponse.decode(value),
  },
  getReprise: {
    path: "/commission.CommissionService/GetReprise",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: RepriseResponse): Buffer => Buffer.from(RepriseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepriseResponse => RepriseResponse.decode(value),
  },
  getReprises: {
    path: "/commission.CommissionService/GetReprises",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReprisesRequest): Buffer => Buffer.from(GetReprisesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReprisesRequest => GetReprisesRequest.decode(value),
    responseSerialize: (value: RepriseListResponse): Buffer => Buffer.from(RepriseListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepriseListResponse => RepriseListResponse.decode(value),
  },
  getReprisesByCommission: {
    path: "/commission.CommissionService/GetReprisesByCommission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByCommissionRequest): Buffer =>
      Buffer.from(GetByCommissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByCommissionRequest => GetByCommissionRequest.decode(value),
    responseSerialize: (value: RepriseListResponse): Buffer => Buffer.from(RepriseListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepriseListResponse => RepriseListResponse.decode(value),
  },
  applyReprise: {
    path: "/commission.CommissionService/ApplyReprise",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ApplyRepriseRequest): Buffer => Buffer.from(ApplyRepriseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ApplyRepriseRequest => ApplyRepriseRequest.decode(value),
    responseSerialize: (value: RepriseResponse): Buffer => Buffer.from(RepriseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepriseResponse => RepriseResponse.decode(value),
  },
  cancelReprise: {
    path: "/commission.CommissionService/CancelReprise",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: RepriseResponse): Buffer => Buffer.from(RepriseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepriseResponse => RepriseResponse.decode(value),
  },
  deleteReprise: {
    path: "/commission.CommissionService/DeleteReprise",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== StatutCommission CRUD ===== */
  createStatut: {
    path: "/commission.CommissionService/CreateStatut",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStatutRequest): Buffer => Buffer.from(CreateStatutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStatutRequest => CreateStatutRequest.decode(value),
    responseSerialize: (value: StatutResponse): Buffer => Buffer.from(StatutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutResponse => StatutResponse.decode(value),
  },
  getStatut: {
    path: "/commission.CommissionService/GetStatut",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StatutResponse): Buffer => Buffer.from(StatutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutResponse => StatutResponse.decode(value),
  },
  getStatuts: {
    path: "/commission.CommissionService/GetStatuts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutsRequest): Buffer => Buffer.from(GetStatutsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutsRequest => GetStatutsRequest.decode(value),
    responseSerialize: (value: StatutListResponse): Buffer => Buffer.from(StatutListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutListResponse => StatutListResponse.decode(value),
  },
  getStatutByCode: {
    path: "/commission.CommissionService/GetStatutByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutByCodeRequest): Buffer =>
      Buffer.from(GetStatutByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutByCodeRequest => GetStatutByCodeRequest.decode(value),
    responseSerialize: (value: StatutResponse): Buffer => Buffer.from(StatutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutResponse => StatutResponse.decode(value),
  },
  updateStatut: {
    path: "/commission.CommissionService/UpdateStatut",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateStatutRequest): Buffer => Buffer.from(UpdateStatutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateStatutRequest => UpdateStatutRequest.decode(value),
    responseSerialize: (value: StatutResponse): Buffer => Buffer.from(StatutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutResponse => StatutResponse.decode(value),
  },
  deleteStatut: {
    path: "/commission.CommissionService/DeleteStatut",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== Commission Engine ===== */
  calculerCommission: {
    path: "/commission.CommissionService/CalculerCommission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CalculerCommissionRequest): Buffer =>
      Buffer.from(CalculerCommissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CalculerCommissionRequest => CalculerCommissionRequest.decode(value),
    responseSerialize: (value: CalculerCommissionResponse): Buffer =>
      Buffer.from(CalculerCommissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalculerCommissionResponse => CalculerCommissionResponse.decode(value),
  },
  genererBordereau: {
    path: "/commission.CommissionService/GenererBordereau",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenererBordereauRequest): Buffer =>
      Buffer.from(GenererBordereauRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GenererBordereauRequest => GenererBordereauRequest.decode(value),
    responseSerialize: (value: GenererBordereauResponse): Buffer =>
      Buffer.from(GenererBordereauResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GenererBordereauResponse => GenererBordereauResponse.decode(value),
  },
  declencherReprise: {
    path: "/commission.CommissionService/DeclencherReprise",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeclencherRepriseRequest): Buffer =>
      Buffer.from(DeclencherRepriseRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeclencherRepriseRequest => DeclencherRepriseRequest.decode(value),
    responseSerialize: (value: RepriseResponse): Buffer => Buffer.from(RepriseResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepriseResponse => RepriseResponse.decode(value),
  },
  /** ===== Audit Logs ===== */
  getAuditLogs: {
    path: "/commission.CommissionService/GetAuditLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditLogsRequest): Buffer => Buffer.from(GetAuditLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuditLogsRequest => GetAuditLogsRequest.decode(value),
    responseSerialize: (value: AuditLogListResponse): Buffer =>
      Buffer.from(AuditLogListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuditLogListResponse => AuditLogListResponse.decode(value),
  },
  getAuditLogsByRef: {
    path: "/commission.CommissionService/GetAuditLogsByRef",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditLogsByRefRequest): Buffer =>
      Buffer.from(GetAuditLogsByRefRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuditLogsByRefRequest => GetAuditLogsByRefRequest.decode(value),
    responseSerialize: (value: AuditLogListResponse): Buffer =>
      Buffer.from(AuditLogListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuditLogListResponse => AuditLogListResponse.decode(value),
  },
  getAuditLogsByCommission: {
    path: "/commission.CommissionService/GetAuditLogsByCommission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByCommissionRequest): Buffer =>
      Buffer.from(GetByCommissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByCommissionRequest => GetByCommissionRequest.decode(value),
    responseSerialize: (value: AuditLogListResponse): Buffer =>
      Buffer.from(AuditLogListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuditLogListResponse => AuditLogListResponse.decode(value),
  },
  /** ===== Recurrences ===== */
  getRecurrences: {
    path: "/commission.CommissionService/GetRecurrences",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRecurrencesRequest): Buffer =>
      Buffer.from(GetRecurrencesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRecurrencesRequest => GetRecurrencesRequest.decode(value),
    responseSerialize: (value: RecurrenceListResponse): Buffer =>
      Buffer.from(RecurrenceListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RecurrenceListResponse => RecurrenceListResponse.decode(value),
  },
  getRecurrencesByContrat: {
    path: "/commission.CommissionService/GetRecurrencesByContrat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRecurrencesByContratRequest): Buffer =>
      Buffer.from(GetRecurrencesByContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRecurrencesByContratRequest => GetRecurrencesByContratRequest.decode(value),
    responseSerialize: (value: RecurrenceListResponse): Buffer =>
      Buffer.from(RecurrenceListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RecurrenceListResponse => RecurrenceListResponse.decode(value),
  },
  /** ===== Reports Negatifs ===== */
  getReportsNegatifs: {
    path: "/commission.CommissionService/GetReportsNegatifs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReportsNegatifsRequest): Buffer =>
      Buffer.from(GetReportsNegatifsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReportsNegatifsRequest => GetReportsNegatifsRequest.decode(value),
    responseSerialize: (value: ReportNegatifListResponse): Buffer =>
      Buffer.from(ReportNegatifListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReportNegatifListResponse => ReportNegatifListResponse.decode(value),
  },
} as const;

export interface CommissionServiceServer extends UntypedServiceImplementation {
  /** ===== Commission CRUD ===== */
  createCommission: handleUnaryCall<CreateCommissionRequest, CommissionResponse>;
  getCommission: handleUnaryCall<GetByIdRequest, CommissionResponse>;
  getCommissions: handleUnaryCall<GetCommissionsRequest, CommissionListResponse>;
  getCommissionsByApporteur: handleUnaryCall<GetByApporteurRequest, CommissionListResponse>;
  getCommissionsByPeriode: handleUnaryCall<GetByPeriodeRequest, CommissionListResponse>;
  updateCommission: handleUnaryCall<UpdateCommissionRequest, CommissionResponse>;
  deleteCommission: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ===== Bareme CRUD ===== */
  createBareme: handleUnaryCall<CreateBaremeRequest, BaremeResponse>;
  getBareme: handleUnaryCall<GetByIdRequest, BaremeResponse>;
  getBaremes: handleUnaryCall<GetBaremesRequest, BaremeListResponse>;
  getBaremeApplicable: handleUnaryCall<GetBaremeApplicableRequest, BaremeResponse>;
  updateBareme: handleUnaryCall<UpdateBaremeRequest, BaremeResponse>;
  deleteBareme: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ===== Palier CRUD ===== */
  createPalier: handleUnaryCall<CreatePalierRequest, PalierResponse>;
  getPalier: handleUnaryCall<GetByIdRequest, PalierResponse>;
  getPaliersByBareme: handleUnaryCall<GetByBaremeRequest, PalierListResponse>;
  updatePalier: handleUnaryCall<UpdatePalierRequest, PalierResponse>;
  deletePalier: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ===== Bordereau CRUD ===== */
  createBordereau: handleUnaryCall<CreateBordereauRequest, BordereauResponse>;
  getBordereau: handleUnaryCall<GetByIdRequest, BordereauResponse>;
  getBordereaux: handleUnaryCall<GetBordereauxRequest, BordereauListResponse>;
  getBordereauByApporteurPeriode: handleUnaryCall<GetBordereauByApporteurPeriodeRequest, BordereauResponse>;
  updateBordereau: handleUnaryCall<UpdateBordereauRequest, BordereauResponse>;
  validateBordereau: handleUnaryCall<ValidateBordereauRequest, BordereauResponse>;
  exportBordereau: handleUnaryCall<GetByIdRequest, ExportBordereauResponse>;
  deleteBordereau: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ===== LigneBordereau CRUD ===== */
  createLigneBordereau: handleUnaryCall<CreateLigneBordereauRequest, LigneBordereauResponse>;
  getLigneBordereau: handleUnaryCall<GetByIdRequest, LigneBordereauResponse>;
  getLignesByBordereau: handleUnaryCall<GetByBordereauRequest, LigneBordereauListResponse>;
  updateLigneBordereau: handleUnaryCall<UpdateLigneBordereauRequest, LigneBordereauResponse>;
  validateLigne: handleUnaryCall<ValidateLigneRequest, LigneBordereauResponse>;
  deleteLigneBordereau: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ===== Reprise CRUD ===== */
  createReprise: handleUnaryCall<CreateRepriseRequest, RepriseResponse>;
  getReprise: handleUnaryCall<GetByIdRequest, RepriseResponse>;
  getReprises: handleUnaryCall<GetReprisesRequest, RepriseListResponse>;
  getReprisesByCommission: handleUnaryCall<GetByCommissionRequest, RepriseListResponse>;
  applyReprise: handleUnaryCall<ApplyRepriseRequest, RepriseResponse>;
  cancelReprise: handleUnaryCall<GetByIdRequest, RepriseResponse>;
  deleteReprise: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ===== StatutCommission CRUD ===== */
  createStatut: handleUnaryCall<CreateStatutRequest, StatutResponse>;
  getStatut: handleUnaryCall<GetByIdRequest, StatutResponse>;
  getStatuts: handleUnaryCall<GetStatutsRequest, StatutListResponse>;
  getStatutByCode: handleUnaryCall<GetStatutByCodeRequest, StatutResponse>;
  updateStatut: handleUnaryCall<UpdateStatutRequest, StatutResponse>;
  deleteStatut: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ===== Commission Engine ===== */
  calculerCommission: handleUnaryCall<CalculerCommissionRequest, CalculerCommissionResponse>;
  genererBordereau: handleUnaryCall<GenererBordereauRequest, GenererBordereauResponse>;
  declencherReprise: handleUnaryCall<DeclencherRepriseRequest, RepriseResponse>;
  /** ===== Audit Logs ===== */
  getAuditLogs: handleUnaryCall<GetAuditLogsRequest, AuditLogListResponse>;
  getAuditLogsByRef: handleUnaryCall<GetAuditLogsByRefRequest, AuditLogListResponse>;
  getAuditLogsByCommission: handleUnaryCall<GetByCommissionRequest, AuditLogListResponse>;
  /** ===== Recurrences ===== */
  getRecurrences: handleUnaryCall<GetRecurrencesRequest, RecurrenceListResponse>;
  getRecurrencesByContrat: handleUnaryCall<GetRecurrencesByContratRequest, RecurrenceListResponse>;
  /** ===== Reports Negatifs ===== */
  getReportsNegatifs: handleUnaryCall<GetReportsNegatifsRequest, ReportNegatifListResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
