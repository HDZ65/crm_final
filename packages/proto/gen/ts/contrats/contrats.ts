// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: contrats/contrats.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface StatutContrat {
  id: string;
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateStatutContratRequest {
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
}

export interface UpdateStatutContratRequest {
  id: string;
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
}

export interface GetStatutContratRequest {
  id: string;
}

export interface GetStatutContratByCodeRequest {
  code: string;
}

export interface ListStatutContratRequest {
  pagination?: Pagination | undefined;
}

export interface ListStatutContratResponse {
  statuts: StatutContrat[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteStatutContratRequest {
  id: string;
}

export interface Contrat {
  id: string;
  organisationId: string;
  reference: string;
  titre: string;
  description: string;
  type: string;
  statut: string;
  dateDebut: string;
  dateFin: string;
  dateSignature: string;
  montant: number;
  devise: string;
  frequenceFacturation: string;
  documentUrl: string;
  fournisseur: string;
  clientId: string;
  commercialId: string;
  societeId: string;
  notes: string;
  createdAt: string;
  updatedAt: string;
}

export interface ContratWithDetails {
  contrat?: Contrat | undefined;
  lignes: LigneContrat[];
  historique: HistoriqueStatutContrat[];
}

export interface CreateContratRequest {
  organisationId: string;
  reference: string;
  titre: string;
  description: string;
  type: string;
  statut: string;
  dateDebut: string;
  dateFin: string;
  dateSignature: string;
  montant: number;
  devise: string;
  frequenceFacturation: string;
  documentUrl: string;
  fournisseur: string;
  clientId: string;
  commercialId: string;
  societeId: string;
  notes: string;
}

export interface UpdateContratRequest {
  id: string;
  reference: string;
  titre: string;
  description: string;
  type: string;
  statut: string;
  dateDebut: string;
  dateFin: string;
  dateSignature: string;
  montant: number;
  devise: string;
  frequenceFacturation: string;
  documentUrl: string;
  fournisseur: string;
  clientId: string;
  commercialId: string;
  societeId: string;
  notes: string;
}

export interface GetContratRequest {
  id: string;
}

export interface GetContratByReferenceRequest {
  organisationId: string;
  reference: string;
}

export interface ListContratRequest {
  organisationId: string;
  clientId: string;
  commercialId: string;
  societeId: string;
  statut: string;
  search: string;
  pagination?: Pagination | undefined;
}

export interface ListContratResponse {
  contrats: Contrat[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteContratRequest {
  id: string;
}

export interface LigneContrat {
  id: string;
  contratId: string;
  produitId: string;
  periodeFacturationId: string;
  quantite: number;
  prixUnitaire: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateLigneContratRequest {
  contratId: string;
  produitId: string;
  periodeFacturationId: string;
  quantite: number;
  prixUnitaire: number;
}

export interface UpdateLigneContratRequest {
  id: string;
  produitId: string;
  periodeFacturationId: string;
  quantite: number;
  prixUnitaire: number;
}

export interface GetLigneContratRequest {
  id: string;
}

export interface ListLigneContratByContratRequest {
  contratId: string;
  pagination?: Pagination | undefined;
}

export interface ListLigneContratResponse {
  lignes: LigneContrat[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteLigneContratRequest {
  id: string;
}

export interface HistoriqueStatutContrat {
  id: string;
  contratId: string;
  ancienStatutId: string;
  nouveauStatutId: string;
  dateChangement: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateHistoriqueStatutContratRequest {
  contratId: string;
  ancienStatutId: string;
  nouveauStatutId: string;
  dateChangement: string;
}

export interface GetHistoriqueStatutContratRequest {
  id: string;
}

export interface ListHistoriqueByContratRequest {
  contratId: string;
  pagination?: Pagination | undefined;
}

export interface ListHistoriqueStatutContratResponse {
  historique: HistoriqueStatutContrat[];
  pagination?: PaginationResult | undefined;
}

export interface DeleteHistoriqueStatutContratRequest {
  id: string;
}

export interface OrchestrationRequest {
  contractId: string;
  /** JSON payload */
  payload: string;
}

export interface OrchestrationResponse {
  success: boolean;
  message: string;
  historyId: string;
}

export interface OrchestrationHistory {
  id: string;
  contractId: string;
  operation: string;
  status: string;
  payload: string;
  responsePayload: string;
  errorMessage: string;
  startedAt: string;
  finishedAt: string;
  createdAt: string;
}

export interface GetOrchestrationHistoryRequest {
  contractId: string;
  pagination?: Pagination | undefined;
}

export interface ListOrchestrationHistoryResponse {
  history: OrchestrationHistory[];
  pagination?: PaginationResult | undefined;
}

/** ========== COMMON MESSAGES ========== */
export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
}

function createBaseStatutContrat(): StatutContrat {
  return { id: "", code: "", nom: "", description: "", ordreAffichage: 0, createdAt: "", updatedAt: "" };
}

export const StatutContrat: MessageFns<StatutContrat> = {
  encode(message: StatutContrat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(40).int32(message.ordreAffichage);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatutContrat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatutContrat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStatutContratRequest(): CreateStatutContratRequest {
  return { code: "", nom: "", description: "", ordreAffichage: 0 };
}

export const CreateStatutContratRequest: MessageFns<CreateStatutContratRequest> = {
  encode(message: CreateStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(32).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateStatutContratRequest(): UpdateStatutContratRequest {
  return { id: "", code: "", nom: "", description: "", ordreAffichage: 0 };
}

export const UpdateStatutContratRequest: MessageFns<UpdateStatutContratRequest> = {
  encode(message: UpdateStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(40).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutContratRequest(): GetStatutContratRequest {
  return { id: "" };
}

export const GetStatutContratRequest: MessageFns<GetStatutContratRequest> = {
  encode(message: GetStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutContratByCodeRequest(): GetStatutContratByCodeRequest {
  return { code: "" };
}

export const GetStatutContratByCodeRequest: MessageFns<GetStatutContratByCodeRequest> = {
  encode(message: GetStatutContratByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutContratByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutContratByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListStatutContratRequest(): ListStatutContratRequest {
  return {};
}

export const ListStatutContratRequest: MessageFns<ListStatutContratRequest> = {
  encode(message: ListStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListStatutContratResponse(): ListStatutContratResponse {
  return { statuts: [] };
}

export const ListStatutContratResponse: MessageFns<ListStatutContratResponse> = {
  encode(message: ListStatutContratResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.statuts) {
      StatutContrat.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStatutContratResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStatutContratResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statuts.push(StatutContrat.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteStatutContratRequest(): DeleteStatutContratRequest {
  return { id: "" };
}

export const DeleteStatutContratRequest: MessageFns<DeleteStatutContratRequest> = {
  encode(message: DeleteStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseContrat(): Contrat {
  return {
    id: "",
    organisationId: "",
    reference: "",
    titre: "",
    description: "",
    type: "",
    statut: "",
    dateDebut: "",
    dateFin: "",
    dateSignature: "",
    montant: 0,
    devise: "",
    frequenceFacturation: "",
    documentUrl: "",
    fournisseur: "",
    clientId: "",
    commercialId: "",
    societeId: "",
    notes: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Contrat: MessageFns<Contrat> = {
  encode(message: Contrat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.reference !== "") {
      writer.uint32(26).string(message.reference);
    }
    if (message.titre !== "") {
      writer.uint32(34).string(message.titre);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.statut !== "") {
      writer.uint32(58).string(message.statut);
    }
    if (message.dateDebut !== "") {
      writer.uint32(66).string(message.dateDebut);
    }
    if (message.dateFin !== "") {
      writer.uint32(74).string(message.dateFin);
    }
    if (message.dateSignature !== "") {
      writer.uint32(82).string(message.dateSignature);
    }
    if (message.montant !== 0) {
      writer.uint32(89).double(message.montant);
    }
    if (message.devise !== "") {
      writer.uint32(98).string(message.devise);
    }
    if (message.frequenceFacturation !== "") {
      writer.uint32(106).string(message.frequenceFacturation);
    }
    if (message.documentUrl !== "") {
      writer.uint32(114).string(message.documentUrl);
    }
    if (message.fournisseur !== "") {
      writer.uint32(122).string(message.fournisseur);
    }
    if (message.clientId !== "") {
      writer.uint32(130).string(message.clientId);
    }
    if (message.commercialId !== "") {
      writer.uint32(138).string(message.commercialId);
    }
    if (message.societeId !== "") {
      writer.uint32(146).string(message.societeId);
    }
    if (message.notes !== "") {
      writer.uint32(154).string(message.notes);
    }
    if (message.createdAt !== "") {
      writer.uint32(162).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(170).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Contrat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContrat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.statut = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dateSignature = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.montant = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.devise = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.frequenceFacturation = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.documentUrl = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.fournisseur = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.commercialId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseContratWithDetails(): ContratWithDetails {
  return { lignes: [], historique: [] };
}

export const ContratWithDetails: MessageFns<ContratWithDetails> = {
  encode(message: ContratWithDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contrat !== undefined) {
      Contrat.encode(message.contrat, writer.uint32(10).fork()).join();
    }
    for (const v of message.lignes) {
      LigneContrat.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.historique) {
      HistoriqueStatutContrat.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContratWithDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContratWithDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contrat = Contrat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lignes.push(LigneContrat.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.historique.push(HistoriqueStatutContrat.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateContratRequest(): CreateContratRequest {
  return {
    organisationId: "",
    reference: "",
    titre: "",
    description: "",
    type: "",
    statut: "",
    dateDebut: "",
    dateFin: "",
    dateSignature: "",
    montant: 0,
    devise: "",
    frequenceFacturation: "",
    documentUrl: "",
    fournisseur: "",
    clientId: "",
    commercialId: "",
    societeId: "",
    notes: "",
  };
}

export const CreateContratRequest: MessageFns<CreateContratRequest> = {
  encode(message: CreateContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.reference !== "") {
      writer.uint32(18).string(message.reference);
    }
    if (message.titre !== "") {
      writer.uint32(26).string(message.titre);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.statut !== "") {
      writer.uint32(50).string(message.statut);
    }
    if (message.dateDebut !== "") {
      writer.uint32(58).string(message.dateDebut);
    }
    if (message.dateFin !== "") {
      writer.uint32(66).string(message.dateFin);
    }
    if (message.dateSignature !== "") {
      writer.uint32(74).string(message.dateSignature);
    }
    if (message.montant !== 0) {
      writer.uint32(81).double(message.montant);
    }
    if (message.devise !== "") {
      writer.uint32(90).string(message.devise);
    }
    if (message.frequenceFacturation !== "") {
      writer.uint32(98).string(message.frequenceFacturation);
    }
    if (message.documentUrl !== "") {
      writer.uint32(106).string(message.documentUrl);
    }
    if (message.fournisseur !== "") {
      writer.uint32(114).string(message.fournisseur);
    }
    if (message.clientId !== "") {
      writer.uint32(122).string(message.clientId);
    }
    if (message.commercialId !== "") {
      writer.uint32(130).string(message.commercialId);
    }
    if (message.societeId !== "") {
      writer.uint32(138).string(message.societeId);
    }
    if (message.notes !== "") {
      writer.uint32(146).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.statut = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dateSignature = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.montant = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.devise = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.frequenceFacturation = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.documentUrl = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.fournisseur = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.commercialId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateContratRequest(): UpdateContratRequest {
  return {
    id: "",
    reference: "",
    titre: "",
    description: "",
    type: "",
    statut: "",
    dateDebut: "",
    dateFin: "",
    dateSignature: "",
    montant: 0,
    devise: "",
    frequenceFacturation: "",
    documentUrl: "",
    fournisseur: "",
    clientId: "",
    commercialId: "",
    societeId: "",
    notes: "",
  };
}

export const UpdateContratRequest: MessageFns<UpdateContratRequest> = {
  encode(message: UpdateContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reference !== "") {
      writer.uint32(18).string(message.reference);
    }
    if (message.titre !== "") {
      writer.uint32(26).string(message.titre);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.statut !== "") {
      writer.uint32(50).string(message.statut);
    }
    if (message.dateDebut !== "") {
      writer.uint32(58).string(message.dateDebut);
    }
    if (message.dateFin !== "") {
      writer.uint32(66).string(message.dateFin);
    }
    if (message.dateSignature !== "") {
      writer.uint32(74).string(message.dateSignature);
    }
    if (message.montant !== 0) {
      writer.uint32(81).double(message.montant);
    }
    if (message.devise !== "") {
      writer.uint32(90).string(message.devise);
    }
    if (message.frequenceFacturation !== "") {
      writer.uint32(98).string(message.frequenceFacturation);
    }
    if (message.documentUrl !== "") {
      writer.uint32(106).string(message.documentUrl);
    }
    if (message.fournisseur !== "") {
      writer.uint32(114).string(message.fournisseur);
    }
    if (message.clientId !== "") {
      writer.uint32(122).string(message.clientId);
    }
    if (message.commercialId !== "") {
      writer.uint32(130).string(message.commercialId);
    }
    if (message.societeId !== "") {
      writer.uint32(138).string(message.societeId);
    }
    if (message.notes !== "") {
      writer.uint32(146).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.statut = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dateSignature = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.montant = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.devise = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.frequenceFacturation = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.documentUrl = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.fournisseur = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.commercialId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetContratRequest(): GetContratRequest {
  return { id: "" };
}

export const GetContratRequest: MessageFns<GetContratRequest> = {
  encode(message: GetContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetContratByReferenceRequest(): GetContratByReferenceRequest {
  return { organisationId: "", reference: "" };
}

export const GetContratByReferenceRequest: MessageFns<GetContratByReferenceRequest> = {
  encode(message: GetContratByReferenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.reference !== "") {
      writer.uint32(18).string(message.reference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContratByReferenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContratByReferenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListContratRequest(): ListContratRequest {
  return { organisationId: "", clientId: "", commercialId: "", societeId: "", statut: "", search: "" };
}

export const ListContratRequest: MessageFns<ListContratRequest> = {
  encode(message: ListContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.commercialId !== "") {
      writer.uint32(26).string(message.commercialId);
    }
    if (message.societeId !== "") {
      writer.uint32(34).string(message.societeId);
    }
    if (message.statut !== "") {
      writer.uint32(42).string(message.statut);
    }
    if (message.search !== "") {
      writer.uint32(50).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commercialId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.statut = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListContratResponse(): ListContratResponse {
  return { contrats: [] };
}

export const ListContratResponse: MessageFns<ListContratResponse> = {
  encode(message: ListContratResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contrats) {
      Contrat.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContratResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContratResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contrats.push(Contrat.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteContratRequest(): DeleteContratRequest {
  return { id: "" };
}

export const DeleteContratRequest: MessageFns<DeleteContratRequest> = {
  encode(message: DeleteContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLigneContrat(): LigneContrat {
  return {
    id: "",
    contratId: "",
    produitId: "",
    periodeFacturationId: "",
    quantite: 0,
    prixUnitaire: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const LigneContrat: MessageFns<LigneContrat> = {
  encode(message: LigneContrat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.produitId !== "") {
      writer.uint32(26).string(message.produitId);
    }
    if (message.periodeFacturationId !== "") {
      writer.uint32(34).string(message.periodeFacturationId);
    }
    if (message.quantite !== 0) {
      writer.uint32(40).int32(message.quantite);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(49).double(message.prixUnitaire);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LigneContrat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLigneContrat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.periodeFacturationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateLigneContratRequest(): CreateLigneContratRequest {
  return { contratId: "", produitId: "", periodeFacturationId: "", quantite: 0, prixUnitaire: 0 };
}

export const CreateLigneContratRequest: MessageFns<CreateLigneContratRequest> = {
  encode(message: CreateLigneContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.produitId !== "") {
      writer.uint32(18).string(message.produitId);
    }
    if (message.periodeFacturationId !== "") {
      writer.uint32(26).string(message.periodeFacturationId);
    }
    if (message.quantite !== 0) {
      writer.uint32(32).int32(message.quantite);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(41).double(message.prixUnitaire);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLigneContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLigneContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periodeFacturationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateLigneContratRequest(): UpdateLigneContratRequest {
  return { id: "", produitId: "", periodeFacturationId: "", quantite: 0, prixUnitaire: 0 };
}

export const UpdateLigneContratRequest: MessageFns<UpdateLigneContratRequest> = {
  encode(message: UpdateLigneContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.produitId !== "") {
      writer.uint32(18).string(message.produitId);
    }
    if (message.periodeFacturationId !== "") {
      writer.uint32(26).string(message.periodeFacturationId);
    }
    if (message.quantite !== 0) {
      writer.uint32(32).int32(message.quantite);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(41).double(message.prixUnitaire);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLigneContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLigneContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.periodeFacturationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetLigneContratRequest(): GetLigneContratRequest {
  return { id: "" };
}

export const GetLigneContratRequest: MessageFns<GetLigneContratRequest> = {
  encode(message: GetLigneContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLigneContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLigneContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListLigneContratByContratRequest(): ListLigneContratByContratRequest {
  return { contratId: "" };
}

export const ListLigneContratByContratRequest: MessageFns<ListLigneContratByContratRequest> = {
  encode(message: ListLigneContratByContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLigneContratByContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLigneContratByContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListLigneContratResponse(): ListLigneContratResponse {
  return { lignes: [] };
}

export const ListLigneContratResponse: MessageFns<ListLigneContratResponse> = {
  encode(message: ListLigneContratResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lignes) {
      LigneContrat.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLigneContratResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLigneContratResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lignes.push(LigneContrat.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteLigneContratRequest(): DeleteLigneContratRequest {
  return { id: "" };
}

export const DeleteLigneContratRequest: MessageFns<DeleteLigneContratRequest> = {
  encode(message: DeleteLigneContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLigneContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLigneContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHistoriqueStatutContrat(): HistoriqueStatutContrat {
  return {
    id: "",
    contratId: "",
    ancienStatutId: "",
    nouveauStatutId: "",
    dateChangement: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const HistoriqueStatutContrat: MessageFns<HistoriqueStatutContrat> = {
  encode(message: HistoriqueStatutContrat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contratId !== "") {
      writer.uint32(18).string(message.contratId);
    }
    if (message.ancienStatutId !== "") {
      writer.uint32(26).string(message.ancienStatutId);
    }
    if (message.nouveauStatutId !== "") {
      writer.uint32(34).string(message.nouveauStatutId);
    }
    if (message.dateChangement !== "") {
      writer.uint32(42).string(message.dateChangement);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoriqueStatutContrat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoriqueStatutContrat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ancienStatutId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nouveauStatutId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateChangement = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateHistoriqueStatutContratRequest(): CreateHistoriqueStatutContratRequest {
  return { contratId: "", ancienStatutId: "", nouveauStatutId: "", dateChangement: "" };
}

export const CreateHistoriqueStatutContratRequest: MessageFns<CreateHistoriqueStatutContratRequest> = {
  encode(message: CreateHistoriqueStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.ancienStatutId !== "") {
      writer.uint32(18).string(message.ancienStatutId);
    }
    if (message.nouveauStatutId !== "") {
      writer.uint32(26).string(message.nouveauStatutId);
    }
    if (message.dateChangement !== "") {
      writer.uint32(34).string(message.dateChangement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHistoriqueStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHistoriqueStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ancienStatutId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nouveauStatutId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateChangement = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetHistoriqueStatutContratRequest(): GetHistoriqueStatutContratRequest {
  return { id: "" };
}

export const GetHistoriqueStatutContratRequest: MessageFns<GetHistoriqueStatutContratRequest> = {
  encode(message: GetHistoriqueStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHistoriqueStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHistoriqueStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHistoriqueByContratRequest(): ListHistoriqueByContratRequest {
  return { contratId: "" };
}

export const ListHistoriqueByContratRequest: MessageFns<ListHistoriqueByContratRequest> = {
  encode(message: ListHistoriqueByContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratId !== "") {
      writer.uint32(10).string(message.contratId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHistoriqueByContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHistoriqueByContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHistoriqueStatutContratResponse(): ListHistoriqueStatutContratResponse {
  return { historique: [] };
}

export const ListHistoriqueStatutContratResponse: MessageFns<ListHistoriqueStatutContratResponse> = {
  encode(message: ListHistoriqueStatutContratResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.historique) {
      HistoriqueStatutContrat.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHistoriqueStatutContratResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHistoriqueStatutContratResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.historique.push(HistoriqueStatutContrat.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteHistoriqueStatutContratRequest(): DeleteHistoriqueStatutContratRequest {
  return { id: "" };
}

export const DeleteHistoriqueStatutContratRequest: MessageFns<DeleteHistoriqueStatutContratRequest> = {
  encode(message: DeleteHistoriqueStatutContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHistoriqueStatutContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHistoriqueStatutContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOrchestrationRequest(): OrchestrationRequest {
  return { contractId: "", payload: "" };
}

export const OrchestrationRequest: MessageFns<OrchestrationRequest> = {
  encode(message: OrchestrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractId !== "") {
      writer.uint32(10).string(message.contractId);
    }
    if (message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOrchestrationResponse(): OrchestrationResponse {
  return { success: false, message: "", historyId: "" };
}

export const OrchestrationResponse: MessageFns<OrchestrationResponse> = {
  encode(message: OrchestrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.historyId !== "") {
      writer.uint32(26).string(message.historyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.historyId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOrchestrationHistory(): OrchestrationHistory {
  return {
    id: "",
    contractId: "",
    operation: "",
    status: "",
    payload: "",
    responsePayload: "",
    errorMessage: "",
    startedAt: "",
    finishedAt: "",
    createdAt: "",
  };
}

export const OrchestrationHistory: MessageFns<OrchestrationHistory> = {
  encode(message: OrchestrationHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contractId !== "") {
      writer.uint32(18).string(message.contractId);
    }
    if (message.operation !== "") {
      writer.uint32(26).string(message.operation);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.payload !== "") {
      writer.uint32(42).string(message.payload);
    }
    if (message.responsePayload !== "") {
      writer.uint32(50).string(message.responsePayload);
    }
    if (message.errorMessage !== "") {
      writer.uint32(58).string(message.errorMessage);
    }
    if (message.startedAt !== "") {
      writer.uint32(66).string(message.startedAt);
    }
    if (message.finishedAt !== "") {
      writer.uint32(74).string(message.finishedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.responsePayload = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.finishedAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetOrchestrationHistoryRequest(): GetOrchestrationHistoryRequest {
  return { contractId: "" };
}

export const GetOrchestrationHistoryRequest: MessageFns<GetOrchestrationHistoryRequest> = {
  encode(message: GetOrchestrationHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contractId !== "") {
      writer.uint32(10).string(message.contractId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrchestrationHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrchestrationHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListOrchestrationHistoryResponse(): ListOrchestrationHistoryResponse {
  return { history: [] };
}

export const ListOrchestrationHistoryResponse: MessageFns<ListOrchestrationHistoryResponse> = {
  encode(message: ListOrchestrationHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.history) {
      OrchestrationHistory.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrchestrationHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrchestrationHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.history.push(OrchestrationHistory.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ========== STATUT CONTRAT SERVICE ========== */

export interface StatutContratServiceClient {
  create(request: CreateStatutContratRequest, metadata?: Metadata): Observable<StatutContrat>;

  update(request: UpdateStatutContratRequest, metadata?: Metadata): Observable<StatutContrat>;

  get(request: GetStatutContratRequest, metadata?: Metadata): Observable<StatutContrat>;

  getByCode(request: GetStatutContratByCodeRequest, metadata?: Metadata): Observable<StatutContrat>;

  list(request: ListStatutContratRequest, metadata?: Metadata): Observable<ListStatutContratResponse>;

  delete(request: DeleteStatutContratRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== STATUT CONTRAT SERVICE ========== */

export interface StatutContratServiceController {
  create(
    request: CreateStatutContratRequest,
    metadata?: Metadata,
  ): Promise<StatutContrat> | Observable<StatutContrat> | StatutContrat;

  update(
    request: UpdateStatutContratRequest,
    metadata?: Metadata,
  ): Promise<StatutContrat> | Observable<StatutContrat> | StatutContrat;

  get(
    request: GetStatutContratRequest,
    metadata?: Metadata,
  ): Promise<StatutContrat> | Observable<StatutContrat> | StatutContrat;

  getByCode(
    request: GetStatutContratByCodeRequest,
    metadata?: Metadata,
  ): Promise<StatutContrat> | Observable<StatutContrat> | StatutContrat;

  list(
    request: ListStatutContratRequest,
    metadata?: Metadata,
  ): Promise<ListStatutContratResponse> | Observable<ListStatutContratResponse> | ListStatutContratResponse;

  delete(
    request: DeleteStatutContratRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function StatutContratServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("StatutContratService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("StatutContratService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const STATUT_CONTRAT_SERVICE_NAME = "StatutContratService";

/** ========== STATUT CONTRAT SERVICE ========== */
export type StatutContratServiceService = typeof StatutContratServiceService;
export const StatutContratServiceService = {
  create: {
    path: "/contrats.StatutContratService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStatutContratRequest): Buffer =>
      Buffer.from(CreateStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStatutContratRequest => CreateStatutContratRequest.decode(value),
    responseSerialize: (value: StatutContrat): Buffer => Buffer.from(StatutContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutContrat => StatutContrat.decode(value),
  },
  update: {
    path: "/contrats.StatutContratService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateStatutContratRequest): Buffer =>
      Buffer.from(UpdateStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateStatutContratRequest => UpdateStatutContratRequest.decode(value),
    responseSerialize: (value: StatutContrat): Buffer => Buffer.from(StatutContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutContrat => StatutContrat.decode(value),
  },
  get: {
    path: "/contrats.StatutContratService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutContratRequest): Buffer =>
      Buffer.from(GetStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutContratRequest => GetStatutContratRequest.decode(value),
    responseSerialize: (value: StatutContrat): Buffer => Buffer.from(StatutContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutContrat => StatutContrat.decode(value),
  },
  getByCode: {
    path: "/contrats.StatutContratService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutContratByCodeRequest): Buffer =>
      Buffer.from(GetStatutContratByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutContratByCodeRequest => GetStatutContratByCodeRequest.decode(value),
    responseSerialize: (value: StatutContrat): Buffer => Buffer.from(StatutContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutContrat => StatutContrat.decode(value),
  },
  list: {
    path: "/contrats.StatutContratService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListStatutContratRequest): Buffer =>
      Buffer.from(ListStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListStatutContratRequest => ListStatutContratRequest.decode(value),
    responseSerialize: (value: ListStatutContratResponse): Buffer =>
      Buffer.from(ListStatutContratResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListStatutContratResponse => ListStatutContratResponse.decode(value),
  },
  delete: {
    path: "/contrats.StatutContratService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteStatutContratRequest): Buffer =>
      Buffer.from(DeleteStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteStatutContratRequest => DeleteStatutContratRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface StatutContratServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateStatutContratRequest, StatutContrat>;
  update: handleUnaryCall<UpdateStatutContratRequest, StatutContrat>;
  get: handleUnaryCall<GetStatutContratRequest, StatutContrat>;
  getByCode: handleUnaryCall<GetStatutContratByCodeRequest, StatutContrat>;
  list: handleUnaryCall<ListStatutContratRequest, ListStatutContratResponse>;
  delete: handleUnaryCall<DeleteStatutContratRequest, DeleteResponse>;
}

/** ========== CONTRAT SERVICE ========== */

export interface ContratServiceClient {
  create(request: CreateContratRequest, metadata?: Metadata): Observable<Contrat>;

  update(request: UpdateContratRequest, metadata?: Metadata): Observable<Contrat>;

  get(request: GetContratRequest, metadata?: Metadata): Observable<Contrat>;

  getByReference(request: GetContratByReferenceRequest, metadata?: Metadata): Observable<Contrat>;

  list(request: ListContratRequest, metadata?: Metadata): Observable<ListContratResponse>;

  delete(request: DeleteContratRequest, metadata?: Metadata): Observable<DeleteResponse>;

  getWithDetails(request: GetContratRequest, metadata?: Metadata): Observable<ContratWithDetails>;
}

/** ========== CONTRAT SERVICE ========== */

export interface ContratServiceController {
  create(request: CreateContratRequest, metadata?: Metadata): Promise<Contrat> | Observable<Contrat> | Contrat;

  update(request: UpdateContratRequest, metadata?: Metadata): Promise<Contrat> | Observable<Contrat> | Contrat;

  get(request: GetContratRequest, metadata?: Metadata): Promise<Contrat> | Observable<Contrat> | Contrat;

  getByReference(
    request: GetContratByReferenceRequest,
    metadata?: Metadata,
  ): Promise<Contrat> | Observable<Contrat> | Contrat;

  list(
    request: ListContratRequest,
    metadata?: Metadata,
  ): Promise<ListContratResponse> | Observable<ListContratResponse> | ListContratResponse;

  delete(
    request: DeleteContratRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  getWithDetails(
    request: GetContratRequest,
    metadata?: Metadata,
  ): Promise<ContratWithDetails> | Observable<ContratWithDetails> | ContratWithDetails;
}

export function ContratServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByReference", "list", "delete", "getWithDetails"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ContratService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ContratService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CONTRAT_SERVICE_NAME = "ContratService";

/** ========== CONTRAT SERVICE ========== */
export type ContratServiceService = typeof ContratServiceService;
export const ContratServiceService = {
  create: {
    path: "/contrats.ContratService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateContratRequest): Buffer => Buffer.from(CreateContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateContratRequest => CreateContratRequest.decode(value),
    responseSerialize: (value: Contrat): Buffer => Buffer.from(Contrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): Contrat => Contrat.decode(value),
  },
  update: {
    path: "/contrats.ContratService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateContratRequest): Buffer => Buffer.from(UpdateContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateContratRequest => UpdateContratRequest.decode(value),
    responseSerialize: (value: Contrat): Buffer => Buffer.from(Contrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): Contrat => Contrat.decode(value),
  },
  get: {
    path: "/contrats.ContratService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContratRequest): Buffer => Buffer.from(GetContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContratRequest => GetContratRequest.decode(value),
    responseSerialize: (value: Contrat): Buffer => Buffer.from(Contrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): Contrat => Contrat.decode(value),
  },
  getByReference: {
    path: "/contrats.ContratService/GetByReference",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContratByReferenceRequest): Buffer =>
      Buffer.from(GetContratByReferenceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContratByReferenceRequest => GetContratByReferenceRequest.decode(value),
    responseSerialize: (value: Contrat): Buffer => Buffer.from(Contrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): Contrat => Contrat.decode(value),
  },
  list: {
    path: "/contrats.ContratService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListContratRequest): Buffer => Buffer.from(ListContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListContratRequest => ListContratRequest.decode(value),
    responseSerialize: (value: ListContratResponse): Buffer => Buffer.from(ListContratResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListContratResponse => ListContratResponse.decode(value),
  },
  delete: {
    path: "/contrats.ContratService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteContratRequest): Buffer => Buffer.from(DeleteContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteContratRequest => DeleteContratRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getWithDetails: {
    path: "/contrats.ContratService/GetWithDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContratRequest): Buffer => Buffer.from(GetContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContratRequest => GetContratRequest.decode(value),
    responseSerialize: (value: ContratWithDetails): Buffer => Buffer.from(ContratWithDetails.encode(value).finish()),
    responseDeserialize: (value: Buffer): ContratWithDetails => ContratWithDetails.decode(value),
  },
} as const;

export interface ContratServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateContratRequest, Contrat>;
  update: handleUnaryCall<UpdateContratRequest, Contrat>;
  get: handleUnaryCall<GetContratRequest, Contrat>;
  getByReference: handleUnaryCall<GetContratByReferenceRequest, Contrat>;
  list: handleUnaryCall<ListContratRequest, ListContratResponse>;
  delete: handleUnaryCall<DeleteContratRequest, DeleteResponse>;
  getWithDetails: handleUnaryCall<GetContratRequest, ContratWithDetails>;
}

/** ========== LIGNE CONTRAT SERVICE ========== */

export interface LigneContratServiceClient {
  create(request: CreateLigneContratRequest, metadata?: Metadata): Observable<LigneContrat>;

  update(request: UpdateLigneContratRequest, metadata?: Metadata): Observable<LigneContrat>;

  get(request: GetLigneContratRequest, metadata?: Metadata): Observable<LigneContrat>;

  listByContrat(request: ListLigneContratByContratRequest, metadata?: Metadata): Observable<ListLigneContratResponse>;

  delete(request: DeleteLigneContratRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== LIGNE CONTRAT SERVICE ========== */

export interface LigneContratServiceController {
  create(
    request: CreateLigneContratRequest,
    metadata?: Metadata,
  ): Promise<LigneContrat> | Observable<LigneContrat> | LigneContrat;

  update(
    request: UpdateLigneContratRequest,
    metadata?: Metadata,
  ): Promise<LigneContrat> | Observable<LigneContrat> | LigneContrat;

  get(
    request: GetLigneContratRequest,
    metadata?: Metadata,
  ): Promise<LigneContrat> | Observable<LigneContrat> | LigneContrat;

  listByContrat(
    request: ListLigneContratByContratRequest,
    metadata?: Metadata,
  ): Promise<ListLigneContratResponse> | Observable<ListLigneContratResponse> | ListLigneContratResponse;

  delete(
    request: DeleteLigneContratRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function LigneContratServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "listByContrat", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("LigneContratService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("LigneContratService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const LIGNE_CONTRAT_SERVICE_NAME = "LigneContratService";

/** ========== LIGNE CONTRAT SERVICE ========== */
export type LigneContratServiceService = typeof LigneContratServiceService;
export const LigneContratServiceService = {
  create: {
    path: "/contrats.LigneContratService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateLigneContratRequest): Buffer =>
      Buffer.from(CreateLigneContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateLigneContratRequest => CreateLigneContratRequest.decode(value),
    responseSerialize: (value: LigneContrat): Buffer => Buffer.from(LigneContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneContrat => LigneContrat.decode(value),
  },
  update: {
    path: "/contrats.LigneContratService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateLigneContratRequest): Buffer =>
      Buffer.from(UpdateLigneContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateLigneContratRequest => UpdateLigneContratRequest.decode(value),
    responseSerialize: (value: LigneContrat): Buffer => Buffer.from(LigneContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneContrat => LigneContrat.decode(value),
  },
  get: {
    path: "/contrats.LigneContratService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLigneContratRequest): Buffer =>
      Buffer.from(GetLigneContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLigneContratRequest => GetLigneContratRequest.decode(value),
    responseSerialize: (value: LigneContrat): Buffer => Buffer.from(LigneContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneContrat => LigneContrat.decode(value),
  },
  listByContrat: {
    path: "/contrats.LigneContratService/ListByContrat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListLigneContratByContratRequest): Buffer =>
      Buffer.from(ListLigneContratByContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListLigneContratByContratRequest =>
      ListLigneContratByContratRequest.decode(value),
    responseSerialize: (value: ListLigneContratResponse): Buffer =>
      Buffer.from(ListLigneContratResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListLigneContratResponse => ListLigneContratResponse.decode(value),
  },
  delete: {
    path: "/contrats.LigneContratService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteLigneContratRequest): Buffer =>
      Buffer.from(DeleteLigneContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteLigneContratRequest => DeleteLigneContratRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface LigneContratServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateLigneContratRequest, LigneContrat>;
  update: handleUnaryCall<UpdateLigneContratRequest, LigneContrat>;
  get: handleUnaryCall<GetLigneContratRequest, LigneContrat>;
  listByContrat: handleUnaryCall<ListLigneContratByContratRequest, ListLigneContratResponse>;
  delete: handleUnaryCall<DeleteLigneContratRequest, DeleteResponse>;
}

/** ========== HISTORIQUE STATUT CONTRAT SERVICE ========== */

export interface HistoriqueStatutContratServiceClient {
  create(request: CreateHistoriqueStatutContratRequest, metadata?: Metadata): Observable<HistoriqueStatutContrat>;

  get(request: GetHistoriqueStatutContratRequest, metadata?: Metadata): Observable<HistoriqueStatutContrat>;

  listByContrat(
    request: ListHistoriqueByContratRequest,
    metadata?: Metadata,
  ): Observable<ListHistoriqueStatutContratResponse>;

  delete(request: DeleteHistoriqueStatutContratRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== HISTORIQUE STATUT CONTRAT SERVICE ========== */

export interface HistoriqueStatutContratServiceController {
  create(
    request: CreateHistoriqueStatutContratRequest,
    metadata?: Metadata,
  ): Promise<HistoriqueStatutContrat> | Observable<HistoriqueStatutContrat> | HistoriqueStatutContrat;

  get(
    request: GetHistoriqueStatutContratRequest,
    metadata?: Metadata,
  ): Promise<HistoriqueStatutContrat> | Observable<HistoriqueStatutContrat> | HistoriqueStatutContrat;

  listByContrat(
    request: ListHistoriqueByContratRequest,
    metadata?: Metadata,
  ):
    | Promise<ListHistoriqueStatutContratResponse>
    | Observable<ListHistoriqueStatutContratResponse>
    | ListHistoriqueStatutContratResponse;

  delete(
    request: DeleteHistoriqueStatutContratRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function HistoriqueStatutContratServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "get", "listByContrat", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("HistoriqueStatutContratService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("HistoriqueStatutContratService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const HISTORIQUE_STATUT_CONTRAT_SERVICE_NAME = "HistoriqueStatutContratService";

/** ========== HISTORIQUE STATUT CONTRAT SERVICE ========== */
export type HistoriqueStatutContratServiceService = typeof HistoriqueStatutContratServiceService;
export const HistoriqueStatutContratServiceService = {
  create: {
    path: "/contrats.HistoriqueStatutContratService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateHistoriqueStatutContratRequest): Buffer =>
      Buffer.from(CreateHistoriqueStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateHistoriqueStatutContratRequest =>
      CreateHistoriqueStatutContratRequest.decode(value),
    responseSerialize: (value: HistoriqueStatutContrat): Buffer =>
      Buffer.from(HistoriqueStatutContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): HistoriqueStatutContrat => HistoriqueStatutContrat.decode(value),
  },
  get: {
    path: "/contrats.HistoriqueStatutContratService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHistoriqueStatutContratRequest): Buffer =>
      Buffer.from(GetHistoriqueStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetHistoriqueStatutContratRequest =>
      GetHistoriqueStatutContratRequest.decode(value),
    responseSerialize: (value: HistoriqueStatutContrat): Buffer =>
      Buffer.from(HistoriqueStatutContrat.encode(value).finish()),
    responseDeserialize: (value: Buffer): HistoriqueStatutContrat => HistoriqueStatutContrat.decode(value),
  },
  listByContrat: {
    path: "/contrats.HistoriqueStatutContratService/ListByContrat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListHistoriqueByContratRequest): Buffer =>
      Buffer.from(ListHistoriqueByContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListHistoriqueByContratRequest => ListHistoriqueByContratRequest.decode(value),
    responseSerialize: (value: ListHistoriqueStatutContratResponse): Buffer =>
      Buffer.from(ListHistoriqueStatutContratResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHistoriqueStatutContratResponse =>
      ListHistoriqueStatutContratResponse.decode(value),
  },
  delete: {
    path: "/contrats.HistoriqueStatutContratService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteHistoriqueStatutContratRequest): Buffer =>
      Buffer.from(DeleteHistoriqueStatutContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteHistoriqueStatutContratRequest =>
      DeleteHistoriqueStatutContratRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface HistoriqueStatutContratServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateHistoriqueStatutContratRequest, HistoriqueStatutContrat>;
  get: handleUnaryCall<GetHistoriqueStatutContratRequest, HistoriqueStatutContrat>;
  listByContrat: handleUnaryCall<ListHistoriqueByContratRequest, ListHistoriqueStatutContratResponse>;
  delete: handleUnaryCall<DeleteHistoriqueStatutContratRequest, DeleteResponse>;
}

/** ========== CONTRACT ORCHESTRATION SERVICE ========== */

export interface ContractOrchestrationServiceClient {
  activate(request: OrchestrationRequest, metadata?: Metadata): Observable<OrchestrationResponse>;

  suspend(request: OrchestrationRequest, metadata?: Metadata): Observable<OrchestrationResponse>;

  terminate(request: OrchestrationRequest, metadata?: Metadata): Observable<OrchestrationResponse>;

  portIn(request: OrchestrationRequest, metadata?: Metadata): Observable<OrchestrationResponse>;

  getHistory(
    request: GetOrchestrationHistoryRequest,
    metadata?: Metadata,
  ): Observable<ListOrchestrationHistoryResponse>;
}

/** ========== CONTRACT ORCHESTRATION SERVICE ========== */

export interface ContractOrchestrationServiceController {
  activate(
    request: OrchestrationRequest,
    metadata?: Metadata,
  ): Promise<OrchestrationResponse> | Observable<OrchestrationResponse> | OrchestrationResponse;

  suspend(
    request: OrchestrationRequest,
    metadata?: Metadata,
  ): Promise<OrchestrationResponse> | Observable<OrchestrationResponse> | OrchestrationResponse;

  terminate(
    request: OrchestrationRequest,
    metadata?: Metadata,
  ): Promise<OrchestrationResponse> | Observable<OrchestrationResponse> | OrchestrationResponse;

  portIn(
    request: OrchestrationRequest,
    metadata?: Metadata,
  ): Promise<OrchestrationResponse> | Observable<OrchestrationResponse> | OrchestrationResponse;

  getHistory(
    request: GetOrchestrationHistoryRequest,
    metadata?: Metadata,
  ):
    | Promise<ListOrchestrationHistoryResponse>
    | Observable<ListOrchestrationHistoryResponse>
    | ListOrchestrationHistoryResponse;
}

export function ContractOrchestrationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["activate", "suspend", "terminate", "portIn", "getHistory"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ContractOrchestrationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ContractOrchestrationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CONTRACT_ORCHESTRATION_SERVICE_NAME = "ContractOrchestrationService";

/** ========== CONTRACT ORCHESTRATION SERVICE ========== */
export type ContractOrchestrationServiceService = typeof ContractOrchestrationServiceService;
export const ContractOrchestrationServiceService = {
  activate: {
    path: "/contrats.ContractOrchestrationService/Activate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OrchestrationRequest): Buffer => Buffer.from(OrchestrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OrchestrationRequest => OrchestrationRequest.decode(value),
    responseSerialize: (value: OrchestrationResponse): Buffer =>
      Buffer.from(OrchestrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OrchestrationResponse => OrchestrationResponse.decode(value),
  },
  suspend: {
    path: "/contrats.ContractOrchestrationService/Suspend",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OrchestrationRequest): Buffer => Buffer.from(OrchestrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OrchestrationRequest => OrchestrationRequest.decode(value),
    responseSerialize: (value: OrchestrationResponse): Buffer =>
      Buffer.from(OrchestrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OrchestrationResponse => OrchestrationResponse.decode(value),
  },
  terminate: {
    path: "/contrats.ContractOrchestrationService/Terminate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OrchestrationRequest): Buffer => Buffer.from(OrchestrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OrchestrationRequest => OrchestrationRequest.decode(value),
    responseSerialize: (value: OrchestrationResponse): Buffer =>
      Buffer.from(OrchestrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OrchestrationResponse => OrchestrationResponse.decode(value),
  },
  portIn: {
    path: "/contrats.ContractOrchestrationService/PortIn",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OrchestrationRequest): Buffer => Buffer.from(OrchestrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OrchestrationRequest => OrchestrationRequest.decode(value),
    responseSerialize: (value: OrchestrationResponse): Buffer =>
      Buffer.from(OrchestrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OrchestrationResponse => OrchestrationResponse.decode(value),
  },
  getHistory: {
    path: "/contrats.ContractOrchestrationService/GetHistory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrchestrationHistoryRequest): Buffer =>
      Buffer.from(GetOrchestrationHistoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetOrchestrationHistoryRequest => GetOrchestrationHistoryRequest.decode(value),
    responseSerialize: (value: ListOrchestrationHistoryResponse): Buffer =>
      Buffer.from(ListOrchestrationHistoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListOrchestrationHistoryResponse =>
      ListOrchestrationHistoryResponse.decode(value),
  },
} as const;

export interface ContractOrchestrationServiceServer extends UntypedServiceImplementation {
  activate: handleUnaryCall<OrchestrationRequest, OrchestrationResponse>;
  suspend: handleUnaryCall<OrchestrationRequest, OrchestrationResponse>;
  terminate: handleUnaryCall<OrchestrationRequest, OrchestrationResponse>;
  portIn: handleUnaryCall<OrchestrationRequest, OrchestrationResponse>;
  getHistory: handleUnaryCall<GetOrchestrationHistoryRequest, ListOrchestrationHistoryResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
