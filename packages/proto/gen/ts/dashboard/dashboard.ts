// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: dashboard/dashboard.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface Empty {
}

export interface DashboardFilters {
  organisationId: string;
  societeId?: string | undefined;
  produitId?: string | undefined;
  canal?: string | undefined;
  dateDebut?: string | undefined;
  dateFin?:
    | string
    | undefined;
  /** mois_courant, mois_dernier, trimestre_courant, annee_courante, personnalisee */
  periodeRapide?: string | undefined;
}

export interface Variation {
  pourcentage: number;
  /** hausse, baisse, stable */
  tendance: string;
}

export interface GetKpisRequest {
  filters?: DashboardFilters | undefined;
}

export interface KpisResponse {
  contratsActifs: number;
  contratsActifsVariation?: Variation | undefined;
  mrr: number;
  mrrVariation?: Variation | undefined;
  tauxChurn: number;
  tauxChurnVariation?: Variation | undefined;
  tauxImpayes: number;
  tauxImpayesVariation?: Variation | undefined;
}

export interface GetEvolutionCaRequest {
  filters?: DashboardFilters | undefined;
}

export interface EvolutionCaMensuelle {
  mois: string;
  caRealise: number;
  objectif: number;
}

export interface EvolutionCaResponse {
  periodeDebut: string;
  periodeFin: string;
  donnees: EvolutionCaMensuelle[];
}

export interface GetRepartitionProduitsRequest {
  filters?: DashboardFilters | undefined;
}

export interface RepartitionProduit {
  produitId: string;
  nomProduit: string;
  ca: number;
  pourcentage: number;
  couleur: string;
}

export interface RepartitionProduitsResponse {
  caTotal: number;
  produits: RepartitionProduit[];
}

export interface GetStatsSocietesRequest {
  filters?: DashboardFilters | undefined;
}

export interface StatsSociete {
  societeId: string;
  nomSociete: string;
  contratsActifs: number;
  mrr: number;
  arr: number;
  nouveauxClients: number;
  nouveauxClientsVariation: number;
  tauxChurn: number;
  tauxImpayes: number;
}

export interface StatsSocietesResponse {
  societes: StatsSociete[];
  total: number;
}

export interface GetAlertesRequest {
  filters?: DashboardFilters | undefined;
}

export interface Alerte {
  id: string;
  titre: string;
  description: string;
  /** critique, avertissement, info */
  niveau: string;
  /** taux_impayes, taux_churn, controles_qualite, objectif_ca, autre */
  type: string;
  valeurActuelle: number;
  seuil: number;
  dateDetection: string;
  entiteConcernee: string;
  entiteId: string;
}

export interface AlertesResponse {
  alertes: Alerte[];
  total: number;
  nombreCritiques: number;
  nombreAvertissements: number;
  nombreInfos: number;
}

export interface GetKpisCommerciauxRequest {
  filters?: DashboardFilters | undefined;
}

export interface ClassementCommercial {
  commercialId: string;
  nomComplet: string;
  valeur: number;
  rang: number;
}

export interface KpisCommerciauxResponse {
  nouveauxClientsMois: number;
  nouveauxClientsVariation?: Variation | undefined;
  tauxConversion: number;
  tauxConversionVariation?: Variation | undefined;
  panierMoyen: number;
  panierMoyenVariation?: Variation | undefined;
  caPrevisionnel3Mois: number;
  classementParVentes: ClassementCommercial[];
  classementParCa: ClassementCommercial[];
  classementParConversion: ClassementCommercial[];
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDashboardFilters(): DashboardFilters {
  return { organisationId: "" };
}

export const DashboardFilters: MessageFns<DashboardFilters> = {
  encode(message: DashboardFilters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.produitId !== undefined) {
      writer.uint32(26).string(message.produitId);
    }
    if (message.canal !== undefined) {
      writer.uint32(34).string(message.canal);
    }
    if (message.dateDebut !== undefined) {
      writer.uint32(42).string(message.dateDebut);
    }
    if (message.dateFin !== undefined) {
      writer.uint32(50).string(message.dateFin);
    }
    if (message.periodeRapide !== undefined) {
      writer.uint32(58).string(message.periodeRapide);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DashboardFilters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDashboardFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.canal = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.periodeRapide = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVariation(): Variation {
  return { pourcentage: 0, tendance: "" };
}

export const Variation: MessageFns<Variation> = {
  encode(message: Variation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pourcentage !== 0) {
      writer.uint32(9).double(message.pourcentage);
    }
    if (message.tendance !== "") {
      writer.uint32(18).string(message.tendance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.pourcentage = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tendance = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetKpisRequest(): GetKpisRequest {
  return {};
}

export const GetKpisRequest: MessageFns<GetKpisRequest> = {
  encode(message: GetKpisRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      DashboardFilters.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKpisRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKpisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = DashboardFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseKpisResponse(): KpisResponse {
  return { contratsActifs: 0, mrr: 0, tauxChurn: 0, tauxImpayes: 0 };
}

export const KpisResponse: MessageFns<KpisResponse> = {
  encode(message: KpisResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contratsActifs !== 0) {
      writer.uint32(8).int32(message.contratsActifs);
    }
    if (message.contratsActifsVariation !== undefined) {
      Variation.encode(message.contratsActifsVariation, writer.uint32(18).fork()).join();
    }
    if (message.mrr !== 0) {
      writer.uint32(25).double(message.mrr);
    }
    if (message.mrrVariation !== undefined) {
      Variation.encode(message.mrrVariation, writer.uint32(34).fork()).join();
    }
    if (message.tauxChurn !== 0) {
      writer.uint32(41).double(message.tauxChurn);
    }
    if (message.tauxChurnVariation !== undefined) {
      Variation.encode(message.tauxChurnVariation, writer.uint32(50).fork()).join();
    }
    if (message.tauxImpayes !== 0) {
      writer.uint32(57).double(message.tauxImpayes);
    }
    if (message.tauxImpayesVariation !== undefined) {
      Variation.encode(message.tauxImpayesVariation, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KpisResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKpisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.contratsActifs = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contratsActifsVariation = Variation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.mrr = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mrrVariation = Variation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.tauxChurn = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tauxChurnVariation = Variation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.tauxImpayes = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tauxImpayesVariation = Variation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetEvolutionCaRequest(): GetEvolutionCaRequest {
  return {};
}

export const GetEvolutionCaRequest: MessageFns<GetEvolutionCaRequest> = {
  encode(message: GetEvolutionCaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      DashboardFilters.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEvolutionCaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEvolutionCaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = DashboardFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEvolutionCaMensuelle(): EvolutionCaMensuelle {
  return { mois: "", caRealise: 0, objectif: 0 };
}

export const EvolutionCaMensuelle: MessageFns<EvolutionCaMensuelle> = {
  encode(message: EvolutionCaMensuelle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mois !== "") {
      writer.uint32(10).string(message.mois);
    }
    if (message.caRealise !== 0) {
      writer.uint32(17).double(message.caRealise);
    }
    if (message.objectif !== 0) {
      writer.uint32(25).double(message.objectif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvolutionCaMensuelle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvolutionCaMensuelle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mois = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.caRealise = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.objectif = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEvolutionCaResponse(): EvolutionCaResponse {
  return { periodeDebut: "", periodeFin: "", donnees: [] };
}

export const EvolutionCaResponse: MessageFns<EvolutionCaResponse> = {
  encode(message: EvolutionCaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.periodeDebut !== "") {
      writer.uint32(10).string(message.periodeDebut);
    }
    if (message.periodeFin !== "") {
      writer.uint32(18).string(message.periodeFin);
    }
    for (const v of message.donnees) {
      EvolutionCaMensuelle.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvolutionCaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvolutionCaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.periodeDebut = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.periodeFin = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.donnees.push(EvolutionCaMensuelle.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRepartitionProduitsRequest(): GetRepartitionProduitsRequest {
  return {};
}

export const GetRepartitionProduitsRequest: MessageFns<GetRepartitionProduitsRequest> = {
  encode(message: GetRepartitionProduitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      DashboardFilters.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepartitionProduitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepartitionProduitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = DashboardFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRepartitionProduit(): RepartitionProduit {
  return { produitId: "", nomProduit: "", ca: 0, pourcentage: 0, couleur: "" };
}

export const RepartitionProduit: MessageFns<RepartitionProduit> = {
  encode(message: RepartitionProduit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    if (message.nomProduit !== "") {
      writer.uint32(18).string(message.nomProduit);
    }
    if (message.ca !== 0) {
      writer.uint32(25).double(message.ca);
    }
    if (message.pourcentage !== 0) {
      writer.uint32(33).double(message.pourcentage);
    }
    if (message.couleur !== "") {
      writer.uint32(42).string(message.couleur);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepartitionProduit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepartitionProduit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nomProduit = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.ca = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.pourcentage = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.couleur = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRepartitionProduitsResponse(): RepartitionProduitsResponse {
  return { caTotal: 0, produits: [] };
}

export const RepartitionProduitsResponse: MessageFns<RepartitionProduitsResponse> = {
  encode(message: RepartitionProduitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caTotal !== 0) {
      writer.uint32(9).double(message.caTotal);
    }
    for (const v of message.produits) {
      RepartitionProduit.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepartitionProduitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepartitionProduitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.caTotal = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produits.push(RepartitionProduit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatsSocietesRequest(): GetStatsSocietesRequest {
  return {};
}

export const GetStatsSocietesRequest: MessageFns<GetStatsSocietesRequest> = {
  encode(message: GetStatsSocietesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      DashboardFilters.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatsSocietesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatsSocietesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = DashboardFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatsSociete(): StatsSociete {
  return {
    societeId: "",
    nomSociete: "",
    contratsActifs: 0,
    mrr: 0,
    arr: 0,
    nouveauxClients: 0,
    nouveauxClientsVariation: 0,
    tauxChurn: 0,
    tauxImpayes: 0,
  };
}

export const StatsSociete: MessageFns<StatsSociete> = {
  encode(message: StatsSociete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.nomSociete !== "") {
      writer.uint32(18).string(message.nomSociete);
    }
    if (message.contratsActifs !== 0) {
      writer.uint32(24).int32(message.contratsActifs);
    }
    if (message.mrr !== 0) {
      writer.uint32(33).double(message.mrr);
    }
    if (message.arr !== 0) {
      writer.uint32(41).double(message.arr);
    }
    if (message.nouveauxClients !== 0) {
      writer.uint32(48).int32(message.nouveauxClients);
    }
    if (message.nouveauxClientsVariation !== 0) {
      writer.uint32(57).double(message.nouveauxClientsVariation);
    }
    if (message.tauxChurn !== 0) {
      writer.uint32(65).double(message.tauxChurn);
    }
    if (message.tauxImpayes !== 0) {
      writer.uint32(73).double(message.tauxImpayes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatsSociete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatsSociete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nomSociete = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.contratsActifs = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.mrr = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.arr = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nouveauxClients = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.nouveauxClientsVariation = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.tauxChurn = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.tauxImpayes = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatsSocietesResponse(): StatsSocietesResponse {
  return { societes: [], total: 0 };
}

export const StatsSocietesResponse: MessageFns<StatsSocietesResponse> = {
  encode(message: StatsSocietesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.societes) {
      StatsSociete.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatsSocietesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatsSocietesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societes.push(StatsSociete.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAlertesRequest(): GetAlertesRequest {
  return {};
}

export const GetAlertesRequest: MessageFns<GetAlertesRequest> = {
  encode(message: GetAlertesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      DashboardFilters.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAlertesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAlertesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = DashboardFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAlerte(): Alerte {
  return {
    id: "",
    titre: "",
    description: "",
    niveau: "",
    type: "",
    valeurActuelle: 0,
    seuil: 0,
    dateDetection: "",
    entiteConcernee: "",
    entiteId: "",
  };
}

export const Alerte: MessageFns<Alerte> = {
  encode(message: Alerte, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.titre !== "") {
      writer.uint32(18).string(message.titre);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.niveau !== "") {
      writer.uint32(34).string(message.niveau);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.valeurActuelle !== 0) {
      writer.uint32(49).double(message.valeurActuelle);
    }
    if (message.seuil !== 0) {
      writer.uint32(57).double(message.seuil);
    }
    if (message.dateDetection !== "") {
      writer.uint32(66).string(message.dateDetection);
    }
    if (message.entiteConcernee !== "") {
      writer.uint32(74).string(message.entiteConcernee);
    }
    if (message.entiteId !== "") {
      writer.uint32(82).string(message.entiteId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Alerte {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlerte();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.niveau = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.valeurActuelle = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.seuil = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateDetection = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.entiteConcernee = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.entiteId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAlertesResponse(): AlertesResponse {
  return { alertes: [], total: 0, nombreCritiques: 0, nombreAvertissements: 0, nombreInfos: 0 };
}

export const AlertesResponse: MessageFns<AlertesResponse> = {
  encode(message: AlertesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alertes) {
      Alerte.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.nombreCritiques !== 0) {
      writer.uint32(24).int32(message.nombreCritiques);
    }
    if (message.nombreAvertissements !== 0) {
      writer.uint32(32).int32(message.nombreAvertissements);
    }
    if (message.nombreInfos !== 0) {
      writer.uint32(40).int32(message.nombreInfos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alertes.push(Alerte.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nombreCritiques = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.nombreAvertissements = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.nombreInfos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetKpisCommerciauxRequest(): GetKpisCommerciauxRequest {
  return {};
}

export const GetKpisCommerciauxRequest: MessageFns<GetKpisCommerciauxRequest> = {
  encode(message: GetKpisCommerciauxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      DashboardFilters.encode(message.filters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKpisCommerciauxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKpisCommerciauxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = DashboardFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseClassementCommercial(): ClassementCommercial {
  return { commercialId: "", nomComplet: "", valeur: 0, rang: 0 };
}

export const ClassementCommercial: MessageFns<ClassementCommercial> = {
  encode(message: ClassementCommercial, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commercialId !== "") {
      writer.uint32(10).string(message.commercialId);
    }
    if (message.nomComplet !== "") {
      writer.uint32(18).string(message.nomComplet);
    }
    if (message.valeur !== 0) {
      writer.uint32(25).double(message.valeur);
    }
    if (message.rang !== 0) {
      writer.uint32(32).int32(message.rang);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClassementCommercial {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassementCommercial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commercialId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nomComplet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.valeur = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rang = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseKpisCommerciauxResponse(): KpisCommerciauxResponse {
  return {
    nouveauxClientsMois: 0,
    tauxConversion: 0,
    panierMoyen: 0,
    caPrevisionnel3Mois: 0,
    classementParVentes: [],
    classementParCa: [],
    classementParConversion: [],
  };
}

export const KpisCommerciauxResponse: MessageFns<KpisCommerciauxResponse> = {
  encode(message: KpisCommerciauxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nouveauxClientsMois !== 0) {
      writer.uint32(8).int32(message.nouveauxClientsMois);
    }
    if (message.nouveauxClientsVariation !== undefined) {
      Variation.encode(message.nouveauxClientsVariation, writer.uint32(18).fork()).join();
    }
    if (message.tauxConversion !== 0) {
      writer.uint32(25).double(message.tauxConversion);
    }
    if (message.tauxConversionVariation !== undefined) {
      Variation.encode(message.tauxConversionVariation, writer.uint32(34).fork()).join();
    }
    if (message.panierMoyen !== 0) {
      writer.uint32(41).double(message.panierMoyen);
    }
    if (message.panierMoyenVariation !== undefined) {
      Variation.encode(message.panierMoyenVariation, writer.uint32(50).fork()).join();
    }
    if (message.caPrevisionnel3Mois !== 0) {
      writer.uint32(57).double(message.caPrevisionnel3Mois);
    }
    for (const v of message.classementParVentes) {
      ClassementCommercial.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.classementParCa) {
      ClassementCommercial.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.classementParConversion) {
      ClassementCommercial.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KpisCommerciauxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKpisCommerciauxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nouveauxClientsMois = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nouveauxClientsVariation = Variation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.tauxConversion = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tauxConversionVariation = Variation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.panierMoyen = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.panierMoyenVariation = Variation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.caPrevisionnel3Mois = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.classementParVentes.push(ClassementCommercial.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.classementParCa.push(ClassementCommercial.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.classementParConversion.push(ClassementCommercial.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface DashboardKpisServiceClient {
  getKpis(request: GetKpisRequest, metadata?: Metadata): Observable<KpisResponse>;
}

export interface DashboardKpisServiceController {
  getKpis(
    request: GetKpisRequest,
    metadata?: Metadata,
  ): Promise<KpisResponse> | Observable<KpisResponse> | KpisResponse;
}

export function DashboardKpisServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getKpis"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("DashboardKpisService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("DashboardKpisService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const DASHBOARD_KPIS_SERVICE_NAME = "DashboardKpisService";

export type DashboardKpisServiceService = typeof DashboardKpisServiceService;
export const DashboardKpisServiceService = {
  getKpis: {
    path: "/dashboard.DashboardKpisService/GetKpis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetKpisRequest): Buffer => Buffer.from(GetKpisRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetKpisRequest => GetKpisRequest.decode(value),
    responseSerialize: (value: KpisResponse): Buffer => Buffer.from(KpisResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): KpisResponse => KpisResponse.decode(value),
  },
} as const;

export interface DashboardKpisServiceServer extends UntypedServiceImplementation {
  getKpis: handleUnaryCall<GetKpisRequest, KpisResponse>;
}

export interface EvolutionCaServiceClient {
  getEvolutionCa(request: GetEvolutionCaRequest, metadata?: Metadata): Observable<EvolutionCaResponse>;
}

export interface EvolutionCaServiceController {
  getEvolutionCa(
    request: GetEvolutionCaRequest,
    metadata?: Metadata,
  ): Promise<EvolutionCaResponse> | Observable<EvolutionCaResponse> | EvolutionCaResponse;
}

export function EvolutionCaServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getEvolutionCa"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("EvolutionCaService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("EvolutionCaService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const EVOLUTION_CA_SERVICE_NAME = "EvolutionCaService";

export type EvolutionCaServiceService = typeof EvolutionCaServiceService;
export const EvolutionCaServiceService = {
  getEvolutionCa: {
    path: "/dashboard.EvolutionCaService/GetEvolutionCa",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEvolutionCaRequest): Buffer =>
      Buffer.from(GetEvolutionCaRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEvolutionCaRequest => GetEvolutionCaRequest.decode(value),
    responseSerialize: (value: EvolutionCaResponse): Buffer => Buffer.from(EvolutionCaResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EvolutionCaResponse => EvolutionCaResponse.decode(value),
  },
} as const;

export interface EvolutionCaServiceServer extends UntypedServiceImplementation {
  getEvolutionCa: handleUnaryCall<GetEvolutionCaRequest, EvolutionCaResponse>;
}

export interface RepartitionProduitsServiceClient {
  getRepartitionProduits(
    request: GetRepartitionProduitsRequest,
    metadata?: Metadata,
  ): Observable<RepartitionProduitsResponse>;
}

export interface RepartitionProduitsServiceController {
  getRepartitionProduits(
    request: GetRepartitionProduitsRequest,
    metadata?: Metadata,
  ): Promise<RepartitionProduitsResponse> | Observable<RepartitionProduitsResponse> | RepartitionProduitsResponse;
}

export function RepartitionProduitsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getRepartitionProduits"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("RepartitionProduitsService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("RepartitionProduitsService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const REPARTITION_PRODUITS_SERVICE_NAME = "RepartitionProduitsService";

export type RepartitionProduitsServiceService = typeof RepartitionProduitsServiceService;
export const RepartitionProduitsServiceService = {
  getRepartitionProduits: {
    path: "/dashboard.RepartitionProduitsService/GetRepartitionProduits",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRepartitionProduitsRequest): Buffer =>
      Buffer.from(GetRepartitionProduitsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRepartitionProduitsRequest => GetRepartitionProduitsRequest.decode(value),
    responseSerialize: (value: RepartitionProduitsResponse): Buffer =>
      Buffer.from(RepartitionProduitsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepartitionProduitsResponse => RepartitionProduitsResponse.decode(value),
  },
} as const;

export interface RepartitionProduitsServiceServer extends UntypedServiceImplementation {
  getRepartitionProduits: handleUnaryCall<GetRepartitionProduitsRequest, RepartitionProduitsResponse>;
}

export interface StatsSocietesServiceClient {
  getStatsSocietes(request: GetStatsSocietesRequest, metadata?: Metadata): Observable<StatsSocietesResponse>;
}

export interface StatsSocietesServiceController {
  getStatsSocietes(
    request: GetStatsSocietesRequest,
    metadata?: Metadata,
  ): Promise<StatsSocietesResponse> | Observable<StatsSocietesResponse> | StatsSocietesResponse;
}

export function StatsSocietesServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getStatsSocietes"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("StatsSocietesService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("StatsSocietesService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const STATS_SOCIETES_SERVICE_NAME = "StatsSocietesService";

export type StatsSocietesServiceService = typeof StatsSocietesServiceService;
export const StatsSocietesServiceService = {
  getStatsSocietes: {
    path: "/dashboard.StatsSocietesService/GetStatsSocietes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatsSocietesRequest): Buffer =>
      Buffer.from(GetStatsSocietesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatsSocietesRequest => GetStatsSocietesRequest.decode(value),
    responseSerialize: (value: StatsSocietesResponse): Buffer =>
      Buffer.from(StatsSocietesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatsSocietesResponse => StatsSocietesResponse.decode(value),
  },
} as const;

export interface StatsSocietesServiceServer extends UntypedServiceImplementation {
  getStatsSocietes: handleUnaryCall<GetStatsSocietesRequest, StatsSocietesResponse>;
}

export interface AlertesServiceClient {
  getAlertes(request: GetAlertesRequest, metadata?: Metadata): Observable<AlertesResponse>;
}

export interface AlertesServiceController {
  getAlertes(
    request: GetAlertesRequest,
    metadata?: Metadata,
  ): Promise<AlertesResponse> | Observable<AlertesResponse> | AlertesResponse;
}

export function AlertesServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getAlertes"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AlertesService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AlertesService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ALERTES_SERVICE_NAME = "AlertesService";

export type AlertesServiceService = typeof AlertesServiceService;
export const AlertesServiceService = {
  getAlertes: {
    path: "/dashboard.AlertesService/GetAlertes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAlertesRequest): Buffer => Buffer.from(GetAlertesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAlertesRequest => GetAlertesRequest.decode(value),
    responseSerialize: (value: AlertesResponse): Buffer => Buffer.from(AlertesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AlertesResponse => AlertesResponse.decode(value),
  },
} as const;

export interface AlertesServiceServer extends UntypedServiceImplementation {
  getAlertes: handleUnaryCall<GetAlertesRequest, AlertesResponse>;
}

export interface KpisCommerciauxServiceClient {
  getKpisCommerciaux(request: GetKpisCommerciauxRequest, metadata?: Metadata): Observable<KpisCommerciauxResponse>;
}

export interface KpisCommerciauxServiceController {
  getKpisCommerciaux(
    request: GetKpisCommerciauxRequest,
    metadata?: Metadata,
  ): Promise<KpisCommerciauxResponse> | Observable<KpisCommerciauxResponse> | KpisCommerciauxResponse;
}

export function KpisCommerciauxServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getKpisCommerciaux"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("KpisCommerciauxService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("KpisCommerciauxService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const KPIS_COMMERCIAUX_SERVICE_NAME = "KpisCommerciauxService";

export type KpisCommerciauxServiceService = typeof KpisCommerciauxServiceService;
export const KpisCommerciauxServiceService = {
  getKpisCommerciaux: {
    path: "/dashboard.KpisCommerciauxService/GetKpisCommerciaux",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetKpisCommerciauxRequest): Buffer =>
      Buffer.from(GetKpisCommerciauxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetKpisCommerciauxRequest => GetKpisCommerciauxRequest.decode(value),
    responseSerialize: (value: KpisCommerciauxResponse): Buffer =>
      Buffer.from(KpisCommerciauxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): KpisCommerciauxResponse => KpisCommerciauxResponse.decode(value),
  },
} as const;

export interface KpisCommerciauxServiceServer extends UntypedServiceImplementation {
  getKpisCommerciaux: handleUnaryCall<GetKpisCommerciauxRequest, KpisCommerciauxResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
