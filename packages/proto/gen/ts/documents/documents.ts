// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: documents/documents.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface PieceJointe {
  id: string;
  nomFichier: string;
  url: string;
  typeMime: string;
  taille: number;
  entiteType: string;
  entiteId: string;
  dateUpload: string;
  uploadedBy: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreatePieceJointeRequest {
  nomFichier: string;
  url: string;
  typeMime: string;
  taille: number;
  entiteType: string;
  entiteId: string;
  uploadedBy: string;
}

export interface UpdatePieceJointeRequest {
  id: string;
  nomFichier: string;
  url: string;
}

export interface GetPieceJointeRequest {
  id: string;
}

export interface ListPieceJointeRequest {
  search: string;
  typeMime: string;
  pagination?: Pagination | undefined;
}

export interface ListPieceJointeByEntiteRequest {
  entiteType: string;
  entiteId: string;
  pagination?: Pagination | undefined;
}

export interface DeletePieceJointeRequest {
  id: string;
}

export interface ListPieceJointeResponse {
  pieces: PieceJointe[];
  pagination?: PaginationResult | undefined;
}

export interface BoiteMail {
  id: string;
  nom: string;
  adresseEmail: string;
  fournisseur: string;
  typeConnexion: string;
  serveurSmtp: string;
  portSmtp: number;
  serveurImap: string;
  portImap: number;
  utiliseSsl: boolean;
  utiliseTls: boolean;
  username: string;
  clientId: string;
  tokenExpiration: string;
  signatureHtml: string;
  signatureTexte: string;
  estParDefaut: boolean;
  actif: boolean;
  utilisateurId: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateBoiteMailRequest {
  nom: string;
  adresseEmail: string;
  fournisseur: string;
  typeConnexion: string;
  serveurSmtp: string;
  portSmtp: number;
  serveurImap: string;
  portImap: number;
  utiliseSsl: boolean;
  utiliseTls: boolean;
  username: string;
  motDePasse: string;
  clientId: string;
  clientSecret: string;
  signatureHtml: string;
  signatureTexte: string;
  estParDefaut: boolean;
  utilisateurId: string;
}

export interface UpdateBoiteMailRequest {
  id: string;
  nom: string;
  serveurSmtp: string;
  portSmtp: number;
  serveurImap: string;
  portImap: number;
  utiliseSsl: boolean;
  utiliseTls: boolean;
  username: string;
  motDePasse: string;
  signatureHtml: string;
  signatureTexte: string;
}

export interface GetBoiteMailRequest {
  id: string;
}

export interface GetBoiteMailByUtilisateurRequest {
  utilisateurId: string;
}

export interface GetDefaultBoiteMailRequest {
  utilisateurId: string;
}

export interface ListBoiteMailRequest {
  search: string;
  fournisseur: string;
  actif: boolean;
  pagination?: Pagination | undefined;
}

export interface ListBoiteMailByUtilisateurRequest {
  utilisateurId: string;
  actif: boolean;
  pagination?: Pagination | undefined;
}

export interface SetDefaultBoiteMailRequest {
  id: string;
  utilisateurId: string;
}

export interface ActivateBoiteMailRequest {
  id: string;
}

export interface UpdateOAuthTokensRequest {
  id: string;
  accessToken: string;
  refreshToken: string;
  tokenExpiration: string;
}

export interface TestConnectionRequest {
  id: string;
}

export interface TestConnectionResponse {
  success: boolean;
  message: string;
}

export interface DeleteBoiteMailRequest {
  id: string;
}

export interface ListBoiteMailResponse {
  boites: BoiteMail[];
  pagination?: PaginationResult | undefined;
}

/** ========== COMMON MESSAGES ========== */
export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
}

function createBasePieceJointe(): PieceJointe {
  return {
    id: "",
    nomFichier: "",
    url: "",
    typeMime: "",
    taille: 0,
    entiteType: "",
    entiteId: "",
    dateUpload: "",
    uploadedBy: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const PieceJointe: MessageFns<PieceJointe> = {
  encode(message: PieceJointe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nomFichier !== "") {
      writer.uint32(18).string(message.nomFichier);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.typeMime !== "") {
      writer.uint32(34).string(message.typeMime);
    }
    if (message.taille !== 0) {
      writer.uint32(40).int64(message.taille);
    }
    if (message.entiteType !== "") {
      writer.uint32(50).string(message.entiteType);
    }
    if (message.entiteId !== "") {
      writer.uint32(58).string(message.entiteId);
    }
    if (message.dateUpload !== "") {
      writer.uint32(66).string(message.dateUpload);
    }
    if (message.uploadedBy !== "") {
      writer.uint32(74).string(message.uploadedBy);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PieceJointe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePieceJointe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nomFichier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typeMime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.taille = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.entiteType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.entiteId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateUpload = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.uploadedBy = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePieceJointeRequest(): CreatePieceJointeRequest {
  return { nomFichier: "", url: "", typeMime: "", taille: 0, entiteType: "", entiteId: "", uploadedBy: "" };
}

export const CreatePieceJointeRequest: MessageFns<CreatePieceJointeRequest> = {
  encode(message: CreatePieceJointeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nomFichier !== "") {
      writer.uint32(10).string(message.nomFichier);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.typeMime !== "") {
      writer.uint32(26).string(message.typeMime);
    }
    if (message.taille !== 0) {
      writer.uint32(32).int64(message.taille);
    }
    if (message.entiteType !== "") {
      writer.uint32(42).string(message.entiteType);
    }
    if (message.entiteId !== "") {
      writer.uint32(50).string(message.entiteId);
    }
    if (message.uploadedBy !== "") {
      writer.uint32(58).string(message.uploadedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePieceJointeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePieceJointeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nomFichier = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.typeMime = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.taille = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.entiteType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.entiteId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.uploadedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePieceJointeRequest(): UpdatePieceJointeRequest {
  return { id: "", nomFichier: "", url: "" };
}

export const UpdatePieceJointeRequest: MessageFns<UpdatePieceJointeRequest> = {
  encode(message: UpdatePieceJointeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nomFichier !== "") {
      writer.uint32(18).string(message.nomFichier);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePieceJointeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePieceJointeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nomFichier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPieceJointeRequest(): GetPieceJointeRequest {
  return { id: "" };
}

export const GetPieceJointeRequest: MessageFns<GetPieceJointeRequest> = {
  encode(message: GetPieceJointeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPieceJointeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPieceJointeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPieceJointeRequest(): ListPieceJointeRequest {
  return { search: "", typeMime: "" };
}

export const ListPieceJointeRequest: MessageFns<ListPieceJointeRequest> = {
  encode(message: ListPieceJointeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.typeMime !== "") {
      writer.uint32(18).string(message.typeMime);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPieceJointeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPieceJointeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.typeMime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPieceJointeByEntiteRequest(): ListPieceJointeByEntiteRequest {
  return { entiteType: "", entiteId: "" };
}

export const ListPieceJointeByEntiteRequest: MessageFns<ListPieceJointeByEntiteRequest> = {
  encode(message: ListPieceJointeByEntiteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entiteType !== "") {
      writer.uint32(10).string(message.entiteType);
    }
    if (message.entiteId !== "") {
      writer.uint32(18).string(message.entiteId);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPieceJointeByEntiteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPieceJointeByEntiteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entiteType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entiteId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeletePieceJointeRequest(): DeletePieceJointeRequest {
  return { id: "" };
}

export const DeletePieceJointeRequest: MessageFns<DeletePieceJointeRequest> = {
  encode(message: DeletePieceJointeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePieceJointeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePieceJointeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPieceJointeResponse(): ListPieceJointeResponse {
  return { pieces: [] };
}

export const ListPieceJointeResponse: MessageFns<ListPieceJointeResponse> = {
  encode(message: ListPieceJointeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pieces) {
      PieceJointe.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPieceJointeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPieceJointeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pieces.push(PieceJointe.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBoiteMail(): BoiteMail {
  return {
    id: "",
    nom: "",
    adresseEmail: "",
    fournisseur: "",
    typeConnexion: "",
    serveurSmtp: "",
    portSmtp: 0,
    serveurImap: "",
    portImap: 0,
    utiliseSsl: false,
    utiliseTls: false,
    username: "",
    clientId: "",
    tokenExpiration: "",
    signatureHtml: "",
    signatureTexte: "",
    estParDefaut: false,
    actif: false,
    utilisateurId: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const BoiteMail: MessageFns<BoiteMail> = {
  encode(message: BoiteMail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.adresseEmail !== "") {
      writer.uint32(26).string(message.adresseEmail);
    }
    if (message.fournisseur !== "") {
      writer.uint32(34).string(message.fournisseur);
    }
    if (message.typeConnexion !== "") {
      writer.uint32(42).string(message.typeConnexion);
    }
    if (message.serveurSmtp !== "") {
      writer.uint32(50).string(message.serveurSmtp);
    }
    if (message.portSmtp !== 0) {
      writer.uint32(56).int32(message.portSmtp);
    }
    if (message.serveurImap !== "") {
      writer.uint32(66).string(message.serveurImap);
    }
    if (message.portImap !== 0) {
      writer.uint32(72).int32(message.portImap);
    }
    if (message.utiliseSsl !== false) {
      writer.uint32(80).bool(message.utiliseSsl);
    }
    if (message.utiliseTls !== false) {
      writer.uint32(88).bool(message.utiliseTls);
    }
    if (message.username !== "") {
      writer.uint32(98).string(message.username);
    }
    if (message.clientId !== "") {
      writer.uint32(106).string(message.clientId);
    }
    if (message.tokenExpiration !== "") {
      writer.uint32(114).string(message.tokenExpiration);
    }
    if (message.signatureHtml !== "") {
      writer.uint32(122).string(message.signatureHtml);
    }
    if (message.signatureTexte !== "") {
      writer.uint32(130).string(message.signatureTexte);
    }
    if (message.estParDefaut !== false) {
      writer.uint32(136).bool(message.estParDefaut);
    }
    if (message.actif !== false) {
      writer.uint32(144).bool(message.actif);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(154).string(message.utilisateurId);
    }
    if (message.createdAt !== "") {
      writer.uint32(162).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(170).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoiteMail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoiteMail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fournisseur = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.typeConnexion = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.serveurSmtp = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.portSmtp = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.serveurImap = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.portImap = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.utiliseSsl = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.utiliseTls = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.tokenExpiration = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.signatureHtml = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.signatureTexte = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.estParDefaut = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateBoiteMailRequest(): CreateBoiteMailRequest {
  return {
    nom: "",
    adresseEmail: "",
    fournisseur: "",
    typeConnexion: "",
    serveurSmtp: "",
    portSmtp: 0,
    serveurImap: "",
    portImap: 0,
    utiliseSsl: false,
    utiliseTls: false,
    username: "",
    motDePasse: "",
    clientId: "",
    clientSecret: "",
    signatureHtml: "",
    signatureTexte: "",
    estParDefaut: false,
    utilisateurId: "",
  };
}

export const CreateBoiteMailRequest: MessageFns<CreateBoiteMailRequest> = {
  encode(message: CreateBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nom !== "") {
      writer.uint32(10).string(message.nom);
    }
    if (message.adresseEmail !== "") {
      writer.uint32(18).string(message.adresseEmail);
    }
    if (message.fournisseur !== "") {
      writer.uint32(26).string(message.fournisseur);
    }
    if (message.typeConnexion !== "") {
      writer.uint32(34).string(message.typeConnexion);
    }
    if (message.serveurSmtp !== "") {
      writer.uint32(42).string(message.serveurSmtp);
    }
    if (message.portSmtp !== 0) {
      writer.uint32(48).int32(message.portSmtp);
    }
    if (message.serveurImap !== "") {
      writer.uint32(58).string(message.serveurImap);
    }
    if (message.portImap !== 0) {
      writer.uint32(64).int32(message.portImap);
    }
    if (message.utiliseSsl !== false) {
      writer.uint32(72).bool(message.utiliseSsl);
    }
    if (message.utiliseTls !== false) {
      writer.uint32(80).bool(message.utiliseTls);
    }
    if (message.username !== "") {
      writer.uint32(90).string(message.username);
    }
    if (message.motDePasse !== "") {
      writer.uint32(98).string(message.motDePasse);
    }
    if (message.clientId !== "") {
      writer.uint32(106).string(message.clientId);
    }
    if (message.clientSecret !== "") {
      writer.uint32(114).string(message.clientSecret);
    }
    if (message.signatureHtml !== "") {
      writer.uint32(122).string(message.signatureHtml);
    }
    if (message.signatureTexte !== "") {
      writer.uint32(130).string(message.signatureTexte);
    }
    if (message.estParDefaut !== false) {
      writer.uint32(136).bool(message.estParDefaut);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(146).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fournisseur = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.typeConnexion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.serveurSmtp = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.portSmtp = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.serveurImap = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.portImap = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.utiliseSsl = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.utiliseTls = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.motDePasse = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.signatureHtml = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.signatureTexte = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.estParDefaut = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateBoiteMailRequest(): UpdateBoiteMailRequest {
  return {
    id: "",
    nom: "",
    serveurSmtp: "",
    portSmtp: 0,
    serveurImap: "",
    portImap: 0,
    utiliseSsl: false,
    utiliseTls: false,
    username: "",
    motDePasse: "",
    signatureHtml: "",
    signatureTexte: "",
  };
}

export const UpdateBoiteMailRequest: MessageFns<UpdateBoiteMailRequest> = {
  encode(message: UpdateBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.serveurSmtp !== "") {
      writer.uint32(26).string(message.serveurSmtp);
    }
    if (message.portSmtp !== 0) {
      writer.uint32(32).int32(message.portSmtp);
    }
    if (message.serveurImap !== "") {
      writer.uint32(42).string(message.serveurImap);
    }
    if (message.portImap !== 0) {
      writer.uint32(48).int32(message.portImap);
    }
    if (message.utiliseSsl !== false) {
      writer.uint32(56).bool(message.utiliseSsl);
    }
    if (message.utiliseTls !== false) {
      writer.uint32(64).bool(message.utiliseTls);
    }
    if (message.username !== "") {
      writer.uint32(74).string(message.username);
    }
    if (message.motDePasse !== "") {
      writer.uint32(82).string(message.motDePasse);
    }
    if (message.signatureHtml !== "") {
      writer.uint32(90).string(message.signatureHtml);
    }
    if (message.signatureTexte !== "") {
      writer.uint32(98).string(message.signatureTexte);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serveurSmtp = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.portSmtp = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.serveurImap = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.portImap = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.utiliseSsl = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.utiliseTls = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.motDePasse = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.signatureHtml = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.signatureTexte = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetBoiteMailRequest(): GetBoiteMailRequest {
  return { id: "" };
}

export const GetBoiteMailRequest: MessageFns<GetBoiteMailRequest> = {
  encode(message: GetBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetBoiteMailByUtilisateurRequest(): GetBoiteMailByUtilisateurRequest {
  return { utilisateurId: "" };
}

export const GetBoiteMailByUtilisateurRequest: MessageFns<GetBoiteMailByUtilisateurRequest> = {
  encode(message: GetBoiteMailByUtilisateurRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBoiteMailByUtilisateurRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBoiteMailByUtilisateurRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetDefaultBoiteMailRequest(): GetDefaultBoiteMailRequest {
  return { utilisateurId: "" };
}

export const GetDefaultBoiteMailRequest: MessageFns<GetDefaultBoiteMailRequest> = {
  encode(message: GetDefaultBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDefaultBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDefaultBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListBoiteMailRequest(): ListBoiteMailRequest {
  return { search: "", fournisseur: "", actif: false };
}

export const ListBoiteMailRequest: MessageFns<ListBoiteMailRequest> = {
  encode(message: ListBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.fournisseur !== "") {
      writer.uint32(18).string(message.fournisseur);
    }
    if (message.actif !== false) {
      writer.uint32(24).bool(message.actif);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fournisseur = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListBoiteMailByUtilisateurRequest(): ListBoiteMailByUtilisateurRequest {
  return { utilisateurId: "", actif: false };
}

export const ListBoiteMailByUtilisateurRequest: MessageFns<ListBoiteMailByUtilisateurRequest> = {
  encode(message: ListBoiteMailByUtilisateurRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    if (message.actif !== false) {
      writer.uint32(16).bool(message.actif);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBoiteMailByUtilisateurRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBoiteMailByUtilisateurRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSetDefaultBoiteMailRequest(): SetDefaultBoiteMailRequest {
  return { id: "", utilisateurId: "" };
}

export const SetDefaultBoiteMailRequest: MessageFns<SetDefaultBoiteMailRequest> = {
  encode(message: SetDefaultBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetDefaultBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetDefaultBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseActivateBoiteMailRequest(): ActivateBoiteMailRequest {
  return { id: "" };
}

export const ActivateBoiteMailRequest: MessageFns<ActivateBoiteMailRequest> = {
  encode(message: ActivateBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateOAuthTokensRequest(): UpdateOAuthTokensRequest {
  return { id: "", accessToken: "", refreshToken: "", tokenExpiration: "" };
}

export const UpdateOAuthTokensRequest: MessageFns<UpdateOAuthTokensRequest> = {
  encode(message: UpdateOAuthTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.tokenExpiration !== "") {
      writer.uint32(34).string(message.tokenExpiration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOAuthTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOAuthTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenExpiration = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTestConnectionRequest(): TestConnectionRequest {
  return { id: "" };
}

export const TestConnectionRequest: MessageFns<TestConnectionRequest> = {
  encode(message: TestConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTestConnectionResponse(): TestConnectionResponse {
  return { success: false, message: "" };
}

export const TestConnectionResponse: MessageFns<TestConnectionResponse> = {
  encode(message: TestConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteBoiteMailRequest(): DeleteBoiteMailRequest {
  return { id: "" };
}

export const DeleteBoiteMailRequest: MessageFns<DeleteBoiteMailRequest> = {
  encode(message: DeleteBoiteMailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBoiteMailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBoiteMailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListBoiteMailResponse(): ListBoiteMailResponse {
  return { boites: [] };
}

export const ListBoiteMailResponse: MessageFns<ListBoiteMailResponse> = {
  encode(message: ListBoiteMailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.boites) {
      BoiteMail.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBoiteMailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBoiteMailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.boites.push(BoiteMail.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ========== PIECE JOINTE SERVICE ========== */

export interface PieceJointeServiceClient {
  create(request: CreatePieceJointeRequest, metadata?: Metadata): Observable<PieceJointe>;

  update(request: UpdatePieceJointeRequest, metadata?: Metadata): Observable<PieceJointe>;

  get(request: GetPieceJointeRequest, metadata?: Metadata): Observable<PieceJointe>;

  list(request: ListPieceJointeRequest, metadata?: Metadata): Observable<ListPieceJointeResponse>;

  listByEntite(request: ListPieceJointeByEntiteRequest, metadata?: Metadata): Observable<ListPieceJointeResponse>;

  delete(request: DeletePieceJointeRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== PIECE JOINTE SERVICE ========== */

export interface PieceJointeServiceController {
  create(
    request: CreatePieceJointeRequest,
    metadata?: Metadata,
  ): Promise<PieceJointe> | Observable<PieceJointe> | PieceJointe;

  update(
    request: UpdatePieceJointeRequest,
    metadata?: Metadata,
  ): Promise<PieceJointe> | Observable<PieceJointe> | PieceJointe;

  get(
    request: GetPieceJointeRequest,
    metadata?: Metadata,
  ): Promise<PieceJointe> | Observable<PieceJointe> | PieceJointe;

  list(
    request: ListPieceJointeRequest,
    metadata?: Metadata,
  ): Promise<ListPieceJointeResponse> | Observable<ListPieceJointeResponse> | ListPieceJointeResponse;

  listByEntite(
    request: ListPieceJointeByEntiteRequest,
    metadata?: Metadata,
  ): Promise<ListPieceJointeResponse> | Observable<ListPieceJointeResponse> | ListPieceJointeResponse;

  delete(
    request: DeletePieceJointeRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function PieceJointeServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "list", "listByEntite", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PieceJointeService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PieceJointeService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PIECE_JOINTE_SERVICE_NAME = "PieceJointeService";

/** ========== PIECE JOINTE SERVICE ========== */
export type PieceJointeServiceService = typeof PieceJointeServiceService;
export const PieceJointeServiceService = {
  create: {
    path: "/documents.PieceJointeService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePieceJointeRequest): Buffer =>
      Buffer.from(CreatePieceJointeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePieceJointeRequest => CreatePieceJointeRequest.decode(value),
    responseSerialize: (value: PieceJointe): Buffer => Buffer.from(PieceJointe.encode(value).finish()),
    responseDeserialize: (value: Buffer): PieceJointe => PieceJointe.decode(value),
  },
  update: {
    path: "/documents.PieceJointeService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePieceJointeRequest): Buffer =>
      Buffer.from(UpdatePieceJointeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePieceJointeRequest => UpdatePieceJointeRequest.decode(value),
    responseSerialize: (value: PieceJointe): Buffer => Buffer.from(PieceJointe.encode(value).finish()),
    responseDeserialize: (value: Buffer): PieceJointe => PieceJointe.decode(value),
  },
  get: {
    path: "/documents.PieceJointeService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPieceJointeRequest): Buffer =>
      Buffer.from(GetPieceJointeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPieceJointeRequest => GetPieceJointeRequest.decode(value),
    responseSerialize: (value: PieceJointe): Buffer => Buffer.from(PieceJointe.encode(value).finish()),
    responseDeserialize: (value: Buffer): PieceJointe => PieceJointe.decode(value),
  },
  list: {
    path: "/documents.PieceJointeService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPieceJointeRequest): Buffer =>
      Buffer.from(ListPieceJointeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPieceJointeRequest => ListPieceJointeRequest.decode(value),
    responseSerialize: (value: ListPieceJointeResponse): Buffer =>
      Buffer.from(ListPieceJointeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPieceJointeResponse => ListPieceJointeResponse.decode(value),
  },
  listByEntite: {
    path: "/documents.PieceJointeService/ListByEntite",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPieceJointeByEntiteRequest): Buffer =>
      Buffer.from(ListPieceJointeByEntiteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPieceJointeByEntiteRequest => ListPieceJointeByEntiteRequest.decode(value),
    responseSerialize: (value: ListPieceJointeResponse): Buffer =>
      Buffer.from(ListPieceJointeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPieceJointeResponse => ListPieceJointeResponse.decode(value),
  },
  delete: {
    path: "/documents.PieceJointeService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePieceJointeRequest): Buffer =>
      Buffer.from(DeletePieceJointeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeletePieceJointeRequest => DeletePieceJointeRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface PieceJointeServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreatePieceJointeRequest, PieceJointe>;
  update: handleUnaryCall<UpdatePieceJointeRequest, PieceJointe>;
  get: handleUnaryCall<GetPieceJointeRequest, PieceJointe>;
  list: handleUnaryCall<ListPieceJointeRequest, ListPieceJointeResponse>;
  listByEntite: handleUnaryCall<ListPieceJointeByEntiteRequest, ListPieceJointeResponse>;
  delete: handleUnaryCall<DeletePieceJointeRequest, DeleteResponse>;
}

/** ========== BOITE MAIL SERVICE ========== */

export interface BoiteMailServiceClient {
  create(request: CreateBoiteMailRequest, metadata?: Metadata): Observable<BoiteMail>;

  update(request: UpdateBoiteMailRequest, metadata?: Metadata): Observable<BoiteMail>;

  get(request: GetBoiteMailRequest, metadata?: Metadata): Observable<BoiteMail>;

  getByUtilisateur(request: GetBoiteMailByUtilisateurRequest, metadata?: Metadata): Observable<BoiteMail>;

  getDefault(request: GetDefaultBoiteMailRequest, metadata?: Metadata): Observable<BoiteMail>;

  list(request: ListBoiteMailRequest, metadata?: Metadata): Observable<ListBoiteMailResponse>;

  listByUtilisateur(request: ListBoiteMailByUtilisateurRequest, metadata?: Metadata): Observable<ListBoiteMailResponse>;

  setDefault(request: SetDefaultBoiteMailRequest, metadata?: Metadata): Observable<BoiteMail>;

  activer(request: ActivateBoiteMailRequest, metadata?: Metadata): Observable<BoiteMail>;

  desactiver(request: ActivateBoiteMailRequest, metadata?: Metadata): Observable<BoiteMail>;

  updateOAuthTokens(request: UpdateOAuthTokensRequest, metadata?: Metadata): Observable<BoiteMail>;

  testConnection(request: TestConnectionRequest, metadata?: Metadata): Observable<TestConnectionResponse>;

  delete(request: DeleteBoiteMailRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== BOITE MAIL SERVICE ========== */

export interface BoiteMailServiceController {
  create(request: CreateBoiteMailRequest, metadata?: Metadata): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  update(request: UpdateBoiteMailRequest, metadata?: Metadata): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  get(request: GetBoiteMailRequest, metadata?: Metadata): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  getByUtilisateur(
    request: GetBoiteMailByUtilisateurRequest,
    metadata?: Metadata,
  ): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  getDefault(
    request: GetDefaultBoiteMailRequest,
    metadata?: Metadata,
  ): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  list(
    request: ListBoiteMailRequest,
    metadata?: Metadata,
  ): Promise<ListBoiteMailResponse> | Observable<ListBoiteMailResponse> | ListBoiteMailResponse;

  listByUtilisateur(
    request: ListBoiteMailByUtilisateurRequest,
    metadata?: Metadata,
  ): Promise<ListBoiteMailResponse> | Observable<ListBoiteMailResponse> | ListBoiteMailResponse;

  setDefault(
    request: SetDefaultBoiteMailRequest,
    metadata?: Metadata,
  ): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  activer(
    request: ActivateBoiteMailRequest,
    metadata?: Metadata,
  ): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  desactiver(
    request: ActivateBoiteMailRequest,
    metadata?: Metadata,
  ): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  updateOAuthTokens(
    request: UpdateOAuthTokensRequest,
    metadata?: Metadata,
  ): Promise<BoiteMail> | Observable<BoiteMail> | BoiteMail;

  testConnection(
    request: TestConnectionRequest,
    metadata?: Metadata,
  ): Promise<TestConnectionResponse> | Observable<TestConnectionResponse> | TestConnectionResponse;

  delete(
    request: DeleteBoiteMailRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function BoiteMailServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "create",
      "update",
      "get",
      "getByUtilisateur",
      "getDefault",
      "list",
      "listByUtilisateur",
      "setDefault",
      "activer",
      "desactiver",
      "updateOAuthTokens",
      "testConnection",
      "delete",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("BoiteMailService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("BoiteMailService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const BOITE_MAIL_SERVICE_NAME = "BoiteMailService";

/** ========== BOITE MAIL SERVICE ========== */
export type BoiteMailServiceService = typeof BoiteMailServiceService;
export const BoiteMailServiceService = {
  create: {
    path: "/documents.BoiteMailService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBoiteMailRequest): Buffer =>
      Buffer.from(CreateBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateBoiteMailRequest => CreateBoiteMailRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  update: {
    path: "/documents.BoiteMailService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateBoiteMailRequest): Buffer =>
      Buffer.from(UpdateBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateBoiteMailRequest => UpdateBoiteMailRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  get: {
    path: "/documents.BoiteMailService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBoiteMailRequest): Buffer => Buffer.from(GetBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBoiteMailRequest => GetBoiteMailRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  getByUtilisateur: {
    path: "/documents.BoiteMailService/GetByUtilisateur",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBoiteMailByUtilisateurRequest): Buffer =>
      Buffer.from(GetBoiteMailByUtilisateurRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBoiteMailByUtilisateurRequest =>
      GetBoiteMailByUtilisateurRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  getDefault: {
    path: "/documents.BoiteMailService/GetDefault",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDefaultBoiteMailRequest): Buffer =>
      Buffer.from(GetDefaultBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDefaultBoiteMailRequest => GetDefaultBoiteMailRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  list: {
    path: "/documents.BoiteMailService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListBoiteMailRequest): Buffer => Buffer.from(ListBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListBoiteMailRequest => ListBoiteMailRequest.decode(value),
    responseSerialize: (value: ListBoiteMailResponse): Buffer =>
      Buffer.from(ListBoiteMailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListBoiteMailResponse => ListBoiteMailResponse.decode(value),
  },
  listByUtilisateur: {
    path: "/documents.BoiteMailService/ListByUtilisateur",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListBoiteMailByUtilisateurRequest): Buffer =>
      Buffer.from(ListBoiteMailByUtilisateurRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListBoiteMailByUtilisateurRequest =>
      ListBoiteMailByUtilisateurRequest.decode(value),
    responseSerialize: (value: ListBoiteMailResponse): Buffer =>
      Buffer.from(ListBoiteMailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListBoiteMailResponse => ListBoiteMailResponse.decode(value),
  },
  setDefault: {
    path: "/documents.BoiteMailService/SetDefault",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetDefaultBoiteMailRequest): Buffer =>
      Buffer.from(SetDefaultBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SetDefaultBoiteMailRequest => SetDefaultBoiteMailRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  activer: {
    path: "/documents.BoiteMailService/Activer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateBoiteMailRequest): Buffer =>
      Buffer.from(ActivateBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ActivateBoiteMailRequest => ActivateBoiteMailRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  desactiver: {
    path: "/documents.BoiteMailService/Desactiver",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateBoiteMailRequest): Buffer =>
      Buffer.from(ActivateBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ActivateBoiteMailRequest => ActivateBoiteMailRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  updateOAuthTokens: {
    path: "/documents.BoiteMailService/UpdateOAuthTokens",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateOAuthTokensRequest): Buffer =>
      Buffer.from(UpdateOAuthTokensRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateOAuthTokensRequest => UpdateOAuthTokensRequest.decode(value),
    responseSerialize: (value: BoiteMail): Buffer => Buffer.from(BoiteMail.encode(value).finish()),
    responseDeserialize: (value: Buffer): BoiteMail => BoiteMail.decode(value),
  },
  testConnection: {
    path: "/documents.BoiteMailService/TestConnection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TestConnectionRequest): Buffer =>
      Buffer.from(TestConnectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TestConnectionRequest => TestConnectionRequest.decode(value),
    responseSerialize: (value: TestConnectionResponse): Buffer =>
      Buffer.from(TestConnectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TestConnectionResponse => TestConnectionResponse.decode(value),
  },
  delete: {
    path: "/documents.BoiteMailService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteBoiteMailRequest): Buffer =>
      Buffer.from(DeleteBoiteMailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteBoiteMailRequest => DeleteBoiteMailRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface BoiteMailServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateBoiteMailRequest, BoiteMail>;
  update: handleUnaryCall<UpdateBoiteMailRequest, BoiteMail>;
  get: handleUnaryCall<GetBoiteMailRequest, BoiteMail>;
  getByUtilisateur: handleUnaryCall<GetBoiteMailByUtilisateurRequest, BoiteMail>;
  getDefault: handleUnaryCall<GetDefaultBoiteMailRequest, BoiteMail>;
  list: handleUnaryCall<ListBoiteMailRequest, ListBoiteMailResponse>;
  listByUtilisateur: handleUnaryCall<ListBoiteMailByUtilisateurRequest, ListBoiteMailResponse>;
  setDefault: handleUnaryCall<SetDefaultBoiteMailRequest, BoiteMail>;
  activer: handleUnaryCall<ActivateBoiteMailRequest, BoiteMail>;
  desactiver: handleUnaryCall<ActivateBoiteMailRequest, BoiteMail>;
  updateOAuthTokens: handleUnaryCall<UpdateOAuthTokensRequest, BoiteMail>;
  testConnection: handleUnaryCall<TestConnectionRequest, TestConnectionResponse>;
  delete: handleUnaryCall<DeleteBoiteMailRequest, DeleteResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
