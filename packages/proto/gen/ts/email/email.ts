// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: email/email.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export enum MailProvider {
  MAIL_PROVIDER_UNSPECIFIED = 0,
  MAIL_PROVIDER_GMAIL = 1,
  MAIL_PROVIDER_OUTLOOK = 2,
  MAIL_PROVIDER_EXCHANGE = 3,
  MAIL_PROVIDER_SMTP = 4,
  MAIL_PROVIDER_OTHER = 5,
}

export enum ConnectionType {
  CONNECTION_TYPE_UNSPECIFIED = 0,
  CONNECTION_TYPE_OAUTH2 = 1,
  CONNECTION_TYPE_SMTP_IMAP = 2,
}

export interface Timestamp {
  seconds: number;
  nanos: number;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface OperationResponse {
  success: boolean;
  message: string;
}

export interface Mailbox {
  id: string;
  organisationId: string;
  societeId: string;
  userId: string;
  nom: string;
  adresseEmail: string;
  fournisseur: MailProvider;
  typeConnexion: ConnectionType;
  /** SMTP/IMAP settings (for non-OAuth connections) */
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  imapHost?: string | undefined;
  imapPort?: number | undefined;
  username?:
    | string
    | undefined;
  /** OAuth2 tokens (encrypted) */
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  tokenExpiry?:
    | string
    | undefined;
  /** Additional settings */
  signature?: string | undefined;
  isDefault: boolean;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateMailboxRequest {
  organisationId: string;
  societeId: string;
  userId: string;
  nom: string;
  adresseEmail: string;
  fournisseur: MailProvider;
  typeConnexion: ConnectionType;
  /** SMTP/IMAP settings */
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  imapHost?: string | undefined;
  imapPort?: number | undefined;
  username?: string | undefined;
  password?:
    | string
    | undefined;
  /** OAuth2 tokens */
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  tokenExpiry?: string | undefined;
  signature?: string | undefined;
  isDefault: boolean;
}

export interface GetMailboxRequest {
  id: string;
}

export interface GetMailboxesByOrganisationRequest {
  organisationId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetMailboxesBySocieteRequest {
  societeId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface UpdateMailboxRequest {
  id: string;
  nom?: string | undefined;
  adresseEmail?: string | undefined;
  fournisseur?: MailProvider | undefined;
  typeConnexion?: ConnectionType | undefined;
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  imapHost?: string | undefined;
  imapPort?: number | undefined;
  username?: string | undefined;
  password?: string | undefined;
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
  tokenExpiry?: string | undefined;
  signature?: string | undefined;
  isDefault?: boolean | undefined;
  isActive?: boolean | undefined;
}

export interface DeleteMailboxRequest {
  id: string;
}

export interface MailboxResponse {
  mailbox?: Mailbox | undefined;
}

export interface MailboxListResponse {
  mailboxes: Mailbox[];
  total: number;
}

export interface GetAuthUrlRequest {
  redirectUri: string;
  state?: string | undefined;
  scopes: string[];
}

export interface AuthUrlResponse {
  authorizationUrl: string;
  state: string;
}

export interface ExchangeCodeRequest {
  code: string;
  redirectUri: string;
}

export interface TokenResponse {
  accessToken: string;
  refreshToken?: string | undefined;
  expiresIn: number;
  tokenType: string;
  idToken?: string | undefined;
}

export interface RefreshTokenRequest {
  refreshToken: string;
  mailboxId: string;
}

export interface RevokeTokenRequest {
  accessToken: string;
  mailboxId: string;
}

export interface GetUserInfoRequest {
  accessToken: string;
}

export interface UserInfoResponse {
  email: string;
  name: string;
  picture?: string | undefined;
  locale?: string | undefined;
}

export interface EmailAttachment {
  filename: string;
  contentType: string;
  content: Uint8Array;
  contentId?: string | undefined;
}

export interface EmailRecipient {
  email: string;
  name?: string | undefined;
}

export interface SendEmailRequest {
  mailboxId: string;
  to: EmailRecipient[];
  cc: EmailRecipient[];
  bcc: EmailRecipient[];
  subject: string;
  textBody?: string | undefined;
  htmlBody?: string | undefined;
  attachments: EmailAttachment[];
  replyTo?: string | undefined;
  headers: { [key: string]: string };
}

export interface SendEmailRequest_HeadersEntry {
  key: string;
  value: string;
}

export interface SendEmailWithTemplateRequest {
  mailboxId: string;
  to: EmailRecipient[];
  cc: EmailRecipient[];
  bcc: EmailRecipient[];
  templateId: string;
  templateVariables: { [key: string]: string };
  attachments: EmailAttachment[];
}

export interface SendEmailWithTemplateRequest_TemplateVariablesEntry {
  key: string;
  value: string;
}

export interface SendEmailResponse {
  success: boolean;
  messageId: string;
  error?: string | undefined;
}

export interface GetEmailsRequest {
  mailboxId: string;
  folder?: string | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
  searchQuery?: string | undefined;
}

export interface GetEmailRequest {
  mailboxId: string;
  emailId: string;
}

export interface Email {
  id: string;
  mailboxId: string;
  messageId: string;
  subject: string;
  from?: EmailRecipient | undefined;
  to: EmailRecipient[];
  cc: EmailRecipient[];
  textBody?: string | undefined;
  htmlBody?: string | undefined;
  attachments: EmailAttachment[];
  folder: string;
  isRead: boolean;
  isStarred: boolean;
  receivedAt: string;
}

export interface EmailResponse {
  email?: Email | undefined;
}

export interface EmailListResponse {
  emails: Email[];
  total: number;
}

export interface TestConnectionRequest {
  mailboxId: string;
}

export interface TestConnectionResponse {
  success: boolean;
  message: string;
  errorDetails?: string | undefined;
}

function createBaseTimestamp(): Timestamp {
  return { seconds: 0, nanos: 0 };
}

export const Timestamp: MessageFns<Timestamp> = {
  encode(message: Timestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds !== 0) {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Timestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seconds = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nanos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOperationResponse(): OperationResponse {
  return { success: false, message: "" };
}

export const OperationResponse: MessageFns<OperationResponse> = {
  encode(message: OperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMailbox(): Mailbox {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    userId: "",
    nom: "",
    adresseEmail: "",
    fournisseur: 0,
    typeConnexion: 0,
    isDefault: false,
    isActive: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Mailbox: MessageFns<Mailbox> = {
  encode(message: Mailbox, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.nom !== "") {
      writer.uint32(42).string(message.nom);
    }
    if (message.adresseEmail !== "") {
      writer.uint32(50).string(message.adresseEmail);
    }
    if (message.fournisseur !== 0) {
      writer.uint32(56).int32(message.fournisseur);
    }
    if (message.typeConnexion !== 0) {
      writer.uint32(64).int32(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      writer.uint32(74).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined) {
      writer.uint32(80).int32(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      writer.uint32(90).string(message.imapHost);
    }
    if (message.imapPort !== undefined) {
      writer.uint32(96).int32(message.imapPort);
    }
    if (message.username !== undefined) {
      writer.uint32(106).string(message.username);
    }
    if (message.accessToken !== undefined) {
      writer.uint32(114).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(122).string(message.refreshToken);
    }
    if (message.tokenExpiry !== undefined) {
      writer.uint32(130).string(message.tokenExpiry);
    }
    if (message.signature !== undefined) {
      writer.uint32(138).string(message.signature);
    }
    if (message.isDefault !== false) {
      writer.uint32(144).bool(message.isDefault);
    }
    if (message.isActive !== false) {
      writer.uint32(152).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(162).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(170).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mailbox {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMailbox();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fournisseur = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.typeConnexion = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.smtpPort = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.imapHost = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.imapPort = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.tokenExpiry = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateMailboxRequest(): CreateMailboxRequest {
  return {
    organisationId: "",
    societeId: "",
    userId: "",
    nom: "",
    adresseEmail: "",
    fournisseur: 0,
    typeConnexion: 0,
    isDefault: false,
  };
}

export const CreateMailboxRequest: MessageFns<CreateMailboxRequest> = {
  encode(message: CreateMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.nom !== "") {
      writer.uint32(34).string(message.nom);
    }
    if (message.adresseEmail !== "") {
      writer.uint32(42).string(message.adresseEmail);
    }
    if (message.fournisseur !== 0) {
      writer.uint32(48).int32(message.fournisseur);
    }
    if (message.typeConnexion !== 0) {
      writer.uint32(56).int32(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      writer.uint32(66).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined) {
      writer.uint32(72).int32(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      writer.uint32(82).string(message.imapHost);
    }
    if (message.imapPort !== undefined) {
      writer.uint32(88).int32(message.imapPort);
    }
    if (message.username !== undefined) {
      writer.uint32(98).string(message.username);
    }
    if (message.password !== undefined) {
      writer.uint32(106).string(message.password);
    }
    if (message.accessToken !== undefined) {
      writer.uint32(114).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(122).string(message.refreshToken);
    }
    if (message.tokenExpiry !== undefined) {
      writer.uint32(130).string(message.tokenExpiry);
    }
    if (message.signature !== undefined) {
      writer.uint32(138).string(message.signature);
    }
    if (message.isDefault !== false) {
      writer.uint32(144).bool(message.isDefault);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fournisseur = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.typeConnexion = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.smtpPort = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.imapHost = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.imapPort = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.tokenExpiry = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMailboxRequest(): GetMailboxRequest {
  return { id: "" };
}

export const GetMailboxRequest: MessageFns<GetMailboxRequest> = {
  encode(message: GetMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMailboxesByOrganisationRequest(): GetMailboxesByOrganisationRequest {
  return { organisationId: "" };
}

export const GetMailboxesByOrganisationRequest: MessageFns<GetMailboxesByOrganisationRequest> = {
  encode(message: GetMailboxesByOrganisationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMailboxesByOrganisationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailboxesByOrganisationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetMailboxesBySocieteRequest(): GetMailboxesBySocieteRequest {
  return { societeId: "" };
}

export const GetMailboxesBySocieteRequest: MessageFns<GetMailboxesBySocieteRequest> = {
  encode(message: GetMailboxesBySocieteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMailboxesBySocieteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailboxesBySocieteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateMailboxRequest(): UpdateMailboxRequest {
  return { id: "" };
}

export const UpdateMailboxRequest: MessageFns<UpdateMailboxRequest> = {
  encode(message: UpdateMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.adresseEmail !== undefined) {
      writer.uint32(26).string(message.adresseEmail);
    }
    if (message.fournisseur !== undefined) {
      writer.uint32(32).int32(message.fournisseur);
    }
    if (message.typeConnexion !== undefined) {
      writer.uint32(40).int32(message.typeConnexion);
    }
    if (message.smtpHost !== undefined) {
      writer.uint32(50).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined) {
      writer.uint32(56).int32(message.smtpPort);
    }
    if (message.imapHost !== undefined) {
      writer.uint32(66).string(message.imapHost);
    }
    if (message.imapPort !== undefined) {
      writer.uint32(72).int32(message.imapPort);
    }
    if (message.username !== undefined) {
      writer.uint32(82).string(message.username);
    }
    if (message.password !== undefined) {
      writer.uint32(90).string(message.password);
    }
    if (message.accessToken !== undefined) {
      writer.uint32(98).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(106).string(message.refreshToken);
    }
    if (message.tokenExpiry !== undefined) {
      writer.uint32(114).string(message.tokenExpiry);
    }
    if (message.signature !== undefined) {
      writer.uint32(122).string(message.signature);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(128).bool(message.isDefault);
    }
    if (message.isActive !== undefined) {
      writer.uint32(136).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.adresseEmail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fournisseur = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.typeConnexion = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.smtpPort = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.imapHost = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.imapPort = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.tokenExpiry = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteMailboxRequest(): DeleteMailboxRequest {
  return { id: "" };
}

export const DeleteMailboxRequest: MessageFns<DeleteMailboxRequest> = {
  encode(message: DeleteMailboxRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMailboxRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMailboxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMailboxResponse(): MailboxResponse {
  return {};
}

export const MailboxResponse: MessageFns<MailboxResponse> = {
  encode(message: MailboxResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailbox !== undefined) {
      Mailbox.encode(message.mailbox, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MailboxResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMailboxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailbox = Mailbox.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMailboxListResponse(): MailboxListResponse {
  return { mailboxes: [], total: 0 };
}

export const MailboxListResponse: MessageFns<MailboxListResponse> = {
  encode(message: MailboxListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mailboxes) {
      Mailbox.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MailboxListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMailboxListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxes.push(Mailbox.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuthUrlRequest(): GetAuthUrlRequest {
  return { redirectUri: "", scopes: [] };
}

export const GetAuthUrlRequest: MessageFns<GetAuthUrlRequest> = {
  encode(message: GetAuthUrlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redirectUri !== "") {
      writer.uint32(10).string(message.redirectUri);
    }
    if (message.state !== undefined) {
      writer.uint32(18).string(message.state);
    }
    for (const v of message.scopes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuthUrlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthUrlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthUrlResponse(): AuthUrlResponse {
  return { authorizationUrl: "", state: "" };
}

export const AuthUrlResponse: MessageFns<AuthUrlResponse> = {
  encode(message: AuthUrlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authorizationUrl !== "") {
      writer.uint32(10).string(message.authorizationUrl);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthUrlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthUrlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authorizationUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExchangeCodeRequest(): ExchangeCodeRequest {
  return { code: "", redirectUri: "" };
}

export const ExchangeCodeRequest: MessageFns<ExchangeCodeRequest> = {
  encode(message: ExchangeCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.redirectUri !== "") {
      writer.uint32(18).string(message.redirectUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTokenResponse(): TokenResponse {
  return { accessToken: "", expiresIn: 0, tokenType: "" };
}

export const TokenResponse: MessageFns<TokenResponse> = {
  encode(message: TokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== undefined) {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.expiresIn !== 0) {
      writer.uint32(24).int64(message.expiresIn);
    }
    if (message.tokenType !== "") {
      writer.uint32(34).string(message.tokenType);
    }
    if (message.idToken !== undefined) {
      writer.uint32(42).string(message.idToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresIn = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.idToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "", mailboxId: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    if (message.mailboxId !== "") {
      writer.uint32(18).string(message.mailboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRevokeTokenRequest(): RevokeTokenRequest {
  return { accessToken: "", mailboxId: "" };
}

export const RevokeTokenRequest: MessageFns<RevokeTokenRequest> = {
  encode(message: RevokeTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.mailboxId !== "") {
      writer.uint32(18).string(message.mailboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetUserInfoRequest(): GetUserInfoRequest {
  return { accessToken: "" };
}

export const GetUserInfoRequest: MessageFns<GetUserInfoRequest> = {
  encode(message: GetUserInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserInfoResponse(): UserInfoResponse {
  return { email: "", name: "" };
}

export const UserInfoResponse: MessageFns<UserInfoResponse> = {
  encode(message: UserInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.picture !== undefined) {
      writer.uint32(26).string(message.picture);
    }
    if (message.locale !== undefined) {
      writer.uint32(34).string(message.locale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.picture = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmailAttachment(): EmailAttachment {
  return { filename: "", contentType: "", content: new Uint8Array(0) };
}

export const EmailAttachment: MessageFns<EmailAttachment> = {
  encode(message: EmailAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.contentType !== "") {
      writer.uint32(18).string(message.contentType);
    }
    if (message.content.length !== 0) {
      writer.uint32(26).bytes(message.content);
    }
    if (message.contentId !== undefined) {
      writer.uint32(34).string(message.contentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmailRecipient(): EmailRecipient {
  return { email: "" };
}

export const EmailRecipient: MessageFns<EmailRecipient> = {
  encode(message: EmailRecipient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailRecipient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendEmailRequest(): SendEmailRequest {
  return { mailboxId: "", to: [], cc: [], bcc: [], subject: "", attachments: [], headers: {} };
}

export const SendEmailRequest: MessageFns<SendEmailRequest> = {
  encode(message: SendEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    for (const v of message.to) {
      EmailRecipient.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.cc) {
      EmailRecipient.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.bcc) {
      EmailRecipient.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.subject !== "") {
      writer.uint32(42).string(message.subject);
    }
    if (message.textBody !== undefined) {
      writer.uint32(50).string(message.textBody);
    }
    if (message.htmlBody !== undefined) {
      writer.uint32(58).string(message.htmlBody);
    }
    for (const v of message.attachments) {
      EmailAttachment.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.replyTo !== undefined) {
      writer.uint32(74).string(message.replyTo);
    }
    globalThis.Object.entries(message.headers).forEach(([key, value]: [string, string]) => {
      SendEmailRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bcc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.textBody = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.htmlBody = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attachments.push(EmailAttachment.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.replyTo = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = SendEmailRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.headers[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendEmailRequest_HeadersEntry(): SendEmailRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const SendEmailRequest_HeadersEntry: MessageFns<SendEmailRequest_HeadersEntry> = {
  encode(message: SendEmailRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendEmailWithTemplateRequest(): SendEmailWithTemplateRequest {
  return { mailboxId: "", to: [], cc: [], bcc: [], templateId: "", templateVariables: {}, attachments: [] };
}

export const SendEmailWithTemplateRequest: MessageFns<SendEmailWithTemplateRequest> = {
  encode(message: SendEmailWithTemplateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    for (const v of message.to) {
      EmailRecipient.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.cc) {
      EmailRecipient.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.bcc) {
      EmailRecipient.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.templateId !== "") {
      writer.uint32(42).string(message.templateId);
    }
    globalThis.Object.entries(message.templateVariables).forEach(([key, value]: [string, string]) => {
      SendEmailWithTemplateRequest_TemplateVariablesEntry.encode({ key: key as any, value }, writer.uint32(50).fork())
        .join();
    });
    for (const v of message.attachments) {
      EmailAttachment.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailWithTemplateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailWithTemplateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bcc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.templateId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = SendEmailWithTemplateRequest_TemplateVariablesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.templateVariables[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attachments.push(EmailAttachment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendEmailWithTemplateRequest_TemplateVariablesEntry(): SendEmailWithTemplateRequest_TemplateVariablesEntry {
  return { key: "", value: "" };
}

export const SendEmailWithTemplateRequest_TemplateVariablesEntry: MessageFns<
  SendEmailWithTemplateRequest_TemplateVariablesEntry
> = {
  encode(
    message: SendEmailWithTemplateRequest_TemplateVariablesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailWithTemplateRequest_TemplateVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailWithTemplateRequest_TemplateVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendEmailResponse(): SendEmailResponse {
  return { success: false, messageId: "" };
}

export const SendEmailResponse: MessageFns<SendEmailResponse> = {
  encode(message: SendEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetEmailsRequest(): GetEmailsRequest {
  return { mailboxId: "" };
}

export const GetEmailsRequest: MessageFns<GetEmailsRequest> = {
  encode(message: GetEmailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    if (message.folder !== undefined) {
      writer.uint32(18).string(message.folder);
    }
    if (message.limit !== undefined) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int32(message.offset);
    }
    if (message.searchQuery !== undefined) {
      writer.uint32(42).string(message.searchQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.folder = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetEmailRequest(): GetEmailRequest {
  return { mailboxId: "", emailId: "" };
}

export const GetEmailRequest: MessageFns<GetEmailRequest> = {
  encode(message: GetEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    if (message.emailId !== "") {
      writer.uint32(18).string(message.emailId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.emailId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmail(): Email {
  return {
    id: "",
    mailboxId: "",
    messageId: "",
    subject: "",
    to: [],
    cc: [],
    attachments: [],
    folder: "",
    isRead: false,
    isStarred: false,
    receivedAt: "",
  };
}

export const Email: MessageFns<Email> = {
  encode(message: Email, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.mailboxId !== "") {
      writer.uint32(18).string(message.mailboxId);
    }
    if (message.messageId !== "") {
      writer.uint32(26).string(message.messageId);
    }
    if (message.subject !== "") {
      writer.uint32(34).string(message.subject);
    }
    if (message.from !== undefined) {
      EmailRecipient.encode(message.from, writer.uint32(42).fork()).join();
    }
    for (const v of message.to) {
      EmailRecipient.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.cc) {
      EmailRecipient.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.textBody !== undefined) {
      writer.uint32(66).string(message.textBody);
    }
    if (message.htmlBody !== undefined) {
      writer.uint32(74).string(message.htmlBody);
    }
    for (const v of message.attachments) {
      EmailAttachment.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.folder !== "") {
      writer.uint32(90).string(message.folder);
    }
    if (message.isRead !== false) {
      writer.uint32(96).bool(message.isRead);
    }
    if (message.isStarred !== false) {
      writer.uint32(104).bool(message.isStarred);
    }
    if (message.receivedAt !== "") {
      writer.uint32(114).string(message.receivedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Email {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.from = EmailRecipient.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.to.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cc.push(EmailRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.textBody = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.htmlBody = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attachments.push(EmailAttachment.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.folder = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isRead = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isStarred = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmailResponse(): EmailResponse {
  return {};
}

export const EmailResponse: MessageFns<EmailResponse> = {
  encode(message: EmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== undefined) {
      Email.encode(message.email, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = Email.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmailListResponse(): EmailListResponse {
  return { emails: [], total: 0 };
}

export const EmailListResponse: MessageFns<EmailListResponse> = {
  encode(message: EmailListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.emails) {
      Email.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emails.push(Email.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTestConnectionRequest(): TestConnectionRequest {
  return { mailboxId: "" };
}

export const TestConnectionRequest: MessageFns<TestConnectionRequest> = {
  encode(message: TestConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mailboxId !== "") {
      writer.uint32(10).string(message.mailboxId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mailboxId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTestConnectionResponse(): TestConnectionResponse {
  return { success: false, message: "" };
}

export const TestConnectionResponse: MessageFns<TestConnectionResponse> = {
  encode(message: TestConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.errorDetails !== undefined) {
      writer.uint32(26).string(message.errorDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorDetails = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** Main Email Service */

export interface EmailServiceClient {
  /** ===== Mailbox Management ===== */

  createMailbox(request: CreateMailboxRequest, metadata?: Metadata): Observable<MailboxResponse>;

  getMailbox(request: GetMailboxRequest, metadata?: Metadata): Observable<MailboxResponse>;

  getMailboxesByOrganisation(
    request: GetMailboxesByOrganisationRequest,
    metadata?: Metadata,
  ): Observable<MailboxListResponse>;

  getMailboxesBySociete(request: GetMailboxesBySocieteRequest, metadata?: Metadata): Observable<MailboxListResponse>;

  updateMailbox(request: UpdateMailboxRequest, metadata?: Metadata): Observable<MailboxResponse>;

  deleteMailbox(request: DeleteMailboxRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== OAuth2 Authentication ===== */

  getGoogleAuthUrl(request: GetAuthUrlRequest, metadata?: Metadata): Observable<AuthUrlResponse>;

  exchangeGoogleCode(request: ExchangeCodeRequest, metadata?: Metadata): Observable<TokenResponse>;

  refreshGoogleToken(request: RefreshTokenRequest, metadata?: Metadata): Observable<TokenResponse>;

  revokeGoogleToken(request: RevokeTokenRequest, metadata?: Metadata): Observable<OperationResponse>;

  getMicrosoftAuthUrl(request: GetAuthUrlRequest, metadata?: Metadata): Observable<AuthUrlResponse>;

  exchangeMicrosoftCode(request: ExchangeCodeRequest, metadata?: Metadata): Observable<TokenResponse>;

  refreshMicrosoftToken(request: RefreshTokenRequest, metadata?: Metadata): Observable<TokenResponse>;

  revokeMicrosoftToken(request: RevokeTokenRequest, metadata?: Metadata): Observable<OperationResponse>;

  /** ===== Email Operations ===== */

  sendEmail(request: SendEmailRequest, metadata?: Metadata): Observable<SendEmailResponse>;

  sendEmailWithTemplate(request: SendEmailWithTemplateRequest, metadata?: Metadata): Observable<SendEmailResponse>;

  getEmails(request: GetEmailsRequest, metadata?: Metadata): Observable<EmailListResponse>;

  getEmail(request: GetEmailRequest, metadata?: Metadata): Observable<EmailResponse>;

  /** ===== User Info ===== */

  getGoogleUserInfo(request: GetUserInfoRequest, metadata?: Metadata): Observable<UserInfoResponse>;

  getMicrosoftUserInfo(request: GetUserInfoRequest, metadata?: Metadata): Observable<UserInfoResponse>;

  /** ===== Connection Test ===== */

  testMailboxConnection(request: TestConnectionRequest, metadata?: Metadata): Observable<TestConnectionResponse>;
}

/** Main Email Service */

export interface EmailServiceController {
  /** ===== Mailbox Management ===== */

  createMailbox(
    request: CreateMailboxRequest,
    metadata?: Metadata,
  ): Promise<MailboxResponse> | Observable<MailboxResponse> | MailboxResponse;

  getMailbox(
    request: GetMailboxRequest,
    metadata?: Metadata,
  ): Promise<MailboxResponse> | Observable<MailboxResponse> | MailboxResponse;

  getMailboxesByOrganisation(
    request: GetMailboxesByOrganisationRequest,
    metadata?: Metadata,
  ): Promise<MailboxListResponse> | Observable<MailboxListResponse> | MailboxListResponse;

  getMailboxesBySociete(
    request: GetMailboxesBySocieteRequest,
    metadata?: Metadata,
  ): Promise<MailboxListResponse> | Observable<MailboxListResponse> | MailboxListResponse;

  updateMailbox(
    request: UpdateMailboxRequest,
    metadata?: Metadata,
  ): Promise<MailboxResponse> | Observable<MailboxResponse> | MailboxResponse;

  deleteMailbox(
    request: DeleteMailboxRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== OAuth2 Authentication ===== */

  getGoogleAuthUrl(
    request: GetAuthUrlRequest,
    metadata?: Metadata,
  ): Promise<AuthUrlResponse> | Observable<AuthUrlResponse> | AuthUrlResponse;

  exchangeGoogleCode(
    request: ExchangeCodeRequest,
    metadata?: Metadata,
  ): Promise<TokenResponse> | Observable<TokenResponse> | TokenResponse;

  refreshGoogleToken(
    request: RefreshTokenRequest,
    metadata?: Metadata,
  ): Promise<TokenResponse> | Observable<TokenResponse> | TokenResponse;

  revokeGoogleToken(
    request: RevokeTokenRequest,
    metadata?: Metadata,
  ): Promise<OperationResponse> | Observable<OperationResponse> | OperationResponse;

  getMicrosoftAuthUrl(
    request: GetAuthUrlRequest,
    metadata?: Metadata,
  ): Promise<AuthUrlResponse> | Observable<AuthUrlResponse> | AuthUrlResponse;

  exchangeMicrosoftCode(
    request: ExchangeCodeRequest,
    metadata?: Metadata,
  ): Promise<TokenResponse> | Observable<TokenResponse> | TokenResponse;

  refreshMicrosoftToken(
    request: RefreshTokenRequest,
    metadata?: Metadata,
  ): Promise<TokenResponse> | Observable<TokenResponse> | TokenResponse;

  revokeMicrosoftToken(
    request: RevokeTokenRequest,
    metadata?: Metadata,
  ): Promise<OperationResponse> | Observable<OperationResponse> | OperationResponse;

  /** ===== Email Operations ===== */

  sendEmail(
    request: SendEmailRequest,
    metadata?: Metadata,
  ): Promise<SendEmailResponse> | Observable<SendEmailResponse> | SendEmailResponse;

  sendEmailWithTemplate(
    request: SendEmailWithTemplateRequest,
    metadata?: Metadata,
  ): Promise<SendEmailResponse> | Observable<SendEmailResponse> | SendEmailResponse;

  getEmails(
    request: GetEmailsRequest,
    metadata?: Metadata,
  ): Promise<EmailListResponse> | Observable<EmailListResponse> | EmailListResponse;

  getEmail(
    request: GetEmailRequest,
    metadata?: Metadata,
  ): Promise<EmailResponse> | Observable<EmailResponse> | EmailResponse;

  /** ===== User Info ===== */

  getGoogleUserInfo(
    request: GetUserInfoRequest,
    metadata?: Metadata,
  ): Promise<UserInfoResponse> | Observable<UserInfoResponse> | UserInfoResponse;

  getMicrosoftUserInfo(
    request: GetUserInfoRequest,
    metadata?: Metadata,
  ): Promise<UserInfoResponse> | Observable<UserInfoResponse> | UserInfoResponse;

  /** ===== Connection Test ===== */

  testMailboxConnection(
    request: TestConnectionRequest,
    metadata?: Metadata,
  ): Promise<TestConnectionResponse> | Observable<TestConnectionResponse> | TestConnectionResponse;
}

export function EmailServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createMailbox",
      "getMailbox",
      "getMailboxesByOrganisation",
      "getMailboxesBySociete",
      "updateMailbox",
      "deleteMailbox",
      "getGoogleAuthUrl",
      "exchangeGoogleCode",
      "refreshGoogleToken",
      "revokeGoogleToken",
      "getMicrosoftAuthUrl",
      "exchangeMicrosoftCode",
      "refreshMicrosoftToken",
      "revokeMicrosoftToken",
      "sendEmail",
      "sendEmailWithTemplate",
      "getEmails",
      "getEmail",
      "getGoogleUserInfo",
      "getMicrosoftUserInfo",
      "testMailboxConnection",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("EmailService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("EmailService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const EMAIL_SERVICE_NAME = "EmailService";

/** Main Email Service */
export type EmailServiceService = typeof EmailServiceService;
export const EmailServiceService = {
  /** ===== Mailbox Management ===== */
  createMailbox: {
    path: "/email.EmailService/CreateMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateMailboxRequest): Buffer => Buffer.from(CreateMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateMailboxRequest => CreateMailboxRequest.decode(value),
    responseSerialize: (value: MailboxResponse): Buffer => Buffer.from(MailboxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxResponse => MailboxResponse.decode(value),
  },
  getMailbox: {
    path: "/email.EmailService/GetMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMailboxRequest): Buffer => Buffer.from(GetMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMailboxRequest => GetMailboxRequest.decode(value),
    responseSerialize: (value: MailboxResponse): Buffer => Buffer.from(MailboxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxResponse => MailboxResponse.decode(value),
  },
  getMailboxesByOrganisation: {
    path: "/email.EmailService/GetMailboxesByOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMailboxesByOrganisationRequest): Buffer =>
      Buffer.from(GetMailboxesByOrganisationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMailboxesByOrganisationRequest =>
      GetMailboxesByOrganisationRequest.decode(value),
    responseSerialize: (value: MailboxListResponse): Buffer => Buffer.from(MailboxListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxListResponse => MailboxListResponse.decode(value),
  },
  getMailboxesBySociete: {
    path: "/email.EmailService/GetMailboxesBySociete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMailboxesBySocieteRequest): Buffer =>
      Buffer.from(GetMailboxesBySocieteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMailboxesBySocieteRequest => GetMailboxesBySocieteRequest.decode(value),
    responseSerialize: (value: MailboxListResponse): Buffer => Buffer.from(MailboxListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxListResponse => MailboxListResponse.decode(value),
  },
  updateMailbox: {
    path: "/email.EmailService/UpdateMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateMailboxRequest): Buffer => Buffer.from(UpdateMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateMailboxRequest => UpdateMailboxRequest.decode(value),
    responseSerialize: (value: MailboxResponse): Buffer => Buffer.from(MailboxResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MailboxResponse => MailboxResponse.decode(value),
  },
  deleteMailbox: {
    path: "/email.EmailService/DeleteMailbox",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteMailboxRequest): Buffer => Buffer.from(DeleteMailboxRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteMailboxRequest => DeleteMailboxRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== OAuth2 Authentication ===== */
  getGoogleAuthUrl: {
    path: "/email.EmailService/GetGoogleAuthUrl",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuthUrlRequest): Buffer => Buffer.from(GetAuthUrlRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuthUrlRequest => GetAuthUrlRequest.decode(value),
    responseSerialize: (value: AuthUrlResponse): Buffer => Buffer.from(AuthUrlResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthUrlResponse => AuthUrlResponse.decode(value),
  },
  exchangeGoogleCode: {
    path: "/email.EmailService/ExchangeGoogleCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeCodeRequest): Buffer => Buffer.from(ExchangeCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExchangeCodeRequest => ExchangeCodeRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  refreshGoogleToken: {
    path: "/email.EmailService/RefreshGoogleToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  revokeGoogleToken: {
    path: "/email.EmailService/RevokeGoogleToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokeTokenRequest): Buffer => Buffer.from(RevokeTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RevokeTokenRequest => RevokeTokenRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  getMicrosoftAuthUrl: {
    path: "/email.EmailService/GetMicrosoftAuthUrl",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuthUrlRequest): Buffer => Buffer.from(GetAuthUrlRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuthUrlRequest => GetAuthUrlRequest.decode(value),
    responseSerialize: (value: AuthUrlResponse): Buffer => Buffer.from(AuthUrlResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthUrlResponse => AuthUrlResponse.decode(value),
  },
  exchangeMicrosoftCode: {
    path: "/email.EmailService/ExchangeMicrosoftCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExchangeCodeRequest): Buffer => Buffer.from(ExchangeCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExchangeCodeRequest => ExchangeCodeRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  refreshMicrosoftToken: {
    path: "/email.EmailService/RefreshMicrosoftToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: TokenResponse): Buffer => Buffer.from(TokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TokenResponse => TokenResponse.decode(value),
  },
  revokeMicrosoftToken: {
    path: "/email.EmailService/RevokeMicrosoftToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokeTokenRequest): Buffer => Buffer.from(RevokeTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RevokeTokenRequest => RevokeTokenRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  /** ===== Email Operations ===== */
  sendEmail: {
    path: "/email.EmailService/SendEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendEmailRequest): Buffer => Buffer.from(SendEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendEmailRequest => SendEmailRequest.decode(value),
    responseSerialize: (value: SendEmailResponse): Buffer => Buffer.from(SendEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SendEmailResponse => SendEmailResponse.decode(value),
  },
  sendEmailWithTemplate: {
    path: "/email.EmailService/SendEmailWithTemplate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendEmailWithTemplateRequest): Buffer =>
      Buffer.from(SendEmailWithTemplateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendEmailWithTemplateRequest => SendEmailWithTemplateRequest.decode(value),
    responseSerialize: (value: SendEmailResponse): Buffer => Buffer.from(SendEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SendEmailResponse => SendEmailResponse.decode(value),
  },
  getEmails: {
    path: "/email.EmailService/GetEmails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmailsRequest): Buffer => Buffer.from(GetEmailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmailsRequest => GetEmailsRequest.decode(value),
    responseSerialize: (value: EmailListResponse): Buffer => Buffer.from(EmailListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmailListResponse => EmailListResponse.decode(value),
  },
  getEmail: {
    path: "/email.EmailService/GetEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmailRequest): Buffer => Buffer.from(GetEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmailRequest => GetEmailRequest.decode(value),
    responseSerialize: (value: EmailResponse): Buffer => Buffer.from(EmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmailResponse => EmailResponse.decode(value),
  },
  /** ===== User Info ===== */
  getGoogleUserInfo: {
    path: "/email.EmailService/GetGoogleUserInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserInfoRequest): Buffer => Buffer.from(GetUserInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUserInfoRequest => GetUserInfoRequest.decode(value),
    responseSerialize: (value: UserInfoResponse): Buffer => Buffer.from(UserInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UserInfoResponse => UserInfoResponse.decode(value),
  },
  getMicrosoftUserInfo: {
    path: "/email.EmailService/GetMicrosoftUserInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserInfoRequest): Buffer => Buffer.from(GetUserInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUserInfoRequest => GetUserInfoRequest.decode(value),
    responseSerialize: (value: UserInfoResponse): Buffer => Buffer.from(UserInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UserInfoResponse => UserInfoResponse.decode(value),
  },
  /** ===== Connection Test ===== */
  testMailboxConnection: {
    path: "/email.EmailService/TestMailboxConnection",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TestConnectionRequest): Buffer =>
      Buffer.from(TestConnectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TestConnectionRequest => TestConnectionRequest.decode(value),
    responseSerialize: (value: TestConnectionResponse): Buffer =>
      Buffer.from(TestConnectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TestConnectionResponse => TestConnectionResponse.decode(value),
  },
} as const;

export interface EmailServiceServer extends UntypedServiceImplementation {
  /** ===== Mailbox Management ===== */
  createMailbox: handleUnaryCall<CreateMailboxRequest, MailboxResponse>;
  getMailbox: handleUnaryCall<GetMailboxRequest, MailboxResponse>;
  getMailboxesByOrganisation: handleUnaryCall<GetMailboxesByOrganisationRequest, MailboxListResponse>;
  getMailboxesBySociete: handleUnaryCall<GetMailboxesBySocieteRequest, MailboxListResponse>;
  updateMailbox: handleUnaryCall<UpdateMailboxRequest, MailboxResponse>;
  deleteMailbox: handleUnaryCall<DeleteMailboxRequest, DeleteResponse>;
  /** ===== OAuth2 Authentication ===== */
  getGoogleAuthUrl: handleUnaryCall<GetAuthUrlRequest, AuthUrlResponse>;
  exchangeGoogleCode: handleUnaryCall<ExchangeCodeRequest, TokenResponse>;
  refreshGoogleToken: handleUnaryCall<RefreshTokenRequest, TokenResponse>;
  revokeGoogleToken: handleUnaryCall<RevokeTokenRequest, OperationResponse>;
  getMicrosoftAuthUrl: handleUnaryCall<GetAuthUrlRequest, AuthUrlResponse>;
  exchangeMicrosoftCode: handleUnaryCall<ExchangeCodeRequest, TokenResponse>;
  refreshMicrosoftToken: handleUnaryCall<RefreshTokenRequest, TokenResponse>;
  revokeMicrosoftToken: handleUnaryCall<RevokeTokenRequest, OperationResponse>;
  /** ===== Email Operations ===== */
  sendEmail: handleUnaryCall<SendEmailRequest, SendEmailResponse>;
  sendEmailWithTemplate: handleUnaryCall<SendEmailWithTemplateRequest, SendEmailResponse>;
  getEmails: handleUnaryCall<GetEmailsRequest, EmailListResponse>;
  getEmail: handleUnaryCall<GetEmailRequest, EmailResponse>;
  /** ===== User Info ===== */
  getGoogleUserInfo: handleUnaryCall<GetUserInfoRequest, UserInfoResponse>;
  getMicrosoftUserInfo: handleUnaryCall<GetUserInfoRequest, UserInfoResponse>;
  /** ===== Connection Test ===== */
  testMailboxConnection: handleUnaryCall<TestConnectionRequest, TestConnectionResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
