// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: factures/factures.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface Empty {
}

export interface PaginationRequest {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResponse {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface StatutFacture {
  id: string;
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateStatutFactureRequest {
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
}

export interface UpdateStatutFactureRequest {
  id: string;
  code?: string | undefined;
  nom?: string | undefined;
  description?: string | undefined;
  ordreAffichage?: number | undefined;
}

export interface GetStatutFactureRequest {
  id: string;
}

export interface GetStatutFactureByCodeRequest {
  code: string;
}

export interface ListStatutsFactureRequest {
  pagination?: PaginationRequest | undefined;
}

export interface ListStatutsFactureResponse {
  statuts: StatutFacture[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteStatutFactureRequest {
  id: string;
}

export interface DeleteStatutFactureResponse {
  success: boolean;
}

export interface EmissionFacture {
  id: string;
  code: string;
  nom: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateEmissionFactureRequest {
  code: string;
  nom: string;
  description: string;
}

export interface UpdateEmissionFactureRequest {
  id: string;
  code?: string | undefined;
  nom?: string | undefined;
  description?: string | undefined;
}

export interface GetEmissionFactureRequest {
  id: string;
}

export interface ListEmissionsFactureRequest {
  pagination?: PaginationRequest | undefined;
}

export interface ListEmissionsFactureResponse {
  emissions: EmissionFacture[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteEmissionFactureRequest {
  id: string;
}

export interface DeleteEmissionFactureResponse {
  success: boolean;
}

export interface LigneFacture {
  id: string;
  factureId: string;
  produitId: string;
  quantite: number;
  prixUnitaire: number;
  description: string;
  montantHt: number;
  tauxTva: number;
  montantTva: number;
  montantTtc: number;
  ordreAffichage: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateLigneFactureRequest {
  factureId: string;
  produitId: string;
  quantite: number;
  prixUnitaire: number;
  description: string;
  tauxTva: number;
  ordreAffichage: number;
}

export interface UpdateLigneFactureRequest {
  id: string;
  produitId?: string | undefined;
  quantite?: number | undefined;
  prixUnitaire?: number | undefined;
  description?: string | undefined;
  tauxTva?: number | undefined;
  ordreAffichage?: number | undefined;
}

export interface GetLigneFactureRequest {
  id: string;
}

export interface ListLignesFactureRequest {
  factureId: string;
  pagination?: PaginationRequest | undefined;
}

export interface ListLignesFactureResponse {
  lignes: LigneFacture[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteLigneFactureRequest {
  id: string;
}

export interface DeleteLigneFactureResponse {
  success: boolean;
}

export interface ClientInfo {
  id: string;
  nom: string;
  prenom: string;
}

export interface Facture {
  id: string;
  organisationId: string;
  numero: string;
  dateEmission: string;
  montantHt: number;
  montantTtc: number;
  statutId: string;
  emissionFactureId: string;
  clientBaseId: string;
  contratId: string;
  clientPartenaireId: string;
  adresseFacturationId: string;
  createdAt: string;
  updatedAt: string;
  /** Relations */
  statut?: StatutFacture | undefined;
  client?: ClientInfo | undefined;
  lignes: LigneFacture[];
}

export interface CreateFactureRequest {
  organisationId: string;
  dateEmission: string;
  statutId: string;
  emissionFactureId: string;
  clientBaseId: string;
  contratId: string;
  clientPartenaireId: string;
  adresseFacturationId: string;
  lignes: CreateLigneFactureItem[];
}

export interface CreateLigneFactureItem {
  produitId: string;
  quantite: number;
  prixUnitaire: number;
  description: string;
  tauxTva: number;
}

export interface UpdateFactureRequest {
  id: string;
  dateEmission?: string | undefined;
  statutId?: string | undefined;
  emissionFactureId?: string | undefined;
  adresseFacturationId?: string | undefined;
}

export interface GetFactureRequest {
  id: string;
}

export interface GetFactureByNumeroRequest {
  organisationId: string;
  numero: string;
}

export interface ListFacturesRequest {
  organisationId: string;
  clientBaseId?: string | undefined;
  contratId?: string | undefined;
  statutId?: string | undefined;
  dateFrom?: string | undefined;
  dateTo?: string | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListFacturesResponse {
  factures: Facture[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteFactureRequest {
  id: string;
}

export interface DeleteFactureResponse {
  success: boolean;
}

/** Validation/Finalization */
export interface ValidateFactureRequest {
  id: string;
}

export interface ValidateFactureResponse {
  valid: boolean;
  errors: string[];
  facture?: Facture | undefined;
}

export interface FinalizeFactureRequest {
  id: string;
}

export interface FactureSettings {
  id: string;
  societeId: string;
  logoBase64: string;
  logoMimeType: string;
  primaryColor: string;
  secondaryColor: string;
  companyName: string;
  companyAddress: string;
  companyPhone: string;
  companyEmail: string;
  companySiret: string;
  companyTvaNumber: string;
  companyRcs: string;
  companyCapital: string;
  iban: string;
  bic: string;
  bankName: string;
  headerText: string;
  footerText: string;
  legalMentions: string;
  paymentTerms: string;
  invoicePrefix: string;
  showLogo: boolean;
  logoPosition: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateFactureSettingsRequest {
  societeId: string;
  primaryColor: string;
  secondaryColor: string;
  companyName: string;
  companyAddress: string;
  companyPhone: string;
  companyEmail: string;
  companySiret: string;
  companyTvaNumber: string;
  companyRcs: string;
  companyCapital: string;
  iban: string;
  bic: string;
  bankName: string;
  headerText: string;
  footerText: string;
  legalMentions: string;
  paymentTerms: string;
  invoicePrefix: string;
  showLogo: boolean;
  logoPosition: string;
}

export interface UpdateFactureSettingsRequest {
  id: string;
  primaryColor?: string | undefined;
  secondaryColor?: string | undefined;
  companyName?: string | undefined;
  companyAddress?: string | undefined;
  companyPhone?: string | undefined;
  companyEmail?: string | undefined;
  companySiret?: string | undefined;
  companyTvaNumber?: string | undefined;
  companyRcs?: string | undefined;
  companyCapital?: string | undefined;
  iban?: string | undefined;
  bic?: string | undefined;
  bankName?: string | undefined;
  headerText?: string | undefined;
  footerText?: string | undefined;
  legalMentions?: string | undefined;
  paymentTerms?: string | undefined;
  invoicePrefix?: string | undefined;
  showLogo?: boolean | undefined;
  logoPosition?: string | undefined;
}

export interface UploadLogoRequest {
  settingsId: string;
  logoBase64: string;
  logoMimeType: string;
}

export interface GetFactureSettingsRequest {
  id: string;
}

export interface GetFactureSettingsBySocieteRequest {
  societeId: string;
}

export interface DeleteFactureSettingsRequest {
  id: string;
}

export interface DeleteFactureSettingsResponse {
  success: boolean;
}

export interface GenerateNextNumeroRequest {
  organisationId: string;
  societeId: string;
}

export interface GenerateNextNumeroResponse {
  numero: string;
}

export interface CalculateTotalsRequest {
  lignes: CalculateTotalsLine[];
}

export interface CalculateTotalsLine {
  quantite: number;
  prixUnitaire: number;
  tauxTva: number;
}

export interface CalculateTotalsResponse {
  montantHt: number;
  montantTva: number;
  montantTtc: number;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatutFacture(): StatutFacture {
  return { id: "", code: "", nom: "", description: "", ordreAffichage: 0, createdAt: "", updatedAt: "" };
}

export const StatutFacture: MessageFns<StatutFacture> = {
  encode(message: StatutFacture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(40).int32(message.ordreAffichage);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatutFacture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatutFacture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStatutFactureRequest(): CreateStatutFactureRequest {
  return { code: "", nom: "", description: "", ordreAffichage: 0 };
}

export const CreateStatutFactureRequest: MessageFns<CreateStatutFactureRequest> = {
  encode(message: CreateStatutFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(32).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStatutFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStatutFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateStatutFactureRequest(): UpdateStatutFactureRequest {
  return { id: "" };
}

export const UpdateStatutFactureRequest: MessageFns<UpdateStatutFactureRequest> = {
  encode(message: UpdateStatutFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== undefined) {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== undefined) {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.ordreAffichage !== undefined) {
      writer.uint32(40).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStatutFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStatutFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutFactureRequest(): GetStatutFactureRequest {
  return { id: "" };
}

export const GetStatutFactureRequest: MessageFns<GetStatutFactureRequest> = {
  encode(message: GetStatutFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutFactureByCodeRequest(): GetStatutFactureByCodeRequest {
  return { code: "" };
}

export const GetStatutFactureByCodeRequest: MessageFns<GetStatutFactureByCodeRequest> = {
  encode(message: GetStatutFactureByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutFactureByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutFactureByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListStatutsFactureRequest(): ListStatutsFactureRequest {
  return {};
}

export const ListStatutsFactureRequest: MessageFns<ListStatutsFactureRequest> = {
  encode(message: ListStatutsFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStatutsFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStatutsFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListStatutsFactureResponse(): ListStatutsFactureResponse {
  return { statuts: [] };
}

export const ListStatutsFactureResponse: MessageFns<ListStatutsFactureResponse> = {
  encode(message: ListStatutsFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.statuts) {
      StatutFacture.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStatutsFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStatutsFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statuts.push(StatutFacture.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteStatutFactureRequest(): DeleteStatutFactureRequest {
  return { id: "" };
}

export const DeleteStatutFactureRequest: MessageFns<DeleteStatutFactureRequest> = {
  encode(message: DeleteStatutFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStatutFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStatutFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteStatutFactureResponse(): DeleteStatutFactureResponse {
  return { success: false };
}

export const DeleteStatutFactureResponse: MessageFns<DeleteStatutFactureResponse> = {
  encode(message: DeleteStatutFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStatutFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStatutFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmissionFacture(): EmissionFacture {
  return { id: "", code: "", nom: "", description: "", createdAt: "", updatedAt: "" };
}

export const EmissionFacture: MessageFns<EmissionFacture> = {
  encode(message: EmissionFacture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmissionFacture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmissionFacture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateEmissionFactureRequest(): CreateEmissionFactureRequest {
  return { code: "", nom: "", description: "" };
}

export const CreateEmissionFactureRequest: MessageFns<CreateEmissionFactureRequest> = {
  encode(message: CreateEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateEmissionFactureRequest(): UpdateEmissionFactureRequest {
  return { id: "" };
}

export const UpdateEmissionFactureRequest: MessageFns<UpdateEmissionFactureRequest> = {
  encode(message: UpdateEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== undefined) {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== undefined) {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetEmissionFactureRequest(): GetEmissionFactureRequest {
  return { id: "" };
}

export const GetEmissionFactureRequest: MessageFns<GetEmissionFactureRequest> = {
  encode(message: GetEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListEmissionsFactureRequest(): ListEmissionsFactureRequest {
  return {};
}

export const ListEmissionsFactureRequest: MessageFns<ListEmissionsFactureRequest> = {
  encode(message: ListEmissionsFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEmissionsFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEmissionsFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListEmissionsFactureResponse(): ListEmissionsFactureResponse {
  return { emissions: [] };
}

export const ListEmissionsFactureResponse: MessageFns<ListEmissionsFactureResponse> = {
  encode(message: ListEmissionsFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.emissions) {
      EmissionFacture.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEmissionsFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEmissionsFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emissions.push(EmissionFacture.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteEmissionFactureRequest(): DeleteEmissionFactureRequest {
  return { id: "" };
}

export const DeleteEmissionFactureRequest: MessageFns<DeleteEmissionFactureRequest> = {
  encode(message: DeleteEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteEmissionFactureResponse(): DeleteEmissionFactureResponse {
  return { success: false };
}

export const DeleteEmissionFactureResponse: MessageFns<DeleteEmissionFactureResponse> = {
  encode(message: DeleteEmissionFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEmissionFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEmissionFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLigneFacture(): LigneFacture {
  return {
    id: "",
    factureId: "",
    produitId: "",
    quantite: 0,
    prixUnitaire: 0,
    description: "",
    montantHt: 0,
    tauxTva: 0,
    montantTva: 0,
    montantTtc: 0,
    ordreAffichage: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const LigneFacture: MessageFns<LigneFacture> = {
  encode(message: LigneFacture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.factureId !== "") {
      writer.uint32(18).string(message.factureId);
    }
    if (message.produitId !== "") {
      writer.uint32(26).string(message.produitId);
    }
    if (message.quantite !== 0) {
      writer.uint32(32).int32(message.quantite);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(41).double(message.prixUnitaire);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.montantHt !== 0) {
      writer.uint32(57).double(message.montantHt);
    }
    if (message.tauxTva !== 0) {
      writer.uint32(65).double(message.tauxTva);
    }
    if (message.montantTva !== 0) {
      writer.uint32(73).double(message.montantTva);
    }
    if (message.montantTtc !== 0) {
      writer.uint32(81).double(message.montantTtc);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(88).int32(message.ordreAffichage);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LigneFacture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLigneFacture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.montantHt = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.montantTva = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.montantTtc = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateLigneFactureRequest(): CreateLigneFactureRequest {
  return { factureId: "", produitId: "", quantite: 0, prixUnitaire: 0, description: "", tauxTva: 0, ordreAffichage: 0 };
}

export const CreateLigneFactureRequest: MessageFns<CreateLigneFactureRequest> = {
  encode(message: CreateLigneFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.factureId !== "") {
      writer.uint32(10).string(message.factureId);
    }
    if (message.produitId !== "") {
      writer.uint32(18).string(message.produitId);
    }
    if (message.quantite !== 0) {
      writer.uint32(24).int32(message.quantite);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(33).double(message.prixUnitaire);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.tauxTva !== 0) {
      writer.uint32(49).double(message.tauxTva);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(56).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLigneFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLigneFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateLigneFactureRequest(): UpdateLigneFactureRequest {
  return { id: "" };
}

export const UpdateLigneFactureRequest: MessageFns<UpdateLigneFactureRequest> = {
  encode(message: UpdateLigneFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.produitId !== undefined) {
      writer.uint32(18).string(message.produitId);
    }
    if (message.quantite !== undefined) {
      writer.uint32(24).int32(message.quantite);
    }
    if (message.prixUnitaire !== undefined) {
      writer.uint32(33).double(message.prixUnitaire);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.tauxTva !== undefined) {
      writer.uint32(49).double(message.tauxTva);
    }
    if (message.ordreAffichage !== undefined) {
      writer.uint32(56).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLigneFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLigneFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetLigneFactureRequest(): GetLigneFactureRequest {
  return { id: "" };
}

export const GetLigneFactureRequest: MessageFns<GetLigneFactureRequest> = {
  encode(message: GetLigneFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLigneFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLigneFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListLignesFactureRequest(): ListLignesFactureRequest {
  return { factureId: "" };
}

export const ListLignesFactureRequest: MessageFns<ListLignesFactureRequest> = {
  encode(message: ListLignesFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.factureId !== "") {
      writer.uint32(10).string(message.factureId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLignesFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLignesFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListLignesFactureResponse(): ListLignesFactureResponse {
  return { lignes: [] };
}

export const ListLignesFactureResponse: MessageFns<ListLignesFactureResponse> = {
  encode(message: ListLignesFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lignes) {
      LigneFacture.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLignesFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLignesFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lignes.push(LigneFacture.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteLigneFactureRequest(): DeleteLigneFactureRequest {
  return { id: "" };
}

export const DeleteLigneFactureRequest: MessageFns<DeleteLigneFactureRequest> = {
  encode(message: DeleteLigneFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLigneFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLigneFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteLigneFactureResponse(): DeleteLigneFactureResponse {
  return { success: false };
}

export const DeleteLigneFactureResponse: MessageFns<DeleteLigneFactureResponse> = {
  encode(message: DeleteLigneFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLigneFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLigneFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseClientInfo(): ClientInfo {
  return { id: "", nom: "", prenom: "" };
}

export const ClientInfo: MessageFns<ClientInfo> = {
  encode(message: ClientInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.prenom !== "") {
      writer.uint32(26).string(message.prenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFacture(): Facture {
  return {
    id: "",
    organisationId: "",
    numero: "",
    dateEmission: "",
    montantHt: 0,
    montantTtc: 0,
    statutId: "",
    emissionFactureId: "",
    clientBaseId: "",
    contratId: "",
    clientPartenaireId: "",
    adresseFacturationId: "",
    createdAt: "",
    updatedAt: "",
    lignes: [],
  };
}

export const Facture: MessageFns<Facture> = {
  encode(message: Facture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.numero !== "") {
      writer.uint32(26).string(message.numero);
    }
    if (message.dateEmission !== "") {
      writer.uint32(34).string(message.dateEmission);
    }
    if (message.montantHt !== 0) {
      writer.uint32(41).double(message.montantHt);
    }
    if (message.montantTtc !== 0) {
      writer.uint32(49).double(message.montantTtc);
    }
    if (message.statutId !== "") {
      writer.uint32(58).string(message.statutId);
    }
    if (message.emissionFactureId !== "") {
      writer.uint32(66).string(message.emissionFactureId);
    }
    if (message.clientBaseId !== "") {
      writer.uint32(74).string(message.clientBaseId);
    }
    if (message.contratId !== "") {
      writer.uint32(82).string(message.contratId);
    }
    if (message.clientPartenaireId !== "") {
      writer.uint32(90).string(message.clientPartenaireId);
    }
    if (message.adresseFacturationId !== "") {
      writer.uint32(98).string(message.adresseFacturationId);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    if (message.statut !== undefined) {
      StatutFacture.encode(message.statut, writer.uint32(122).fork()).join();
    }
    if (message.client !== undefined) {
      ClientInfo.encode(message.client, writer.uint32(130).fork()).join();
    }
    for (const v of message.lignes) {
      LigneFacture.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Facture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.numero = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateEmission = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.montantHt = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.montantTtc = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.emissionFactureId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.clientPartenaireId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.adresseFacturationId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.statut = StatutFacture.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.client = ClientInfo.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.lignes.push(LigneFacture.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateFactureRequest(): CreateFactureRequest {
  return {
    organisationId: "",
    dateEmission: "",
    statutId: "",
    emissionFactureId: "",
    clientBaseId: "",
    contratId: "",
    clientPartenaireId: "",
    adresseFacturationId: "",
    lignes: [],
  };
}

export const CreateFactureRequest: MessageFns<CreateFactureRequest> = {
  encode(message: CreateFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.dateEmission !== "") {
      writer.uint32(18).string(message.dateEmission);
    }
    if (message.statutId !== "") {
      writer.uint32(26).string(message.statutId);
    }
    if (message.emissionFactureId !== "") {
      writer.uint32(34).string(message.emissionFactureId);
    }
    if (message.clientBaseId !== "") {
      writer.uint32(42).string(message.clientBaseId);
    }
    if (message.contratId !== "") {
      writer.uint32(50).string(message.contratId);
    }
    if (message.clientPartenaireId !== "") {
      writer.uint32(58).string(message.clientPartenaireId);
    }
    if (message.adresseFacturationId !== "") {
      writer.uint32(66).string(message.adresseFacturationId);
    }
    for (const v of message.lignes) {
      CreateLigneFactureItem.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dateEmission = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.emissionFactureId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clientPartenaireId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.adresseFacturationId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lignes.push(CreateLigneFactureItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateLigneFactureItem(): CreateLigneFactureItem {
  return { produitId: "", quantite: 0, prixUnitaire: 0, description: "", tauxTva: 0 };
}

export const CreateLigneFactureItem: MessageFns<CreateLigneFactureItem> = {
  encode(message: CreateLigneFactureItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    if (message.quantite !== 0) {
      writer.uint32(16).int32(message.quantite);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(25).double(message.prixUnitaire);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.tauxTva !== 0) {
      writer.uint32(41).double(message.tauxTva);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLigneFactureItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLigneFactureItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateFactureRequest(): UpdateFactureRequest {
  return { id: "" };
}

export const UpdateFactureRequest: MessageFns<UpdateFactureRequest> = {
  encode(message: UpdateFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.dateEmission !== undefined) {
      writer.uint32(18).string(message.dateEmission);
    }
    if (message.statutId !== undefined) {
      writer.uint32(26).string(message.statutId);
    }
    if (message.emissionFactureId !== undefined) {
      writer.uint32(34).string(message.emissionFactureId);
    }
    if (message.adresseFacturationId !== undefined) {
      writer.uint32(42).string(message.adresseFacturationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dateEmission = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.emissionFactureId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.adresseFacturationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetFactureRequest(): GetFactureRequest {
  return { id: "" };
}

export const GetFactureRequest: MessageFns<GetFactureRequest> = {
  encode(message: GetFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetFactureByNumeroRequest(): GetFactureByNumeroRequest {
  return { organisationId: "", numero: "" };
}

export const GetFactureByNumeroRequest: MessageFns<GetFactureByNumeroRequest> = {
  encode(message: GetFactureByNumeroRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.numero !== "") {
      writer.uint32(18).string(message.numero);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFactureByNumeroRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFactureByNumeroRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.numero = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListFacturesRequest(): ListFacturesRequest {
  return { organisationId: "" };
}

export const ListFacturesRequest: MessageFns<ListFacturesRequest> = {
  encode(message: ListFacturesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientBaseId !== undefined) {
      writer.uint32(18).string(message.clientBaseId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(26).string(message.contratId);
    }
    if (message.statutId !== undefined) {
      writer.uint32(34).string(message.statutId);
    }
    if (message.dateFrom !== undefined) {
      writer.uint32(42).string(message.dateFrom);
    }
    if (message.dateTo !== undefined) {
      writer.uint32(50).string(message.dateTo);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFacturesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFacturesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statutId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateFrom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dateTo = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListFacturesResponse(): ListFacturesResponse {
  return { factures: [] };
}

export const ListFacturesResponse: MessageFns<ListFacturesResponse> = {
  encode(message: ListFacturesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.factures) {
      Facture.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFacturesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFacturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factures.push(Facture.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteFactureRequest(): DeleteFactureRequest {
  return { id: "" };
}

export const DeleteFactureRequest: MessageFns<DeleteFactureRequest> = {
  encode(message: DeleteFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteFactureResponse(): DeleteFactureResponse {
  return { success: false };
}

export const DeleteFactureResponse: MessageFns<DeleteFactureResponse> = {
  encode(message: DeleteFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidateFactureRequest(): ValidateFactureRequest {
  return { id: "" };
}

export const ValidateFactureRequest: MessageFns<ValidateFactureRequest> = {
  encode(message: ValidateFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidateFactureResponse(): ValidateFactureResponse {
  return { valid: false, errors: [] };
}

export const ValidateFactureResponse: MessageFns<ValidateFactureResponse> = {
  encode(message: ValidateFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    for (const v of message.errors) {
      writer.uint32(18).string(v!);
    }
    if (message.facture !== undefined) {
      Facture.encode(message.facture, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.facture = Facture.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFinalizeFactureRequest(): FinalizeFactureRequest {
  return { id: "" };
}

export const FinalizeFactureRequest: MessageFns<FinalizeFactureRequest> = {
  encode(message: FinalizeFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFactureSettings(): FactureSettings {
  return {
    id: "",
    societeId: "",
    logoBase64: "",
    logoMimeType: "",
    primaryColor: "",
    secondaryColor: "",
    companyName: "",
    companyAddress: "",
    companyPhone: "",
    companyEmail: "",
    companySiret: "",
    companyTvaNumber: "",
    companyRcs: "",
    companyCapital: "",
    iban: "",
    bic: "",
    bankName: "",
    headerText: "",
    footerText: "",
    legalMentions: "",
    paymentTerms: "",
    invoicePrefix: "",
    showLogo: false,
    logoPosition: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const FactureSettings: MessageFns<FactureSettings> = {
  encode(message: FactureSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.logoBase64 !== "") {
      writer.uint32(26).string(message.logoBase64);
    }
    if (message.logoMimeType !== "") {
      writer.uint32(34).string(message.logoMimeType);
    }
    if (message.primaryColor !== "") {
      writer.uint32(42).string(message.primaryColor);
    }
    if (message.secondaryColor !== "") {
      writer.uint32(50).string(message.secondaryColor);
    }
    if (message.companyName !== "") {
      writer.uint32(58).string(message.companyName);
    }
    if (message.companyAddress !== "") {
      writer.uint32(66).string(message.companyAddress);
    }
    if (message.companyPhone !== "") {
      writer.uint32(74).string(message.companyPhone);
    }
    if (message.companyEmail !== "") {
      writer.uint32(82).string(message.companyEmail);
    }
    if (message.companySiret !== "") {
      writer.uint32(90).string(message.companySiret);
    }
    if (message.companyTvaNumber !== "") {
      writer.uint32(98).string(message.companyTvaNumber);
    }
    if (message.companyRcs !== "") {
      writer.uint32(106).string(message.companyRcs);
    }
    if (message.companyCapital !== "") {
      writer.uint32(114).string(message.companyCapital);
    }
    if (message.iban !== "") {
      writer.uint32(122).string(message.iban);
    }
    if (message.bic !== "") {
      writer.uint32(130).string(message.bic);
    }
    if (message.bankName !== "") {
      writer.uint32(138).string(message.bankName);
    }
    if (message.headerText !== "") {
      writer.uint32(146).string(message.headerText);
    }
    if (message.footerText !== "") {
      writer.uint32(154).string(message.footerText);
    }
    if (message.legalMentions !== "") {
      writer.uint32(162).string(message.legalMentions);
    }
    if (message.paymentTerms !== "") {
      writer.uint32(170).string(message.paymentTerms);
    }
    if (message.invoicePrefix !== "") {
      writer.uint32(178).string(message.invoicePrefix);
    }
    if (message.showLogo !== false) {
      writer.uint32(184).bool(message.showLogo);
    }
    if (message.logoPosition !== "") {
      writer.uint32(194).string(message.logoPosition);
    }
    if (message.createdAt !== "") {
      writer.uint32(202).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(210).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactureSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactureSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logoBase64 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.logoMimeType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.primaryColor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.secondaryColor = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.companyName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.companyAddress = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.companyPhone = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.companyEmail = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.companySiret = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.companyTvaNumber = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.companyRcs = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.companyCapital = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.iban = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.headerText = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.footerText = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.legalMentions = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.paymentTerms = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.invoicePrefix = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.showLogo = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.logoPosition = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateFactureSettingsRequest(): CreateFactureSettingsRequest {
  return {
    societeId: "",
    primaryColor: "",
    secondaryColor: "",
    companyName: "",
    companyAddress: "",
    companyPhone: "",
    companyEmail: "",
    companySiret: "",
    companyTvaNumber: "",
    companyRcs: "",
    companyCapital: "",
    iban: "",
    bic: "",
    bankName: "",
    headerText: "",
    footerText: "",
    legalMentions: "",
    paymentTerms: "",
    invoicePrefix: "",
    showLogo: false,
    logoPosition: "",
  };
}

export const CreateFactureSettingsRequest: MessageFns<CreateFactureSettingsRequest> = {
  encode(message: CreateFactureSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.primaryColor !== "") {
      writer.uint32(18).string(message.primaryColor);
    }
    if (message.secondaryColor !== "") {
      writer.uint32(26).string(message.secondaryColor);
    }
    if (message.companyName !== "") {
      writer.uint32(34).string(message.companyName);
    }
    if (message.companyAddress !== "") {
      writer.uint32(42).string(message.companyAddress);
    }
    if (message.companyPhone !== "") {
      writer.uint32(50).string(message.companyPhone);
    }
    if (message.companyEmail !== "") {
      writer.uint32(58).string(message.companyEmail);
    }
    if (message.companySiret !== "") {
      writer.uint32(66).string(message.companySiret);
    }
    if (message.companyTvaNumber !== "") {
      writer.uint32(74).string(message.companyTvaNumber);
    }
    if (message.companyRcs !== "") {
      writer.uint32(82).string(message.companyRcs);
    }
    if (message.companyCapital !== "") {
      writer.uint32(90).string(message.companyCapital);
    }
    if (message.iban !== "") {
      writer.uint32(98).string(message.iban);
    }
    if (message.bic !== "") {
      writer.uint32(106).string(message.bic);
    }
    if (message.bankName !== "") {
      writer.uint32(114).string(message.bankName);
    }
    if (message.headerText !== "") {
      writer.uint32(122).string(message.headerText);
    }
    if (message.footerText !== "") {
      writer.uint32(130).string(message.footerText);
    }
    if (message.legalMentions !== "") {
      writer.uint32(138).string(message.legalMentions);
    }
    if (message.paymentTerms !== "") {
      writer.uint32(146).string(message.paymentTerms);
    }
    if (message.invoicePrefix !== "") {
      writer.uint32(154).string(message.invoicePrefix);
    }
    if (message.showLogo !== false) {
      writer.uint32(160).bool(message.showLogo);
    }
    if (message.logoPosition !== "") {
      writer.uint32(170).string(message.logoPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFactureSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFactureSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.primaryColor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secondaryColor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.companyName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.companyAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.companyPhone = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.companyEmail = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.companySiret = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.companyTvaNumber = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.companyRcs = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.companyCapital = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.iban = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.headerText = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.footerText = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.legalMentions = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.paymentTerms = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.invoicePrefix = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.showLogo = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.logoPosition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateFactureSettingsRequest(): UpdateFactureSettingsRequest {
  return { id: "" };
}

export const UpdateFactureSettingsRequest: MessageFns<UpdateFactureSettingsRequest> = {
  encode(message: UpdateFactureSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.primaryColor !== undefined) {
      writer.uint32(18).string(message.primaryColor);
    }
    if (message.secondaryColor !== undefined) {
      writer.uint32(26).string(message.secondaryColor);
    }
    if (message.companyName !== undefined) {
      writer.uint32(34).string(message.companyName);
    }
    if (message.companyAddress !== undefined) {
      writer.uint32(42).string(message.companyAddress);
    }
    if (message.companyPhone !== undefined) {
      writer.uint32(50).string(message.companyPhone);
    }
    if (message.companyEmail !== undefined) {
      writer.uint32(58).string(message.companyEmail);
    }
    if (message.companySiret !== undefined) {
      writer.uint32(66).string(message.companySiret);
    }
    if (message.companyTvaNumber !== undefined) {
      writer.uint32(74).string(message.companyTvaNumber);
    }
    if (message.companyRcs !== undefined) {
      writer.uint32(82).string(message.companyRcs);
    }
    if (message.companyCapital !== undefined) {
      writer.uint32(90).string(message.companyCapital);
    }
    if (message.iban !== undefined) {
      writer.uint32(98).string(message.iban);
    }
    if (message.bic !== undefined) {
      writer.uint32(106).string(message.bic);
    }
    if (message.bankName !== undefined) {
      writer.uint32(114).string(message.bankName);
    }
    if (message.headerText !== undefined) {
      writer.uint32(122).string(message.headerText);
    }
    if (message.footerText !== undefined) {
      writer.uint32(130).string(message.footerText);
    }
    if (message.legalMentions !== undefined) {
      writer.uint32(138).string(message.legalMentions);
    }
    if (message.paymentTerms !== undefined) {
      writer.uint32(146).string(message.paymentTerms);
    }
    if (message.invoicePrefix !== undefined) {
      writer.uint32(154).string(message.invoicePrefix);
    }
    if (message.showLogo !== undefined) {
      writer.uint32(160).bool(message.showLogo);
    }
    if (message.logoPosition !== undefined) {
      writer.uint32(170).string(message.logoPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFactureSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFactureSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.primaryColor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secondaryColor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.companyName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.companyAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.companyPhone = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.companyEmail = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.companySiret = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.companyTvaNumber = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.companyRcs = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.companyCapital = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.iban = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.headerText = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.footerText = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.legalMentions = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.paymentTerms = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.invoicePrefix = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.showLogo = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.logoPosition = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUploadLogoRequest(): UploadLogoRequest {
  return { settingsId: "", logoBase64: "", logoMimeType: "" };
}

export const UploadLogoRequest: MessageFns<UploadLogoRequest> = {
  encode(message: UploadLogoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settingsId !== "") {
      writer.uint32(10).string(message.settingsId);
    }
    if (message.logoBase64 !== "") {
      writer.uint32(18).string(message.logoBase64);
    }
    if (message.logoMimeType !== "") {
      writer.uint32(26).string(message.logoMimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadLogoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadLogoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settingsId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.logoBase64 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logoMimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetFactureSettingsRequest(): GetFactureSettingsRequest {
  return { id: "" };
}

export const GetFactureSettingsRequest: MessageFns<GetFactureSettingsRequest> = {
  encode(message: GetFactureSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFactureSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFactureSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetFactureSettingsBySocieteRequest(): GetFactureSettingsBySocieteRequest {
  return { societeId: "" };
}

export const GetFactureSettingsBySocieteRequest: MessageFns<GetFactureSettingsBySocieteRequest> = {
  encode(message: GetFactureSettingsBySocieteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFactureSettingsBySocieteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFactureSettingsBySocieteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteFactureSettingsRequest(): DeleteFactureSettingsRequest {
  return { id: "" };
}

export const DeleteFactureSettingsRequest: MessageFns<DeleteFactureSettingsRequest> = {
  encode(message: DeleteFactureSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFactureSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFactureSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteFactureSettingsResponse(): DeleteFactureSettingsResponse {
  return { success: false };
}

export const DeleteFactureSettingsResponse: MessageFns<DeleteFactureSettingsResponse> = {
  encode(message: DeleteFactureSettingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFactureSettingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFactureSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGenerateNextNumeroRequest(): GenerateNextNumeroRequest {
  return { organisationId: "", societeId: "" };
}

export const GenerateNextNumeroRequest: MessageFns<GenerateNextNumeroRequest> = {
  encode(message: GenerateNextNumeroRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateNextNumeroRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateNextNumeroRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGenerateNextNumeroResponse(): GenerateNextNumeroResponse {
  return { numero: "" };
}

export const GenerateNextNumeroResponse: MessageFns<GenerateNextNumeroResponse> = {
  encode(message: GenerateNextNumeroResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numero !== "") {
      writer.uint32(10).string(message.numero);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateNextNumeroResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateNextNumeroResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.numero = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculateTotalsRequest(): CalculateTotalsRequest {
  return { lignes: [] };
}

export const CalculateTotalsRequest: MessageFns<CalculateTotalsRequest> = {
  encode(message: CalculateTotalsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lignes) {
      CalculateTotalsLine.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculateTotalsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculateTotalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lignes.push(CalculateTotalsLine.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculateTotalsLine(): CalculateTotalsLine {
  return { quantite: 0, prixUnitaire: 0, tauxTva: 0 };
}

export const CalculateTotalsLine: MessageFns<CalculateTotalsLine> = {
  encode(message: CalculateTotalsLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quantite !== 0) {
      writer.uint32(8).int32(message.quantite);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(17).double(message.prixUnitaire);
    }
    if (message.tauxTva !== 0) {
      writer.uint32(25).double(message.tauxTva);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculateTotalsLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculateTotalsLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculateTotalsResponse(): CalculateTotalsResponse {
  return { montantHt: 0, montantTva: 0, montantTtc: 0 };
}

export const CalculateTotalsResponse: MessageFns<CalculateTotalsResponse> = {
  encode(message: CalculateTotalsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.montantHt !== 0) {
      writer.uint32(9).double(message.montantHt);
    }
    if (message.montantTva !== 0) {
      writer.uint32(17).double(message.montantTva);
    }
    if (message.montantTtc !== 0) {
      writer.uint32(25).double(message.montantTtc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculateTotalsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculateTotalsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.montantHt = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.montantTva = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.montantTtc = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface StatutFactureServiceClient {
  create(request: CreateStatutFactureRequest, metadata?: Metadata): Observable<StatutFacture>;

  update(request: UpdateStatutFactureRequest, metadata?: Metadata): Observable<StatutFacture>;

  get(request: GetStatutFactureRequest, metadata?: Metadata): Observable<StatutFacture>;

  getByCode(request: GetStatutFactureByCodeRequest, metadata?: Metadata): Observable<StatutFacture>;

  list(request: ListStatutsFactureRequest, metadata?: Metadata): Observable<ListStatutsFactureResponse>;

  delete(request: DeleteStatutFactureRequest, metadata?: Metadata): Observable<DeleteStatutFactureResponse>;
}

export interface StatutFactureServiceController {
  create(
    request: CreateStatutFactureRequest,
    metadata?: Metadata,
  ): Promise<StatutFacture> | Observable<StatutFacture> | StatutFacture;

  update(
    request: UpdateStatutFactureRequest,
    metadata?: Metadata,
  ): Promise<StatutFacture> | Observable<StatutFacture> | StatutFacture;

  get(
    request: GetStatutFactureRequest,
    metadata?: Metadata,
  ): Promise<StatutFacture> | Observable<StatutFacture> | StatutFacture;

  getByCode(
    request: GetStatutFactureByCodeRequest,
    metadata?: Metadata,
  ): Promise<StatutFacture> | Observable<StatutFacture> | StatutFacture;

  list(
    request: ListStatutsFactureRequest,
    metadata?: Metadata,
  ): Promise<ListStatutsFactureResponse> | Observable<ListStatutsFactureResponse> | ListStatutsFactureResponse;

  delete(
    request: DeleteStatutFactureRequest,
    metadata?: Metadata,
  ): Promise<DeleteStatutFactureResponse> | Observable<DeleteStatutFactureResponse> | DeleteStatutFactureResponse;
}

export function StatutFactureServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("StatutFactureService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("StatutFactureService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const STATUT_FACTURE_SERVICE_NAME = "StatutFactureService";

export type StatutFactureServiceService = typeof StatutFactureServiceService;
export const StatutFactureServiceService = {
  create: {
    path: "/factures.StatutFactureService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStatutFactureRequest): Buffer =>
      Buffer.from(CreateStatutFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStatutFactureRequest => CreateStatutFactureRequest.decode(value),
    responseSerialize: (value: StatutFacture): Buffer => Buffer.from(StatutFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutFacture => StatutFacture.decode(value),
  },
  update: {
    path: "/factures.StatutFactureService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateStatutFactureRequest): Buffer =>
      Buffer.from(UpdateStatutFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateStatutFactureRequest => UpdateStatutFactureRequest.decode(value),
    responseSerialize: (value: StatutFacture): Buffer => Buffer.from(StatutFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutFacture => StatutFacture.decode(value),
  },
  get: {
    path: "/factures.StatutFactureService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutFactureRequest): Buffer =>
      Buffer.from(GetStatutFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutFactureRequest => GetStatutFactureRequest.decode(value),
    responseSerialize: (value: StatutFacture): Buffer => Buffer.from(StatutFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutFacture => StatutFacture.decode(value),
  },
  getByCode: {
    path: "/factures.StatutFactureService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutFactureByCodeRequest): Buffer =>
      Buffer.from(GetStatutFactureByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutFactureByCodeRequest => GetStatutFactureByCodeRequest.decode(value),
    responseSerialize: (value: StatutFacture): Buffer => Buffer.from(StatutFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutFacture => StatutFacture.decode(value),
  },
  list: {
    path: "/factures.StatutFactureService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListStatutsFactureRequest): Buffer =>
      Buffer.from(ListStatutsFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListStatutsFactureRequest => ListStatutsFactureRequest.decode(value),
    responseSerialize: (value: ListStatutsFactureResponse): Buffer =>
      Buffer.from(ListStatutsFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListStatutsFactureResponse => ListStatutsFactureResponse.decode(value),
  },
  delete: {
    path: "/factures.StatutFactureService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteStatutFactureRequest): Buffer =>
      Buffer.from(DeleteStatutFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteStatutFactureRequest => DeleteStatutFactureRequest.decode(value),
    responseSerialize: (value: DeleteStatutFactureResponse): Buffer =>
      Buffer.from(DeleteStatutFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteStatutFactureResponse => DeleteStatutFactureResponse.decode(value),
  },
} as const;

export interface StatutFactureServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateStatutFactureRequest, StatutFacture>;
  update: handleUnaryCall<UpdateStatutFactureRequest, StatutFacture>;
  get: handleUnaryCall<GetStatutFactureRequest, StatutFacture>;
  getByCode: handleUnaryCall<GetStatutFactureByCodeRequest, StatutFacture>;
  list: handleUnaryCall<ListStatutsFactureRequest, ListStatutsFactureResponse>;
  delete: handleUnaryCall<DeleteStatutFactureRequest, DeleteStatutFactureResponse>;
}

export interface EmissionFactureServiceClient {
  create(request: CreateEmissionFactureRequest, metadata?: Metadata): Observable<EmissionFacture>;

  update(request: UpdateEmissionFactureRequest, metadata?: Metadata): Observable<EmissionFacture>;

  get(request: GetEmissionFactureRequest, metadata?: Metadata): Observable<EmissionFacture>;

  list(request: ListEmissionsFactureRequest, metadata?: Metadata): Observable<ListEmissionsFactureResponse>;

  delete(request: DeleteEmissionFactureRequest, metadata?: Metadata): Observable<DeleteEmissionFactureResponse>;
}

export interface EmissionFactureServiceController {
  create(
    request: CreateEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<EmissionFacture> | Observable<EmissionFacture> | EmissionFacture;

  update(
    request: UpdateEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<EmissionFacture> | Observable<EmissionFacture> | EmissionFacture;

  get(
    request: GetEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<EmissionFacture> | Observable<EmissionFacture> | EmissionFacture;

  list(
    request: ListEmissionsFactureRequest,
    metadata?: Metadata,
  ): Promise<ListEmissionsFactureResponse> | Observable<ListEmissionsFactureResponse> | ListEmissionsFactureResponse;

  delete(
    request: DeleteEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<DeleteEmissionFactureResponse> | Observable<DeleteEmissionFactureResponse> | DeleteEmissionFactureResponse;
}

export function EmissionFactureServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("EmissionFactureService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("EmissionFactureService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const EMISSION_FACTURE_SERVICE_NAME = "EmissionFactureService";

export type EmissionFactureServiceService = typeof EmissionFactureServiceService;
export const EmissionFactureServiceService = {
  create: {
    path: "/factures.EmissionFactureService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateEmissionFactureRequest): Buffer =>
      Buffer.from(CreateEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateEmissionFactureRequest => CreateEmissionFactureRequest.decode(value),
    responseSerialize: (value: EmissionFacture): Buffer => Buffer.from(EmissionFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmissionFacture => EmissionFacture.decode(value),
  },
  update: {
    path: "/factures.EmissionFactureService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEmissionFactureRequest): Buffer =>
      Buffer.from(UpdateEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateEmissionFactureRequest => UpdateEmissionFactureRequest.decode(value),
    responseSerialize: (value: EmissionFacture): Buffer => Buffer.from(EmissionFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmissionFacture => EmissionFacture.decode(value),
  },
  get: {
    path: "/factures.EmissionFactureService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmissionFactureRequest): Buffer =>
      Buffer.from(GetEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmissionFactureRequest => GetEmissionFactureRequest.decode(value),
    responseSerialize: (value: EmissionFacture): Buffer => Buffer.from(EmissionFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmissionFacture => EmissionFacture.decode(value),
  },
  list: {
    path: "/factures.EmissionFactureService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListEmissionsFactureRequest): Buffer =>
      Buffer.from(ListEmissionsFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListEmissionsFactureRequest => ListEmissionsFactureRequest.decode(value),
    responseSerialize: (value: ListEmissionsFactureResponse): Buffer =>
      Buffer.from(ListEmissionsFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListEmissionsFactureResponse => ListEmissionsFactureResponse.decode(value),
  },
  delete: {
    path: "/factures.EmissionFactureService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteEmissionFactureRequest): Buffer =>
      Buffer.from(DeleteEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteEmissionFactureRequest => DeleteEmissionFactureRequest.decode(value),
    responseSerialize: (value: DeleteEmissionFactureResponse): Buffer =>
      Buffer.from(DeleteEmissionFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteEmissionFactureResponse => DeleteEmissionFactureResponse.decode(value),
  },
} as const;

export interface EmissionFactureServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateEmissionFactureRequest, EmissionFacture>;
  update: handleUnaryCall<UpdateEmissionFactureRequest, EmissionFacture>;
  get: handleUnaryCall<GetEmissionFactureRequest, EmissionFacture>;
  list: handleUnaryCall<ListEmissionsFactureRequest, ListEmissionsFactureResponse>;
  delete: handleUnaryCall<DeleteEmissionFactureRequest, DeleteEmissionFactureResponse>;
}

export interface LigneFactureServiceClient {
  create(request: CreateLigneFactureRequest, metadata?: Metadata): Observable<LigneFacture>;

  update(request: UpdateLigneFactureRequest, metadata?: Metadata): Observable<LigneFacture>;

  get(request: GetLigneFactureRequest, metadata?: Metadata): Observable<LigneFacture>;

  list(request: ListLignesFactureRequest, metadata?: Metadata): Observable<ListLignesFactureResponse>;

  delete(request: DeleteLigneFactureRequest, metadata?: Metadata): Observable<DeleteLigneFactureResponse>;
}

export interface LigneFactureServiceController {
  create(
    request: CreateLigneFactureRequest,
    metadata?: Metadata,
  ): Promise<LigneFacture> | Observable<LigneFacture> | LigneFacture;

  update(
    request: UpdateLigneFactureRequest,
    metadata?: Metadata,
  ): Promise<LigneFacture> | Observable<LigneFacture> | LigneFacture;

  get(
    request: GetLigneFactureRequest,
    metadata?: Metadata,
  ): Promise<LigneFacture> | Observable<LigneFacture> | LigneFacture;

  list(
    request: ListLignesFactureRequest,
    metadata?: Metadata,
  ): Promise<ListLignesFactureResponse> | Observable<ListLignesFactureResponse> | ListLignesFactureResponse;

  delete(
    request: DeleteLigneFactureRequest,
    metadata?: Metadata,
  ): Promise<DeleteLigneFactureResponse> | Observable<DeleteLigneFactureResponse> | DeleteLigneFactureResponse;
}

export function LigneFactureServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("LigneFactureService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("LigneFactureService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const LIGNE_FACTURE_SERVICE_NAME = "LigneFactureService";

export type LigneFactureServiceService = typeof LigneFactureServiceService;
export const LigneFactureServiceService = {
  create: {
    path: "/factures.LigneFactureService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateLigneFactureRequest): Buffer =>
      Buffer.from(CreateLigneFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateLigneFactureRequest => CreateLigneFactureRequest.decode(value),
    responseSerialize: (value: LigneFacture): Buffer => Buffer.from(LigneFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneFacture => LigneFacture.decode(value),
  },
  update: {
    path: "/factures.LigneFactureService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateLigneFactureRequest): Buffer =>
      Buffer.from(UpdateLigneFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateLigneFactureRequest => UpdateLigneFactureRequest.decode(value),
    responseSerialize: (value: LigneFacture): Buffer => Buffer.from(LigneFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneFacture => LigneFacture.decode(value),
  },
  get: {
    path: "/factures.LigneFactureService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLigneFactureRequest): Buffer =>
      Buffer.from(GetLigneFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLigneFactureRequest => GetLigneFactureRequest.decode(value),
    responseSerialize: (value: LigneFacture): Buffer => Buffer.from(LigneFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): LigneFacture => LigneFacture.decode(value),
  },
  list: {
    path: "/factures.LigneFactureService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListLignesFactureRequest): Buffer =>
      Buffer.from(ListLignesFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListLignesFactureRequest => ListLignesFactureRequest.decode(value),
    responseSerialize: (value: ListLignesFactureResponse): Buffer =>
      Buffer.from(ListLignesFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListLignesFactureResponse => ListLignesFactureResponse.decode(value),
  },
  delete: {
    path: "/factures.LigneFactureService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteLigneFactureRequest): Buffer =>
      Buffer.from(DeleteLigneFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteLigneFactureRequest => DeleteLigneFactureRequest.decode(value),
    responseSerialize: (value: DeleteLigneFactureResponse): Buffer =>
      Buffer.from(DeleteLigneFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteLigneFactureResponse => DeleteLigneFactureResponse.decode(value),
  },
} as const;

export interface LigneFactureServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateLigneFactureRequest, LigneFacture>;
  update: handleUnaryCall<UpdateLigneFactureRequest, LigneFacture>;
  get: handleUnaryCall<GetLigneFactureRequest, LigneFacture>;
  list: handleUnaryCall<ListLignesFactureRequest, ListLignesFactureResponse>;
  delete: handleUnaryCall<DeleteLigneFactureRequest, DeleteLigneFactureResponse>;
}

export interface FactureServiceClient {
  create(request: CreateFactureRequest, metadata?: Metadata): Observable<Facture>;

  update(request: UpdateFactureRequest, metadata?: Metadata): Observable<Facture>;

  get(request: GetFactureRequest, metadata?: Metadata): Observable<Facture>;

  getByNumero(request: GetFactureByNumeroRequest, metadata?: Metadata): Observable<Facture>;

  list(request: ListFacturesRequest, metadata?: Metadata): Observable<ListFacturesResponse>;

  delete(request: DeleteFactureRequest, metadata?: Metadata): Observable<DeleteFactureResponse>;

  validate(request: ValidateFactureRequest, metadata?: Metadata): Observable<ValidateFactureResponse>;

  finalize(request: FinalizeFactureRequest, metadata?: Metadata): Observable<Facture>;
}

export interface FactureServiceController {
  create(request: CreateFactureRequest, metadata?: Metadata): Promise<Facture> | Observable<Facture> | Facture;

  update(request: UpdateFactureRequest, metadata?: Metadata): Promise<Facture> | Observable<Facture> | Facture;

  get(request: GetFactureRequest, metadata?: Metadata): Promise<Facture> | Observable<Facture> | Facture;

  getByNumero(
    request: GetFactureByNumeroRequest,
    metadata?: Metadata,
  ): Promise<Facture> | Observable<Facture> | Facture;

  list(
    request: ListFacturesRequest,
    metadata?: Metadata,
  ): Promise<ListFacturesResponse> | Observable<ListFacturesResponse> | ListFacturesResponse;

  delete(
    request: DeleteFactureRequest,
    metadata?: Metadata,
  ): Promise<DeleteFactureResponse> | Observable<DeleteFactureResponse> | DeleteFactureResponse;

  validate(
    request: ValidateFactureRequest,
    metadata?: Metadata,
  ): Promise<ValidateFactureResponse> | Observable<ValidateFactureResponse> | ValidateFactureResponse;

  finalize(request: FinalizeFactureRequest, metadata?: Metadata): Promise<Facture> | Observable<Facture> | Facture;
}

export function FactureServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByNumero", "list", "delete", "validate", "finalize"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("FactureService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("FactureService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const FACTURE_SERVICE_NAME = "FactureService";

export type FactureServiceService = typeof FactureServiceService;
export const FactureServiceService = {
  create: {
    path: "/factures.FactureService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateFactureRequest): Buffer => Buffer.from(CreateFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateFactureRequest => CreateFactureRequest.decode(value),
    responseSerialize: (value: Facture): Buffer => Buffer.from(Facture.encode(value).finish()),
    responseDeserialize: (value: Buffer): Facture => Facture.decode(value),
  },
  update: {
    path: "/factures.FactureService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateFactureRequest): Buffer => Buffer.from(UpdateFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateFactureRequest => UpdateFactureRequest.decode(value),
    responseSerialize: (value: Facture): Buffer => Buffer.from(Facture.encode(value).finish()),
    responseDeserialize: (value: Buffer): Facture => Facture.decode(value),
  },
  get: {
    path: "/factures.FactureService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFactureRequest): Buffer => Buffer.from(GetFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetFactureRequest => GetFactureRequest.decode(value),
    responseSerialize: (value: Facture): Buffer => Buffer.from(Facture.encode(value).finish()),
    responseDeserialize: (value: Buffer): Facture => Facture.decode(value),
  },
  getByNumero: {
    path: "/factures.FactureService/GetByNumero",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFactureByNumeroRequest): Buffer =>
      Buffer.from(GetFactureByNumeroRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetFactureByNumeroRequest => GetFactureByNumeroRequest.decode(value),
    responseSerialize: (value: Facture): Buffer => Buffer.from(Facture.encode(value).finish()),
    responseDeserialize: (value: Buffer): Facture => Facture.decode(value),
  },
  list: {
    path: "/factures.FactureService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListFacturesRequest): Buffer => Buffer.from(ListFacturesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListFacturesRequest => ListFacturesRequest.decode(value),
    responseSerialize: (value: ListFacturesResponse): Buffer =>
      Buffer.from(ListFacturesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListFacturesResponse => ListFacturesResponse.decode(value),
  },
  delete: {
    path: "/factures.FactureService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteFactureRequest): Buffer => Buffer.from(DeleteFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteFactureRequest => DeleteFactureRequest.decode(value),
    responseSerialize: (value: DeleteFactureResponse): Buffer =>
      Buffer.from(DeleteFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteFactureResponse => DeleteFactureResponse.decode(value),
  },
  validate: {
    path: "/factures.FactureService/Validate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateFactureRequest): Buffer =>
      Buffer.from(ValidateFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ValidateFactureRequest => ValidateFactureRequest.decode(value),
    responseSerialize: (value: ValidateFactureResponse): Buffer =>
      Buffer.from(ValidateFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ValidateFactureResponse => ValidateFactureResponse.decode(value),
  },
  finalize: {
    path: "/factures.FactureService/Finalize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FinalizeFactureRequest): Buffer =>
      Buffer.from(FinalizeFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): FinalizeFactureRequest => FinalizeFactureRequest.decode(value),
    responseSerialize: (value: Facture): Buffer => Buffer.from(Facture.encode(value).finish()),
    responseDeserialize: (value: Buffer): Facture => Facture.decode(value),
  },
} as const;

export interface FactureServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateFactureRequest, Facture>;
  update: handleUnaryCall<UpdateFactureRequest, Facture>;
  get: handleUnaryCall<GetFactureRequest, Facture>;
  getByNumero: handleUnaryCall<GetFactureByNumeroRequest, Facture>;
  list: handleUnaryCall<ListFacturesRequest, ListFacturesResponse>;
  delete: handleUnaryCall<DeleteFactureRequest, DeleteFactureResponse>;
  validate: handleUnaryCall<ValidateFactureRequest, ValidateFactureResponse>;
  finalize: handleUnaryCall<FinalizeFactureRequest, Facture>;
}

export interface FactureSettingsServiceClient {
  create(request: CreateFactureSettingsRequest, metadata?: Metadata): Observable<FactureSettings>;

  update(request: UpdateFactureSettingsRequest, metadata?: Metadata): Observable<FactureSettings>;

  get(request: GetFactureSettingsRequest, metadata?: Metadata): Observable<FactureSettings>;

  getBySociete(request: GetFactureSettingsBySocieteRequest, metadata?: Metadata): Observable<FactureSettings>;

  delete(request: DeleteFactureSettingsRequest, metadata?: Metadata): Observable<DeleteFactureSettingsResponse>;

  uploadLogo(request: UploadLogoRequest, metadata?: Metadata): Observable<FactureSettings>;
}

export interface FactureSettingsServiceController {
  create(
    request: CreateFactureSettingsRequest,
    metadata?: Metadata,
  ): Promise<FactureSettings> | Observable<FactureSettings> | FactureSettings;

  update(
    request: UpdateFactureSettingsRequest,
    metadata?: Metadata,
  ): Promise<FactureSettings> | Observable<FactureSettings> | FactureSettings;

  get(
    request: GetFactureSettingsRequest,
    metadata?: Metadata,
  ): Promise<FactureSettings> | Observable<FactureSettings> | FactureSettings;

  getBySociete(
    request: GetFactureSettingsBySocieteRequest,
    metadata?: Metadata,
  ): Promise<FactureSettings> | Observable<FactureSettings> | FactureSettings;

  delete(
    request: DeleteFactureSettingsRequest,
    metadata?: Metadata,
  ): Promise<DeleteFactureSettingsResponse> | Observable<DeleteFactureSettingsResponse> | DeleteFactureSettingsResponse;

  uploadLogo(
    request: UploadLogoRequest,
    metadata?: Metadata,
  ): Promise<FactureSettings> | Observable<FactureSettings> | FactureSettings;
}

export function FactureSettingsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getBySociete", "delete", "uploadLogo"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("FactureSettingsService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("FactureSettingsService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const FACTURE_SETTINGS_SERVICE_NAME = "FactureSettingsService";

export type FactureSettingsServiceService = typeof FactureSettingsServiceService;
export const FactureSettingsServiceService = {
  create: {
    path: "/factures.FactureSettingsService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateFactureSettingsRequest): Buffer =>
      Buffer.from(CreateFactureSettingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateFactureSettingsRequest => CreateFactureSettingsRequest.decode(value),
    responseSerialize: (value: FactureSettings): Buffer => Buffer.from(FactureSettings.encode(value).finish()),
    responseDeserialize: (value: Buffer): FactureSettings => FactureSettings.decode(value),
  },
  update: {
    path: "/factures.FactureSettingsService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateFactureSettingsRequest): Buffer =>
      Buffer.from(UpdateFactureSettingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateFactureSettingsRequest => UpdateFactureSettingsRequest.decode(value),
    responseSerialize: (value: FactureSettings): Buffer => Buffer.from(FactureSettings.encode(value).finish()),
    responseDeserialize: (value: Buffer): FactureSettings => FactureSettings.decode(value),
  },
  get: {
    path: "/factures.FactureSettingsService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFactureSettingsRequest): Buffer =>
      Buffer.from(GetFactureSettingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetFactureSettingsRequest => GetFactureSettingsRequest.decode(value),
    responseSerialize: (value: FactureSettings): Buffer => Buffer.from(FactureSettings.encode(value).finish()),
    responseDeserialize: (value: Buffer): FactureSettings => FactureSettings.decode(value),
  },
  getBySociete: {
    path: "/factures.FactureSettingsService/GetBySociete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFactureSettingsBySocieteRequest): Buffer =>
      Buffer.from(GetFactureSettingsBySocieteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetFactureSettingsBySocieteRequest =>
      GetFactureSettingsBySocieteRequest.decode(value),
    responseSerialize: (value: FactureSettings): Buffer => Buffer.from(FactureSettings.encode(value).finish()),
    responseDeserialize: (value: Buffer): FactureSettings => FactureSettings.decode(value),
  },
  delete: {
    path: "/factures.FactureSettingsService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteFactureSettingsRequest): Buffer =>
      Buffer.from(DeleteFactureSettingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteFactureSettingsRequest => DeleteFactureSettingsRequest.decode(value),
    responseSerialize: (value: DeleteFactureSettingsResponse): Buffer =>
      Buffer.from(DeleteFactureSettingsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteFactureSettingsResponse => DeleteFactureSettingsResponse.decode(value),
  },
  uploadLogo: {
    path: "/factures.FactureSettingsService/UploadLogo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UploadLogoRequest): Buffer => Buffer.from(UploadLogoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UploadLogoRequest => UploadLogoRequest.decode(value),
    responseSerialize: (value: FactureSettings): Buffer => Buffer.from(FactureSettings.encode(value).finish()),
    responseDeserialize: (value: Buffer): FactureSettings => FactureSettings.decode(value),
  },
} as const;

export interface FactureSettingsServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateFactureSettingsRequest, FactureSettings>;
  update: handleUnaryCall<UpdateFactureSettingsRequest, FactureSettings>;
  get: handleUnaryCall<GetFactureSettingsRequest, FactureSettings>;
  getBySociete: handleUnaryCall<GetFactureSettingsBySocieteRequest, FactureSettings>;
  delete: handleUnaryCall<DeleteFactureSettingsRequest, DeleteFactureSettingsResponse>;
  uploadLogo: handleUnaryCall<UploadLogoRequest, FactureSettings>;
}

export interface FactureGenerationServiceClient {
  generateNextNumero(request: GenerateNextNumeroRequest, metadata?: Metadata): Observable<GenerateNextNumeroResponse>;

  calculateTotals(request: CalculateTotalsRequest, metadata?: Metadata): Observable<CalculateTotalsResponse>;
}

export interface FactureGenerationServiceController {
  generateNextNumero(
    request: GenerateNextNumeroRequest,
    metadata?: Metadata,
  ): Promise<GenerateNextNumeroResponse> | Observable<GenerateNextNumeroResponse> | GenerateNextNumeroResponse;

  calculateTotals(
    request: CalculateTotalsRequest,
    metadata?: Metadata,
  ): Promise<CalculateTotalsResponse> | Observable<CalculateTotalsResponse> | CalculateTotalsResponse;
}

export function FactureGenerationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["generateNextNumero", "calculateTotals"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("FactureGenerationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("FactureGenerationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const FACTURE_GENERATION_SERVICE_NAME = "FactureGenerationService";

export type FactureGenerationServiceService = typeof FactureGenerationServiceService;
export const FactureGenerationServiceService = {
  generateNextNumero: {
    path: "/factures.FactureGenerationService/GenerateNextNumero",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateNextNumeroRequest): Buffer =>
      Buffer.from(GenerateNextNumeroRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GenerateNextNumeroRequest => GenerateNextNumeroRequest.decode(value),
    responseSerialize: (value: GenerateNextNumeroResponse): Buffer =>
      Buffer.from(GenerateNextNumeroResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GenerateNextNumeroResponse => GenerateNextNumeroResponse.decode(value),
  },
  calculateTotals: {
    path: "/factures.FactureGenerationService/CalculateTotals",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CalculateTotalsRequest): Buffer =>
      Buffer.from(CalculateTotalsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CalculateTotalsRequest => CalculateTotalsRequest.decode(value),
    responseSerialize: (value: CalculateTotalsResponse): Buffer =>
      Buffer.from(CalculateTotalsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalculateTotalsResponse => CalculateTotalsResponse.decode(value),
  },
} as const;

export interface FactureGenerationServiceServer extends UntypedServiceImplementation {
  generateNextNumero: handleUnaryCall<GenerateNextNumeroRequest, GenerateNextNumeroResponse>;
  calculateTotals: handleUnaryCall<CalculateTotalsRequest, CalculateTotalsResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
