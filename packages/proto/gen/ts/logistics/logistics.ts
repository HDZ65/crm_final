// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: logistics/logistics.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface Empty {
}

export interface GetByIdRequest {
  id: string;
}

export interface GetByExpeditionIdRequest {
  expeditionId: string;
}

export interface GetByOrganisationIdRequest {
  organisationId: string;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface Address {
  line1: string;
  line2?: string | undefined;
  postalCode: string;
  city: string;
  country: string;
}

export interface CreateExpeditionRequest {
  organisationId: string;
  clientBaseId: string;
  transporteurCompteId: string;
  contratId?: string | undefined;
  referenceCommande: string;
  produitId?: string | undefined;
  nomProduit?: string | undefined;
  poids?: number | undefined;
  destination?: Address | undefined;
  dateExpedition?: string | undefined;
  dateLivraisonEstimee?: string | undefined;
}

export interface ExpeditionResponse {
  id: string;
  organisationId: string;
  clientBaseId: string;
  transporteurCompteId: string;
  contratId?: string | undefined;
  trackingNumber: string;
  etat: string;
  dateCreation: string;
  dateDernierStatut: string;
  labelUrl: string;
  referenceCommande: string;
  produitId?: string | undefined;
  nomProduit?: string | undefined;
  poids?: number | undefined;
  adresseDestination?: string | undefined;
  villeDestination?: string | undefined;
  codePostalDestination?: string | undefined;
  dateExpedition?: string | undefined;
  dateLivraisonEstimee?: string | undefined;
  dateLivraison?: string | undefined;
  lieuActuel?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface UpdateExpeditionRequest {
  id: string;
  etat?: string | undefined;
  lieuActuel?: string | undefined;
  dateLivraison?: string | undefined;
}

export interface GetExpeditionsByClientRequest {
  clientBaseId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface GetExpeditionsByOrganisationRequest {
  organisationId: string;
  etat?: string | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface ExpeditionListResponse {
  expeditions: ExpeditionResponse[];
  total: number;
}

export interface CreateColisRequest {
  expeditionId: string;
  poidsGr: number;
  longCm: number;
  largCm: number;
  hautCm: number;
  valeurDeclaree: number;
  contenu: string;
}

export interface ColisResponse {
  id: string;
  expeditionId: string;
  poidsGr: number;
  longCm: number;
  largCm: number;
  hautCm: number;
  valeurDeclaree: number;
  contenu: string;
  createdAt: string;
  updatedAt: string;
}

export interface UpdateColisRequest {
  id: string;
  poidsGr?: number | undefined;
  longCm?: number | undefined;
  largCm?: number | undefined;
  hautCm?: number | undefined;
  valeurDeclaree?: number | undefined;
  contenu?: string | undefined;
}

export interface ColisListResponse {
  colis: ColisResponse[];
  total: number;
}

export interface CreateTrackingEventRequest {
  expeditionId: string;
  code: string;
  label: string;
  dateEvenement: string;
  lieu?: string | undefined;
  raw?: string | undefined;
}

export interface TrackingEventResponse {
  id: string;
  expeditionId: string;
  code: string;
  label: string;
  dateEvenement: string;
  lieu?: string | undefined;
  raw?: string | undefined;
  createdAt: string;
}

export interface TrackingEventListResponse {
  events: TrackingEventResponse[];
  total: number;
}

export interface CreateCarrierAccountRequest {
  organisationId: string;
  type: string;
  contractNumber: string;
  password: string;
  labelFormat: string;
  actif: boolean;
}

export interface CarrierAccountResponse {
  id: string;
  organisationId: string;
  type: string;
  contractNumber: string;
  labelFormat: string;
  actif: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface UpdateCarrierAccountRequest {
  id: string;
  contractNumber?: string | undefined;
  password?: string | undefined;
  labelFormat?: string | undefined;
  actif?: boolean | undefined;
}

export interface CarrierAccountListResponse {
  accounts: CarrierAccountResponse[];
  total: number;
}

export interface GenerateLabelRequest {
  organisationId: string;
  serviceLevel: string;
  format: string;
  weightGr: number;
  sender?: Address | undefined;
  recipient?: Address | undefined;
  contractId?: string | undefined;
}

export interface LabelResponse {
  trackingNumber: string;
  labelUrl: string;
  estimatedDeliveryDate?: string | undefined;
}

export interface TrackShipmentRequest {
  trackingNumber: string;
}

export interface TrackingResponse {
  trackingNumber: string;
  status: string;
  events: TrackingEvent[];
  lastUpdatedAt: string;
}

export interface TrackingEvent {
  code: string;
  label: string;
  date: string;
  location?: string | undefined;
}

export interface ValidateAddressRequest {
  address?: Address | undefined;
}

export interface AddressValidationResponse {
  isValid: boolean;
  normalizedAddress?: Address | undefined;
  suggestions: Address[];
}

export interface SimulatePricingRequest {
  serviceLevel: string;
  format: string;
  weightGr: number;
  originCountry: string;
  destinationCountry: string;
}

export interface PricingResponse {
  serviceLevel: string;
  totalPrice: number;
  currency: string;
  breakdown: PricingBreakdown[];
  estimatedDeliveryDays?: number | undefined;
}

export interface PricingBreakdown {
  label: string;
  amount: number;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "" };
}

export const GetByIdRequest: MessageFns<GetByIdRequest> = {
  encode(message: GetByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByExpeditionIdRequest(): GetByExpeditionIdRequest {
  return { expeditionId: "" };
}

export const GetByExpeditionIdRequest: MessageFns<GetByExpeditionIdRequest> = {
  encode(message: GetByExpeditionIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expeditionId !== "") {
      writer.uint32(10).string(message.expeditionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByExpeditionIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByExpeditionIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByOrganisationIdRequest(): GetByOrganisationIdRequest {
  return { organisationId: "" };
}

export const GetByOrganisationIdRequest: MessageFns<GetByOrganisationIdRequest> = {
  encode(message: GetByOrganisationIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByOrganisationIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByOrganisationIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAddress(): Address {
  return { line1: "", postalCode: "", city: "", country: "" };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line1 !== "") {
      writer.uint32(10).string(message.line1);
    }
    if (message.line2 !== undefined) {
      writer.uint32(18).string(message.line2);
    }
    if (message.postalCode !== "") {
      writer.uint32(26).string(message.postalCode);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.country !== "") {
      writer.uint32(42).string(message.country);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.line1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.line2 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.country = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateExpeditionRequest(): CreateExpeditionRequest {
  return { organisationId: "", clientBaseId: "", transporteurCompteId: "", referenceCommande: "" };
}

export const CreateExpeditionRequest: MessageFns<CreateExpeditionRequest> = {
  encode(message: CreateExpeditionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.clientBaseId !== "") {
      writer.uint32(18).string(message.clientBaseId);
    }
    if (message.transporteurCompteId !== "") {
      writer.uint32(26).string(message.transporteurCompteId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.referenceCommande !== "") {
      writer.uint32(42).string(message.referenceCommande);
    }
    if (message.produitId !== undefined) {
      writer.uint32(50).string(message.produitId);
    }
    if (message.nomProduit !== undefined) {
      writer.uint32(58).string(message.nomProduit);
    }
    if (message.poids !== undefined) {
      writer.uint32(65).double(message.poids);
    }
    if (message.destination !== undefined) {
      Address.encode(message.destination, writer.uint32(74).fork()).join();
    }
    if (message.dateExpedition !== undefined) {
      writer.uint32(82).string(message.dateExpedition);
    }
    if (message.dateLivraisonEstimee !== undefined) {
      writer.uint32(90).string(message.dateLivraisonEstimee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExpeditionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExpeditionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transporteurCompteId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.referenceCommande = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nomProduit = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.poids = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.destination = Address.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dateExpedition = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dateLivraisonEstimee = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExpeditionResponse(): ExpeditionResponse {
  return {
    id: "",
    organisationId: "",
    clientBaseId: "",
    transporteurCompteId: "",
    trackingNumber: "",
    etat: "",
    dateCreation: "",
    dateDernierStatut: "",
    labelUrl: "",
    referenceCommande: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const ExpeditionResponse: MessageFns<ExpeditionResponse> = {
  encode(message: ExpeditionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.clientBaseId !== "") {
      writer.uint32(26).string(message.clientBaseId);
    }
    if (message.transporteurCompteId !== "") {
      writer.uint32(34).string(message.transporteurCompteId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(42).string(message.contratId);
    }
    if (message.trackingNumber !== "") {
      writer.uint32(50).string(message.trackingNumber);
    }
    if (message.etat !== "") {
      writer.uint32(58).string(message.etat);
    }
    if (message.dateCreation !== "") {
      writer.uint32(66).string(message.dateCreation);
    }
    if (message.dateDernierStatut !== "") {
      writer.uint32(74).string(message.dateDernierStatut);
    }
    if (message.labelUrl !== "") {
      writer.uint32(82).string(message.labelUrl);
    }
    if (message.referenceCommande !== "") {
      writer.uint32(90).string(message.referenceCommande);
    }
    if (message.produitId !== undefined) {
      writer.uint32(98).string(message.produitId);
    }
    if (message.nomProduit !== undefined) {
      writer.uint32(106).string(message.nomProduit);
    }
    if (message.poids !== undefined) {
      writer.uint32(113).double(message.poids);
    }
    if (message.adresseDestination !== undefined) {
      writer.uint32(122).string(message.adresseDestination);
    }
    if (message.villeDestination !== undefined) {
      writer.uint32(130).string(message.villeDestination);
    }
    if (message.codePostalDestination !== undefined) {
      writer.uint32(138).string(message.codePostalDestination);
    }
    if (message.dateExpedition !== undefined) {
      writer.uint32(146).string(message.dateExpedition);
    }
    if (message.dateLivraisonEstimee !== undefined) {
      writer.uint32(154).string(message.dateLivraisonEstimee);
    }
    if (message.dateLivraison !== undefined) {
      writer.uint32(162).string(message.dateLivraison);
    }
    if (message.lieuActuel !== undefined) {
      writer.uint32(170).string(message.lieuActuel);
    }
    if (message.createdAt !== "") {
      writer.uint32(178).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(186).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpeditionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpeditionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transporteurCompteId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.etat = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateCreation = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dateDernierStatut = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.labelUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.referenceCommande = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.nomProduit = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 113) {
            break;
          }

          message.poids = reader.double();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.adresseDestination = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.villeDestination = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.codePostalDestination = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.dateExpedition = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.dateLivraisonEstimee = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.dateLivraison = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.lieuActuel = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateExpeditionRequest(): UpdateExpeditionRequest {
  return { id: "" };
}

export const UpdateExpeditionRequest: MessageFns<UpdateExpeditionRequest> = {
  encode(message: UpdateExpeditionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.etat !== undefined) {
      writer.uint32(18).string(message.etat);
    }
    if (message.lieuActuel !== undefined) {
      writer.uint32(26).string(message.lieuActuel);
    }
    if (message.dateLivraison !== undefined) {
      writer.uint32(34).string(message.dateLivraison);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateExpeditionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExpeditionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.etat = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lieuActuel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateLivraison = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetExpeditionsByClientRequest(): GetExpeditionsByClientRequest {
  return { clientBaseId: "" };
}

export const GetExpeditionsByClientRequest: MessageFns<GetExpeditionsByClientRequest> = {
  encode(message: GetExpeditionsByClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientBaseId !== "") {
      writer.uint32(10).string(message.clientBaseId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExpeditionsByClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExpeditionsByClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientBaseId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetExpeditionsByOrganisationRequest(): GetExpeditionsByOrganisationRequest {
  return { organisationId: "" };
}

export const GetExpeditionsByOrganisationRequest: MessageFns<GetExpeditionsByOrganisationRequest> = {
  encode(message: GetExpeditionsByOrganisationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.etat !== undefined) {
      writer.uint32(18).string(message.etat);
    }
    if (message.limit !== undefined) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExpeditionsByOrganisationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExpeditionsByOrganisationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.etat = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExpeditionListResponse(): ExpeditionListResponse {
  return { expeditions: [], total: 0 };
}

export const ExpeditionListResponse: MessageFns<ExpeditionListResponse> = {
  encode(message: ExpeditionListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expeditions) {
      ExpeditionResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExpeditionListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpeditionListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expeditions.push(ExpeditionResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateColisRequest(): CreateColisRequest {
  return { expeditionId: "", poidsGr: 0, longCm: 0, largCm: 0, hautCm: 0, valeurDeclaree: 0, contenu: "" };
}

export const CreateColisRequest: MessageFns<CreateColisRequest> = {
  encode(message: CreateColisRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expeditionId !== "") {
      writer.uint32(10).string(message.expeditionId);
    }
    if (message.poidsGr !== 0) {
      writer.uint32(16).int32(message.poidsGr);
    }
    if (message.longCm !== 0) {
      writer.uint32(24).int32(message.longCm);
    }
    if (message.largCm !== 0) {
      writer.uint32(32).int32(message.largCm);
    }
    if (message.hautCm !== 0) {
      writer.uint32(40).int32(message.hautCm);
    }
    if (message.valeurDeclaree !== 0) {
      writer.uint32(49).double(message.valeurDeclaree);
    }
    if (message.contenu !== "") {
      writer.uint32(58).string(message.contenu);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateColisRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateColisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.poidsGr = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.longCm = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.largCm = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hautCm = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.valeurDeclaree = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contenu = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseColisResponse(): ColisResponse {
  return {
    id: "",
    expeditionId: "",
    poidsGr: 0,
    longCm: 0,
    largCm: 0,
    hautCm: 0,
    valeurDeclaree: 0,
    contenu: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const ColisResponse: MessageFns<ColisResponse> = {
  encode(message: ColisResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.expeditionId !== "") {
      writer.uint32(18).string(message.expeditionId);
    }
    if (message.poidsGr !== 0) {
      writer.uint32(24).int32(message.poidsGr);
    }
    if (message.longCm !== 0) {
      writer.uint32(32).int32(message.longCm);
    }
    if (message.largCm !== 0) {
      writer.uint32(40).int32(message.largCm);
    }
    if (message.hautCm !== 0) {
      writer.uint32(48).int32(message.hautCm);
    }
    if (message.valeurDeclaree !== 0) {
      writer.uint32(57).double(message.valeurDeclaree);
    }
    if (message.contenu !== "") {
      writer.uint32(66).string(message.contenu);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColisResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.poidsGr = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.longCm = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.largCm = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.hautCm = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.valeurDeclaree = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.contenu = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateColisRequest(): UpdateColisRequest {
  return { id: "" };
}

export const UpdateColisRequest: MessageFns<UpdateColisRequest> = {
  encode(message: UpdateColisRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.poidsGr !== undefined) {
      writer.uint32(16).int32(message.poidsGr);
    }
    if (message.longCm !== undefined) {
      writer.uint32(24).int32(message.longCm);
    }
    if (message.largCm !== undefined) {
      writer.uint32(32).int32(message.largCm);
    }
    if (message.hautCm !== undefined) {
      writer.uint32(40).int32(message.hautCm);
    }
    if (message.valeurDeclaree !== undefined) {
      writer.uint32(49).double(message.valeurDeclaree);
    }
    if (message.contenu !== undefined) {
      writer.uint32(58).string(message.contenu);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateColisRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateColisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.poidsGr = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.longCm = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.largCm = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hautCm = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.valeurDeclaree = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contenu = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseColisListResponse(): ColisListResponse {
  return { colis: [], total: 0 };
}

export const ColisListResponse: MessageFns<ColisListResponse> = {
  encode(message: ColisListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.colis) {
      ColisResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColisListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColisListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.colis.push(ColisResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateTrackingEventRequest(): CreateTrackingEventRequest {
  return { expeditionId: "", code: "", label: "", dateEvenement: "" };
}

export const CreateTrackingEventRequest: MessageFns<CreateTrackingEventRequest> = {
  encode(message: CreateTrackingEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expeditionId !== "") {
      writer.uint32(10).string(message.expeditionId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(34).string(message.dateEvenement);
    }
    if (message.lieu !== undefined) {
      writer.uint32(42).string(message.lieu);
    }
    if (message.raw !== undefined) {
      writer.uint32(50).string(message.raw);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTrackingEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTrackingEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lieu = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.raw = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTrackingEventResponse(): TrackingEventResponse {
  return { id: "", expeditionId: "", code: "", label: "", dateEvenement: "", createdAt: "" };
}

export const TrackingEventResponse: MessageFns<TrackingEventResponse> = {
  encode(message: TrackingEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.expeditionId !== "") {
      writer.uint32(18).string(message.expeditionId);
    }
    if (message.code !== "") {
      writer.uint32(26).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.dateEvenement !== "") {
      writer.uint32(42).string(message.dateEvenement);
    }
    if (message.lieu !== undefined) {
      writer.uint32(50).string(message.lieu);
    }
    if (message.raw !== undefined) {
      writer.uint32(58).string(message.raw);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackingEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackingEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expeditionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateEvenement = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lieu = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.raw = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTrackingEventListResponse(): TrackingEventListResponse {
  return { events: [], total: 0 };
}

export const TrackingEventListResponse: MessageFns<TrackingEventListResponse> = {
  encode(message: TrackingEventListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      TrackingEventResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackingEventListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackingEventListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(TrackingEventResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCarrierAccountRequest(): CreateCarrierAccountRequest {
  return { organisationId: "", type: "", contractNumber: "", password: "", labelFormat: "", actif: false };
}

export const CreateCarrierAccountRequest: MessageFns<CreateCarrierAccountRequest> = {
  encode(message: CreateCarrierAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.contractNumber !== "") {
      writer.uint32(26).string(message.contractNumber);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    if (message.labelFormat !== "") {
      writer.uint32(42).string(message.labelFormat);
    }
    if (message.actif !== false) {
      writer.uint32(48).bool(message.actif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCarrierAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCarrierAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.labelFormat = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCarrierAccountResponse(): CarrierAccountResponse {
  return {
    id: "",
    organisationId: "",
    type: "",
    contractNumber: "",
    labelFormat: "",
    actif: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const CarrierAccountResponse: MessageFns<CarrierAccountResponse> = {
  encode(message: CarrierAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.contractNumber !== "") {
      writer.uint32(34).string(message.contractNumber);
    }
    if (message.labelFormat !== "") {
      writer.uint32(42).string(message.labelFormat);
    }
    if (message.actif !== false) {
      writer.uint32(48).bool(message.actif);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CarrierAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCarrierAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.labelFormat = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateCarrierAccountRequest(): UpdateCarrierAccountRequest {
  return { id: "" };
}

export const UpdateCarrierAccountRequest: MessageFns<UpdateCarrierAccountRequest> = {
  encode(message: UpdateCarrierAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contractNumber !== undefined) {
      writer.uint32(18).string(message.contractNumber);
    }
    if (message.password !== undefined) {
      writer.uint32(26).string(message.password);
    }
    if (message.labelFormat !== undefined) {
      writer.uint32(34).string(message.labelFormat);
    }
    if (message.actif !== undefined) {
      writer.uint32(40).bool(message.actif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCarrierAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCarrierAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.labelFormat = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCarrierAccountListResponse(): CarrierAccountListResponse {
  return { accounts: [], total: 0 };
}

export const CarrierAccountListResponse: MessageFns<CarrierAccountListResponse> = {
  encode(message: CarrierAccountListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      CarrierAccountResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CarrierAccountListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCarrierAccountListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(CarrierAccountResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGenerateLabelRequest(): GenerateLabelRequest {
  return { organisationId: "", serviceLevel: "", format: "", weightGr: 0 };
}

export const GenerateLabelRequest: MessageFns<GenerateLabelRequest> = {
  encode(message: GenerateLabelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.serviceLevel !== "") {
      writer.uint32(18).string(message.serviceLevel);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.weightGr !== 0) {
      writer.uint32(32).int32(message.weightGr);
    }
    if (message.sender !== undefined) {
      Address.encode(message.sender, writer.uint32(42).fork()).join();
    }
    if (message.recipient !== undefined) {
      Address.encode(message.recipient, writer.uint32(50).fork()).join();
    }
    if (message.contractId !== undefined) {
      writer.uint32(58).string(message.contractId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateLabelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateLabelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceLevel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weightGr = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sender = Address.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipient = Address.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLabelResponse(): LabelResponse {
  return { trackingNumber: "", labelUrl: "" };
}

export const LabelResponse: MessageFns<LabelResponse> = {
  encode(message: LabelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingNumber !== "") {
      writer.uint32(10).string(message.trackingNumber);
    }
    if (message.labelUrl !== "") {
      writer.uint32(18).string(message.labelUrl);
    }
    if (message.estimatedDeliveryDate !== undefined) {
      writer.uint32(26).string(message.estimatedDeliveryDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.labelUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.estimatedDeliveryDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTrackShipmentRequest(): TrackShipmentRequest {
  return { trackingNumber: "" };
}

export const TrackShipmentRequest: MessageFns<TrackShipmentRequest> = {
  encode(message: TrackShipmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingNumber !== "") {
      writer.uint32(10).string(message.trackingNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackShipmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackShipmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTrackingResponse(): TrackingResponse {
  return { trackingNumber: "", status: "", events: [], lastUpdatedAt: "" };
}

export const TrackingResponse: MessageFns<TrackingResponse> = {
  encode(message: TrackingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingNumber !== "") {
      writer.uint32(10).string(message.trackingNumber);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    for (const v of message.events) {
      TrackingEvent.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.lastUpdatedAt !== "") {
      writer.uint32(34).string(message.lastUpdatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.events.push(TrackingEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastUpdatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTrackingEvent(): TrackingEvent {
  return { code: "", label: "", date: "" };
}

export const TrackingEvent: MessageFns<TrackingEvent> = {
  encode(message: TrackingEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.location !== undefined) {
      writer.uint32(34).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackingEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidateAddressRequest(): ValidateAddressRequest {
  return {};
}

export const ValidateAddressRequest: MessageFns<ValidateAddressRequest> = {
  encode(message: ValidateAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAddressValidationResponse(): AddressValidationResponse {
  return { isValid: false, suggestions: [] };
}

export const AddressValidationResponse: MessageFns<AddressValidationResponse> = {
  encode(message: AddressValidationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isValid !== false) {
      writer.uint32(8).bool(message.isValid);
    }
    if (message.normalizedAddress !== undefined) {
      Address.encode(message.normalizedAddress, writer.uint32(18).fork()).join();
    }
    for (const v of message.suggestions) {
      Address.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressValidationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressValidationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isValid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.normalizedAddress = Address.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.suggestions.push(Address.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSimulatePricingRequest(): SimulatePricingRequest {
  return { serviceLevel: "", format: "", weightGr: 0, originCountry: "", destinationCountry: "" };
}

export const SimulatePricingRequest: MessageFns<SimulatePricingRequest> = {
  encode(message: SimulatePricingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceLevel !== "") {
      writer.uint32(10).string(message.serviceLevel);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.weightGr !== 0) {
      writer.uint32(24).int32(message.weightGr);
    }
    if (message.originCountry !== "") {
      writer.uint32(34).string(message.originCountry);
    }
    if (message.destinationCountry !== "") {
      writer.uint32(42).string(message.destinationCountry);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimulatePricingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulatePricingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceLevel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.weightGr = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originCountry = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.destinationCountry = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePricingResponse(): PricingResponse {
  return { serviceLevel: "", totalPrice: 0, currency: "", breakdown: [] };
}

export const PricingResponse: MessageFns<PricingResponse> = {
  encode(message: PricingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceLevel !== "") {
      writer.uint32(10).string(message.serviceLevel);
    }
    if (message.totalPrice !== 0) {
      writer.uint32(17).double(message.totalPrice);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    for (const v of message.breakdown) {
      PricingBreakdown.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.estimatedDeliveryDays !== undefined) {
      writer.uint32(40).int32(message.estimatedDeliveryDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceLevel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.totalPrice = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.breakdown.push(PricingBreakdown.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.estimatedDeliveryDays = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePricingBreakdown(): PricingBreakdown {
  return { label: "", amount: 0 };
}

export const PricingBreakdown: MessageFns<PricingBreakdown> = {
  encode(message: PricingBreakdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.amount !== 0) {
      writer.uint32(17).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingBreakdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface LogisticsServiceClient {
  /** ==================== EXPEDITIONS ==================== */

  createExpedition(request: CreateExpeditionRequest, metadata?: Metadata): Observable<ExpeditionResponse>;

  getExpedition(request: GetByIdRequest, metadata?: Metadata): Observable<ExpeditionResponse>;

  getExpeditionsByClient(
    request: GetExpeditionsByClientRequest,
    metadata?: Metadata,
  ): Observable<ExpeditionListResponse>;

  getExpeditionsByOrganisation(
    request: GetExpeditionsByOrganisationRequest,
    metadata?: Metadata,
  ): Observable<ExpeditionListResponse>;

  updateExpedition(request: UpdateExpeditionRequest, metadata?: Metadata): Observable<ExpeditionResponse>;

  deleteExpedition(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ==================== COLIS (PARCELS) ==================== */

  createColis(request: CreateColisRequest, metadata?: Metadata): Observable<ColisResponse>;

  getColis(request: GetByIdRequest, metadata?: Metadata): Observable<ColisResponse>;

  getColisByExpedition(request: GetByExpeditionIdRequest, metadata?: Metadata): Observable<ColisListResponse>;

  updateColis(request: UpdateColisRequest, metadata?: Metadata): Observable<ColisResponse>;

  deleteColis(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ==================== TRACKING EVENTS ==================== */

  createTrackingEvent(request: CreateTrackingEventRequest, metadata?: Metadata): Observable<TrackingEventResponse>;

  getTrackingEvents(request: GetByExpeditionIdRequest, metadata?: Metadata): Observable<TrackingEventListResponse>;

  getLatestTrackingEvent(request: GetByExpeditionIdRequest, metadata?: Metadata): Observable<TrackingEventResponse>;

  /** ==================== CARRIER ACCOUNTS ==================== */

  createCarrierAccount(request: CreateCarrierAccountRequest, metadata?: Metadata): Observable<CarrierAccountResponse>;

  getCarrierAccount(request: GetByIdRequest, metadata?: Metadata): Observable<CarrierAccountResponse>;

  getCarrierAccountsByOrganisation(
    request: GetByOrganisationIdRequest,
    metadata?: Metadata,
  ): Observable<CarrierAccountListResponse>;

  updateCarrierAccount(request: UpdateCarrierAccountRequest, metadata?: Metadata): Observable<CarrierAccountResponse>;

  deleteCarrierAccount(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ==================== MAILEVA OPERATIONS ==================== */

  generateLabel(request: GenerateLabelRequest, metadata?: Metadata): Observable<LabelResponse>;

  trackShipment(request: TrackShipmentRequest, metadata?: Metadata): Observable<TrackingResponse>;

  validateAddress(request: ValidateAddressRequest, metadata?: Metadata): Observable<AddressValidationResponse>;

  simulatePricing(request: SimulatePricingRequest, metadata?: Metadata): Observable<PricingResponse>;
}

export interface LogisticsServiceController {
  /** ==================== EXPEDITIONS ==================== */

  createExpedition(
    request: CreateExpeditionRequest,
    metadata?: Metadata,
  ): Promise<ExpeditionResponse> | Observable<ExpeditionResponse> | ExpeditionResponse;

  getExpedition(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<ExpeditionResponse> | Observable<ExpeditionResponse> | ExpeditionResponse;

  getExpeditionsByClient(
    request: GetExpeditionsByClientRequest,
    metadata?: Metadata,
  ): Promise<ExpeditionListResponse> | Observable<ExpeditionListResponse> | ExpeditionListResponse;

  getExpeditionsByOrganisation(
    request: GetExpeditionsByOrganisationRequest,
    metadata?: Metadata,
  ): Promise<ExpeditionListResponse> | Observable<ExpeditionListResponse> | ExpeditionListResponse;

  updateExpedition(
    request: UpdateExpeditionRequest,
    metadata?: Metadata,
  ): Promise<ExpeditionResponse> | Observable<ExpeditionResponse> | ExpeditionResponse;

  deleteExpedition(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ==================== COLIS (PARCELS) ==================== */

  createColis(
    request: CreateColisRequest,
    metadata?: Metadata,
  ): Promise<ColisResponse> | Observable<ColisResponse> | ColisResponse;

  getColis(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<ColisResponse> | Observable<ColisResponse> | ColisResponse;

  getColisByExpedition(
    request: GetByExpeditionIdRequest,
    metadata?: Metadata,
  ): Promise<ColisListResponse> | Observable<ColisListResponse> | ColisListResponse;

  updateColis(
    request: UpdateColisRequest,
    metadata?: Metadata,
  ): Promise<ColisResponse> | Observable<ColisResponse> | ColisResponse;

  deleteColis(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ==================== TRACKING EVENTS ==================== */

  createTrackingEvent(
    request: CreateTrackingEventRequest,
    metadata?: Metadata,
  ): Promise<TrackingEventResponse> | Observable<TrackingEventResponse> | TrackingEventResponse;

  getTrackingEvents(
    request: GetByExpeditionIdRequest,
    metadata?: Metadata,
  ): Promise<TrackingEventListResponse> | Observable<TrackingEventListResponse> | TrackingEventListResponse;

  getLatestTrackingEvent(
    request: GetByExpeditionIdRequest,
    metadata?: Metadata,
  ): Promise<TrackingEventResponse> | Observable<TrackingEventResponse> | TrackingEventResponse;

  /** ==================== CARRIER ACCOUNTS ==================== */

  createCarrierAccount(
    request: CreateCarrierAccountRequest,
    metadata?: Metadata,
  ): Promise<CarrierAccountResponse> | Observable<CarrierAccountResponse> | CarrierAccountResponse;

  getCarrierAccount(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<CarrierAccountResponse> | Observable<CarrierAccountResponse> | CarrierAccountResponse;

  getCarrierAccountsByOrganisation(
    request: GetByOrganisationIdRequest,
    metadata?: Metadata,
  ): Promise<CarrierAccountListResponse> | Observable<CarrierAccountListResponse> | CarrierAccountListResponse;

  updateCarrierAccount(
    request: UpdateCarrierAccountRequest,
    metadata?: Metadata,
  ): Promise<CarrierAccountResponse> | Observable<CarrierAccountResponse> | CarrierAccountResponse;

  deleteCarrierAccount(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ==================== MAILEVA OPERATIONS ==================== */

  generateLabel(
    request: GenerateLabelRequest,
    metadata?: Metadata,
  ): Promise<LabelResponse> | Observable<LabelResponse> | LabelResponse;

  trackShipment(
    request: TrackShipmentRequest,
    metadata?: Metadata,
  ): Promise<TrackingResponse> | Observable<TrackingResponse> | TrackingResponse;

  validateAddress(
    request: ValidateAddressRequest,
    metadata?: Metadata,
  ): Promise<AddressValidationResponse> | Observable<AddressValidationResponse> | AddressValidationResponse;

  simulatePricing(
    request: SimulatePricingRequest,
    metadata?: Metadata,
  ): Promise<PricingResponse> | Observable<PricingResponse> | PricingResponse;
}

export function LogisticsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createExpedition",
      "getExpedition",
      "getExpeditionsByClient",
      "getExpeditionsByOrganisation",
      "updateExpedition",
      "deleteExpedition",
      "createColis",
      "getColis",
      "getColisByExpedition",
      "updateColis",
      "deleteColis",
      "createTrackingEvent",
      "getTrackingEvents",
      "getLatestTrackingEvent",
      "createCarrierAccount",
      "getCarrierAccount",
      "getCarrierAccountsByOrganisation",
      "updateCarrierAccount",
      "deleteCarrierAccount",
      "generateLabel",
      "trackShipment",
      "validateAddress",
      "simulatePricing",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("LogisticsService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("LogisticsService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const LOGISTICS_SERVICE_NAME = "LogisticsService";

export type LogisticsServiceService = typeof LogisticsServiceService;
export const LogisticsServiceService = {
  /** ==================== EXPEDITIONS ==================== */
  createExpedition: {
    path: "/logistics.LogisticsService/CreateExpedition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateExpeditionRequest): Buffer =>
      Buffer.from(CreateExpeditionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateExpeditionRequest => CreateExpeditionRequest.decode(value),
    responseSerialize: (value: ExpeditionResponse): Buffer => Buffer.from(ExpeditionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExpeditionResponse => ExpeditionResponse.decode(value),
  },
  getExpedition: {
    path: "/logistics.LogisticsService/GetExpedition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: ExpeditionResponse): Buffer => Buffer.from(ExpeditionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExpeditionResponse => ExpeditionResponse.decode(value),
  },
  getExpeditionsByClient: {
    path: "/logistics.LogisticsService/GetExpeditionsByClient",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetExpeditionsByClientRequest): Buffer =>
      Buffer.from(GetExpeditionsByClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetExpeditionsByClientRequest => GetExpeditionsByClientRequest.decode(value),
    responseSerialize: (value: ExpeditionListResponse): Buffer =>
      Buffer.from(ExpeditionListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExpeditionListResponse => ExpeditionListResponse.decode(value),
  },
  getExpeditionsByOrganisation: {
    path: "/logistics.LogisticsService/GetExpeditionsByOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetExpeditionsByOrganisationRequest): Buffer =>
      Buffer.from(GetExpeditionsByOrganisationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetExpeditionsByOrganisationRequest =>
      GetExpeditionsByOrganisationRequest.decode(value),
    responseSerialize: (value: ExpeditionListResponse): Buffer =>
      Buffer.from(ExpeditionListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExpeditionListResponse => ExpeditionListResponse.decode(value),
  },
  updateExpedition: {
    path: "/logistics.LogisticsService/UpdateExpedition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateExpeditionRequest): Buffer =>
      Buffer.from(UpdateExpeditionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateExpeditionRequest => UpdateExpeditionRequest.decode(value),
    responseSerialize: (value: ExpeditionResponse): Buffer => Buffer.from(ExpeditionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExpeditionResponse => ExpeditionResponse.decode(value),
  },
  deleteExpedition: {
    path: "/logistics.LogisticsService/DeleteExpedition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ==================== COLIS (PARCELS) ==================== */
  createColis: {
    path: "/logistics.LogisticsService/CreateColis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateColisRequest): Buffer => Buffer.from(CreateColisRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateColisRequest => CreateColisRequest.decode(value),
    responseSerialize: (value: ColisResponse): Buffer => Buffer.from(ColisResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ColisResponse => ColisResponse.decode(value),
  },
  getColis: {
    path: "/logistics.LogisticsService/GetColis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: ColisResponse): Buffer => Buffer.from(ColisResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ColisResponse => ColisResponse.decode(value),
  },
  getColisByExpedition: {
    path: "/logistics.LogisticsService/GetColisByExpedition",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByExpeditionIdRequest): Buffer =>
      Buffer.from(GetByExpeditionIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByExpeditionIdRequest => GetByExpeditionIdRequest.decode(value),
    responseSerialize: (value: ColisListResponse): Buffer => Buffer.from(ColisListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ColisListResponse => ColisListResponse.decode(value),
  },
  updateColis: {
    path: "/logistics.LogisticsService/UpdateColis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateColisRequest): Buffer => Buffer.from(UpdateColisRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateColisRequest => UpdateColisRequest.decode(value),
    responseSerialize: (value: ColisResponse): Buffer => Buffer.from(ColisResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ColisResponse => ColisResponse.decode(value),
  },
  deleteColis: {
    path: "/logistics.LogisticsService/DeleteColis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ==================== TRACKING EVENTS ==================== */
  createTrackingEvent: {
    path: "/logistics.LogisticsService/CreateTrackingEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTrackingEventRequest): Buffer =>
      Buffer.from(CreateTrackingEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateTrackingEventRequest => CreateTrackingEventRequest.decode(value),
    responseSerialize: (value: TrackingEventResponse): Buffer =>
      Buffer.from(TrackingEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TrackingEventResponse => TrackingEventResponse.decode(value),
  },
  getTrackingEvents: {
    path: "/logistics.LogisticsService/GetTrackingEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByExpeditionIdRequest): Buffer =>
      Buffer.from(GetByExpeditionIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByExpeditionIdRequest => GetByExpeditionIdRequest.decode(value),
    responseSerialize: (value: TrackingEventListResponse): Buffer =>
      Buffer.from(TrackingEventListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TrackingEventListResponse => TrackingEventListResponse.decode(value),
  },
  getLatestTrackingEvent: {
    path: "/logistics.LogisticsService/GetLatestTrackingEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByExpeditionIdRequest): Buffer =>
      Buffer.from(GetByExpeditionIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByExpeditionIdRequest => GetByExpeditionIdRequest.decode(value),
    responseSerialize: (value: TrackingEventResponse): Buffer =>
      Buffer.from(TrackingEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TrackingEventResponse => TrackingEventResponse.decode(value),
  },
  /** ==================== CARRIER ACCOUNTS ==================== */
  createCarrierAccount: {
    path: "/logistics.LogisticsService/CreateCarrierAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCarrierAccountRequest): Buffer =>
      Buffer.from(CreateCarrierAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCarrierAccountRequest => CreateCarrierAccountRequest.decode(value),
    responseSerialize: (value: CarrierAccountResponse): Buffer =>
      Buffer.from(CarrierAccountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CarrierAccountResponse => CarrierAccountResponse.decode(value),
  },
  getCarrierAccount: {
    path: "/logistics.LogisticsService/GetCarrierAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: CarrierAccountResponse): Buffer =>
      Buffer.from(CarrierAccountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CarrierAccountResponse => CarrierAccountResponse.decode(value),
  },
  getCarrierAccountsByOrganisation: {
    path: "/logistics.LogisticsService/GetCarrierAccountsByOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByOrganisationIdRequest): Buffer =>
      Buffer.from(GetByOrganisationIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByOrganisationIdRequest => GetByOrganisationIdRequest.decode(value),
    responseSerialize: (value: CarrierAccountListResponse): Buffer =>
      Buffer.from(CarrierAccountListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CarrierAccountListResponse => CarrierAccountListResponse.decode(value),
  },
  updateCarrierAccount: {
    path: "/logistics.LogisticsService/UpdateCarrierAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCarrierAccountRequest): Buffer =>
      Buffer.from(UpdateCarrierAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateCarrierAccountRequest => UpdateCarrierAccountRequest.decode(value),
    responseSerialize: (value: CarrierAccountResponse): Buffer =>
      Buffer.from(CarrierAccountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CarrierAccountResponse => CarrierAccountResponse.decode(value),
  },
  deleteCarrierAccount: {
    path: "/logistics.LogisticsService/DeleteCarrierAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ==================== MAILEVA OPERATIONS ==================== */
  generateLabel: {
    path: "/logistics.LogisticsService/GenerateLabel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateLabelRequest): Buffer => Buffer.from(GenerateLabelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GenerateLabelRequest => GenerateLabelRequest.decode(value),
    responseSerialize: (value: LabelResponse): Buffer => Buffer.from(LabelResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LabelResponse => LabelResponse.decode(value),
  },
  trackShipment: {
    path: "/logistics.LogisticsService/TrackShipment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TrackShipmentRequest): Buffer => Buffer.from(TrackShipmentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TrackShipmentRequest => TrackShipmentRequest.decode(value),
    responseSerialize: (value: TrackingResponse): Buffer => Buffer.from(TrackingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TrackingResponse => TrackingResponse.decode(value),
  },
  validateAddress: {
    path: "/logistics.LogisticsService/ValidateAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateAddressRequest): Buffer =>
      Buffer.from(ValidateAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ValidateAddressRequest => ValidateAddressRequest.decode(value),
    responseSerialize: (value: AddressValidationResponse): Buffer =>
      Buffer.from(AddressValidationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AddressValidationResponse => AddressValidationResponse.decode(value),
  },
  simulatePricing: {
    path: "/logistics.LogisticsService/SimulatePricing",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SimulatePricingRequest): Buffer =>
      Buffer.from(SimulatePricingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SimulatePricingRequest => SimulatePricingRequest.decode(value),
    responseSerialize: (value: PricingResponse): Buffer => Buffer.from(PricingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PricingResponse => PricingResponse.decode(value),
  },
} as const;

export interface LogisticsServiceServer extends UntypedServiceImplementation {
  /** ==================== EXPEDITIONS ==================== */
  createExpedition: handleUnaryCall<CreateExpeditionRequest, ExpeditionResponse>;
  getExpedition: handleUnaryCall<GetByIdRequest, ExpeditionResponse>;
  getExpeditionsByClient: handleUnaryCall<GetExpeditionsByClientRequest, ExpeditionListResponse>;
  getExpeditionsByOrganisation: handleUnaryCall<GetExpeditionsByOrganisationRequest, ExpeditionListResponse>;
  updateExpedition: handleUnaryCall<UpdateExpeditionRequest, ExpeditionResponse>;
  deleteExpedition: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ==================== COLIS (PARCELS) ==================== */
  createColis: handleUnaryCall<CreateColisRequest, ColisResponse>;
  getColis: handleUnaryCall<GetByIdRequest, ColisResponse>;
  getColisByExpedition: handleUnaryCall<GetByExpeditionIdRequest, ColisListResponse>;
  updateColis: handleUnaryCall<UpdateColisRequest, ColisResponse>;
  deleteColis: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ==================== TRACKING EVENTS ==================== */
  createTrackingEvent: handleUnaryCall<CreateTrackingEventRequest, TrackingEventResponse>;
  getTrackingEvents: handleUnaryCall<GetByExpeditionIdRequest, TrackingEventListResponse>;
  getLatestTrackingEvent: handleUnaryCall<GetByExpeditionIdRequest, TrackingEventResponse>;
  /** ==================== CARRIER ACCOUNTS ==================== */
  createCarrierAccount: handleUnaryCall<CreateCarrierAccountRequest, CarrierAccountResponse>;
  getCarrierAccount: handleUnaryCall<GetByIdRequest, CarrierAccountResponse>;
  getCarrierAccountsByOrganisation: handleUnaryCall<GetByOrganisationIdRequest, CarrierAccountListResponse>;
  updateCarrierAccount: handleUnaryCall<UpdateCarrierAccountRequest, CarrierAccountResponse>;
  deleteCarrierAccount: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ==================== MAILEVA OPERATIONS ==================== */
  generateLabel: handleUnaryCall<GenerateLabelRequest, LabelResponse>;
  trackShipment: handleUnaryCall<TrackShipmentRequest, TrackingResponse>;
  validateAddress: handleUnaryCall<ValidateAddressRequest, AddressValidationResponse>;
  simulatePricing: handleUnaryCall<SimulatePricingRequest, PricingResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
