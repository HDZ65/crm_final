// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: notifications/notifications.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export enum NotificationType {
  NOTIFICATION_TYPE_UNSPECIFIED = 0,
  NOTIFICATION_TYPE_CONTRAT_EXPIRE = 1,
  NOTIFICATION_TYPE_CONTRAT_BIENTOT_EXPIRE = 2,
  NOTIFICATION_TYPE_IMPAYE = 3,
  NOTIFICATION_TYPE_NOUVEAU_CLIENT = 4,
  NOTIFICATION_TYPE_NOUVEAU_CONTRAT = 5,
  NOTIFICATION_TYPE_TACHE_ASSIGNEE = 6,
  NOTIFICATION_TYPE_RAPPEL = 7,
  NOTIFICATION_TYPE_ALERTE = 8,
  NOTIFICATION_TYPE_INFO = 9,
  NOTIFICATION_TYPE_SYSTEME = 10,
}

export interface EmptyRequest {
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface OperationResponse {
  success: boolean;
  message: string;
  affectedCount: number;
}

export interface Notification {
  id: string;
  organisationId: string;
  utilisateurId: string;
  type: NotificationType;
  titre: string;
  message: string;
  lu: boolean;
  metadata: { [key: string]: string };
  lienUrl?: string | undefined;
  createdAt: string;
  updatedAt: string;
}

export interface Notification_MetadataEntry {
  key: string;
  value: string;
}

export interface CreateNotificationRequest {
  organisationId: string;
  utilisateurId: string;
  type: NotificationType;
  titre: string;
  message: string;
  metadata: { [key: string]: string };
  lienUrl?: string | undefined;
  broadcastWebsocket: boolean;
}

export interface CreateNotificationRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GetNotificationRequest {
  id: string;
}

export interface GetNotificationsRequest {
  organisationId: string;
  limit?: number | undefined;
  offset?: number | undefined;
  typeFilter?: NotificationType | undefined;
  unreadOnly?: boolean | undefined;
}

export interface GetNotificationsByUserRequest {
  utilisateurId: string;
  limit?: number | undefined;
  offset?: number | undefined;
}

export interface UpdateNotificationRequest {
  id: string;
  titre?: string | undefined;
  message?: string | undefined;
  lu?: boolean | undefined;
  metadata: { [key: string]: string };
  lienUrl?: string | undefined;
}

export interface UpdateNotificationRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface DeleteNotificationRequest {
  id: string;
}

export interface NotificationResponse {
  notification?: Notification | undefined;
}

export interface NotificationListResponse {
  notifications: Notification[];
  total: number;
}

export interface MarkAsReadRequest {
  id: string;
}

export interface MarkAllAsReadRequest {
  utilisateurId: string;
}

export interface GetUnreadCountRequest {
  utilisateurId: string;
}

export interface UnreadCountResponse {
  total: number;
  unread: number;
}

export interface DeleteAllByUserRequest {
  utilisateurId: string;
}

export interface DeleteOlderThanRequest {
  date: string;
}

export interface NotifyNewClientRequest {
  organisationId: string;
  utilisateurId: string;
  clientId: string;
  clientNom: string;
}

export interface NotifyNewContratRequest {
  organisationId: string;
  utilisateurId: string;
  contratId: string;
  contratNumero: string;
  clientNom: string;
}

export interface NotifyContratExpiringRequest {
  organisationId: string;
  utilisateurId: string;
  contratId: string;
  contratNumero: string;
  dateExpiration: string;
  joursRestants: number;
}

export interface NotifyImpayeRequest {
  organisationId: string;
  utilisateurId: string;
  factureId: string;
  factureNumero: string;
  clientNom: string;
  montant: string;
}

export interface NotifyTacheRequest {
  organisationId: string;
  utilisateurId: string;
  tacheId: string;
  tacheTitre: string;
  assignePar: string;
}

export interface NotifyRappelRequest {
  organisationId: string;
  utilisateurId: string;
  titre: string;
  message: string;
  lienUrl?: string | undefined;
}

export interface NotifyAlerteRequest {
  organisationId: string;
  utilisateurId: string;
  titre: string;
  message: string;
  niveau: string;
}

export interface NotifyInfoRequest {
  organisationId: string;
  utilisateurId: string;
  titre: string;
  message: string;
}

export interface NotifyOrganisationRequest {
  organisationId: string;
  utilisateurIds: string[];
  type: NotificationType;
  titre: string;
  message: string;
  metadata: { [key: string]: string };
}

export interface NotifyOrganisationRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface ConnectedUsersResponse {
  count: number;
}

export interface IsUserConnectedRequest {
  utilisateurId: string;
}

export interface IsUserConnectedResponse {
  connected: boolean;
}

function createBaseEmptyRequest(): EmptyRequest {
  return {};
}

export const EmptyRequest: MessageFns<EmptyRequest> = {
  encode(_: EmptyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseOperationResponse(): OperationResponse {
  return { success: false, message: "", affectedCount: 0 };
}

export const OperationResponse: MessageFns<OperationResponse> = {
  encode(message: OperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.affectedCount !== 0) {
      writer.uint32(24).int32(message.affectedCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.affectedCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotification(): Notification {
  return {
    id: "",
    organisationId: "",
    utilisateurId: "",
    type: 0,
    titre: "",
    message: "",
    lu: false,
    metadata: {},
    createdAt: "",
    updatedAt: "",
  };
}

export const Notification: MessageFns<Notification> = {
  encode(message: Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(26).string(message.utilisateurId);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.titre !== "") {
      writer.uint32(42).string(message.titre);
    }
    if (message.message !== "") {
      writer.uint32(50).string(message.message);
    }
    if (message.lu !== false) {
      writer.uint32(56).bool(message.lu);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      Notification_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.lienUrl !== undefined) {
      writer.uint32(74).string(message.lienUrl);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lu = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Notification_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lienUrl = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotification_MetadataEntry(): Notification_MetadataEntry {
  return { key: "", value: "" };
}

export const Notification_MetadataEntry: MessageFns<Notification_MetadataEntry> = {
  encode(message: Notification_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateNotificationRequest(): CreateNotificationRequest {
  return {
    organisationId: "",
    utilisateurId: "",
    type: 0,
    titre: "",
    message: "",
    metadata: {},
    broadcastWebsocket: false,
  };
}

export const CreateNotificationRequest: MessageFns<CreateNotificationRequest> = {
  encode(message: CreateNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.titre !== "") {
      writer.uint32(34).string(message.titre);
    }
    if (message.message !== "") {
      writer.uint32(42).string(message.message);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateNotificationRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.lienUrl !== undefined) {
      writer.uint32(58).string(message.lienUrl);
    }
    if (message.broadcastWebsocket !== false) {
      writer.uint32(64).bool(message.broadcastWebsocket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateNotificationRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lienUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.broadcastWebsocket = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateNotificationRequest_MetadataEntry(): CreateNotificationRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateNotificationRequest_MetadataEntry: MessageFns<CreateNotificationRequest_MetadataEntry> = {
  encode(message: CreateNotificationRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNotificationRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNotificationRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetNotificationRequest(): GetNotificationRequest {
  return { id: "" };
}

export const GetNotificationRequest: MessageFns<GetNotificationRequest> = {
  encode(message: GetNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetNotificationsRequest(): GetNotificationsRequest {
  return { organisationId: "" };
}

export const GetNotificationsRequest: MessageFns<GetNotificationsRequest> = {
  encode(message: GetNotificationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    if (message.typeFilter !== undefined) {
      writer.uint32(32).int32(message.typeFilter);
    }
    if (message.unreadOnly !== undefined) {
      writer.uint32(40).bool(message.unreadOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.typeFilter = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.unreadOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetNotificationsByUserRequest(): GetNotificationsByUserRequest {
  return { utilisateurId: "" };
}

export const GetNotificationsByUserRequest: MessageFns<GetNotificationsByUserRequest> = {
  encode(message: GetNotificationsByUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.offset !== undefined) {
      writer.uint32(24).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationsByUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationsByUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateNotificationRequest(): UpdateNotificationRequest {
  return { id: "", metadata: {} };
}

export const UpdateNotificationRequest: MessageFns<UpdateNotificationRequest> = {
  encode(message: UpdateNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.titre !== undefined) {
      writer.uint32(18).string(message.titre);
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    if (message.lu !== undefined) {
      writer.uint32(32).bool(message.lu);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      UpdateNotificationRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.lienUrl !== undefined) {
      writer.uint32(50).string(message.lienUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lu = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = UpdateNotificationRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lienUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateNotificationRequest_MetadataEntry(): UpdateNotificationRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const UpdateNotificationRequest_MetadataEntry: MessageFns<UpdateNotificationRequest_MetadataEntry> = {
  encode(message: UpdateNotificationRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNotificationRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNotificationRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteNotificationRequest(): DeleteNotificationRequest {
  return { id: "" };
}

export const DeleteNotificationRequest: MessageFns<DeleteNotificationRequest> = {
  encode(message: DeleteNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotificationResponse(): NotificationResponse {
  return {};
}

export const NotificationResponse: MessageFns<NotificationResponse> = {
  encode(message: NotificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notification !== undefined) {
      Notification.encode(message.notification, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notification = Notification.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotificationListResponse(): NotificationListResponse {
  return { notifications: [], total: 0 };
}

export const NotificationListResponse: MessageFns<NotificationListResponse> = {
  encode(message: NotificationListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notifications.push(Notification.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMarkAsReadRequest(): MarkAsReadRequest {
  return { id: "" };
}

export const MarkAsReadRequest: MessageFns<MarkAsReadRequest> = {
  encode(message: MarkAsReadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkAsReadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkAsReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMarkAllAsReadRequest(): MarkAllAsReadRequest {
  return { utilisateurId: "" };
}

export const MarkAllAsReadRequest: MessageFns<MarkAllAsReadRequest> = {
  encode(message: MarkAllAsReadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkAllAsReadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkAllAsReadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetUnreadCountRequest(): GetUnreadCountRequest {
  return { utilisateurId: "" };
}

export const GetUnreadCountRequest: MessageFns<GetUnreadCountRequest> = {
  encode(message: GetUnreadCountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnreadCountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnreadCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUnreadCountResponse(): UnreadCountResponse {
  return { total: 0, unread: 0 };
}

export const UnreadCountResponse: MessageFns<UnreadCountResponse> = {
  encode(message: UnreadCountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.unread !== 0) {
      writer.uint32(16).int32(message.unread);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnreadCountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnreadCountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unread = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteAllByUserRequest(): DeleteAllByUserRequest {
  return { utilisateurId: "" };
}

export const DeleteAllByUserRequest: MessageFns<DeleteAllByUserRequest> = {
  encode(message: DeleteAllByUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAllByUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAllByUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteOlderThanRequest(): DeleteOlderThanRequest {
  return { date: "" };
}

export const DeleteOlderThanRequest: MessageFns<DeleteOlderThanRequest> = {
  encode(message: DeleteOlderThanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOlderThanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOlderThanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyNewClientRequest(): NotifyNewClientRequest {
  return { organisationId: "", utilisateurId: "", clientId: "", clientNom: "" };
}

export const NotifyNewClientRequest: MessageFns<NotifyNewClientRequest> = {
  encode(message: NotifyNewClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.clientNom !== "") {
      writer.uint32(34).string(message.clientNom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyNewClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyNewClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientNom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyNewContratRequest(): NotifyNewContratRequest {
  return { organisationId: "", utilisateurId: "", contratId: "", contratNumero: "", clientNom: "" };
}

export const NotifyNewContratRequest: MessageFns<NotifyNewContratRequest> = {
  encode(message: NotifyNewContratRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.contratId !== "") {
      writer.uint32(26).string(message.contratId);
    }
    if (message.contratNumero !== "") {
      writer.uint32(34).string(message.contratNumero);
    }
    if (message.clientNom !== "") {
      writer.uint32(42).string(message.clientNom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyNewContratRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyNewContratRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratNumero = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientNom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyContratExpiringRequest(): NotifyContratExpiringRequest {
  return {
    organisationId: "",
    utilisateurId: "",
    contratId: "",
    contratNumero: "",
    dateExpiration: "",
    joursRestants: 0,
  };
}

export const NotifyContratExpiringRequest: MessageFns<NotifyContratExpiringRequest> = {
  encode(message: NotifyContratExpiringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.contratId !== "") {
      writer.uint32(26).string(message.contratId);
    }
    if (message.contratNumero !== "") {
      writer.uint32(34).string(message.contratNumero);
    }
    if (message.dateExpiration !== "") {
      writer.uint32(42).string(message.dateExpiration);
    }
    if (message.joursRestants !== 0) {
      writer.uint32(48).int32(message.joursRestants);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyContratExpiringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyContratExpiringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratNumero = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateExpiration = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.joursRestants = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyImpayeRequest(): NotifyImpayeRequest {
  return { organisationId: "", utilisateurId: "", factureId: "", factureNumero: "", clientNom: "", montant: "" };
}

export const NotifyImpayeRequest: MessageFns<NotifyImpayeRequest> = {
  encode(message: NotifyImpayeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.factureId !== "") {
      writer.uint32(26).string(message.factureId);
    }
    if (message.factureNumero !== "") {
      writer.uint32(34).string(message.factureNumero);
    }
    if (message.clientNom !== "") {
      writer.uint32(42).string(message.clientNom);
    }
    if (message.montant !== "") {
      writer.uint32(50).string(message.montant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyImpayeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyImpayeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.factureNumero = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientNom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.montant = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyTacheRequest(): NotifyTacheRequest {
  return { organisationId: "", utilisateurId: "", tacheId: "", tacheTitre: "", assignePar: "" };
}

export const NotifyTacheRequest: MessageFns<NotifyTacheRequest> = {
  encode(message: NotifyTacheRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.tacheId !== "") {
      writer.uint32(26).string(message.tacheId);
    }
    if (message.tacheTitre !== "") {
      writer.uint32(34).string(message.tacheTitre);
    }
    if (message.assignePar !== "") {
      writer.uint32(42).string(message.assignePar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyTacheRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyTacheRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tacheId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tacheTitre = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assignePar = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyRappelRequest(): NotifyRappelRequest {
  return { organisationId: "", utilisateurId: "", titre: "", message: "" };
}

export const NotifyRappelRequest: MessageFns<NotifyRappelRequest> = {
  encode(message: NotifyRappelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.titre !== "") {
      writer.uint32(26).string(message.titre);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.lienUrl !== undefined) {
      writer.uint32(42).string(message.lienUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyRappelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyRappelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lienUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyAlerteRequest(): NotifyAlerteRequest {
  return { organisationId: "", utilisateurId: "", titre: "", message: "", niveau: "" };
}

export const NotifyAlerteRequest: MessageFns<NotifyAlerteRequest> = {
  encode(message: NotifyAlerteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.titre !== "") {
      writer.uint32(26).string(message.titre);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.niveau !== "") {
      writer.uint32(42).string(message.niveau);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyAlerteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyAlerteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.niveau = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyInfoRequest(): NotifyInfoRequest {
  return { organisationId: "", utilisateurId: "", titre: "", message: "" };
}

export const NotifyInfoRequest: MessageFns<NotifyInfoRequest> = {
  encode(message: NotifyInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.titre !== "") {
      writer.uint32(26).string(message.titre);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyOrganisationRequest(): NotifyOrganisationRequest {
  return { organisationId: "", utilisateurIds: [], type: 0, titre: "", message: "", metadata: {} };
}

export const NotifyOrganisationRequest: MessageFns<NotifyOrganisationRequest> = {
  encode(message: NotifyOrganisationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    for (const v of message.utilisateurIds) {
      writer.uint32(18).string(v!);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.titre !== "") {
      writer.uint32(34).string(message.titre);
    }
    if (message.message !== "") {
      writer.uint32(42).string(message.message);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      NotifyOrganisationRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyOrganisationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyOrganisationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.titre = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = NotifyOrganisationRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseNotifyOrganisationRequest_MetadataEntry(): NotifyOrganisationRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const NotifyOrganisationRequest_MetadataEntry: MessageFns<NotifyOrganisationRequest_MetadataEntry> = {
  encode(message: NotifyOrganisationRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyOrganisationRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyOrganisationRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseConnectedUsersResponse(): ConnectedUsersResponse {
  return { count: 0 };
}

export const ConnectedUsersResponse: MessageFns<ConnectedUsersResponse> = {
  encode(message: ConnectedUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectedUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectedUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseIsUserConnectedRequest(): IsUserConnectedRequest {
  return { utilisateurId: "" };
}

export const IsUserConnectedRequest: MessageFns<IsUserConnectedRequest> = {
  encode(message: IsUserConnectedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilisateurId !== "") {
      writer.uint32(10).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsUserConnectedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsUserConnectedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseIsUserConnectedResponse(): IsUserConnectedResponse {
  return { connected: false };
}

export const IsUserConnectedResponse: MessageFns<IsUserConnectedResponse> = {
  encode(message: IsUserConnectedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connected !== false) {
      writer.uint32(8).bool(message.connected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsUserConnectedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsUserConnectedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.connected = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface NotificationServiceClient {
  /** ===== CRUD Operations ===== */

  createNotification(request: CreateNotificationRequest, metadata?: Metadata): Observable<NotificationResponse>;

  getNotification(request: GetNotificationRequest, metadata?: Metadata): Observable<NotificationResponse>;

  getNotifications(request: GetNotificationsRequest, metadata?: Metadata): Observable<NotificationListResponse>;

  getNotificationsByUser(
    request: GetNotificationsByUserRequest,
    metadata?: Metadata,
  ): Observable<NotificationListResponse>;

  getUnreadNotificationsByUser(
    request: GetNotificationsByUserRequest,
    metadata?: Metadata,
  ): Observable<NotificationListResponse>;

  updateNotification(request: UpdateNotificationRequest, metadata?: Metadata): Observable<NotificationResponse>;

  deleteNotification(request: DeleteNotificationRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ===== Read Status Management ===== */

  markAsRead(request: MarkAsReadRequest, metadata?: Metadata): Observable<NotificationResponse>;

  markAllAsRead(request: MarkAllAsReadRequest, metadata?: Metadata): Observable<OperationResponse>;

  getUnreadCount(request: GetUnreadCountRequest, metadata?: Metadata): Observable<UnreadCountResponse>;

  /** ===== Batch Operations ===== */

  deleteAllByUser(request: DeleteAllByUserRequest, metadata?: Metadata): Observable<OperationResponse>;

  deleteOlderThan(request: DeleteOlderThanRequest, metadata?: Metadata): Observable<OperationResponse>;

  /** ===== Business Notifications ===== */

  notifyNewClient(request: NotifyNewClientRequest, metadata?: Metadata): Observable<NotificationResponse>;

  notifyNewContrat(request: NotifyNewContratRequest, metadata?: Metadata): Observable<NotificationResponse>;

  notifyContratExpiringSoon(
    request: NotifyContratExpiringRequest,
    metadata?: Metadata,
  ): Observable<NotificationResponse>;

  notifyContratExpired(request: NotifyContratExpiringRequest, metadata?: Metadata): Observable<NotificationResponse>;

  notifyImpaye(request: NotifyImpayeRequest, metadata?: Metadata): Observable<NotificationResponse>;

  notifyTacheAssignee(request: NotifyTacheRequest, metadata?: Metadata): Observable<NotificationResponse>;

  notifyRappel(request: NotifyRappelRequest, metadata?: Metadata): Observable<NotificationResponse>;

  notifyAlerte(request: NotifyAlerteRequest, metadata?: Metadata): Observable<NotificationResponse>;

  notifyInfo(request: NotifyInfoRequest, metadata?: Metadata): Observable<NotificationResponse>;

  /** ===== Broadcast ===== */

  notifyOrganisation(request: NotifyOrganisationRequest, metadata?: Metadata): Observable<OperationResponse>;

  /** ===== WebSocket Status ===== */

  getConnectedUsersCount(request: EmptyRequest, metadata?: Metadata): Observable<ConnectedUsersResponse>;

  isUserConnected(request: IsUserConnectedRequest, metadata?: Metadata): Observable<IsUserConnectedResponse>;
}

export interface NotificationServiceController {
  /** ===== CRUD Operations ===== */

  createNotification(
    request: CreateNotificationRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  getNotification(
    request: GetNotificationRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  getNotifications(
    request: GetNotificationsRequest,
    metadata?: Metadata,
  ): Promise<NotificationListResponse> | Observable<NotificationListResponse> | NotificationListResponse;

  getNotificationsByUser(
    request: GetNotificationsByUserRequest,
    metadata?: Metadata,
  ): Promise<NotificationListResponse> | Observable<NotificationListResponse> | NotificationListResponse;

  getUnreadNotificationsByUser(
    request: GetNotificationsByUserRequest,
    metadata?: Metadata,
  ): Promise<NotificationListResponse> | Observable<NotificationListResponse> | NotificationListResponse;

  updateNotification(
    request: UpdateNotificationRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  deleteNotification(
    request: DeleteNotificationRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ===== Read Status Management ===== */

  markAsRead(
    request: MarkAsReadRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  markAllAsRead(
    request: MarkAllAsReadRequest,
    metadata?: Metadata,
  ): Promise<OperationResponse> | Observable<OperationResponse> | OperationResponse;

  getUnreadCount(
    request: GetUnreadCountRequest,
    metadata?: Metadata,
  ): Promise<UnreadCountResponse> | Observable<UnreadCountResponse> | UnreadCountResponse;

  /** ===== Batch Operations ===== */

  deleteAllByUser(
    request: DeleteAllByUserRequest,
    metadata?: Metadata,
  ): Promise<OperationResponse> | Observable<OperationResponse> | OperationResponse;

  deleteOlderThan(
    request: DeleteOlderThanRequest,
    metadata?: Metadata,
  ): Promise<OperationResponse> | Observable<OperationResponse> | OperationResponse;

  /** ===== Business Notifications ===== */

  notifyNewClient(
    request: NotifyNewClientRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyNewContrat(
    request: NotifyNewContratRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyContratExpiringSoon(
    request: NotifyContratExpiringRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyContratExpired(
    request: NotifyContratExpiringRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyImpaye(
    request: NotifyImpayeRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyTacheAssignee(
    request: NotifyTacheRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyRappel(
    request: NotifyRappelRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyAlerte(
    request: NotifyAlerteRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  notifyInfo(
    request: NotifyInfoRequest,
    metadata?: Metadata,
  ): Promise<NotificationResponse> | Observable<NotificationResponse> | NotificationResponse;

  /** ===== Broadcast ===== */

  notifyOrganisation(
    request: NotifyOrganisationRequest,
    metadata?: Metadata,
  ): Promise<OperationResponse> | Observable<OperationResponse> | OperationResponse;

  /** ===== WebSocket Status ===== */

  getConnectedUsersCount(
    request: EmptyRequest,
    metadata?: Metadata,
  ): Promise<ConnectedUsersResponse> | Observable<ConnectedUsersResponse> | ConnectedUsersResponse;

  isUserConnected(
    request: IsUserConnectedRequest,
    metadata?: Metadata,
  ): Promise<IsUserConnectedResponse> | Observable<IsUserConnectedResponse> | IsUserConnectedResponse;
}

export function NotificationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createNotification",
      "getNotification",
      "getNotifications",
      "getNotificationsByUser",
      "getUnreadNotificationsByUser",
      "updateNotification",
      "deleteNotification",
      "markAsRead",
      "markAllAsRead",
      "getUnreadCount",
      "deleteAllByUser",
      "deleteOlderThan",
      "notifyNewClient",
      "notifyNewContrat",
      "notifyContratExpiringSoon",
      "notifyContratExpired",
      "notifyImpaye",
      "notifyTacheAssignee",
      "notifyRappel",
      "notifyAlerte",
      "notifyInfo",
      "notifyOrganisation",
      "getConnectedUsersCount",
      "isUserConnected",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("NotificationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("NotificationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const NOTIFICATION_SERVICE_NAME = "NotificationService";

export type NotificationServiceService = typeof NotificationServiceService;
export const NotificationServiceService = {
  /** ===== CRUD Operations ===== */
  createNotification: {
    path: "/notifications.NotificationService/CreateNotification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateNotificationRequest): Buffer =>
      Buffer.from(CreateNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateNotificationRequest => CreateNotificationRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  getNotification: {
    path: "/notifications.NotificationService/GetNotification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNotificationRequest): Buffer =>
      Buffer.from(GetNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetNotificationRequest => GetNotificationRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  getNotifications: {
    path: "/notifications.NotificationService/GetNotifications",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNotificationsRequest): Buffer =>
      Buffer.from(GetNotificationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetNotificationsRequest => GetNotificationsRequest.decode(value),
    responseSerialize: (value: NotificationListResponse): Buffer =>
      Buffer.from(NotificationListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationListResponse => NotificationListResponse.decode(value),
  },
  getNotificationsByUser: {
    path: "/notifications.NotificationService/GetNotificationsByUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNotificationsByUserRequest): Buffer =>
      Buffer.from(GetNotificationsByUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetNotificationsByUserRequest => GetNotificationsByUserRequest.decode(value),
    responseSerialize: (value: NotificationListResponse): Buffer =>
      Buffer.from(NotificationListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationListResponse => NotificationListResponse.decode(value),
  },
  getUnreadNotificationsByUser: {
    path: "/notifications.NotificationService/GetUnreadNotificationsByUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNotificationsByUserRequest): Buffer =>
      Buffer.from(GetNotificationsByUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetNotificationsByUserRequest => GetNotificationsByUserRequest.decode(value),
    responseSerialize: (value: NotificationListResponse): Buffer =>
      Buffer.from(NotificationListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationListResponse => NotificationListResponse.decode(value),
  },
  updateNotification: {
    path: "/notifications.NotificationService/UpdateNotification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateNotificationRequest): Buffer =>
      Buffer.from(UpdateNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateNotificationRequest => UpdateNotificationRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  deleteNotification: {
    path: "/notifications.NotificationService/DeleteNotification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteNotificationRequest): Buffer =>
      Buffer.from(DeleteNotificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteNotificationRequest => DeleteNotificationRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ===== Read Status Management ===== */
  markAsRead: {
    path: "/notifications.NotificationService/MarkAsRead",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkAsReadRequest): Buffer => Buffer.from(MarkAsReadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarkAsReadRequest => MarkAsReadRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  markAllAsRead: {
    path: "/notifications.NotificationService/MarkAllAsRead",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkAllAsReadRequest): Buffer => Buffer.from(MarkAllAsReadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarkAllAsReadRequest => MarkAllAsReadRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  getUnreadCount: {
    path: "/notifications.NotificationService/GetUnreadCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUnreadCountRequest): Buffer =>
      Buffer.from(GetUnreadCountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUnreadCountRequest => GetUnreadCountRequest.decode(value),
    responseSerialize: (value: UnreadCountResponse): Buffer => Buffer.from(UnreadCountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UnreadCountResponse => UnreadCountResponse.decode(value),
  },
  /** ===== Batch Operations ===== */
  deleteAllByUser: {
    path: "/notifications.NotificationService/DeleteAllByUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAllByUserRequest): Buffer =>
      Buffer.from(DeleteAllByUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteAllByUserRequest => DeleteAllByUserRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  deleteOlderThan: {
    path: "/notifications.NotificationService/DeleteOlderThan",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteOlderThanRequest): Buffer =>
      Buffer.from(DeleteOlderThanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteOlderThanRequest => DeleteOlderThanRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  /** ===== Business Notifications ===== */
  notifyNewClient: {
    path: "/notifications.NotificationService/NotifyNewClient",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyNewClientRequest): Buffer =>
      Buffer.from(NotifyNewClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyNewClientRequest => NotifyNewClientRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyNewContrat: {
    path: "/notifications.NotificationService/NotifyNewContrat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyNewContratRequest): Buffer =>
      Buffer.from(NotifyNewContratRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyNewContratRequest => NotifyNewContratRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyContratExpiringSoon: {
    path: "/notifications.NotificationService/NotifyContratExpiringSoon",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyContratExpiringRequest): Buffer =>
      Buffer.from(NotifyContratExpiringRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyContratExpiringRequest => NotifyContratExpiringRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyContratExpired: {
    path: "/notifications.NotificationService/NotifyContratExpired",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyContratExpiringRequest): Buffer =>
      Buffer.from(NotifyContratExpiringRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyContratExpiringRequest => NotifyContratExpiringRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyImpaye: {
    path: "/notifications.NotificationService/NotifyImpaye",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyImpayeRequest): Buffer => Buffer.from(NotifyImpayeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyImpayeRequest => NotifyImpayeRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyTacheAssignee: {
    path: "/notifications.NotificationService/NotifyTacheAssignee",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyTacheRequest): Buffer => Buffer.from(NotifyTacheRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyTacheRequest => NotifyTacheRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyRappel: {
    path: "/notifications.NotificationService/NotifyRappel",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyRappelRequest): Buffer => Buffer.from(NotifyRappelRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyRappelRequest => NotifyRappelRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyAlerte: {
    path: "/notifications.NotificationService/NotifyAlerte",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyAlerteRequest): Buffer => Buffer.from(NotifyAlerteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyAlerteRequest => NotifyAlerteRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  notifyInfo: {
    path: "/notifications.NotificationService/NotifyInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyInfoRequest): Buffer => Buffer.from(NotifyInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyInfoRequest => NotifyInfoRequest.decode(value),
    responseSerialize: (value: NotificationResponse): Buffer =>
      Buffer.from(NotificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): NotificationResponse => NotificationResponse.decode(value),
  },
  /** ===== Broadcast ===== */
  notifyOrganisation: {
    path: "/notifications.NotificationService/NotifyOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: NotifyOrganisationRequest): Buffer =>
      Buffer.from(NotifyOrganisationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): NotifyOrganisationRequest => NotifyOrganisationRequest.decode(value),
    responseSerialize: (value: OperationResponse): Buffer => Buffer.from(OperationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OperationResponse => OperationResponse.decode(value),
  },
  /** ===== WebSocket Status ===== */
  getConnectedUsersCount: {
    path: "/notifications.NotificationService/GetConnectedUsersCount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EmptyRequest): Buffer => Buffer.from(EmptyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): EmptyRequest => EmptyRequest.decode(value),
    responseSerialize: (value: ConnectedUsersResponse): Buffer =>
      Buffer.from(ConnectedUsersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConnectedUsersResponse => ConnectedUsersResponse.decode(value),
  },
  isUserConnected: {
    path: "/notifications.NotificationService/IsUserConnected",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IsUserConnectedRequest): Buffer =>
      Buffer.from(IsUserConnectedRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): IsUserConnectedRequest => IsUserConnectedRequest.decode(value),
    responseSerialize: (value: IsUserConnectedResponse): Buffer =>
      Buffer.from(IsUserConnectedResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): IsUserConnectedResponse => IsUserConnectedResponse.decode(value),
  },
} as const;

export interface NotificationServiceServer extends UntypedServiceImplementation {
  /** ===== CRUD Operations ===== */
  createNotification: handleUnaryCall<CreateNotificationRequest, NotificationResponse>;
  getNotification: handleUnaryCall<GetNotificationRequest, NotificationResponse>;
  getNotifications: handleUnaryCall<GetNotificationsRequest, NotificationListResponse>;
  getNotificationsByUser: handleUnaryCall<GetNotificationsByUserRequest, NotificationListResponse>;
  getUnreadNotificationsByUser: handleUnaryCall<GetNotificationsByUserRequest, NotificationListResponse>;
  updateNotification: handleUnaryCall<UpdateNotificationRequest, NotificationResponse>;
  deleteNotification: handleUnaryCall<DeleteNotificationRequest, DeleteResponse>;
  /** ===== Read Status Management ===== */
  markAsRead: handleUnaryCall<MarkAsReadRequest, NotificationResponse>;
  markAllAsRead: handleUnaryCall<MarkAllAsReadRequest, OperationResponse>;
  getUnreadCount: handleUnaryCall<GetUnreadCountRequest, UnreadCountResponse>;
  /** ===== Batch Operations ===== */
  deleteAllByUser: handleUnaryCall<DeleteAllByUserRequest, OperationResponse>;
  deleteOlderThan: handleUnaryCall<DeleteOlderThanRequest, OperationResponse>;
  /** ===== Business Notifications ===== */
  notifyNewClient: handleUnaryCall<NotifyNewClientRequest, NotificationResponse>;
  notifyNewContrat: handleUnaryCall<NotifyNewContratRequest, NotificationResponse>;
  notifyContratExpiringSoon: handleUnaryCall<NotifyContratExpiringRequest, NotificationResponse>;
  notifyContratExpired: handleUnaryCall<NotifyContratExpiringRequest, NotificationResponse>;
  notifyImpaye: handleUnaryCall<NotifyImpayeRequest, NotificationResponse>;
  notifyTacheAssignee: handleUnaryCall<NotifyTacheRequest, NotificationResponse>;
  notifyRappel: handleUnaryCall<NotifyRappelRequest, NotificationResponse>;
  notifyAlerte: handleUnaryCall<NotifyAlerteRequest, NotificationResponse>;
  notifyInfo: handleUnaryCall<NotifyInfoRequest, NotificationResponse>;
  /** ===== Broadcast ===== */
  notifyOrganisation: handleUnaryCall<NotifyOrganisationRequest, OperationResponse>;
  /** ===== WebSocket Status ===== */
  getConnectedUsersCount: handleUnaryCall<EmptyRequest, ConnectedUsersResponse>;
  isUserConnected: handleUnaryCall<IsUserConnectedRequest, IsUserConnectedResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
