// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: payments/payment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export enum PaymentStatus {
  PAYMENT_STATUS_UNSPECIFIED = 0,
  PAYMENT_STATUS_PENDING = 1,
  PAYMENT_STATUS_SUBMITTED = 2,
  PAYMENT_STATUS_PAID = 3,
  PAYMENT_STATUS_REJECTED = 4,
  PAYMENT_STATUS_REFUNDED = 5,
  PAYMENT_STATUS_CANCELLED = 6,
  PAYMENT_STATUS_FAILED = 7,
}

export enum MandateStatus {
  MANDATE_STATUS_UNSPECIFIED = 0,
  MANDATE_STATUS_PENDING_CUSTOMER_APPROVAL = 1,
  MANDATE_STATUS_PENDING_SUBMISSION = 2,
  MANDATE_STATUS_SUBMITTED = 3,
  MANDATE_STATUS_ACTIVE = 4,
  MANDATE_STATUS_SUSPENDED_BY_PAYER = 5,
  MANDATE_STATUS_FAILED = 6,
  MANDATE_STATUS_CANCELLED = 7,
  MANDATE_STATUS_EXPIRED = 8,
  MANDATE_STATUS_CONSUMED = 9,
  MANDATE_STATUS_BLOCKED = 10,
}

export enum ScheduleStatus {
  SCHEDULE_STATUS_UNSPECIFIED = 0,
  SCHEDULE_STATUS_ACTIVE = 1,
  SCHEDULE_STATUS_PAUSED = 2,
  SCHEDULE_STATUS_CANCELLED = 3,
  SCHEDULE_STATUS_COMPLETED = 4,
}

export enum AuditAction {
  AUDIT_ACTION_UNSPECIFIED = 0,
  AUDIT_ACTION_PAYMENT_CREATED = 1,
  AUDIT_ACTION_PAYMENT_SUBMITTED = 2,
  AUDIT_ACTION_PAYMENT_SUCCEEDED = 3,
  AUDIT_ACTION_PAYMENT_FAILED = 4,
  AUDIT_ACTION_PAYMENT_CANCELLED = 5,
  AUDIT_ACTION_PAYMENT_REFUNDED = 6,
  AUDIT_ACTION_MANDATE_CREATED = 7,
  AUDIT_ACTION_MANDATE_ACTIVATED = 8,
  AUDIT_ACTION_MANDATE_CANCELLED = 9,
  AUDIT_ACTION_SCHEDULE_CREATED = 10,
  AUDIT_ACTION_SCHEDULE_PAUSED = 11,
  AUDIT_ACTION_SCHEDULE_RESUMED = 12,
  AUDIT_ACTION_SCHEDULE_CANCELLED = 13,
}

/** Portal session status */
export enum PortalSessionStatus {
  PORTAL_SESSION_STATUS_UNSPECIFIED = 0,
  /** PORTAL_SESSION_CREATED - Session created, token generated */
  PORTAL_SESSION_CREATED = 1,
  /** PORTAL_SESSION_ACTIVE - First accessed */
  PORTAL_SESSION_ACTIVE = 2,
  /** PORTAL_SESSION_REDIRECTED - Redirected to PSP */
  PORTAL_SESSION_REDIRECTED = 3,
  /** PORTAL_SESSION_COMPLETED - Payment completed */
  PORTAL_SESSION_COMPLETED = 4,
  /** PORTAL_SESSION_FAILED - Payment failed */
  PORTAL_SESSION_FAILED = 5,
  /** PORTAL_SESSION_EXPIRED - TTL exceeded */
  PORTAL_SESSION_EXPIRED = 6,
  /** PORTAL_SESSION_CANCELLED - Manually cancelled */
  PORTAL_SESSION_CANCELLED = 7,
}

/** Allowed actions on portal */
export enum PortalSessionAction {
  PORTAL_SESSION_ACTION_UNSPECIFIED = 0,
  /** PORTAL_ACTION_PAY_NOW - Immediate payment */
  PORTAL_ACTION_PAY_NOW = 1,
  /** PORTAL_ACTION_UPDATE_CARD - Update payment method */
  PORTAL_ACTION_UPDATE_CARD = 2,
  /** PORTAL_ACTION_SETUP_MANDATE - Setup direct debit mandate */
  PORTAL_ACTION_SETUP_MANDATE = 3,
}

/** Portal error codes */
export enum PortalErrorCode {
  PORTAL_ERROR_CODE_UNSPECIFIED = 0,
  PORTAL_ERROR_SESSION_NOT_FOUND = 1,
  PORTAL_ERROR_SESSION_EXPIRED = 2,
  PORTAL_ERROR_SESSION_ALREADY_USED = 3,
  PORTAL_ERROR_SESSION_REVOKED = 4,
  PORTAL_ERROR_SESSION_TERMINAL = 5,
  PORTAL_ERROR_INVALID_TOKEN = 6,
  PORTAL_ERROR_TOKEN_MALFORMED = 7,
  PORTAL_ERROR_INVALID_TRANSITION = 8,
  PORTAL_ERROR_ACTION_NOT_ALLOWED = 9,
}

/** PSP provider for portal */
export enum PortalPspProvider {
  PORTAL_PSP_PROVIDER_UNSPECIFIED = 0,
  PORTAL_PSP_STRIPE = 1,
  PORTAL_PSP_GOCARDLESS = 2,
  PORTAL_PSP_SLIMPAY = 3,
  PORTAL_PSP_EMERCHANTPAY = 4,
}

/** Portal audit event types */
export enum PortalAuditEventType {
  PORTAL_AUDIT_EVENT_UNSPECIFIED = 0,
  PORTAL_SESSION_CREATED_EVENT = 1,
  PORTAL_SESSION_ACTIVATED_EVENT = 2,
  PORTAL_TOKEN_VALIDATED_EVENT = 3,
  PORTAL_TOKEN_REJECTED_EVENT = 4,
  PORTAL_SESSION_ACCESSED_EVENT = 5,
  PORTAL_REDIRECT_INITIATED_EVENT = 6,
  PORTAL_PAYMENT_INITIATED_EVENT = 7,
  PORTAL_PAYMENT_COMPLETED_EVENT = 8,
  PORTAL_PAYMENT_FAILED_EVENT = 9,
  PORTAL_SESSION_EXPIRED_EVENT = 10,
  PORTAL_SESSION_CANCELLED_EVENT = 11,
}

/** Actor type for portal audit */
export enum PortalAuditActorType {
  PORTAL_AUDIT_ACTOR_UNSPECIFIED = 0,
  PORTAL_ACTOR_SYSTEM = 1,
  PORTAL_ACTOR_ADMIN = 2,
  PORTAL_ACTOR_PORTAL_TOKEN = 3,
  PORTAL_ACTOR_WEBHOOK = 4,
}

export interface Empty {
}

export interface GetByIdRequest {
  id: string;
  /** Pour le multi-tenant */
  societeId: string;
}

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface CreateStripeCheckoutSessionRequest {
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  /** 'payment', 'subscription', 'setup' */
  mode: string;
  successUrl: string;
  cancelUrl: string;
  customerId?: string | undefined;
  customerEmail?:
    | string
    | undefined;
  /** Pour les abonnements */
  priceId?: string | undefined;
  metadata: { [key: string]: string };
  lineItems: LineItem[];
}

export interface CreateStripeCheckoutSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface LineItem {
  name: string;
  description: string;
  amount: number;
  quantity: number;
  currency: string;
}

export interface StripeCheckoutSessionResponse {
  id: string;
  url: string;
  status: string;
  paymentStatus: string;
  customerId?: string | undefined;
  subscriptionId?: string | undefined;
}

export interface CreateStripePaymentIntentRequest {
  societeId: string;
  amount: number;
  currency: string;
  customerId?: string | undefined;
  description?: string | undefined;
  paymentMethod?: string | undefined;
  confirm: boolean;
  automaticPaymentMethods: boolean;
  metadata: { [key: string]: string };
}

export interface CreateStripePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripePaymentIntentResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  clientSecret?: string | undefined;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeCustomerRequest {
  societeId: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  description?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeCustomerRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeCustomerResponse {
  id: string;
  email: string;
  name?: string | undefined;
  phone?: string | undefined;
  created: number;
}

export interface CreateStripeSubscriptionRequest {
  societeId: string;
  customerId: string;
  priceId: string;
  paymentMethod?: string | undefined;
  defaultPaymentMethod?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateStripeSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSubscriptionResponse {
  id: string;
  customerId: string;
  status: string;
  currentPeriodStart: number;
  currentPeriodEnd: number;
  cancelAtPeriodEnd: boolean;
}

export interface CreateStripeRefundRequest {
  societeId: string;
  paymentIntentId: string;
  /** Partial refund, omit for full */
  amount?: number | undefined;
  reason?: string | undefined;
}

export interface StripeRefundResponse {
  id: string;
  amount: number;
  currency: string;
  status: string;
  paymentIntentId: string;
}

export interface CreateStripeSetupIntentRequest {
  societeId: string;
  customerId?: string | undefined;
  paymentMethodTypes: string[];
  metadata: { [key: string]: string };
}

export interface CreateStripeSetupIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StripeSetupIntentResponse {
  id: string;
  clientSecret: string;
  status: string;
  customerId?: string | undefined;
  paymentMethod?: string | undefined;
}

export interface CreateStripeBillingPortalRequest {
  societeId: string;
  customerId: string;
  returnUrl: string;
}

export interface StripeBillingPortalResponse {
  id: string;
  url: string;
}

export interface CreatePayPalOrderRequest {
  societeId: string;
  /** 'CAPTURE' or 'AUTHORIZE' */
  intent: string;
  purchaseUnits: PayPalPurchaseUnit[];
  returnUrl: string;
  cancelUrl: string;
  metadata: { [key: string]: string };
}

export interface CreatePayPalOrderRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PayPalPurchaseUnit {
  referenceId?:
    | string
    | undefined;
  /** En centimes */
  amount: number;
  currency: string;
  description?: string | undefined;
  customId?: string | undefined;
  invoiceId?: string | undefined;
}

export interface PayPalOrderResponse {
  id: string;
  status: string;
  approveUrl?: string | undefined;
  captureUrl?: string | undefined;
  links: PayPalLink[];
}

export interface PayPalLink {
  href: string;
  rel: string;
  method: string;
}

export interface GetPayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface CapturePayPalOrderRequest {
  orderId: string;
  societeId: string;
}

export interface PayPalCaptureResponse {
  id: string;
  status: string;
  payer?: PayPalPayer | undefined;
  purchaseUnits: PayPalCapturedPurchaseUnit[];
}

export interface PayPalPayer {
  emailAddress?: string | undefined;
  payerId?: string | undefined;
  givenName?: string | undefined;
  surname?: string | undefined;
}

export interface PayPalCapturedPurchaseUnit {
  referenceId?: string | undefined;
  captures: PayPalCapture[];
}

export interface PayPalCapture {
  id: string;
  status: string;
  amount?: PayPalAmount | undefined;
}

export interface PayPalAmount {
  currencyCode: string;
  value: string;
}

export interface SetupGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
  /** 'bacs', 'sepa_core', 'ach', etc. */
  scheme: string;
  description?: string | undefined;
  successRedirectUrl: string;
  sessionToken?: string | undefined;
}

export interface GoCardlessMandateResponse {
  id: string;
  clientId: string;
  mandateId: string;
  status: string;
  scheme: string;
  bankName?: string | undefined;
  accountHolderName?: string | undefined;
  accountNumberEnding?: string | undefined;
  redirectUrl?: string | undefined;
}

export interface GetGoCardlessMandateRequest {
  clientId: string;
  societeId: string;
}

export interface CreateGoCardlessPaymentRequest {
  clientId: string;
  societeId: string;
  /** En centimes */
  amount: number;
  currency: string;
  description?:
    | string
    | undefined;
  /** YYYY-MM-DD */
  chargeDate?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessPaymentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessPaymentResponse {
  id: string;
  paymentId: string;
  amount: number;
  currency: string;
  status: string;
  chargeDate?: string | undefined;
}

export interface CreateGoCardlessSubscriptionRequest {
  clientId: string;
  societeId: string;
  amount: number;
  currency: string;
  /** 'weekly', 'monthly', 'yearly' */
  intervalUnit: string;
  interval: number;
  name?: string | undefined;
  startDate?:
    | string
    | undefined;
  /** Number of payments, omit for indefinite */
  count?: number | undefined;
  metadata: { [key: string]: string };
}

export interface CreateGoCardlessSubscriptionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface GoCardlessSubscriptionResponse {
  id: string;
  subscriptionId: string;
  amount: number;
  currency: string;
  status: string;
  intervalUnit: string;
  interval: number;
  nextPaymentDate?: string | undefined;
}

export interface CancelGoCardlessSubscriptionRequest {
  subscriptionId: string;
  societeId: string;
}

export interface CreateScheduleRequest {
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  /** ISO date string */
  dueDate: string;
  description?: string | undefined;
  autoProcess: boolean;
  metadata: { [key: string]: string };
}

export interface CreateScheduleRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface ScheduleResponse {
  id: string;
  organisationId: string;
  societeId: string;
  contratId?: string | undefined;
  factureId?: string | undefined;
  clientId?: string | undefined;
  amount: number;
  currency: string;
  dueDate: string;
  /** PLANNED, PROCESSING, PENDING, PAID, FAILED, UNPAID, CANCELLED, EXPIRED */
  status: string;
  lastAttemptAt?: string | undefined;
  paidAt?: string | undefined;
  retryCount: number;
  errorMessage?: string | undefined;
}

export interface UpdateScheduleRequest {
  id: string;
  amount?: number | undefined;
  dueDate?: string | undefined;
  status?: string | undefined;
  autoProcess?: boolean | undefined;
}

export interface GetDueSchedulesRequest {
  organisationId: string;
  /** Get schedules due before this date */
  beforeDate?: string | undefined;
}

export interface ScheduleListResponse {
  schedules: ScheduleResponse[];
  total: number;
}

export interface ProcessDuePaymentsRequest {
  organisationId: string;
  /** If true, don't actually process */
  dryRun?: boolean | undefined;
}

export interface ProcessDuePaymentsResponse {
  processedCount: number;
  successCount: number;
  failedCount: number;
  results: ProcessedPayment[];
}

export interface ProcessedPayment {
  scheduleId: string;
  success: boolean;
  paymentId?: string | undefined;
  error?: string | undefined;
}

export interface RenewScheduleRequest {
  id: string;
  newDueDate: string;
  newAmount?: number | undefined;
}

export interface CreatePaymentIntentRequest {
  organisationId: string;
  societeId: string;
  scheduleId?:
    | string
    | undefined;
  /** STRIPE, PAYPAL, GOCARDLESS, etc. */
  pspName: string;
  amount: number;
  currency: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreatePaymentIntentRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface PaymentIntentResponse {
  id: string;
  organisationId: string;
  societeId: string;
  scheduleId?: string | undefined;
  pspName: string;
  pspPaymentId?: string | undefined;
  amount: number;
  currency: string;
  /** PENDING, PROCESSING, SUCCEEDED, FAILED, CANCELLED */
  status: string;
  mandateReference?: string | undefined;
  idempotencyKey?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  createdAt: string;
  updatedAt?: string | undefined;
}

export interface UpdatePaymentIntentRequest {
  id: string;
  status?: string | undefined;
  pspPaymentId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface CreatePaymentEventRequest {
  organisationId: string;
  paymentIntentId: string;
  /** PAYMENT_INITIATED, PAYMENT_CONFIRMED, PAYMENT_FAILED, etc. */
  eventType: string;
  /** JSON string */
  rawPayload: string;
}

export interface PaymentEventResponse {
  id: string;
  organisationId: string;
  paymentIntentId: string;
  eventType: string;
  rawPayload: string;
  receivedAt: string;
  processed: boolean;
  processedAt?: string | undefined;
  errorMessage?: string | undefined;
}

export interface GetUnprocessedEventsRequest {
  organisationId: string;
  limit?: number | undefined;
}

export interface PaymentEventListResponse {
  events: PaymentEventResponse[];
  total: number;
}

export interface MarkEventProcessedRequest {
  id: string;
  /** If processing failed */
  errorMessage?: string | undefined;
}

export interface GetPSPAccountsRequest {
  societeId: string;
}

export interface PSPAccountsSummaryResponse {
  stripe?: PSPAccountInfo | undefined;
  paypal?: PSPAccountInfo | undefined;
  gocardless?: PSPAccountInfo | undefined;
  emerchantpay?: PSPAccountInfo | undefined;
  slimpay?: PSPAccountInfo | undefined;
  multisafepay?: PSPAccountInfo | undefined;
}

export interface PSPAccountInfo {
  id: string;
  name: string;
  isActive: boolean;
  isLiveMode: boolean;
  isConfigured: boolean;
}

/** Request to create a portal session */
export interface CreatePortalSessionRequest {
  organisationId: string;
  societeId: string;
  customerId: string;
  contractId?: string | undefined;
  paymentIntentId?: string | undefined;
  allowedActions: PortalSessionAction[];
  /** Time-to-live, default 900 (15 min) */
  ttlSeconds?:
    | number
    | undefined;
  /** Default 1 */
  maxUses?: number | undefined;
  amountCents: number;
  /** Default EUR */
  currency?: string | undefined;
  description?: string | undefined;
  mandateId?:
    | string
    | undefined;
  /** Masked RUM for display */
  rumMasked?: string | undefined;
  idempotencyKey?: string | undefined;
  metadata: { [key: string]: string };
}

export interface CreatePortalSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

/** Response after creating a portal session */
export interface CreatePortalSessionResponse {
  session?:
    | PortalPaymentSession
    | undefined;
  /** One-time use token (returned only on creation) */
  token: string;
  /** Full URL to the payment portal */
  portalUrl: string;
  /** True if returned from idempotency cache */
  wasIdempotentHit: boolean;
}

/** Portal payment session entity */
export interface PortalPaymentSession {
  id: string;
  organisationId: string;
  societeId: string;
  customerId: string;
  contractId?: string | undefined;
  paymentIntentId?:
    | string
    | undefined;
  /** Token (hash stored, never exposed) */
  tokenVersion: string;
  /** State */
  status: PortalSessionStatus;
  allowedActions: PortalSessionAction[];
  /** Timing */
  expiresAt: string;
  maxUses: number;
  useCount: number;
  consumedAt?: string | undefined;
  revokedAt?: string | undefined;
  lastAccessedAt?:
    | string
    | undefined;
  /** Payment details */
  amountCents: number;
  currency: string;
  description?: string | undefined;
  mandateId?: string | undefined;
  rumMasked?:
    | string
    | undefined;
  /** PSP state (for redirect flow) */
  pspState?: string | undefined;
  pspRedirectUrl?: string | undefined;
  pspProvider?: PortalPspProvider | undefined;
  pspSessionId?:
    | string
    | undefined;
  /** Metadata */
  metadata: { [key: string]: string };
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

export interface PortalPaymentSession_MetadataEntry {
  key: string;
  value: string;
}

/** Validate a portal token */
export interface ValidatePortalTokenRequest {
  token: string;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface ValidatePortalTokenResponse {
  valid: boolean;
  session?: PortalPaymentSession | undefined;
  errorCode?: PortalErrorCode | undefined;
  errorMessage?: string | undefined;
}

/** Access a portal session (marks as active) */
export interface AccessPortalSessionRequest {
  token: string;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface AccessPortalSessionResponse {
  session?: PortalPaymentSession | undefined;
}

/** Consume a portal token (for payment action) */
export interface ConsumePortalTokenRequest {
  token: string;
  action: PortalSessionAction;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
}

export interface ConsumePortalTokenResponse {
  session?: PortalPaymentSession | undefined;
}

/** Cancel a portal session */
export interface CancelPortalSessionRequest {
  sessionId: string;
  reason?: string | undefined;
}

export interface CancelPortalSessionResponse {
  session?: PortalPaymentSession | undefined;
}

/** Update PSP info on portal session */
export interface UpdatePortalPspInfoRequest {
  sessionId: string;
  pspState: string;
  pspRedirectUrl: string;
  pspProvider: PortalPspProvider;
  pspSessionId: string;
}

export interface UpdatePortalPspInfoResponse {
  success: boolean;
}

/** Transition portal session status */
export interface TransitionPortalSessionRequest {
  sessionId: string;
  newStatus: PortalSessionStatus;
  reason?: string | undefined;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
}

export interface TransitionPortalSessionResponse {
  session?: PortalPaymentSession | undefined;
}

/** Portal session audit log entry */
export interface PortalSessionAuditLog {
  id: string;
  portalSessionId: string;
  eventType: PortalAuditEventType;
  actorType: PortalAuditActorType;
  previousStatus?: string | undefined;
  newStatus?: string | undefined;
  ipAddressHash?: string | undefined;
  userAgentHash?: string | undefined;
  requestId?: string | undefined;
  correlationId?: string | undefined;
  data: { [key: string]: string };
  timestamp: string;
}

export interface PortalSessionAuditLog_DataEntry {
  key: string;
  value: string;
}

/** List portal sessions */
export interface ListPortalSessionsRequest {
  organisationId: string;
  societeId?: string | undefined;
  customerId?: string | undefined;
  status?: PortalSessionStatus | undefined;
  fromDate?: string | undefined;
  toDate?: string | undefined;
  page?: number | undefined;
  limit?: number | undefined;
}

export interface ListPortalSessionsResponse {
  sessions: PortalPaymentSession[];
  total: number;
  page: number;
  totalPages: number;
}

/** Get portal session audit logs */
export interface GetPortalSessionAuditRequest {
  sessionId: string;
}

export interface GetPortalSessionAuditResponse {
  logs: PortalSessionAuditLog[];
}

/** Portal session stats */
export interface GetPortalSessionStatsRequest {
  organisationId: string;
  societeId?: string | undefined;
  fromDate: string;
  toDate: string;
}

export interface GetPortalSessionStatsResponse {
  totalCreated: number;
  totalCompleted: number;
  totalFailed: number;
  totalExpired: number;
  totalCancelled: number;
  completionRate: number;
}

/** Request context for portal operations */
export interface PortalRequestContext {
  ipHash?: string | undefined;
  uaHash?: string | undefined;
  requestId?: string | undefined;
  correlationId?: string | undefined;
}

/** GoCardless configuration */
export interface GoCardlessConfig {
  accessToken: string;
  baseUrl: string;
}

/** Slimpay OAuth token (cached) */
export interface SlimpayToken {
  accessToken: string;
  /** Unix timestamp */
  expiresAt: number;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetByIdRequest(): GetByIdRequest {
  return { id: "", societeId: "" };
}

export const GetByIdRequest: MessageFns<GetByIdRequest> = {
  encode(message: GetByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest(): CreateStripeCheckoutSessionRequest {
  return {
    societeId: "",
    amount: 0,
    currency: "",
    mode: "",
    successUrl: "",
    cancelUrl: "",
    metadata: {},
    lineItems: [],
  };
}

export const CreateStripeCheckoutSessionRequest: MessageFns<CreateStripeCheckoutSessionRequest> = {
  encode(message: CreateStripeCheckoutSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.mode !== "") {
      writer.uint32(34).string(message.mode);
    }
    if (message.successUrl !== "") {
      writer.uint32(42).string(message.successUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(50).string(message.cancelUrl);
    }
    if (message.customerId !== undefined) {
      writer.uint32(58).string(message.customerId);
    }
    if (message.customerEmail !== undefined) {
      writer.uint32(66).string(message.customerEmail);
    }
    if (message.priceId !== undefined) {
      writer.uint32(74).string(message.priceId);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeCheckoutSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .join();
    });
    for (const v of message.lineItems) {
      LineItem.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.successUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.customerEmail = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.priceId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateStripeCheckoutSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lineItems.push(LineItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeCheckoutSessionRequest_MetadataEntry(): CreateStripeCheckoutSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCheckoutSessionRequest_MetadataEntry: MessageFns<
  CreateStripeCheckoutSessionRequest_MetadataEntry
> = {
  encode(
    message: CreateStripeCheckoutSessionRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCheckoutSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCheckoutSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLineItem(): LineItem {
  return { name: "", description: "", amount: 0, quantity: 0, currency: "" };
}

export const LineItem: MessageFns<LineItem> = {
  encode(message: LineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStripeCheckoutSessionResponse(): StripeCheckoutSessionResponse {
  return { id: "", url: "", status: "", paymentStatus: "" };
}

export const StripeCheckoutSessionResponse: MessageFns<StripeCheckoutSessionResponse> = {
  encode(message: StripeCheckoutSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.paymentStatus !== "") {
      writer.uint32(34).string(message.paymentStatus);
    }
    if (message.customerId !== undefined) {
      writer.uint32(42).string(message.customerId);
    }
    if (message.subscriptionId !== undefined) {
      writer.uint32(50).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeCheckoutSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCheckoutSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest(): CreateStripePaymentIntentRequest {
  return { societeId: "", amount: 0, currency: "", confirm: false, automaticPaymentMethods: false, metadata: {} };
}

export const CreateStripePaymentIntentRequest: MessageFns<CreateStripePaymentIntentRequest> = {
  encode(message: CreateStripePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(50).string(message.paymentMethod);
    }
    if (message.confirm !== false) {
      writer.uint32(56).bool(message.confirm);
    }
    if (message.automaticPaymentMethods !== false) {
      writer.uint32(64).bool(message.automaticPaymentMethods);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.confirm = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.automaticPaymentMethods = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CreateStripePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripePaymentIntentRequest_MetadataEntry(): CreateStripePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripePaymentIntentRequest_MetadataEntry: MessageFns<
  CreateStripePaymentIntentRequest_MetadataEntry
> = {
  encode(
    message: CreateStripePaymentIntentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStripePaymentIntentResponse(): StripePaymentIntentResponse {
  return { id: "", amount: 0, currency: "", status: "" };
}

export const StripePaymentIntentResponse: MessageFns<StripePaymentIntentResponse> = {
  encode(message: StripePaymentIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.clientSecret !== undefined) {
      writer.uint32(42).string(message.clientSecret);
    }
    if (message.customerId !== undefined) {
      writer.uint32(50).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(58).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripePaymentIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeCustomerRequest(): CreateStripeCustomerRequest {
  return { societeId: "", email: "", metadata: {} };
}

export const CreateStripeCustomerRequest: MessageFns<CreateStripeCustomerRequest> = {
  encode(message: CreateStripeCustomerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeCustomerRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCustomerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeCustomerRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeCustomerRequest_MetadataEntry(): CreateStripeCustomerRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeCustomerRequest_MetadataEntry: MessageFns<CreateStripeCustomerRequest_MetadataEntry> = {
  encode(message: CreateStripeCustomerRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeCustomerRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeCustomerRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStripeCustomerResponse(): StripeCustomerResponse {
  return { id: "", email: "", created: 0 };
}

export const StripeCustomerResponse: MessageFns<StripeCustomerResponse> = {
  encode(message: StripeCustomerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.created !== 0) {
      writer.uint32(40).int64(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeCustomerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeCustomerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.created = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest(): CreateStripeSubscriptionRequest {
  return { societeId: "", customerId: "", priceId: "", metadata: {} };
}

export const CreateStripeSubscriptionRequest: MessageFns<CreateStripeSubscriptionRequest> = {
  encode(message: CreateStripeSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.priceId !== "") {
      writer.uint32(26).string(message.priceId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(34).string(message.paymentMethod);
    }
    if (message.defaultPaymentMethod !== undefined) {
      writer.uint32(42).string(message.defaultPaymentMethod);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultPaymentMethod = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreateStripeSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeSubscriptionRequest_MetadataEntry(): CreateStripeSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSubscriptionRequest_MetadataEntry: MessageFns<CreateStripeSubscriptionRequest_MetadataEntry> =
  {
    encode(
      message: CreateStripeSubscriptionRequest_MetadataEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSubscriptionRequest_MetadataEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCreateStripeSubscriptionRequest_MetadataEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseStripeSubscriptionResponse(): StripeSubscriptionResponse {
  return { id: "", customerId: "", status: "", currentPeriodStart: 0, currentPeriodEnd: 0, cancelAtPeriodEnd: false };
}

export const StripeSubscriptionResponse: MessageFns<StripeSubscriptionResponse> = {
  encode(message: StripeSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.currentPeriodStart !== 0) {
      writer.uint32(32).int64(message.currentPeriodStart);
    }
    if (message.currentPeriodEnd !== 0) {
      writer.uint32(40).int64(message.currentPeriodEnd);
    }
    if (message.cancelAtPeriodEnd !== false) {
      writer.uint32(48).bool(message.cancelAtPeriodEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currentPeriodStart = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.currentPeriodEnd = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cancelAtPeriodEnd = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeRefundRequest(): CreateStripeRefundRequest {
  return { societeId: "", paymentIntentId: "" };
}

export const CreateStripeRefundRequest: MessageFns<CreateStripeRefundRequest> = {
  encode(message: CreateStripeRefundRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.amount !== undefined) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeRefundRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStripeRefundResponse(): StripeRefundResponse {
  return { id: "", amount: 0, currency: "", status: "", paymentIntentId: "" };
}

export const StripeRefundResponse: MessageFns<StripeRefundResponse> = {
  encode(message: StripeRefundResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(42).string(message.paymentIntentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeRefundResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest(): CreateStripeSetupIntentRequest {
  return { societeId: "", paymentMethodTypes: [], metadata: {} };
}

export const CreateStripeSetupIntentRequest: MessageFns<CreateStripeSetupIntentRequest> = {
  encode(message: CreateStripeSetupIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== undefined) {
      writer.uint32(18).string(message.customerId);
    }
    for (const v of message.paymentMethodTypes) {
      writer.uint32(26).string(v!);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateStripeSetupIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSetupIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentMethodTypes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateStripeSetupIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeSetupIntentRequest_MetadataEntry(): CreateStripeSetupIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateStripeSetupIntentRequest_MetadataEntry: MessageFns<CreateStripeSetupIntentRequest_MetadataEntry> = {
  encode(
    message: CreateStripeSetupIntentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeSetupIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeSetupIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStripeSetupIntentResponse(): StripeSetupIntentResponse {
  return { id: "", clientSecret: "", status: "" };
}

export const StripeSetupIntentResponse: MessageFns<StripeSetupIntentResponse> = {
  encode(message: StripeSetupIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.customerId !== undefined) {
      writer.uint32(34).string(message.customerId);
    }
    if (message.paymentMethod !== undefined) {
      writer.uint32(42).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeSetupIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeSetupIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStripeBillingPortalRequest(): CreateStripeBillingPortalRequest {
  return { societeId: "", customerId: "", returnUrl: "" };
}

export const CreateStripeBillingPortalRequest: MessageFns<CreateStripeBillingPortalRequest> = {
  encode(message: CreateStripeBillingPortalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.returnUrl !== "") {
      writer.uint32(26).string(message.returnUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeBillingPortalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeBillingPortalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStripeBillingPortalResponse(): StripeBillingPortalResponse {
  return { id: "", url: "" };
}

export const StripeBillingPortalResponse: MessageFns<StripeBillingPortalResponse> = {
  encode(message: StripeBillingPortalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StripeBillingPortalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStripeBillingPortalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePayPalOrderRequest(): CreatePayPalOrderRequest {
  return { societeId: "", intent: "", purchaseUnits: [], returnUrl: "", cancelUrl: "", metadata: {} };
}

export const CreatePayPalOrderRequest: MessageFns<CreatePayPalOrderRequest> = {
  encode(message: CreatePayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    if (message.intent !== "") {
      writer.uint32(18).string(message.intent);
    }
    for (const v of message.purchaseUnits) {
      PayPalPurchaseUnit.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.returnUrl !== "") {
      writer.uint32(34).string(message.returnUrl);
    }
    if (message.cancelUrl !== "") {
      writer.uint32(42).string(message.cancelUrl);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePayPalOrderRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.intent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.purchaseUnits.push(PayPalPurchaseUnit.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cancelUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = CreatePayPalOrderRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePayPalOrderRequest_MetadataEntry(): CreatePayPalOrderRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePayPalOrderRequest_MetadataEntry: MessageFns<CreatePayPalOrderRequest_MetadataEntry> = {
  encode(message: CreatePayPalOrderRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePayPalOrderRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePayPalOrderRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalPurchaseUnit(): PayPalPurchaseUnit {
  return { amount: 0, currency: "" };
}

export const PayPalPurchaseUnit: MessageFns<PayPalPurchaseUnit> = {
  encode(message: PayPalPurchaseUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.customId !== undefined) {
      writer.uint32(42).string(message.customId);
    }
    if (message.invoiceId !== undefined) {
      writer.uint32(50).string(message.invoiceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalPurchaseUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.invoiceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalOrderResponse(): PayPalOrderResponse {
  return { id: "", status: "", links: [] };
}

export const PayPalOrderResponse: MessageFns<PayPalOrderResponse> = {
  encode(message: PayPalOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.approveUrl !== undefined) {
      writer.uint32(26).string(message.approveUrl);
    }
    if (message.captureUrl !== undefined) {
      writer.uint32(34).string(message.captureUrl);
    }
    for (const v of message.links) {
      PayPalLink.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.approveUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.captureUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.links.push(PayPalLink.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalLink(): PayPalLink {
  return { href: "", rel: "", method: "" };
}

export const PayPalLink: MessageFns<PayPalLink> = {
  encode(message: PayPalLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.href !== "") {
      writer.uint32(10).string(message.href);
    }
    if (message.rel !== "") {
      writer.uint32(18).string(message.rel);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.href = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPayPalOrderRequest(): GetPayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const GetPayPalOrderRequest: MessageFns<GetPayPalOrderRequest> = {
  encode(message: GetPayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCapturePayPalOrderRequest(): CapturePayPalOrderRequest {
  return { orderId: "", societeId: "" };
}

export const CapturePayPalOrderRequest: MessageFns<CapturePayPalOrderRequest> = {
  encode(message: CapturePayPalOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapturePayPalOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapturePayPalOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalCaptureResponse(): PayPalCaptureResponse {
  return { id: "", status: "", purchaseUnits: [] };
}

export const PayPalCaptureResponse: MessageFns<PayPalCaptureResponse> = {
  encode(message: PayPalCaptureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.payer !== undefined) {
      PayPalPayer.encode(message.payer, writer.uint32(26).fork()).join();
    }
    for (const v of message.purchaseUnits) {
      PayPalCapturedPurchaseUnit.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCaptureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCaptureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payer = PayPalPayer.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.purchaseUnits.push(PayPalCapturedPurchaseUnit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalPayer(): PayPalPayer {
  return {};
}

export const PayPalPayer: MessageFns<PayPalPayer> = {
  encode(message: PayPalPayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailAddress !== undefined) {
      writer.uint32(10).string(message.emailAddress);
    }
    if (message.payerId !== undefined) {
      writer.uint32(18).string(message.payerId);
    }
    if (message.givenName !== undefined) {
      writer.uint32(26).string(message.givenName);
    }
    if (message.surname !== undefined) {
      writer.uint32(34).string(message.surname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalPayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalPayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.givenName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.surname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalCapturedPurchaseUnit(): PayPalCapturedPurchaseUnit {
  return { captures: [] };
}

export const PayPalCapturedPurchaseUnit: MessageFns<PayPalCapturedPurchaseUnit> = {
  encode(message: PayPalCapturedPurchaseUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== undefined) {
      writer.uint32(10).string(message.referenceId);
    }
    for (const v of message.captures) {
      PayPalCapture.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCapturedPurchaseUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapturedPurchaseUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.captures.push(PayPalCapture.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalCapture(): PayPalCapture {
  return { id: "", status: "" };
}

export const PayPalCapture: MessageFns<PayPalCapture> = {
  encode(message: PayPalCapture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.amount !== undefined) {
      PayPalAmount.encode(message.amount, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalCapture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = PayPalAmount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePayPalAmount(): PayPalAmount {
  return { currencyCode: "", value: "" };
}

export const PayPalAmount: MessageFns<PayPalAmount> = {
  encode(message: PayPalAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PayPalAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayPalAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSetupGoCardlessMandateRequest(): SetupGoCardlessMandateRequest {
  return { clientId: "", societeId: "", scheme: "", successRedirectUrl: "" };
}

export const SetupGoCardlessMandateRequest: MessageFns<SetupGoCardlessMandateRequest> = {
  encode(message: SetupGoCardlessMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheme !== "") {
      writer.uint32(26).string(message.scheme);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.successRedirectUrl !== "") {
      writer.uint32(42).string(message.successRedirectUrl);
    }
    if (message.sessionToken !== undefined) {
      writer.uint32(50).string(message.sessionToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetupGoCardlessMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetupGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.successRedirectUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGoCardlessMandateResponse(): GoCardlessMandateResponse {
  return { id: "", clientId: "", mandateId: "", status: "", scheme: "" };
}

export const GoCardlessMandateResponse: MessageFns<GoCardlessMandateResponse> = {
  encode(message: GoCardlessMandateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.mandateId !== "") {
      writer.uint32(26).string(message.mandateId);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.scheme !== "") {
      writer.uint32(42).string(message.scheme);
    }
    if (message.bankName !== undefined) {
      writer.uint32(50).string(message.bankName);
    }
    if (message.accountHolderName !== undefined) {
      writer.uint32(58).string(message.accountHolderName);
    }
    if (message.accountNumberEnding !== undefined) {
      writer.uint32(66).string(message.accountNumberEnding);
    }
    if (message.redirectUrl !== undefined) {
      writer.uint32(74).string(message.redirectUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessMandateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessMandateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheme = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bankName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accountHolderName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.accountNumberEnding = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.redirectUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetGoCardlessMandateRequest(): GetGoCardlessMandateRequest {
  return { clientId: "", societeId: "" };
}

export const GetGoCardlessMandateRequest: MessageFns<GetGoCardlessMandateRequest> = {
  encode(message: GetGoCardlessMandateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGoCardlessMandateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGoCardlessMandateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest(): CreateGoCardlessPaymentRequest {
  return { clientId: "", societeId: "", amount: 0, currency: "", metadata: {} };
}

export const CreateGoCardlessPaymentRequest: MessageFns<CreateGoCardlessPaymentRequest> = {
  encode(message: CreateGoCardlessPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateGoCardlessPaymentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = CreateGoCardlessPaymentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateGoCardlessPaymentRequest_MetadataEntry(): CreateGoCardlessPaymentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessPaymentRequest_MetadataEntry: MessageFns<CreateGoCardlessPaymentRequest_MetadataEntry> = {
  encode(
    message: CreateGoCardlessPaymentRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessPaymentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessPaymentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGoCardlessPaymentResponse(): GoCardlessPaymentResponse {
  return { id: "", paymentId: "", amount: 0, currency: "", status: "" };
}

export const GoCardlessPaymentResponse: MessageFns<GoCardlessPaymentResponse> = {
  encode(message: GoCardlessPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.chargeDate !== undefined) {
      writer.uint32(50).string(message.chargeDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.chargeDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest(): CreateGoCardlessSubscriptionRequest {
  return { clientId: "", societeId: "", amount: 0, currency: "", intervalUnit: "", interval: 0, metadata: {} };
}

export const CreateGoCardlessSubscriptionRequest: MessageFns<CreateGoCardlessSubscriptionRequest> = {
  encode(message: CreateGoCardlessSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(42).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(48).int32(message.interval);
    }
    if (message.name !== undefined) {
      writer.uint32(58).string(message.name);
    }
    if (message.startDate !== undefined) {
      writer.uint32(66).string(message.startDate);
    }
    if (message.count !== undefined) {
      writer.uint32(72).int32(message.count);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateGoCardlessSubscriptionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.interval = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.startDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CreateGoCardlessSubscriptionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry(): CreateGoCardlessSubscriptionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateGoCardlessSubscriptionRequest_MetadataEntry: MessageFns<
  CreateGoCardlessSubscriptionRequest_MetadataEntry
> = {
  encode(
    message: CreateGoCardlessSubscriptionRequest_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGoCardlessSubscriptionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGoCardlessSubscriptionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGoCardlessSubscriptionResponse(): GoCardlessSubscriptionResponse {
  return { id: "", subscriptionId: "", amount: 0, currency: "", status: "", intervalUnit: "", interval: 0 };
}

export const GoCardlessSubscriptionResponse: MessageFns<GoCardlessSubscriptionResponse> = {
  encode(message: GoCardlessSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(18).string(message.subscriptionId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.intervalUnit !== "") {
      writer.uint32(50).string(message.intervalUnit);
    }
    if (message.interval !== 0) {
      writer.uint32(56).int32(message.interval);
    }
    if (message.nextPaymentDate !== undefined) {
      writer.uint32(66).string(message.nextPaymentDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.intervalUnit = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.interval = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nextPaymentDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelGoCardlessSubscriptionRequest(): CancelGoCardlessSubscriptionRequest {
  return { subscriptionId: "", societeId: "" };
}

export const CancelGoCardlessSubscriptionRequest: MessageFns<CancelGoCardlessSubscriptionRequest> = {
  encode(message: CancelGoCardlessSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelGoCardlessSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelGoCardlessSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateScheduleRequest(): CreateScheduleRequest {
  return { organisationId: "", societeId: "", amount: 0, currency: "", dueDate: "", autoProcess: false, metadata: {} };
}

export const CreateScheduleRequest: MessageFns<CreateScheduleRequest> = {
  encode(message: CreateScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(26).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(34).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(42).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(48).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(66).string(message.dueDate);
    }
    if (message.description !== undefined) {
      writer.uint32(74).string(message.description);
    }
    if (message.autoProcess !== false) {
      writer.uint32(80).bool(message.autoProcess);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateScheduleRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = CreateScheduleRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.metadata[entry11.key] = entry11.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateScheduleRequest_MetadataEntry(): CreateScheduleRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateScheduleRequest_MetadataEntry: MessageFns<CreateScheduleRequest_MetadataEntry> = {
  encode(message: CreateScheduleRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateScheduleRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateScheduleRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseScheduleResponse(): ScheduleResponse {
  return { id: "", organisationId: "", societeId: "", amount: 0, currency: "", dueDate: "", status: "", retryCount: 0 };
}

export const ScheduleResponse: MessageFns<ScheduleResponse> = {
  encode(message: ScheduleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(42).string(message.factureId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(50).string(message.clientId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.dueDate !== "") {
      writer.uint32(74).string(message.dueDate);
    }
    if (message.status !== "") {
      writer.uint32(82).string(message.status);
    }
    if (message.lastAttemptAt !== undefined) {
      writer.uint32(90).string(message.lastAttemptAt);
    }
    if (message.paidAt !== undefined) {
      writer.uint32(98).string(message.paidAt);
    }
    if (message.retryCount !== 0) {
      writer.uint32(104).int32(message.retryCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(114).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lastAttemptAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.paidAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateScheduleRequest(): UpdateScheduleRequest {
  return { id: "" };
}

export const UpdateScheduleRequest: MessageFns<UpdateScheduleRequest> = {
  encode(message: UpdateScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.amount !== undefined) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.dueDate !== undefined) {
      writer.uint32(26).string(message.dueDate);
    }
    if (message.status !== undefined) {
      writer.uint32(34).string(message.status);
    }
    if (message.autoProcess !== undefined) {
      writer.uint32(40).bool(message.autoProcess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.autoProcess = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetDueSchedulesRequest(): GetDueSchedulesRequest {
  return { organisationId: "" };
}

export const GetDueSchedulesRequest: MessageFns<GetDueSchedulesRequest> = {
  encode(message: GetDueSchedulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.beforeDate !== undefined) {
      writer.uint32(18).string(message.beforeDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDueSchedulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDueSchedulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseScheduleListResponse(): ScheduleListResponse {
  return { schedules: [], total: 0 };
}

export const ScheduleListResponse: MessageFns<ScheduleListResponse> = {
  encode(message: ScheduleListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schedules) {
      ScheduleResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedules.push(ScheduleResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessDuePaymentsRequest(): ProcessDuePaymentsRequest {
  return { organisationId: "" };
}

export const ProcessDuePaymentsRequest: MessageFns<ProcessDuePaymentsRequest> = {
  encode(message: ProcessDuePaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.dryRun !== undefined) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDuePaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessDuePaymentsResponse(): ProcessDuePaymentsResponse {
  return { processedCount: 0, successCount: 0, failedCount: 0, results: [] };
}

export const ProcessDuePaymentsResponse: MessageFns<ProcessDuePaymentsResponse> = {
  encode(message: ProcessDuePaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processedCount !== 0) {
      writer.uint32(8).int32(message.processedCount);
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failedCount !== 0) {
      writer.uint32(24).int32(message.failedCount);
    }
    for (const v of message.results) {
      ProcessedPayment.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDuePaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDuePaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processedCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failedCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.results.push(ProcessedPayment.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessedPayment(): ProcessedPayment {
  return { scheduleId: "", success: false };
}

export const ProcessedPayment: MessageFns<ProcessedPayment> = {
  encode(message: ProcessedPayment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduleId !== "") {
      writer.uint32(10).string(message.scheduleId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.paymentId !== undefined) {
      writer.uint32(26).string(message.paymentId);
    }
    if (message.error !== undefined) {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessedPayment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRenewScheduleRequest(): RenewScheduleRequest {
  return { id: "", newDueDate: "" };
}

export const RenewScheduleRequest: MessageFns<RenewScheduleRequest> = {
  encode(message: RenewScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newDueDate !== "") {
      writer.uint32(18).string(message.newDueDate);
    }
    if (message.newAmount !== undefined) {
      writer.uint32(24).int64(message.newAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newDueDate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newAmount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentIntentRequest(): CreatePaymentIntentRequest {
  return { organisationId: "", societeId: "", pspName: "", amount: 0, currency: "", metadata: {} };
}

export const CreatePaymentIntentRequest: MessageFns<CreatePaymentIntentRequest> = {
  encode(message: CreatePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(26).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(34).string(message.pspName);
    }
    if (message.amount !== 0) {
      writer.uint32(40).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(58).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(66).string(message.idempotencyKey);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePaymentIntentRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pspName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CreatePaymentIntentRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentIntentRequest_MetadataEntry(): CreatePaymentIntentRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePaymentIntentRequest_MetadataEntry: MessageFns<CreatePaymentIntentRequest_MetadataEntry> = {
  encode(message: CreatePaymentIntentRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentIntentRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentIntentRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentIntentResponse(): PaymentIntentResponse {
  return { id: "", organisationId: "", societeId: "", pspName: "", amount: 0, currency: "", status: "", createdAt: "" };
}

export const PaymentIntentResponse: MessageFns<PaymentIntentResponse> = {
  encode(message: PaymentIntentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.scheduleId !== undefined) {
      writer.uint32(34).string(message.scheduleId);
    }
    if (message.pspName !== "") {
      writer.uint32(42).string(message.pspName);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(50).string(message.pspPaymentId);
    }
    if (message.amount !== 0) {
      writer.uint32(56).int64(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.mandateReference !== undefined) {
      writer.uint32(82).string(message.mandateReference);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(90).string(message.idempotencyKey);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(98).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(106).string(message.errorMessage);
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(122).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentIntentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentIntentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pspName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mandateReference = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePaymentIntentRequest(): UpdatePaymentIntentRequest {
  return { id: "" };
}

export const UpdatePaymentIntentRequest: MessageFns<UpdatePaymentIntentRequest> = {
  encode(message: UpdatePaymentIntentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      writer.uint32(18).string(message.status);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(26).string(message.pspPaymentId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePaymentIntentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePaymentIntentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentEventRequest(): CreatePaymentEventRequest {
  return { organisationId: "", paymentIntentId: "", eventType: "", rawPayload: "" };
}

export const CreatePaymentEventRequest: MessageFns<CreatePaymentEventRequest> = {
  encode(message: CreatePaymentEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(18).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(34).string(message.rawPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePaymentEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentEventResponse(): PaymentEventResponse {
  return {
    id: "",
    organisationId: "",
    paymentIntentId: "",
    eventType: "",
    rawPayload: "",
    receivedAt: "",
    processed: false,
  };
}

export const PaymentEventResponse: MessageFns<PaymentEventResponse> = {
  encode(message: PaymentEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(26).string(message.paymentIntentId);
    }
    if (message.eventType !== "") {
      writer.uint32(34).string(message.eventType);
    }
    if (message.rawPayload !== "") {
      writer.uint32(42).string(message.rawPayload);
    }
    if (message.receivedAt !== "") {
      writer.uint32(50).string(message.receivedAt);
    }
    if (message.processed !== false) {
      writer.uint32(56).bool(message.processed);
    }
    if (message.processedAt !== undefined) {
      writer.uint32(66).string(message.processedAt);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rawPayload = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.receivedAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.processedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetUnprocessedEventsRequest(): GetUnprocessedEventsRequest {
  return { organisationId: "" };
}

export const GetUnprocessedEventsRequest: MessageFns<GetUnprocessedEventsRequest> = {
  encode(message: GetUnprocessedEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.limit !== undefined) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUnprocessedEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUnprocessedEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentEventListResponse(): PaymentEventListResponse {
  return { events: [], total: 0 };
}

export const PaymentEventListResponse: MessageFns<PaymentEventListResponse> = {
  encode(message: PaymentEventListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      PaymentEventResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentEventListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentEventListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(PaymentEventResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMarkEventProcessedRequest(): MarkEventProcessedRequest {
  return { id: "" };
}

export const MarkEventProcessedRequest: MessageFns<MarkEventProcessedRequest> = {
  encode(message: MarkEventProcessedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkEventProcessedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkEventProcessedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPSPAccountsRequest(): GetPSPAccountsRequest {
  return { societeId: "" };
}

export const GetPSPAccountsRequest: MessageFns<GetPSPAccountsRequest> = {
  encode(message: GetPSPAccountsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPSPAccountsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPSPAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePSPAccountsSummaryResponse(): PSPAccountsSummaryResponse {
  return {};
}

export const PSPAccountsSummaryResponse: MessageFns<PSPAccountsSummaryResponse> = {
  encode(message: PSPAccountsSummaryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stripe !== undefined) {
      PSPAccountInfo.encode(message.stripe, writer.uint32(10).fork()).join();
    }
    if (message.paypal !== undefined) {
      PSPAccountInfo.encode(message.paypal, writer.uint32(18).fork()).join();
    }
    if (message.gocardless !== undefined) {
      PSPAccountInfo.encode(message.gocardless, writer.uint32(26).fork()).join();
    }
    if (message.emerchantpay !== undefined) {
      PSPAccountInfo.encode(message.emerchantpay, writer.uint32(34).fork()).join();
    }
    if (message.slimpay !== undefined) {
      PSPAccountInfo.encode(message.slimpay, writer.uint32(42).fork()).join();
    }
    if (message.multisafepay !== undefined) {
      PSPAccountInfo.encode(message.multisafepay, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PSPAccountsSummaryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountsSummaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stripe = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paypal = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gocardless = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.emerchantpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.slimpay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.multisafepay = PSPAccountInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePSPAccountInfo(): PSPAccountInfo {
  return { id: "", name: "", isActive: false, isLiveMode: false, isConfigured: false };
}

export const PSPAccountInfo: MessageFns<PSPAccountInfo> = {
  encode(message: PSPAccountInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.isLiveMode !== false) {
      writer.uint32(32).bool(message.isLiveMode);
    }
    if (message.isConfigured !== false) {
      writer.uint32(40).bool(message.isConfigured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PSPAccountInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePSPAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isLiveMode = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isConfigured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePortalSessionRequest(): CreatePortalSessionRequest {
  return { organisationId: "", societeId: "", customerId: "", allowedActions: [], amountCents: 0, metadata: {} };
}

export const CreatePortalSessionRequest: MessageFns<CreatePortalSessionRequest> = {
  encode(message: CreatePortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(26).string(message.customerId);
    }
    if (message.contractId !== undefined) {
      writer.uint32(34).string(message.contractId);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(42).string(message.paymentIntentId);
    }
    writer.uint32(50).fork();
    for (const v of message.allowedActions) {
      writer.int32(v);
    }
    writer.join();
    if (message.ttlSeconds !== undefined) {
      writer.uint32(56).int32(message.ttlSeconds);
    }
    if (message.maxUses !== undefined) {
      writer.uint32(64).int32(message.maxUses);
    }
    if (message.amountCents !== 0) {
      writer.uint32(72).int64(message.amountCents);
    }
    if (message.currency !== undefined) {
      writer.uint32(82).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(90).string(message.description);
    }
    if (message.mandateId !== undefined) {
      writer.uint32(98).string(message.mandateId);
    }
    if (message.rumMasked !== undefined) {
      writer.uint32(106).string(message.rumMasked);
    }
    if (message.idempotencyKey !== undefined) {
      writer.uint32(114).string(message.idempotencyKey);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreatePortalSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.allowedActions.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedActions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ttlSeconds = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxUses = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.rumMasked = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = CreatePortalSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.metadata[entry15.key] = entry15.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePortalSessionRequest_MetadataEntry(): CreatePortalSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreatePortalSessionRequest_MetadataEntry: MessageFns<CreatePortalSessionRequest_MetadataEntry> = {
  encode(message: CreatePortalSessionRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePortalSessionResponse(): CreatePortalSessionResponse {
  return { token: "", portalUrl: "", wasIdempotentHit: false };
}

export const CreatePortalSessionResponse: MessageFns<CreatePortalSessionResponse> = {
  encode(message: CreatePortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.portalUrl !== "") {
      writer.uint32(26).string(message.portalUrl);
    }
    if (message.wasIdempotentHit !== false) {
      writer.uint32(32).bool(message.wasIdempotentHit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.portalUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.wasIdempotentHit = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePortalPaymentSession(): PortalPaymentSession {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    customerId: "",
    tokenVersion: "",
    status: 0,
    allowedActions: [],
    expiresAt: "",
    maxUses: 0,
    useCount: 0,
    amountCents: 0,
    currency: "",
    metadata: {},
    createdAt: "",
    updatedAt: "",
  };
}

export const PortalPaymentSession: MessageFns<PortalPaymentSession> = {
  encode(message: PortalPaymentSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.customerId !== "") {
      writer.uint32(34).string(message.customerId);
    }
    if (message.contractId !== undefined) {
      writer.uint32(42).string(message.contractId);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(50).string(message.paymentIntentId);
    }
    if (message.tokenVersion !== "") {
      writer.uint32(58).string(message.tokenVersion);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    writer.uint32(74).fork();
    for (const v of message.allowedActions) {
      writer.int32(v);
    }
    writer.join();
    if (message.expiresAt !== "") {
      writer.uint32(82).string(message.expiresAt);
    }
    if (message.maxUses !== 0) {
      writer.uint32(88).int32(message.maxUses);
    }
    if (message.useCount !== 0) {
      writer.uint32(96).int32(message.useCount);
    }
    if (message.consumedAt !== undefined) {
      writer.uint32(106).string(message.consumedAt);
    }
    if (message.revokedAt !== undefined) {
      writer.uint32(114).string(message.revokedAt);
    }
    if (message.lastAccessedAt !== undefined) {
      writer.uint32(122).string(message.lastAccessedAt);
    }
    if (message.amountCents !== 0) {
      writer.uint32(128).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(138).string(message.currency);
    }
    if (message.description !== undefined) {
      writer.uint32(146).string(message.description);
    }
    if (message.mandateId !== undefined) {
      writer.uint32(154).string(message.mandateId);
    }
    if (message.rumMasked !== undefined) {
      writer.uint32(162).string(message.rumMasked);
    }
    if (message.pspState !== undefined) {
      writer.uint32(170).string(message.pspState);
    }
    if (message.pspRedirectUrl !== undefined) {
      writer.uint32(178).string(message.pspRedirectUrl);
    }
    if (message.pspProvider !== undefined) {
      writer.uint32(184).int32(message.pspProvider);
    }
    if (message.pspSessionId !== undefined) {
      writer.uint32(194).string(message.pspSessionId);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      PortalPaymentSession_MetadataEntry.encode({ key: key as any, value }, writer.uint32(202).fork()).join();
    });
    if (message.createdAt !== "") {
      writer.uint32(210).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(218).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalPaymentSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalPaymentSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contractId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tokenVersion = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.allowedActions.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedActions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxUses = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.useCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.consumedAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.revokedAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.lastAccessedAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.mandateId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.rumMasked = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.pspState = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.pspRedirectUrl = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.pspProvider = reader.int32() as any;
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.pspSessionId = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          const entry25 = PortalPaymentSession_MetadataEntry.decode(reader, reader.uint32());
          if (entry25.value !== undefined) {
            message.metadata[entry25.key] = entry25.value;
          }
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePortalPaymentSession_MetadataEntry(): PortalPaymentSession_MetadataEntry {
  return { key: "", value: "" };
}

export const PortalPaymentSession_MetadataEntry: MessageFns<PortalPaymentSession_MetadataEntry> = {
  encode(message: PortalPaymentSession_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalPaymentSession_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalPaymentSession_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidatePortalTokenRequest(): ValidatePortalTokenRequest {
  return { token: "" };
}

export const ValidatePortalTokenRequest: MessageFns<ValidatePortalTokenRequest> = {
  encode(message: ValidatePortalTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(18).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(26).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePortalTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePortalTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidatePortalTokenResponse(): ValidatePortalTokenResponse {
  return { valid: false };
}

export const ValidatePortalTokenResponse: MessageFns<ValidatePortalTokenResponse> = {
  encode(message: ValidatePortalTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(18).fork()).join();
    }
    if (message.errorCode !== undefined) {
      writer.uint32(24).int32(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatePortalTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatePortalTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAccessPortalSessionRequest(): AccessPortalSessionRequest {
  return { token: "" };
}

export const AccessPortalSessionRequest: MessageFns<AccessPortalSessionRequest> = {
  encode(message: AccessPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(18).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(26).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAccessPortalSessionResponse(): AccessPortalSessionResponse {
  return {};
}

export const AccessPortalSessionResponse: MessageFns<AccessPortalSessionResponse> = {
  encode(message: AccessPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseConsumePortalTokenRequest(): ConsumePortalTokenRequest {
  return { token: "", action: 0 };
}

export const ConsumePortalTokenRequest: MessageFns<ConsumePortalTokenRequest> = {
  encode(message: ConsumePortalTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(26).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(34).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumePortalTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumePortalTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseConsumePortalTokenResponse(): ConsumePortalTokenResponse {
  return {};
}

export const ConsumePortalTokenResponse: MessageFns<ConsumePortalTokenResponse> = {
  encode(message: ConsumePortalTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumePortalTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumePortalTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelPortalSessionRequest(): CancelPortalSessionRequest {
  return { sessionId: "" };
}

export const CancelPortalSessionRequest: MessageFns<CancelPortalSessionRequest> = {
  encode(message: CancelPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.reason !== undefined) {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelPortalSessionResponse(): CancelPortalSessionResponse {
  return {};
}

export const CancelPortalSessionResponse: MessageFns<CancelPortalSessionResponse> = {
  encode(message: CancelPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePortalPspInfoRequest(): UpdatePortalPspInfoRequest {
  return { sessionId: "", pspState: "", pspRedirectUrl: "", pspProvider: 0, pspSessionId: "" };
}

export const UpdatePortalPspInfoRequest: MessageFns<UpdatePortalPspInfoRequest> = {
  encode(message: UpdatePortalPspInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.pspState !== "") {
      writer.uint32(18).string(message.pspState);
    }
    if (message.pspRedirectUrl !== "") {
      writer.uint32(26).string(message.pspRedirectUrl);
    }
    if (message.pspProvider !== 0) {
      writer.uint32(32).int32(message.pspProvider);
    }
    if (message.pspSessionId !== "") {
      writer.uint32(42).string(message.pspSessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePortalPspInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePortalPspInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pspState = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pspRedirectUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pspProvider = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pspSessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePortalPspInfoResponse(): UpdatePortalPspInfoResponse {
  return { success: false };
}

export const UpdatePortalPspInfoResponse: MessageFns<UpdatePortalPspInfoResponse> = {
  encode(message: UpdatePortalPspInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePortalPspInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePortalPspInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTransitionPortalSessionRequest(): TransitionPortalSessionRequest {
  return { sessionId: "", newStatus: 0 };
}

export const TransitionPortalSessionRequest: MessageFns<TransitionPortalSessionRequest> = {
  encode(message: TransitionPortalSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.newStatus !== 0) {
      writer.uint32(16).int32(message.newStatus);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(34).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(42).string(message.userAgentHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionPortalSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionPortalSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTransitionPortalSessionResponse(): TransitionPortalSessionResponse {
  return {};
}

export const TransitionPortalSessionResponse: MessageFns<TransitionPortalSessionResponse> = {
  encode(message: TransitionPortalSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      PortalPaymentSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionPortalSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionPortalSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = PortalPaymentSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePortalSessionAuditLog(): PortalSessionAuditLog {
  return { id: "", portalSessionId: "", eventType: 0, actorType: 0, data: {}, timestamp: "" };
}

export const PortalSessionAuditLog: MessageFns<PortalSessionAuditLog> = {
  encode(message: PortalSessionAuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.portalSessionId !== "") {
      writer.uint32(18).string(message.portalSessionId);
    }
    if (message.eventType !== 0) {
      writer.uint32(24).int32(message.eventType);
    }
    if (message.actorType !== 0) {
      writer.uint32(32).int32(message.actorType);
    }
    if (message.previousStatus !== undefined) {
      writer.uint32(42).string(message.previousStatus);
    }
    if (message.newStatus !== undefined) {
      writer.uint32(50).string(message.newStatus);
    }
    if (message.ipAddressHash !== undefined) {
      writer.uint32(58).string(message.ipAddressHash);
    }
    if (message.userAgentHash !== undefined) {
      writer.uint32(66).string(message.userAgentHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(74).string(message.requestId);
    }
    if (message.correlationId !== undefined) {
      writer.uint32(82).string(message.correlationId);
    }
    globalThis.Object.entries(message.data).forEach(([key, value]: [string, string]) => {
      PortalSessionAuditLog_DataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.timestamp !== "") {
      writer.uint32(98).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalSessionAuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalSessionAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.portalSessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actorType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.previousStatus = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.newStatus = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ipAddressHash = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = PortalSessionAuditLog_DataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.data[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePortalSessionAuditLog_DataEntry(): PortalSessionAuditLog_DataEntry {
  return { key: "", value: "" };
}

export const PortalSessionAuditLog_DataEntry: MessageFns<PortalSessionAuditLog_DataEntry> = {
  encode(message: PortalSessionAuditLog_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalSessionAuditLog_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalSessionAuditLog_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPortalSessionsRequest(): ListPortalSessionsRequest {
  return { organisationId: "" };
}

export const ListPortalSessionsRequest: MessageFns<ListPortalSessionsRequest> = {
  encode(message: ListPortalSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.customerId !== undefined) {
      writer.uint32(26).string(message.customerId);
    }
    if (message.status !== undefined) {
      writer.uint32(32).int32(message.status);
    }
    if (message.fromDate !== undefined) {
      writer.uint32(42).string(message.fromDate);
    }
    if (message.toDate !== undefined) {
      writer.uint32(50).string(message.toDate);
    }
    if (message.page !== undefined) {
      writer.uint32(56).int32(message.page);
    }
    if (message.limit !== undefined) {
      writer.uint32(64).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortalSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortalSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPortalSessionsResponse(): ListPortalSessionsResponse {
  return { sessions: [], total: 0, page: 0, totalPages: 0 };
}

export const ListPortalSessionsResponse: MessageFns<ListPortalSessionsResponse> = {
  encode(message: ListPortalSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      PortalPaymentSession.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortalSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortalSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(PortalPaymentSession.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPortalSessionAuditRequest(): GetPortalSessionAuditRequest {
  return { sessionId: "" };
}

export const GetPortalSessionAuditRequest: MessageFns<GetPortalSessionAuditRequest> = {
  encode(message: GetPortalSessionAuditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionAuditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPortalSessionAuditResponse(): GetPortalSessionAuditResponse {
  return { logs: [] };
}

export const GetPortalSessionAuditResponse: MessageFns<GetPortalSessionAuditResponse> = {
  encode(message: GetPortalSessionAuditResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      PortalSessionAuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionAuditResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(PortalSessionAuditLog.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPortalSessionStatsRequest(): GetPortalSessionStatsRequest {
  return { organisationId: "", fromDate: "", toDate: "" };
}

export const GetPortalSessionStatsRequest: MessageFns<GetPortalSessionStatsRequest> = {
  encode(message: GetPortalSessionStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.fromDate !== "") {
      writer.uint32(26).string(message.fromDate);
    }
    if (message.toDate !== "") {
      writer.uint32(34).string(message.toDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPortalSessionStatsResponse(): GetPortalSessionStatsResponse {
  return { totalCreated: 0, totalCompleted: 0, totalFailed: 0, totalExpired: 0, totalCancelled: 0, completionRate: 0 };
}

export const GetPortalSessionStatsResponse: MessageFns<GetPortalSessionStatsResponse> = {
  encode(message: GetPortalSessionStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCreated !== 0) {
      writer.uint32(8).int32(message.totalCreated);
    }
    if (message.totalCompleted !== 0) {
      writer.uint32(16).int32(message.totalCompleted);
    }
    if (message.totalFailed !== 0) {
      writer.uint32(24).int32(message.totalFailed);
    }
    if (message.totalExpired !== 0) {
      writer.uint32(32).int32(message.totalExpired);
    }
    if (message.totalCancelled !== 0) {
      writer.uint32(40).int32(message.totalCancelled);
    }
    if (message.completionRate !== 0) {
      writer.uint32(49).double(message.completionRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortalSessionStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortalSessionStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCreated = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCompleted = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalFailed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalExpired = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalCancelled = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.completionRate = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePortalRequestContext(): PortalRequestContext {
  return {};
}

export const PortalRequestContext: MessageFns<PortalRequestContext> = {
  encode(message: PortalRequestContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipHash !== undefined) {
      writer.uint32(10).string(message.ipHash);
    }
    if (message.uaHash !== undefined) {
      writer.uint32(18).string(message.uaHash);
    }
    if (message.requestId !== undefined) {
      writer.uint32(26).string(message.requestId);
    }
    if (message.correlationId !== undefined) {
      writer.uint32(34).string(message.correlationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortalRequestContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortalRequestContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uaHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGoCardlessConfig(): GoCardlessConfig {
  return { accessToken: "", baseUrl: "" };
}

export const GoCardlessConfig: MessageFns<GoCardlessConfig> = {
  encode(message: GoCardlessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.baseUrl !== "") {
      writer.uint32(18).string(message.baseUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoCardlessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoCardlessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSlimpayToken(): SlimpayToken {
  return { accessToken: "", expiresAt: 0 };
}

export const SlimpayToken: MessageFns<SlimpayToken> = {
  encode(message: SlimpayToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(16).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlimpayToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlimpayToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface PaymentServiceClient {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */

  createStripeCheckoutSession(
    request: CreateStripeCheckoutSessionRequest,
    metadata?: Metadata,
  ): Observable<StripeCheckoutSessionResponse>;

  createStripePaymentIntent(
    request: CreateStripePaymentIntentRequest,
    metadata?: Metadata,
  ): Observable<StripePaymentIntentResponse>;

  getStripePaymentIntent(request: GetByIdRequest, metadata?: Metadata): Observable<StripePaymentIntentResponse>;

  cancelStripePaymentIntent(request: GetByIdRequest, metadata?: Metadata): Observable<StripePaymentIntentResponse>;

  /** Customers */

  createStripeCustomer(request: CreateStripeCustomerRequest, metadata?: Metadata): Observable<StripeCustomerResponse>;

  getStripeCustomer(request: GetByIdRequest, metadata?: Metadata): Observable<StripeCustomerResponse>;

  /** Subscriptions */

  createStripeSubscription(
    request: CreateStripeSubscriptionRequest,
    metadata?: Metadata,
  ): Observable<StripeSubscriptionResponse>;

  getStripeSubscription(request: GetByIdRequest, metadata?: Metadata): Observable<StripeSubscriptionResponse>;

  cancelStripeSubscription(request: GetByIdRequest, metadata?: Metadata): Observable<StripeSubscriptionResponse>;

  /** Refunds */

  createStripeRefund(request: CreateStripeRefundRequest, metadata?: Metadata): Observable<StripeRefundResponse>;

  /** Setup Intents (for saving payment methods) */

  createStripeSetupIntent(
    request: CreateStripeSetupIntentRequest,
    metadata?: Metadata,
  ): Observable<StripeSetupIntentResponse>;

  /** Billing Portal */

  createStripeBillingPortalSession(
    request: CreateStripeBillingPortalRequest,
    metadata?: Metadata,
  ): Observable<StripeBillingPortalResponse>;

  /** ==================== PAYPAL ==================== */

  createPayPalOrder(request: CreatePayPalOrderRequest, metadata?: Metadata): Observable<PayPalOrderResponse>;

  getPayPalOrder(request: GetPayPalOrderRequest, metadata?: Metadata): Observable<PayPalOrderResponse>;

  capturePayPalOrder(request: CapturePayPalOrderRequest, metadata?: Metadata): Observable<PayPalCaptureResponse>;

  authorizePayPalOrder(request: GetPayPalOrderRequest, metadata?: Metadata): Observable<PayPalOrderResponse>;

  /** ==================== GOCARDLESS ==================== */

  setupGoCardlessMandate(
    request: SetupGoCardlessMandateRequest,
    metadata?: Metadata,
  ): Observable<GoCardlessMandateResponse>;

  getGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata?: Metadata,
  ): Observable<GoCardlessMandateResponse>;

  cancelGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata?: Metadata,
  ): Observable<GoCardlessMandateResponse>;

  createGoCardlessPayment(
    request: CreateGoCardlessPaymentRequest,
    metadata?: Metadata,
  ): Observable<GoCardlessPaymentResponse>;

  createGoCardlessSubscription(
    request: CreateGoCardlessSubscriptionRequest,
    metadata?: Metadata,
  ): Observable<GoCardlessSubscriptionResponse>;

  cancelGoCardlessSubscription(
    request: CancelGoCardlessSubscriptionRequest,
    metadata?: Metadata,
  ): Observable<GoCardlessSubscriptionResponse>;

  /** ==================== SCHEDULES ==================== */

  createSchedule(request: CreateScheduleRequest, metadata?: Metadata): Observable<ScheduleResponse>;

  getSchedule(request: GetByIdRequest, metadata?: Metadata): Observable<ScheduleResponse>;

  updateSchedule(request: UpdateScheduleRequest, metadata?: Metadata): Observable<ScheduleResponse>;

  deleteSchedule(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  getDueSchedules(request: GetDueSchedulesRequest, metadata?: Metadata): Observable<ScheduleListResponse>;

  processDuePayments(request: ProcessDuePaymentsRequest, metadata?: Metadata): Observable<ProcessDuePaymentsResponse>;

  renewSchedule(request: RenewScheduleRequest, metadata?: Metadata): Observable<ScheduleResponse>;

  /** ==================== PAYMENT INTENTS (Internal) ==================== */

  createPaymentIntent(request: CreatePaymentIntentRequest, metadata?: Metadata): Observable<PaymentIntentResponse>;

  getPaymentIntent(request: GetByIdRequest, metadata?: Metadata): Observable<PaymentIntentResponse>;

  updatePaymentIntent(request: UpdatePaymentIntentRequest, metadata?: Metadata): Observable<PaymentIntentResponse>;

  deletePaymentIntent(request: GetByIdRequest, metadata?: Metadata): Observable<DeleteResponse>;

  /** ==================== PAYMENT EVENTS ==================== */

  createPaymentEvent(request: CreatePaymentEventRequest, metadata?: Metadata): Observable<PaymentEventResponse>;

  getPaymentEvent(request: GetByIdRequest, metadata?: Metadata): Observable<PaymentEventResponse>;

  getUnprocessedEvents(request: GetUnprocessedEventsRequest, metadata?: Metadata): Observable<PaymentEventListResponse>;

  markEventProcessed(request: MarkEventProcessedRequest, metadata?: Metadata): Observable<PaymentEventResponse>;

  /** ==================== PSP ACCOUNTS ==================== */

  getPspAccountsSummary(request: GetPSPAccountsRequest, metadata?: Metadata): Observable<PSPAccountsSummaryResponse>;
}

export interface PaymentServiceController {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */

  createStripeCheckoutSession(
    request: CreateStripeCheckoutSessionRequest,
    metadata?: Metadata,
  ): Promise<StripeCheckoutSessionResponse> | Observable<StripeCheckoutSessionResponse> | StripeCheckoutSessionResponse;

  createStripePaymentIntent(
    request: CreateStripePaymentIntentRequest,
    metadata?: Metadata,
  ): Promise<StripePaymentIntentResponse> | Observable<StripePaymentIntentResponse> | StripePaymentIntentResponse;

  getStripePaymentIntent(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<StripePaymentIntentResponse> | Observable<StripePaymentIntentResponse> | StripePaymentIntentResponse;

  cancelStripePaymentIntent(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<StripePaymentIntentResponse> | Observable<StripePaymentIntentResponse> | StripePaymentIntentResponse;

  /** Customers */

  createStripeCustomer(
    request: CreateStripeCustomerRequest,
    metadata?: Metadata,
  ): Promise<StripeCustomerResponse> | Observable<StripeCustomerResponse> | StripeCustomerResponse;

  getStripeCustomer(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<StripeCustomerResponse> | Observable<StripeCustomerResponse> | StripeCustomerResponse;

  /** Subscriptions */

  createStripeSubscription(
    request: CreateStripeSubscriptionRequest,
    metadata?: Metadata,
  ): Promise<StripeSubscriptionResponse> | Observable<StripeSubscriptionResponse> | StripeSubscriptionResponse;

  getStripeSubscription(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<StripeSubscriptionResponse> | Observable<StripeSubscriptionResponse> | StripeSubscriptionResponse;

  cancelStripeSubscription(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<StripeSubscriptionResponse> | Observable<StripeSubscriptionResponse> | StripeSubscriptionResponse;

  /** Refunds */

  createStripeRefund(
    request: CreateStripeRefundRequest,
    metadata?: Metadata,
  ): Promise<StripeRefundResponse> | Observable<StripeRefundResponse> | StripeRefundResponse;

  /** Setup Intents (for saving payment methods) */

  createStripeSetupIntent(
    request: CreateStripeSetupIntentRequest,
    metadata?: Metadata,
  ): Promise<StripeSetupIntentResponse> | Observable<StripeSetupIntentResponse> | StripeSetupIntentResponse;

  /** Billing Portal */

  createStripeBillingPortalSession(
    request: CreateStripeBillingPortalRequest,
    metadata?: Metadata,
  ): Promise<StripeBillingPortalResponse> | Observable<StripeBillingPortalResponse> | StripeBillingPortalResponse;

  /** ==================== PAYPAL ==================== */

  createPayPalOrder(
    request: CreatePayPalOrderRequest,
    metadata?: Metadata,
  ): Promise<PayPalOrderResponse> | Observable<PayPalOrderResponse> | PayPalOrderResponse;

  getPayPalOrder(
    request: GetPayPalOrderRequest,
    metadata?: Metadata,
  ): Promise<PayPalOrderResponse> | Observable<PayPalOrderResponse> | PayPalOrderResponse;

  capturePayPalOrder(
    request: CapturePayPalOrderRequest,
    metadata?: Metadata,
  ): Promise<PayPalCaptureResponse> | Observable<PayPalCaptureResponse> | PayPalCaptureResponse;

  authorizePayPalOrder(
    request: GetPayPalOrderRequest,
    metadata?: Metadata,
  ): Promise<PayPalOrderResponse> | Observable<PayPalOrderResponse> | PayPalOrderResponse;

  /** ==================== GOCARDLESS ==================== */

  setupGoCardlessMandate(
    request: SetupGoCardlessMandateRequest,
    metadata?: Metadata,
  ): Promise<GoCardlessMandateResponse> | Observable<GoCardlessMandateResponse> | GoCardlessMandateResponse;

  getGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata?: Metadata,
  ): Promise<GoCardlessMandateResponse> | Observable<GoCardlessMandateResponse> | GoCardlessMandateResponse;

  cancelGoCardlessMandate(
    request: GetGoCardlessMandateRequest,
    metadata?: Metadata,
  ): Promise<GoCardlessMandateResponse> | Observable<GoCardlessMandateResponse> | GoCardlessMandateResponse;

  createGoCardlessPayment(
    request: CreateGoCardlessPaymentRequest,
    metadata?: Metadata,
  ): Promise<GoCardlessPaymentResponse> | Observable<GoCardlessPaymentResponse> | GoCardlessPaymentResponse;

  createGoCardlessSubscription(
    request: CreateGoCardlessSubscriptionRequest,
    metadata?: Metadata,
  ):
    | Promise<GoCardlessSubscriptionResponse>
    | Observable<GoCardlessSubscriptionResponse>
    | GoCardlessSubscriptionResponse;

  cancelGoCardlessSubscription(
    request: CancelGoCardlessSubscriptionRequest,
    metadata?: Metadata,
  ):
    | Promise<GoCardlessSubscriptionResponse>
    | Observable<GoCardlessSubscriptionResponse>
    | GoCardlessSubscriptionResponse;

  /** ==================== SCHEDULES ==================== */

  createSchedule(
    request: CreateScheduleRequest,
    metadata?: Metadata,
  ): Promise<ScheduleResponse> | Observable<ScheduleResponse> | ScheduleResponse;

  getSchedule(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<ScheduleResponse> | Observable<ScheduleResponse> | ScheduleResponse;

  updateSchedule(
    request: UpdateScheduleRequest,
    metadata?: Metadata,
  ): Promise<ScheduleResponse> | Observable<ScheduleResponse> | ScheduleResponse;

  deleteSchedule(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  getDueSchedules(
    request: GetDueSchedulesRequest,
    metadata?: Metadata,
  ): Promise<ScheduleListResponse> | Observable<ScheduleListResponse> | ScheduleListResponse;

  processDuePayments(
    request: ProcessDuePaymentsRequest,
    metadata?: Metadata,
  ): Promise<ProcessDuePaymentsResponse> | Observable<ProcessDuePaymentsResponse> | ProcessDuePaymentsResponse;

  renewSchedule(
    request: RenewScheduleRequest,
    metadata?: Metadata,
  ): Promise<ScheduleResponse> | Observable<ScheduleResponse> | ScheduleResponse;

  /** ==================== PAYMENT INTENTS (Internal) ==================== */

  createPaymentIntent(
    request: CreatePaymentIntentRequest,
    metadata?: Metadata,
  ): Promise<PaymentIntentResponse> | Observable<PaymentIntentResponse> | PaymentIntentResponse;

  getPaymentIntent(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<PaymentIntentResponse> | Observable<PaymentIntentResponse> | PaymentIntentResponse;

  updatePaymentIntent(
    request: UpdatePaymentIntentRequest,
    metadata?: Metadata,
  ): Promise<PaymentIntentResponse> | Observable<PaymentIntentResponse> | PaymentIntentResponse;

  deletePaymentIntent(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  /** ==================== PAYMENT EVENTS ==================== */

  createPaymentEvent(
    request: CreatePaymentEventRequest,
    metadata?: Metadata,
  ): Promise<PaymentEventResponse> | Observable<PaymentEventResponse> | PaymentEventResponse;

  getPaymentEvent(
    request: GetByIdRequest,
    metadata?: Metadata,
  ): Promise<PaymentEventResponse> | Observable<PaymentEventResponse> | PaymentEventResponse;

  getUnprocessedEvents(
    request: GetUnprocessedEventsRequest,
    metadata?: Metadata,
  ): Promise<PaymentEventListResponse> | Observable<PaymentEventListResponse> | PaymentEventListResponse;

  markEventProcessed(
    request: MarkEventProcessedRequest,
    metadata?: Metadata,
  ): Promise<PaymentEventResponse> | Observable<PaymentEventResponse> | PaymentEventResponse;

  /** ==================== PSP ACCOUNTS ==================== */

  getPspAccountsSummary(
    request: GetPSPAccountsRequest,
    metadata?: Metadata,
  ): Promise<PSPAccountsSummaryResponse> | Observable<PSPAccountsSummaryResponse> | PSPAccountsSummaryResponse;
}

export function PaymentServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createStripeCheckoutSession",
      "createStripePaymentIntent",
      "getStripePaymentIntent",
      "cancelStripePaymentIntent",
      "createStripeCustomer",
      "getStripeCustomer",
      "createStripeSubscription",
      "getStripeSubscription",
      "cancelStripeSubscription",
      "createStripeRefund",
      "createStripeSetupIntent",
      "createStripeBillingPortalSession",
      "createPayPalOrder",
      "getPayPalOrder",
      "capturePayPalOrder",
      "authorizePayPalOrder",
      "setupGoCardlessMandate",
      "getGoCardlessMandate",
      "cancelGoCardlessMandate",
      "createGoCardlessPayment",
      "createGoCardlessSubscription",
      "cancelGoCardlessSubscription",
      "createSchedule",
      "getSchedule",
      "updateSchedule",
      "deleteSchedule",
      "getDueSchedules",
      "processDuePayments",
      "renewSchedule",
      "createPaymentIntent",
      "getPaymentIntent",
      "updatePaymentIntent",
      "deletePaymentIntent",
      "createPaymentEvent",
      "getPaymentEvent",
      "getUnprocessedEvents",
      "markEventProcessed",
      "getPspAccountsSummary",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PAYMENT_SERVICE_NAME = "PaymentService";

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: {
    path: "/payment.PaymentService/CreateStripeCheckoutSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCheckoutSessionRequest): Buffer =>
      Buffer.from(CreateStripeCheckoutSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeCheckoutSessionRequest =>
      CreateStripeCheckoutSessionRequest.decode(value),
    responseSerialize: (value: StripeCheckoutSessionResponse): Buffer =>
      Buffer.from(StripeCheckoutSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCheckoutSessionResponse => StripeCheckoutSessionResponse.decode(value),
  },
  createStripePaymentIntent: {
    path: "/payment.PaymentService/CreateStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripePaymentIntentRequest): Buffer =>
      Buffer.from(CreateStripePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripePaymentIntentRequest =>
      CreateStripePaymentIntentRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  getStripePaymentIntent: {
    path: "/payment.PaymentService/GetStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  cancelStripePaymentIntent: {
    path: "/payment.PaymentService/CancelStripePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripePaymentIntentResponse): Buffer =>
      Buffer.from(StripePaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripePaymentIntentResponse => StripePaymentIntentResponse.decode(value),
  },
  /** Customers */
  createStripeCustomer: {
    path: "/payment.PaymentService/CreateStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeCustomerRequest): Buffer =>
      Buffer.from(CreateStripeCustomerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeCustomerRequest => CreateStripeCustomerRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse): Buffer =>
      Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCustomerResponse => StripeCustomerResponse.decode(value),
  },
  getStripeCustomer: {
    path: "/payment.PaymentService/GetStripeCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeCustomerResponse): Buffer =>
      Buffer.from(StripeCustomerResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeCustomerResponse => StripeCustomerResponse.decode(value),
  },
  /** Subscriptions */
  createStripeSubscription: {
    path: "/payment.PaymentService/CreateStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSubscriptionRequest): Buffer =>
      Buffer.from(CreateStripeSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeSubscriptionRequest =>
      CreateStripeSubscriptionRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  getStripeSubscription: {
    path: "/payment.PaymentService/GetStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  cancelStripeSubscription: {
    path: "/payment.PaymentService/CancelStripeSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: StripeSubscriptionResponse): Buffer =>
      Buffer.from(StripeSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSubscriptionResponse => StripeSubscriptionResponse.decode(value),
  },
  /** Refunds */
  createStripeRefund: {
    path: "/payment.PaymentService/CreateStripeRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeRefundRequest): Buffer =>
      Buffer.from(CreateStripeRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeRefundRequest => CreateStripeRefundRequest.decode(value),
    responseSerialize: (value: StripeRefundResponse): Buffer =>
      Buffer.from(StripeRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeRefundResponse => StripeRefundResponse.decode(value),
  },
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: {
    path: "/payment.PaymentService/CreateStripeSetupIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeSetupIntentRequest): Buffer =>
      Buffer.from(CreateStripeSetupIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeSetupIntentRequest => CreateStripeSetupIntentRequest.decode(value),
    responseSerialize: (value: StripeSetupIntentResponse): Buffer =>
      Buffer.from(StripeSetupIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeSetupIntentResponse => StripeSetupIntentResponse.decode(value),
  },
  /** Billing Portal */
  createStripeBillingPortalSession: {
    path: "/payment.PaymentService/CreateStripeBillingPortalSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStripeBillingPortalRequest): Buffer =>
      Buffer.from(CreateStripeBillingPortalRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStripeBillingPortalRequest =>
      CreateStripeBillingPortalRequest.decode(value),
    responseSerialize: (value: StripeBillingPortalResponse): Buffer =>
      Buffer.from(StripeBillingPortalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StripeBillingPortalResponse => StripeBillingPortalResponse.decode(value),
  },
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: {
    path: "/payment.PaymentService/CreatePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePayPalOrderRequest): Buffer =>
      Buffer.from(CreatePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePayPalOrderRequest => CreatePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  getPayPalOrder: {
    path: "/payment.PaymentService/GetPayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest): Buffer =>
      Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPayPalOrderRequest => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  capturePayPalOrder: {
    path: "/payment.PaymentService/CapturePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CapturePayPalOrderRequest): Buffer =>
      Buffer.from(CapturePayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CapturePayPalOrderRequest => CapturePayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalCaptureResponse): Buffer =>
      Buffer.from(PayPalCaptureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalCaptureResponse => PayPalCaptureResponse.decode(value),
  },
  authorizePayPalOrder: {
    path: "/payment.PaymentService/AuthorizePayPalOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPayPalOrderRequest): Buffer =>
      Buffer.from(GetPayPalOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPayPalOrderRequest => GetPayPalOrderRequest.decode(value),
    responseSerialize: (value: PayPalOrderResponse): Buffer => Buffer.from(PayPalOrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PayPalOrderResponse => PayPalOrderResponse.decode(value),
  },
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: {
    path: "/payment.PaymentService/SetupGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetupGoCardlessMandateRequest): Buffer =>
      Buffer.from(SetupGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SetupGoCardlessMandateRequest => SetupGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  getGoCardlessMandate: {
    path: "/payment.PaymentService/GetGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest): Buffer =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGoCardlessMandateRequest => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  cancelGoCardlessMandate: {
    path: "/payment.PaymentService/CancelGoCardlessMandate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGoCardlessMandateRequest): Buffer =>
      Buffer.from(GetGoCardlessMandateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGoCardlessMandateRequest => GetGoCardlessMandateRequest.decode(value),
    responseSerialize: (value: GoCardlessMandateResponse): Buffer =>
      Buffer.from(GoCardlessMandateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessMandateResponse => GoCardlessMandateResponse.decode(value),
  },
  createGoCardlessPayment: {
    path: "/payment.PaymentService/CreateGoCardlessPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessPaymentRequest): Buffer =>
      Buffer.from(CreateGoCardlessPaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGoCardlessPaymentRequest => CreateGoCardlessPaymentRequest.decode(value),
    responseSerialize: (value: GoCardlessPaymentResponse): Buffer =>
      Buffer.from(GoCardlessPaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessPaymentResponse => GoCardlessPaymentResponse.decode(value),
  },
  createGoCardlessSubscription: {
    path: "/payment.PaymentService/CreateGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGoCardlessSubscriptionRequest): Buffer =>
      Buffer.from(CreateGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGoCardlessSubscriptionRequest =>
      CreateGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse): Buffer =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessSubscriptionResponse =>
      GoCardlessSubscriptionResponse.decode(value),
  },
  cancelGoCardlessSubscription: {
    path: "/payment.PaymentService/CancelGoCardlessSubscription",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelGoCardlessSubscriptionRequest): Buffer =>
      Buffer.from(CancelGoCardlessSubscriptionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelGoCardlessSubscriptionRequest =>
      CancelGoCardlessSubscriptionRequest.decode(value),
    responseSerialize: (value: GoCardlessSubscriptionResponse): Buffer =>
      Buffer.from(GoCardlessSubscriptionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GoCardlessSubscriptionResponse =>
      GoCardlessSubscriptionResponse.decode(value),
  },
  /** ==================== SCHEDULES ==================== */
  createSchedule: {
    path: "/payment.PaymentService/CreateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateScheduleRequest): Buffer =>
      Buffer.from(CreateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateScheduleRequest => CreateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  getSchedule: {
    path: "/payment.PaymentService/GetSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  updateSchedule: {
    path: "/payment.PaymentService/UpdateSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateScheduleRequest): Buffer =>
      Buffer.from(UpdateScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateScheduleRequest => UpdateScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  deleteSchedule: {
    path: "/payment.PaymentService/DeleteSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getDueSchedules: {
    path: "/payment.PaymentService/GetDueSchedules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDueSchedulesRequest): Buffer =>
      Buffer.from(GetDueSchedulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDueSchedulesRequest => GetDueSchedulesRequest.decode(value),
    responseSerialize: (value: ScheduleListResponse): Buffer =>
      Buffer.from(ScheduleListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleListResponse => ScheduleListResponse.decode(value),
  },
  processDuePayments: {
    path: "/payment.PaymentService/ProcessDuePayments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDuePaymentsRequest): Buffer =>
      Buffer.from(ProcessDuePaymentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessDuePaymentsRequest => ProcessDuePaymentsRequest.decode(value),
    responseSerialize: (value: ProcessDuePaymentsResponse): Buffer =>
      Buffer.from(ProcessDuePaymentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessDuePaymentsResponse => ProcessDuePaymentsResponse.decode(value),
  },
  renewSchedule: {
    path: "/payment.PaymentService/RenewSchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenewScheduleRequest): Buffer => Buffer.from(RenewScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RenewScheduleRequest => RenewScheduleRequest.decode(value),
    responseSerialize: (value: ScheduleResponse): Buffer => Buffer.from(ScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleResponse => ScheduleResponse.decode(value),
  },
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: {
    path: "/payment.PaymentService/CreatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentIntentRequest): Buffer =>
      Buffer.from(CreatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePaymentIntentRequest => CreatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  getPaymentIntent: {
    path: "/payment.PaymentService/GetPaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  updatePaymentIntent: {
    path: "/payment.PaymentService/UpdatePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePaymentIntentRequest): Buffer =>
      Buffer.from(UpdatePaymentIntentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePaymentIntentRequest => UpdatePaymentIntentRequest.decode(value),
    responseSerialize: (value: PaymentIntentResponse): Buffer =>
      Buffer.from(PaymentIntentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentIntentResponse => PaymentIntentResponse.decode(value),
  },
  deletePaymentIntent: {
    path: "/payment.PaymentService/DeletePaymentIntent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: {
    path: "/payment.PaymentService/CreatePaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentEventRequest): Buffer =>
      Buffer.from(CreatePaymentEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePaymentEventRequest => CreatePaymentEventRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  getPaymentEvent: {
    path: "/payment.PaymentService/GetPaymentEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetByIdRequest): Buffer => Buffer.from(GetByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetByIdRequest => GetByIdRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  getUnprocessedEvents: {
    path: "/payment.PaymentService/GetUnprocessedEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUnprocessedEventsRequest): Buffer =>
      Buffer.from(GetUnprocessedEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetUnprocessedEventsRequest => GetUnprocessedEventsRequest.decode(value),
    responseSerialize: (value: PaymentEventListResponse): Buffer =>
      Buffer.from(PaymentEventListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventListResponse => PaymentEventListResponse.decode(value),
  },
  markEventProcessed: {
    path: "/payment.PaymentService/MarkEventProcessed",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MarkEventProcessedRequest): Buffer =>
      Buffer.from(MarkEventProcessedRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MarkEventProcessedRequest => MarkEventProcessedRequest.decode(value),
    responseSerialize: (value: PaymentEventResponse): Buffer =>
      Buffer.from(PaymentEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PaymentEventResponse => PaymentEventResponse.decode(value),
  },
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: {
    path: "/payment.PaymentService/GetPSPAccountsSummary",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPSPAccountsRequest): Buffer =>
      Buffer.from(GetPSPAccountsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPSPAccountsRequest => GetPSPAccountsRequest.decode(value),
    responseSerialize: (value: PSPAccountsSummaryResponse): Buffer =>
      Buffer.from(PSPAccountsSummaryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PSPAccountsSummaryResponse => PSPAccountsSummaryResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  /**
   * ==================== STRIPE ====================
   * Checkout & Payment Intents
   */
  createStripeCheckoutSession: handleUnaryCall<CreateStripeCheckoutSessionRequest, StripeCheckoutSessionResponse>;
  createStripePaymentIntent: handleUnaryCall<CreateStripePaymentIntentRequest, StripePaymentIntentResponse>;
  getStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  cancelStripePaymentIntent: handleUnaryCall<GetByIdRequest, StripePaymentIntentResponse>;
  /** Customers */
  createStripeCustomer: handleUnaryCall<CreateStripeCustomerRequest, StripeCustomerResponse>;
  getStripeCustomer: handleUnaryCall<GetByIdRequest, StripeCustomerResponse>;
  /** Subscriptions */
  createStripeSubscription: handleUnaryCall<CreateStripeSubscriptionRequest, StripeSubscriptionResponse>;
  getStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  cancelStripeSubscription: handleUnaryCall<GetByIdRequest, StripeSubscriptionResponse>;
  /** Refunds */
  createStripeRefund: handleUnaryCall<CreateStripeRefundRequest, StripeRefundResponse>;
  /** Setup Intents (for saving payment methods) */
  createStripeSetupIntent: handleUnaryCall<CreateStripeSetupIntentRequest, StripeSetupIntentResponse>;
  /** Billing Portal */
  createStripeBillingPortalSession: handleUnaryCall<CreateStripeBillingPortalRequest, StripeBillingPortalResponse>;
  /** ==================== PAYPAL ==================== */
  createPayPalOrder: handleUnaryCall<CreatePayPalOrderRequest, PayPalOrderResponse>;
  getPayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  capturePayPalOrder: handleUnaryCall<CapturePayPalOrderRequest, PayPalCaptureResponse>;
  authorizePayPalOrder: handleUnaryCall<GetPayPalOrderRequest, PayPalOrderResponse>;
  /** ==================== GOCARDLESS ==================== */
  setupGoCardlessMandate: handleUnaryCall<SetupGoCardlessMandateRequest, GoCardlessMandateResponse>;
  getGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  cancelGoCardlessMandate: handleUnaryCall<GetGoCardlessMandateRequest, GoCardlessMandateResponse>;
  createGoCardlessPayment: handleUnaryCall<CreateGoCardlessPaymentRequest, GoCardlessPaymentResponse>;
  createGoCardlessSubscription: handleUnaryCall<CreateGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  cancelGoCardlessSubscription: handleUnaryCall<CancelGoCardlessSubscriptionRequest, GoCardlessSubscriptionResponse>;
  /** ==================== SCHEDULES ==================== */
  createSchedule: handleUnaryCall<CreateScheduleRequest, ScheduleResponse>;
  getSchedule: handleUnaryCall<GetByIdRequest, ScheduleResponse>;
  updateSchedule: handleUnaryCall<UpdateScheduleRequest, ScheduleResponse>;
  deleteSchedule: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  getDueSchedules: handleUnaryCall<GetDueSchedulesRequest, ScheduleListResponse>;
  processDuePayments: handleUnaryCall<ProcessDuePaymentsRequest, ProcessDuePaymentsResponse>;
  renewSchedule: handleUnaryCall<RenewScheduleRequest, ScheduleResponse>;
  /** ==================== PAYMENT INTENTS (Internal) ==================== */
  createPaymentIntent: handleUnaryCall<CreatePaymentIntentRequest, PaymentIntentResponse>;
  getPaymentIntent: handleUnaryCall<GetByIdRequest, PaymentIntentResponse>;
  updatePaymentIntent: handleUnaryCall<UpdatePaymentIntentRequest, PaymentIntentResponse>;
  deletePaymentIntent: handleUnaryCall<GetByIdRequest, DeleteResponse>;
  /** ==================== PAYMENT EVENTS ==================== */
  createPaymentEvent: handleUnaryCall<CreatePaymentEventRequest, PaymentEventResponse>;
  getPaymentEvent: handleUnaryCall<GetByIdRequest, PaymentEventResponse>;
  getUnprocessedEvents: handleUnaryCall<GetUnprocessedEventsRequest, PaymentEventListResponse>;
  markEventProcessed: handleUnaryCall<MarkEventProcessedRequest, PaymentEventResponse>;
  /** ==================== PSP ACCOUNTS ==================== */
  getPspAccountsSummary: handleUnaryCall<GetPSPAccountsRequest, PSPAccountsSummaryResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
