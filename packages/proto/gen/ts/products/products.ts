// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: products/products.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export enum TypeProduit {
  TYPE_PRODUIT_UNSPECIFIED = 0,
  INTERNE = 1,
  PARTENAIRE = 2,
}

export enum StatutCycleProduit {
  STATUT_CYCLE_PRODUIT_UNSPECIFIED = 0,
  STATUT_CYCLE_PRODUIT_BROUILLON = 1,
  STATUT_CYCLE_PRODUIT_TEST = 2,
  STATUT_CYCLE_PRODUIT_ACTIF = 3,
  STATUT_CYCLE_PRODUIT_GELE = 4,
  STATUT_CYCLE_PRODUIT_RETIRE = 5,
}

export enum CategorieProduit {
  CATEGORIE_PRODUIT_UNSPECIFIED = 0,
  ASSURANCE = 1,
  PREVOYANCE = 2,
  EPARGNE = 3,
  SERVICE = 4,
  ACCESSOIRE = 5,
}

export enum TypeDocumentProduit {
  TYPE_DOCUMENT_PRODUIT_UNSPECIFIED = 0,
  TYPE_DOCUMENT_PRODUIT_DIPA = 1,
  TYPE_DOCUMENT_PRODUIT_CG = 2,
  TYPE_DOCUMENT_PRODUIT_CP = 3,
  TYPE_DOCUMENT_PRODUIT_TARIF = 4,
  TYPE_DOCUMENT_PRODUIT_SCRIPT = 5,
  TYPE_DOCUMENT_PRODUIT_MEDIA = 6,
}

export enum VisibilitePublication {
  VISIBILITE_PUBLICATION_UNSPECIFIED = 0,
  VISIBILITE_PUBLICATION_CACHE = 1,
  VISIBILITE_PUBLICATION_INTERNE = 2,
  VISIBILITE_PUBLICATION_PUBLIC = 3,
}

export interface Empty {
}

export interface PaginationRequest {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResponse {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface Gamme {
  id: string;
  organisationId: string;
  nom: string;
  description: string;
  icone: string;
  code: string;
  ordre: number;
  actif: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateGammeRequest {
  organisationId: string;
  nom: string;
  description: string;
  icone: string;
  code: string;
  ordre: number;
}

export interface UpdateGammeRequest {
  id: string;
  nom?: string | undefined;
  description?: string | undefined;
  icone?: string | undefined;
  code?: string | undefined;
  ordre?: number | undefined;
  actif?: boolean | undefined;
}

export interface GetGammeRequest {
  id: string;
}

export interface ListGammesRequest {
  organisationId: string;
  actif?: boolean | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListGammesResponse {
  gammes: Gamme[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteGammeRequest {
  id: string;
}

export interface DeleteGammeResponse {
  success: boolean;
}

export interface Produit {
  id: string;
  organisationId: string;
  gammeId: string;
  sku: string;
  nom: string;
  description: string;
  categorie: CategorieProduit;
  type: TypeProduit;
  prix: number;
  tauxTva: number;
  devise: string;
  actif: boolean;
  promotionActive: boolean;
  prixPromotion: number;
  dateDebutPromotion: string;
  dateFinPromotion: string;
  imageUrl: string;
  codeExterne: string;
  metadata: string;
  createdAt: string;
  updatedAt: string;
  /** Relations */
  gamme?: Gamme | undefined;
  statutCycle: StatutCycleProduit;
}

export interface CreateProduitRequest {
  organisationId: string;
  gammeId: string;
  sku: string;
  nom: string;
  description: string;
  categorie: CategorieProduit;
  type: TypeProduit;
  prix: number;
  tauxTva: number;
  devise: string;
  imageUrl: string;
  codeExterne: string;
  metadata: string;
  statutCycle: StatutCycleProduit;
}

export interface UpdateProduitRequest {
  id: string;
  gammeId?: string | undefined;
  sku?: string | undefined;
  nom?: string | undefined;
  description?: string | undefined;
  categorie?: CategorieProduit | undefined;
  type?: TypeProduit | undefined;
  prix?: number | undefined;
  tauxTva?: number | undefined;
  devise?: string | undefined;
  actif?: boolean | undefined;
  imageUrl?: string | undefined;
  codeExterne?: string | undefined;
  metadata?: string | undefined;
  statutCycle?: StatutCycleProduit | undefined;
}

export interface GetProduitRequest {
  id: string;
}

export interface GetProduitBySkuRequest {
  organisationId: string;
  sku: string;
}

export interface ListProduitsRequest {
  organisationId: string;
  gammeId?: string | undefined;
  categorie?: CategorieProduit | undefined;
  type?: TypeProduit | undefined;
  actif?: boolean | undefined;
  promotionActive?: boolean | undefined;
  search?: string | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListProduitsResponse {
  produits: Produit[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteProduitRequest {
  id: string;
}

export interface DeleteProduitResponse {
  success: boolean;
}

export interface ProduitVersion {
  id: string;
  produitId: string;
  version: number;
  effectiveFrom: string;
  effectiveTo: string;
  notes: string;
  breakingChanges: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateProduitVersionRequest {
  produitId: string;
  version: number;
  effectiveFrom: string;
  effectiveTo?: string | undefined;
  notes?: string | undefined;
  breakingChanges?: boolean | undefined;
}

export interface UpdateProduitVersionRequest {
  id: string;
  effectiveFrom?: string | undefined;
  effectiveTo?: string | undefined;
  notes?: string | undefined;
  breakingChanges?: boolean | undefined;
}

export interface GetProduitVersionRequest {
  id: string;
}

export interface ListProduitVersionsRequest {
  produitId: string;
  pagination?: PaginationRequest | undefined;
}

export interface ListProduitVersionsResponse {
  versions: ProduitVersion[];
  pagination?: PaginationResponse | undefined;
}

export interface ProduitDocument {
  id: string;
  versionProduitId: string;
  type: TypeDocumentProduit;
  title: string;
  fileUrl: string;
  fileHash: string;
  mandatory: boolean;
  publishedAt: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateProduitDocumentRequest {
  versionProduitId: string;
  type: TypeDocumentProduit;
  title: string;
  fileUrl: string;
  fileHash: string;
  mandatory?: boolean | undefined;
}

export interface UpdateProduitDocumentRequest {
  id: string;
  title?: string | undefined;
  fileUrl?: string | undefined;
  fileHash?: string | undefined;
  mandatory?: boolean | undefined;
  publishedAt?: string | undefined;
}

export interface GetProduitDocumentRequest {
  id: string;
}

export interface ListProduitDocumentsRequest {
  versionProduitId: string;
}

export interface ListProduitDocumentsResponse {
  documents: ProduitDocument[];
}

export interface ProduitPublication {
  id: string;
  versionProduitId: string;
  societeId: string;
  channels: string[];
  visibilite: VisibilitePublication;
  startAt: string;
  endAt: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateProduitPublicationRequest {
  versionProduitId: string;
  societeId: string;
  channels: string[];
  visibilite: VisibilitePublication;
  startAt: string;
  endAt?: string | undefined;
}

export interface UpdateProduitPublicationRequest {
  id: string;
  channels: string[];
  visibilite?: VisibilitePublication | undefined;
  startAt?: string | undefined;
  endAt?: string | undefined;
}

export interface GetProduitPublicationRequest {
  id: string;
}

export interface ListProduitPublicationsByVersionRequest {
  versionProduitId: string;
}

export interface ListProduitPublicationsBySocieteRequest {
  societeId: string;
}

export interface ListProduitPublicationsResponse {
  publications: ProduitPublication[];
}

/** Promotion */
export interface SetPromotionRequest {
  produitId: string;
  prixPromotion: number;
  dateDebut: string;
  dateFin: string;
}

export interface ClearPromotionRequest {
  produitId: string;
}

export interface GrilleTarifaire {
  id: string;
  organisationId: string;
  nom: string;
  description: string;
  dateDebut: string;
  dateFin: string;
  estParDefaut: boolean;
  actif: boolean;
  createdAt: string;
  updatedAt: string;
  /** Relations */
  prixProduits: PrixProduit[];
}

export interface CreateGrilleTarifaireRequest {
  organisationId: string;
  nom: string;
  description: string;
  dateDebut: string;
  dateFin: string;
  estParDefaut: boolean;
}

export interface UpdateGrilleTarifaireRequest {
  id: string;
  nom?: string | undefined;
  description?: string | undefined;
  dateDebut?: string | undefined;
  dateFin?: string | undefined;
  estParDefaut?: boolean | undefined;
  actif?: boolean | undefined;
}

export interface GetGrilleTarifaireRequest {
  id: string;
}

export interface GetGrilleTarifaireActiveRequest {
  organisationId: string;
  date: string;
}

export interface ListGrillesTarifairesRequest {
  organisationId: string;
  actif?: boolean | undefined;
  estParDefaut?: boolean | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListGrillesTarifairesResponse {
  grilles: GrilleTarifaire[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteGrilleTarifaireRequest {
  id: string;
}

export interface DeleteGrilleTarifaireResponse {
  success: boolean;
}

export interface SetGrilleParDefautRequest {
  id: string;
}

export interface PrixProduit {
  id: string;
  grilleTarifaireId: string;
  produitId: string;
  prixUnitaire: number;
  remisePourcent: number;
  prixMinimum: number;
  prixMaximum: number;
  actif: boolean;
  createdAt: string;
  updatedAt: string;
  /** Relations */
  produit?: Produit | undefined;
  grilleTarifaire?: GrilleTarifaire | undefined;
}

export interface CreatePrixProduitRequest {
  grilleTarifaireId: string;
  produitId: string;
  prixUnitaire: number;
  remisePourcent: number;
  prixMinimum: number;
  prixMaximum: number;
}

export interface UpdatePrixProduitRequest {
  id: string;
  prixUnitaire?: number | undefined;
  remisePourcent?: number | undefined;
  prixMinimum?: number | undefined;
  prixMaximum?: number | undefined;
  actif?: boolean | undefined;
}

export interface GetPrixProduitRequest {
  id: string;
}

export interface GetPrixForProduitRequest {
  grilleTarifaireId: string;
  produitId: string;
}

export interface ListPrixProduitsRequest {
  grilleTarifaireId: string;
  produitId?: string | undefined;
  actif?: boolean | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListPrixProduitsResponse {
  prixProduits: PrixProduit[];
  pagination?: PaginationResponse | undefined;
}

export interface DeletePrixProduitRequest {
  id: string;
}

export interface DeletePrixProduitResponse {
  success: boolean;
}

/** Bulk operations */
export interface BulkCreatePrixProduitsRequest {
  grilleTarifaireId: string;
  items: CreatePrixProduitItem[];
}

export interface CreatePrixProduitItem {
  produitId: string;
  prixUnitaire: number;
  remisePourcent: number;
  prixMinimum: number;
  prixMaximum: number;
}

export interface BulkCreatePrixProduitsResponse {
  created: PrixProduit[];
  count: number;
}

export interface GetCatalogRequest {
  organisationId: string;
  grilleTarifaireId?: string | undefined;
  gammeId?: string | undefined;
  includeInactive?: boolean | undefined;
}

export interface CatalogItem {
  produit?: Produit | undefined;
  prix?: PrixProduit | undefined;
  prixFinal: number;
  enPromotion: boolean;
}

export interface GetCatalogResponse {
  items: CatalogItem[];
  grilleUtilisee?: GrilleTarifaire | undefined;
}

export interface CalculatePriceRequest {
  produitId: string;
  grilleTarifaireId: string;
  quantite: number;
  remiseAdditionnelle: number;
}

export interface CalculatePriceResponse {
  prixUnitaire: number;
  prixApresRemise: number;
  prixTotalHt: number;
  tva: number;
  prixTotalTtc: number;
  promotionAppliquee: boolean;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGamme(): Gamme {
  return {
    id: "",
    organisationId: "",
    nom: "",
    description: "",
    icone: "",
    code: "",
    ordre: 0,
    actif: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const Gamme: MessageFns<Gamme> = {
  encode(message: Gamme, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.icone !== "") {
      writer.uint32(42).string(message.icone);
    }
    if (message.code !== "") {
      writer.uint32(50).string(message.code);
    }
    if (message.ordre !== 0) {
      writer.uint32(56).int32(message.ordre);
    }
    if (message.actif !== false) {
      writer.uint32(64).bool(message.actif);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Gamme {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGamme();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.icone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateGammeRequest(): CreateGammeRequest {
  return { organisationId: "", nom: "", description: "", icone: "", code: "", ordre: 0 };
}

export const CreateGammeRequest: MessageFns<CreateGammeRequest> = {
  encode(message: CreateGammeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.icone !== "") {
      writer.uint32(34).string(message.icone);
    }
    if (message.code !== "") {
      writer.uint32(42).string(message.code);
    }
    if (message.ordre !== 0) {
      writer.uint32(48).int32(message.ordre);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGammeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGammeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateGammeRequest(): UpdateGammeRequest {
  return { id: "" };
}

export const UpdateGammeRequest: MessageFns<UpdateGammeRequest> = {
  encode(message: UpdateGammeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.icone !== undefined) {
      writer.uint32(34).string(message.icone);
    }
    if (message.code !== undefined) {
      writer.uint32(42).string(message.code);
    }
    if (message.ordre !== undefined) {
      writer.uint32(48).int32(message.ordre);
    }
    if (message.actif !== undefined) {
      writer.uint32(56).bool(message.actif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGammeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGammeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.icone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetGammeRequest(): GetGammeRequest {
  return { id: "" };
}

export const GetGammeRequest: MessageFns<GetGammeRequest> = {
  encode(message: GetGammeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGammeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGammeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListGammesRequest(): ListGammesRequest {
  return { organisationId: "" };
}

export const ListGammesRequest: MessageFns<ListGammesRequest> = {
  encode(message: ListGammesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.actif !== undefined) {
      writer.uint32(16).bool(message.actif);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGammesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGammesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListGammesResponse(): ListGammesResponse {
  return { gammes: [] };
}

export const ListGammesResponse: MessageFns<ListGammesResponse> = {
  encode(message: ListGammesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gammes) {
      Gamme.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGammesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGammesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gammes.push(Gamme.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteGammeRequest(): DeleteGammeRequest {
  return { id: "" };
}

export const DeleteGammeRequest: MessageFns<DeleteGammeRequest> = {
  encode(message: DeleteGammeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGammeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGammeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteGammeResponse(): DeleteGammeResponse {
  return { success: false };
}

export const DeleteGammeResponse: MessageFns<DeleteGammeResponse> = {
  encode(message: DeleteGammeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGammeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGammeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProduit(): Produit {
  return {
    id: "",
    organisationId: "",
    gammeId: "",
    sku: "",
    nom: "",
    description: "",
    categorie: 0,
    type: 0,
    prix: 0,
    tauxTva: 0,
    devise: "",
    actif: false,
    promotionActive: false,
    prixPromotion: 0,
    dateDebutPromotion: "",
    dateFinPromotion: "",
    imageUrl: "",
    codeExterne: "",
    metadata: "",
    createdAt: "",
    updatedAt: "",
    statutCycle: 0,
  };
}

export const Produit: MessageFns<Produit> = {
  encode(message: Produit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.gammeId !== "") {
      writer.uint32(26).string(message.gammeId);
    }
    if (message.sku !== "") {
      writer.uint32(34).string(message.sku);
    }
    if (message.nom !== "") {
      writer.uint32(42).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.categorie !== 0) {
      writer.uint32(56).int32(message.categorie);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    if (message.prix !== 0) {
      writer.uint32(73).double(message.prix);
    }
    if (message.tauxTva !== 0) {
      writer.uint32(81).double(message.tauxTva);
    }
    if (message.devise !== "") {
      writer.uint32(90).string(message.devise);
    }
    if (message.actif !== false) {
      writer.uint32(96).bool(message.actif);
    }
    if (message.promotionActive !== false) {
      writer.uint32(104).bool(message.promotionActive);
    }
    if (message.prixPromotion !== 0) {
      writer.uint32(113).double(message.prixPromotion);
    }
    if (message.dateDebutPromotion !== "") {
      writer.uint32(122).string(message.dateDebutPromotion);
    }
    if (message.dateFinPromotion !== "") {
      writer.uint32(130).string(message.dateFinPromotion);
    }
    if (message.imageUrl !== "") {
      writer.uint32(138).string(message.imageUrl);
    }
    if (message.codeExterne !== "") {
      writer.uint32(146).string(message.codeExterne);
    }
    if (message.metadata !== "") {
      writer.uint32(154).string(message.metadata);
    }
    if (message.createdAt !== "") {
      writer.uint32(162).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(170).string(message.updatedAt);
    }
    if (message.gamme !== undefined) {
      Gamme.encode(message.gamme, writer.uint32(178).fork()).join();
    }
    if (message.statutCycle !== 0) {
      writer.uint32(184).int32(message.statutCycle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Produit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gammeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.categorie = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.prix = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.devise = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.promotionActive = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 113) {
            break;
          }

          message.prixPromotion = reader.double();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.dateDebutPromotion = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dateFinPromotion = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.codeExterne = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.gamme = Gamme.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.statutCycle = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProduitRequest(): CreateProduitRequest {
  return {
    organisationId: "",
    gammeId: "",
    sku: "",
    nom: "",
    description: "",
    categorie: 0,
    type: 0,
    prix: 0,
    tauxTva: 0,
    devise: "",
    imageUrl: "",
    codeExterne: "",
    metadata: "",
    statutCycle: 0,
  };
}

export const CreateProduitRequest: MessageFns<CreateProduitRequest> = {
  encode(message: CreateProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.gammeId !== "") {
      writer.uint32(18).string(message.gammeId);
    }
    if (message.sku !== "") {
      writer.uint32(26).string(message.sku);
    }
    if (message.nom !== "") {
      writer.uint32(34).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.categorie !== 0) {
      writer.uint32(48).int32(message.categorie);
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.prix !== 0) {
      writer.uint32(65).double(message.prix);
    }
    if (message.tauxTva !== 0) {
      writer.uint32(73).double(message.tauxTva);
    }
    if (message.devise !== "") {
      writer.uint32(82).string(message.devise);
    }
    if (message.imageUrl !== "") {
      writer.uint32(90).string(message.imageUrl);
    }
    if (message.codeExterne !== "") {
      writer.uint32(98).string(message.codeExterne);
    }
    if (message.metadata !== "") {
      writer.uint32(106).string(message.metadata);
    }
    if (message.statutCycle !== 0) {
      writer.uint32(112).int32(message.statutCycle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gammeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.categorie = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.prix = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.devise = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.codeExterne = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.statutCycle = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProduitRequest(): UpdateProduitRequest {
  return { id: "" };
}

export const UpdateProduitRequest: MessageFns<UpdateProduitRequest> = {
  encode(message: UpdateProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.gammeId !== undefined) {
      writer.uint32(18).string(message.gammeId);
    }
    if (message.sku !== undefined) {
      writer.uint32(26).string(message.sku);
    }
    if (message.nom !== undefined) {
      writer.uint32(34).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.categorie !== undefined) {
      writer.uint32(48).int32(message.categorie);
    }
    if (message.type !== undefined) {
      writer.uint32(56).int32(message.type);
    }
    if (message.prix !== undefined) {
      writer.uint32(65).double(message.prix);
    }
    if (message.tauxTva !== undefined) {
      writer.uint32(73).double(message.tauxTva);
    }
    if (message.devise !== undefined) {
      writer.uint32(82).string(message.devise);
    }
    if (message.actif !== undefined) {
      writer.uint32(88).bool(message.actif);
    }
    if (message.imageUrl !== undefined) {
      writer.uint32(98).string(message.imageUrl);
    }
    if (message.codeExterne !== undefined) {
      writer.uint32(106).string(message.codeExterne);
    }
    if (message.metadata !== undefined) {
      writer.uint32(114).string(message.metadata);
    }
    if (message.statutCycle !== undefined) {
      writer.uint32(120).int32(message.statutCycle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gammeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.categorie = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.prix = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.tauxTva = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.devise = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.imageUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.codeExterne = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.statutCycle = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProduitRequest(): GetProduitRequest {
  return { id: "" };
}

export const GetProduitRequest: MessageFns<GetProduitRequest> = {
  encode(message: GetProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProduitBySkuRequest(): GetProduitBySkuRequest {
  return { organisationId: "", sku: "" };
}

export const GetProduitBySkuRequest: MessageFns<GetProduitBySkuRequest> = {
  encode(message: GetProduitBySkuRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.sku !== "") {
      writer.uint32(18).string(message.sku);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProduitBySkuRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProduitBySkuRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitsRequest(): ListProduitsRequest {
  return { organisationId: "" };
}

export const ListProduitsRequest: MessageFns<ListProduitsRequest> = {
  encode(message: ListProduitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.gammeId !== undefined) {
      writer.uint32(18).string(message.gammeId);
    }
    if (message.categorie !== undefined) {
      writer.uint32(24).int32(message.categorie);
    }
    if (message.type !== undefined) {
      writer.uint32(32).int32(message.type);
    }
    if (message.actif !== undefined) {
      writer.uint32(40).bool(message.actif);
    }
    if (message.promotionActive !== undefined) {
      writer.uint32(48).bool(message.promotionActive);
    }
    if (message.search !== undefined) {
      writer.uint32(58).string(message.search);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gammeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.categorie = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.promotionActive = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitsResponse(): ListProduitsResponse {
  return { produits: [] };
}

export const ListProduitsResponse: MessageFns<ListProduitsResponse> = {
  encode(message: ListProduitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.produits) {
      Produit.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produits.push(Produit.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteProduitRequest(): DeleteProduitRequest {
  return { id: "" };
}

export const DeleteProduitRequest: MessageFns<DeleteProduitRequest> = {
  encode(message: DeleteProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteProduitResponse(): DeleteProduitResponse {
  return { success: false };
}

export const DeleteProduitResponse: MessageFns<DeleteProduitResponse> = {
  encode(message: DeleteProduitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProduitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProduitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProduitVersion(): ProduitVersion {
  return {
    id: "",
    produitId: "",
    version: 0,
    effectiveFrom: "",
    effectiveTo: "",
    notes: "",
    breakingChanges: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const ProduitVersion: MessageFns<ProduitVersion> = {
  encode(message: ProduitVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.produitId !== "") {
      writer.uint32(18).string(message.produitId);
    }
    if (message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    if (message.effectiveFrom !== "") {
      writer.uint32(34).string(message.effectiveFrom);
    }
    if (message.effectiveTo !== "") {
      writer.uint32(42).string(message.effectiveTo);
    }
    if (message.notes !== "") {
      writer.uint32(50).string(message.notes);
    }
    if (message.breakingChanges !== false) {
      writer.uint32(56).bool(message.breakingChanges);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProduitVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduitVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.effectiveFrom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.effectiveTo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.breakingChanges = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProduitVersionRequest(): CreateProduitVersionRequest {
  return { produitId: "", version: 0, effectiveFrom: "" };
}

export const CreateProduitVersionRequest: MessageFns<CreateProduitVersionRequest> = {
  encode(message: CreateProduitVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.effectiveFrom !== "") {
      writer.uint32(26).string(message.effectiveFrom);
    }
    if (message.effectiveTo !== undefined) {
      writer.uint32(34).string(message.effectiveTo);
    }
    if (message.notes !== undefined) {
      writer.uint32(42).string(message.notes);
    }
    if (message.breakingChanges !== undefined) {
      writer.uint32(48).bool(message.breakingChanges);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProduitVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProduitVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.effectiveFrom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.effectiveTo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.breakingChanges = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProduitVersionRequest(): UpdateProduitVersionRequest {
  return { id: "" };
}

export const UpdateProduitVersionRequest: MessageFns<UpdateProduitVersionRequest> = {
  encode(message: UpdateProduitVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.effectiveFrom !== undefined) {
      writer.uint32(18).string(message.effectiveFrom);
    }
    if (message.effectiveTo !== undefined) {
      writer.uint32(26).string(message.effectiveTo);
    }
    if (message.notes !== undefined) {
      writer.uint32(34).string(message.notes);
    }
    if (message.breakingChanges !== undefined) {
      writer.uint32(40).bool(message.breakingChanges);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProduitVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProduitVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.effectiveFrom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.effectiveTo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.breakingChanges = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProduitVersionRequest(): GetProduitVersionRequest {
  return { id: "" };
}

export const GetProduitVersionRequest: MessageFns<GetProduitVersionRequest> = {
  encode(message: GetProduitVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProduitVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProduitVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitVersionsRequest(): ListProduitVersionsRequest {
  return { produitId: "" };
}

export const ListProduitVersionsRequest: MessageFns<ListProduitVersionsRequest> = {
  encode(message: ListProduitVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitVersionsResponse(): ListProduitVersionsResponse {
  return { versions: [] };
}

export const ListProduitVersionsResponse: MessageFns<ListProduitVersionsResponse> = {
  encode(message: ListProduitVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.versions) {
      ProduitVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versions.push(ProduitVersion.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProduitDocument(): ProduitDocument {
  return {
    id: "",
    versionProduitId: "",
    type: 0,
    title: "",
    fileUrl: "",
    fileHash: "",
    mandatory: false,
    publishedAt: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const ProduitDocument: MessageFns<ProduitDocument> = {
  encode(message: ProduitDocument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.versionProduitId !== "") {
      writer.uint32(18).string(message.versionProduitId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.fileUrl !== "") {
      writer.uint32(42).string(message.fileUrl);
    }
    if (message.fileHash !== "") {
      writer.uint32(50).string(message.fileHash);
    }
    if (message.mandatory !== false) {
      writer.uint32(56).bool(message.mandatory);
    }
    if (message.publishedAt !== "") {
      writer.uint32(66).string(message.publishedAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProduitDocument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduitDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.versionProduitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fileHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.mandatory = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.publishedAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProduitDocumentRequest(): CreateProduitDocumentRequest {
  return { versionProduitId: "", type: 0, title: "", fileUrl: "", fileHash: "" };
}

export const CreateProduitDocumentRequest: MessageFns<CreateProduitDocumentRequest> = {
  encode(message: CreateProduitDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionProduitId !== "") {
      writer.uint32(10).string(message.versionProduitId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.fileUrl !== "") {
      writer.uint32(34).string(message.fileUrl);
    }
    if (message.fileHash !== "") {
      writer.uint32(42).string(message.fileHash);
    }
    if (message.mandatory !== undefined) {
      writer.uint32(48).bool(message.mandatory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProduitDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProduitDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionProduitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.mandatory = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProduitDocumentRequest(): UpdateProduitDocumentRequest {
  return { id: "" };
}

export const UpdateProduitDocumentRequest: MessageFns<UpdateProduitDocumentRequest> = {
  encode(message: UpdateProduitDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== undefined) {
      writer.uint32(18).string(message.title);
    }
    if (message.fileUrl !== undefined) {
      writer.uint32(26).string(message.fileUrl);
    }
    if (message.fileHash !== undefined) {
      writer.uint32(34).string(message.fileHash);
    }
    if (message.mandatory !== undefined) {
      writer.uint32(40).bool(message.mandatory);
    }
    if (message.publishedAt !== undefined) {
      writer.uint32(50).string(message.publishedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProduitDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProduitDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.mandatory = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publishedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProduitDocumentRequest(): GetProduitDocumentRequest {
  return { id: "" };
}

export const GetProduitDocumentRequest: MessageFns<GetProduitDocumentRequest> = {
  encode(message: GetProduitDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProduitDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProduitDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitDocumentsRequest(): ListProduitDocumentsRequest {
  return { versionProduitId: "" };
}

export const ListProduitDocumentsRequest: MessageFns<ListProduitDocumentsRequest> = {
  encode(message: ListProduitDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionProduitId !== "") {
      writer.uint32(10).string(message.versionProduitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionProduitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitDocumentsResponse(): ListProduitDocumentsResponse {
  return { documents: [] };
}

export const ListProduitDocumentsResponse: MessageFns<ListProduitDocumentsResponse> = {
  encode(message: ListProduitDocumentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      ProduitDocument.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitDocumentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(ProduitDocument.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProduitPublication(): ProduitPublication {
  return {
    id: "",
    versionProduitId: "",
    societeId: "",
    channels: [],
    visibilite: 0,
    startAt: "",
    endAt: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const ProduitPublication: MessageFns<ProduitPublication> = {
  encode(message: ProduitPublication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.versionProduitId !== "") {
      writer.uint32(18).string(message.versionProduitId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    for (const v of message.channels) {
      writer.uint32(34).string(v!);
    }
    if (message.visibilite !== 0) {
      writer.uint32(40).int32(message.visibilite);
    }
    if (message.startAt !== "") {
      writer.uint32(50).string(message.startAt);
    }
    if (message.endAt !== "") {
      writer.uint32(58).string(message.endAt);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProduitPublication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduitPublication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.versionProduitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channels.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.visibilite = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProduitPublicationRequest(): CreateProduitPublicationRequest {
  return { versionProduitId: "", societeId: "", channels: [], visibilite: 0, startAt: "" };
}

export const CreateProduitPublicationRequest: MessageFns<CreateProduitPublicationRequest> = {
  encode(message: CreateProduitPublicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionProduitId !== "") {
      writer.uint32(10).string(message.versionProduitId);
    }
    if (message.societeId !== "") {
      writer.uint32(18).string(message.societeId);
    }
    for (const v of message.channels) {
      writer.uint32(26).string(v!);
    }
    if (message.visibilite !== 0) {
      writer.uint32(32).int32(message.visibilite);
    }
    if (message.startAt !== "") {
      writer.uint32(42).string(message.startAt);
    }
    if (message.endAt !== undefined) {
      writer.uint32(50).string(message.endAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProduitPublicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProduitPublicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionProduitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channels.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.visibilite = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProduitPublicationRequest(): UpdateProduitPublicationRequest {
  return { id: "", channels: [] };
}

export const UpdateProduitPublicationRequest: MessageFns<UpdateProduitPublicationRequest> = {
  encode(message: UpdateProduitPublicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.channels) {
      writer.uint32(18).string(v!);
    }
    if (message.visibilite !== undefined) {
      writer.uint32(24).int32(message.visibilite);
    }
    if (message.startAt !== undefined) {
      writer.uint32(34).string(message.startAt);
    }
    if (message.endAt !== undefined) {
      writer.uint32(42).string(message.endAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProduitPublicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProduitPublicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channels.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.visibilite = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetProduitPublicationRequest(): GetProduitPublicationRequest {
  return { id: "" };
}

export const GetProduitPublicationRequest: MessageFns<GetProduitPublicationRequest> = {
  encode(message: GetProduitPublicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProduitPublicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProduitPublicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitPublicationsByVersionRequest(): ListProduitPublicationsByVersionRequest {
  return { versionProduitId: "" };
}

export const ListProduitPublicationsByVersionRequest: MessageFns<ListProduitPublicationsByVersionRequest> = {
  encode(message: ListProduitPublicationsByVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.versionProduitId !== "") {
      writer.uint32(10).string(message.versionProduitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitPublicationsByVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitPublicationsByVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.versionProduitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitPublicationsBySocieteRequest(): ListProduitPublicationsBySocieteRequest {
  return { societeId: "" };
}

export const ListProduitPublicationsBySocieteRequest: MessageFns<ListProduitPublicationsBySocieteRequest> = {
  encode(message: ListProduitPublicationsBySocieteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.societeId !== "") {
      writer.uint32(10).string(message.societeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitPublicationsBySocieteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitPublicationsBySocieteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListProduitPublicationsResponse(): ListProduitPublicationsResponse {
  return { publications: [] };
}

export const ListProduitPublicationsResponse: MessageFns<ListProduitPublicationsResponse> = {
  encode(message: ListProduitPublicationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.publications) {
      ProduitPublication.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProduitPublicationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProduitPublicationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publications.push(ProduitPublication.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSetPromotionRequest(): SetPromotionRequest {
  return { produitId: "", prixPromotion: 0, dateDebut: "", dateFin: "" };
}

export const SetPromotionRequest: MessageFns<SetPromotionRequest> = {
  encode(message: SetPromotionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    if (message.prixPromotion !== 0) {
      writer.uint32(17).double(message.prixPromotion);
    }
    if (message.dateDebut !== "") {
      writer.uint32(26).string(message.dateDebut);
    }
    if (message.dateFin !== "") {
      writer.uint32(34).string(message.dateFin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetPromotionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetPromotionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.prixPromotion = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseClearPromotionRequest(): ClearPromotionRequest {
  return { produitId: "" };
}

export const ClearPromotionRequest: MessageFns<ClearPromotionRequest> = {
  encode(message: ClearPromotionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearPromotionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearPromotionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGrilleTarifaire(): GrilleTarifaire {
  return {
    id: "",
    organisationId: "",
    nom: "",
    description: "",
    dateDebut: "",
    dateFin: "",
    estParDefaut: false,
    actif: false,
    createdAt: "",
    updatedAt: "",
    prixProduits: [],
  };
}

export const GrilleTarifaire: MessageFns<GrilleTarifaire> = {
  encode(message: GrilleTarifaire, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.dateDebut !== "") {
      writer.uint32(42).string(message.dateDebut);
    }
    if (message.dateFin !== "") {
      writer.uint32(50).string(message.dateFin);
    }
    if (message.estParDefaut !== false) {
      writer.uint32(56).bool(message.estParDefaut);
    }
    if (message.actif !== false) {
      writer.uint32(64).bool(message.actif);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    for (const v of message.prixProduits) {
      PrixProduit.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrilleTarifaire {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrilleTarifaire();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.estParDefaut = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.prixProduits.push(PrixProduit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateGrilleTarifaireRequest(): CreateGrilleTarifaireRequest {
  return { organisationId: "", nom: "", description: "", dateDebut: "", dateFin: "", estParDefaut: false };
}

export const CreateGrilleTarifaireRequest: MessageFns<CreateGrilleTarifaireRequest> = {
  encode(message: CreateGrilleTarifaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.dateDebut !== "") {
      writer.uint32(34).string(message.dateDebut);
    }
    if (message.dateFin !== "") {
      writer.uint32(42).string(message.dateFin);
    }
    if (message.estParDefaut !== false) {
      writer.uint32(48).bool(message.estParDefaut);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGrilleTarifaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGrilleTarifaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.estParDefaut = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateGrilleTarifaireRequest(): UpdateGrilleTarifaireRequest {
  return { id: "" };
}

export const UpdateGrilleTarifaireRequest: MessageFns<UpdateGrilleTarifaireRequest> = {
  encode(message: UpdateGrilleTarifaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.dateDebut !== undefined) {
      writer.uint32(34).string(message.dateDebut);
    }
    if (message.dateFin !== undefined) {
      writer.uint32(42).string(message.dateFin);
    }
    if (message.estParDefaut !== undefined) {
      writer.uint32(48).bool(message.estParDefaut);
    }
    if (message.actif !== undefined) {
      writer.uint32(56).bool(message.actif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGrilleTarifaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGrilleTarifaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dateDebut = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dateFin = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.estParDefaut = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetGrilleTarifaireRequest(): GetGrilleTarifaireRequest {
  return { id: "" };
}

export const GetGrilleTarifaireRequest: MessageFns<GetGrilleTarifaireRequest> = {
  encode(message: GetGrilleTarifaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGrilleTarifaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGrilleTarifaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetGrilleTarifaireActiveRequest(): GetGrilleTarifaireActiveRequest {
  return { organisationId: "", date: "" };
}

export const GetGrilleTarifaireActiveRequest: MessageFns<GetGrilleTarifaireActiveRequest> = {
  encode(message: GetGrilleTarifaireActiveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGrilleTarifaireActiveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGrilleTarifaireActiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListGrillesTarifairesRequest(): ListGrillesTarifairesRequest {
  return { organisationId: "" };
}

export const ListGrillesTarifairesRequest: MessageFns<ListGrillesTarifairesRequest> = {
  encode(message: ListGrillesTarifairesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.actif !== undefined) {
      writer.uint32(16).bool(message.actif);
    }
    if (message.estParDefaut !== undefined) {
      writer.uint32(24).bool(message.estParDefaut);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGrillesTarifairesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGrillesTarifairesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.estParDefaut = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListGrillesTarifairesResponse(): ListGrillesTarifairesResponse {
  return { grilles: [] };
}

export const ListGrillesTarifairesResponse: MessageFns<ListGrillesTarifairesResponse> = {
  encode(message: ListGrillesTarifairesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.grilles) {
      GrilleTarifaire.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGrillesTarifairesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGrillesTarifairesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grilles.push(GrilleTarifaire.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteGrilleTarifaireRequest(): DeleteGrilleTarifaireRequest {
  return { id: "" };
}

export const DeleteGrilleTarifaireRequest: MessageFns<DeleteGrilleTarifaireRequest> = {
  encode(message: DeleteGrilleTarifaireRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGrilleTarifaireRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGrilleTarifaireRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteGrilleTarifaireResponse(): DeleteGrilleTarifaireResponse {
  return { success: false };
}

export const DeleteGrilleTarifaireResponse: MessageFns<DeleteGrilleTarifaireResponse> = {
  encode(message: DeleteGrilleTarifaireResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGrilleTarifaireResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGrilleTarifaireResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSetGrilleParDefautRequest(): SetGrilleParDefautRequest {
  return { id: "" };
}

export const SetGrilleParDefautRequest: MessageFns<SetGrilleParDefautRequest> = {
  encode(message: SetGrilleParDefautRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGrilleParDefautRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGrilleParDefautRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePrixProduit(): PrixProduit {
  return {
    id: "",
    grilleTarifaireId: "",
    produitId: "",
    prixUnitaire: 0,
    remisePourcent: 0,
    prixMinimum: 0,
    prixMaximum: 0,
    actif: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const PrixProduit: MessageFns<PrixProduit> = {
  encode(message: PrixProduit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.grilleTarifaireId !== "") {
      writer.uint32(18).string(message.grilleTarifaireId);
    }
    if (message.produitId !== "") {
      writer.uint32(26).string(message.produitId);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(33).double(message.prixUnitaire);
    }
    if (message.remisePourcent !== 0) {
      writer.uint32(41).double(message.remisePourcent);
    }
    if (message.prixMinimum !== 0) {
      writer.uint32(49).double(message.prixMinimum);
    }
    if (message.prixMaximum !== 0) {
      writer.uint32(57).double(message.prixMaximum);
    }
    if (message.actif !== false) {
      writer.uint32(64).bool(message.actif);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(82).string(message.updatedAt);
    }
    if (message.produit !== undefined) {
      Produit.encode(message.produit, writer.uint32(90).fork()).join();
    }
    if (message.grilleTarifaire !== undefined) {
      GrilleTarifaire.encode(message.grilleTarifaire, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrixProduit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrixProduit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grilleTarifaireId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.remisePourcent = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.prixMinimum = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.prixMaximum = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.produit = Produit.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.grilleTarifaire = GrilleTarifaire.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePrixProduitRequest(): CreatePrixProduitRequest {
  return { grilleTarifaireId: "", produitId: "", prixUnitaire: 0, remisePourcent: 0, prixMinimum: 0, prixMaximum: 0 };
}

export const CreatePrixProduitRequest: MessageFns<CreatePrixProduitRequest> = {
  encode(message: CreatePrixProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grilleTarifaireId !== "") {
      writer.uint32(10).string(message.grilleTarifaireId);
    }
    if (message.produitId !== "") {
      writer.uint32(18).string(message.produitId);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(25).double(message.prixUnitaire);
    }
    if (message.remisePourcent !== 0) {
      writer.uint32(33).double(message.remisePourcent);
    }
    if (message.prixMinimum !== 0) {
      writer.uint32(41).double(message.prixMinimum);
    }
    if (message.prixMaximum !== 0) {
      writer.uint32(49).double(message.prixMaximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePrixProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePrixProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grilleTarifaireId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.remisePourcent = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.prixMinimum = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.prixMaximum = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePrixProduitRequest(): UpdatePrixProduitRequest {
  return { id: "" };
}

export const UpdatePrixProduitRequest: MessageFns<UpdatePrixProduitRequest> = {
  encode(message: UpdatePrixProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.prixUnitaire !== undefined) {
      writer.uint32(17).double(message.prixUnitaire);
    }
    if (message.remisePourcent !== undefined) {
      writer.uint32(25).double(message.remisePourcent);
    }
    if (message.prixMinimum !== undefined) {
      writer.uint32(33).double(message.prixMinimum);
    }
    if (message.prixMaximum !== undefined) {
      writer.uint32(41).double(message.prixMaximum);
    }
    if (message.actif !== undefined) {
      writer.uint32(48).bool(message.actif);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePrixProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePrixProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.remisePourcent = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.prixMinimum = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.prixMaximum = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPrixProduitRequest(): GetPrixProduitRequest {
  return { id: "" };
}

export const GetPrixProduitRequest: MessageFns<GetPrixProduitRequest> = {
  encode(message: GetPrixProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPrixProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPrixProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPrixForProduitRequest(): GetPrixForProduitRequest {
  return { grilleTarifaireId: "", produitId: "" };
}

export const GetPrixForProduitRequest: MessageFns<GetPrixForProduitRequest> = {
  encode(message: GetPrixForProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grilleTarifaireId !== "") {
      writer.uint32(10).string(message.grilleTarifaireId);
    }
    if (message.produitId !== "") {
      writer.uint32(18).string(message.produitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPrixForProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPrixForProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grilleTarifaireId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPrixProduitsRequest(): ListPrixProduitsRequest {
  return { grilleTarifaireId: "" };
}

export const ListPrixProduitsRequest: MessageFns<ListPrixProduitsRequest> = {
  encode(message: ListPrixProduitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grilleTarifaireId !== "") {
      writer.uint32(10).string(message.grilleTarifaireId);
    }
    if (message.produitId !== undefined) {
      writer.uint32(18).string(message.produitId);
    }
    if (message.actif !== undefined) {
      writer.uint32(24).bool(message.actif);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrixProduitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrixProduitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grilleTarifaireId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPrixProduitsResponse(): ListPrixProduitsResponse {
  return { prixProduits: [] };
}

export const ListPrixProduitsResponse: MessageFns<ListPrixProduitsResponse> = {
  encode(message: ListPrixProduitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prixProduits) {
      PrixProduit.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrixProduitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrixProduitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prixProduits.push(PrixProduit.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeletePrixProduitRequest(): DeletePrixProduitRequest {
  return { id: "" };
}

export const DeletePrixProduitRequest: MessageFns<DeletePrixProduitRequest> = {
  encode(message: DeletePrixProduitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePrixProduitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePrixProduitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeletePrixProduitResponse(): DeletePrixProduitResponse {
  return { success: false };
}

export const DeletePrixProduitResponse: MessageFns<DeletePrixProduitResponse> = {
  encode(message: DeletePrixProduitResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePrixProduitResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePrixProduitResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBulkCreatePrixProduitsRequest(): BulkCreatePrixProduitsRequest {
  return { grilleTarifaireId: "", items: [] };
}

export const BulkCreatePrixProduitsRequest: MessageFns<BulkCreatePrixProduitsRequest> = {
  encode(message: BulkCreatePrixProduitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grilleTarifaireId !== "") {
      writer.uint32(10).string(message.grilleTarifaireId);
    }
    for (const v of message.items) {
      CreatePrixProduitItem.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkCreatePrixProduitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkCreatePrixProduitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grilleTarifaireId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(CreatePrixProduitItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePrixProduitItem(): CreatePrixProduitItem {
  return { produitId: "", prixUnitaire: 0, remisePourcent: 0, prixMinimum: 0, prixMaximum: 0 };
}

export const CreatePrixProduitItem: MessageFns<CreatePrixProduitItem> = {
  encode(message: CreatePrixProduitItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    if (message.prixUnitaire !== 0) {
      writer.uint32(17).double(message.prixUnitaire);
    }
    if (message.remisePourcent !== 0) {
      writer.uint32(25).double(message.remisePourcent);
    }
    if (message.prixMinimum !== 0) {
      writer.uint32(33).double(message.prixMinimum);
    }
    if (message.prixMaximum !== 0) {
      writer.uint32(41).double(message.prixMaximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePrixProduitItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePrixProduitItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.remisePourcent = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.prixMinimum = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.prixMaximum = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBulkCreatePrixProduitsResponse(): BulkCreatePrixProduitsResponse {
  return { created: [], count: 0 };
}

export const BulkCreatePrixProduitsResponse: MessageFns<BulkCreatePrixProduitsResponse> = {
  encode(message: BulkCreatePrixProduitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.created) {
      PrixProduit.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BulkCreatePrixProduitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkCreatePrixProduitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.created.push(PrixProduit.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCatalogRequest(): GetCatalogRequest {
  return { organisationId: "" };
}

export const GetCatalogRequest: MessageFns<GetCatalogRequest> = {
  encode(message: GetCatalogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.grilleTarifaireId !== undefined) {
      writer.uint32(18).string(message.grilleTarifaireId);
    }
    if (message.gammeId !== undefined) {
      writer.uint32(26).string(message.gammeId);
    }
    if (message.includeInactive !== undefined) {
      writer.uint32(32).bool(message.includeInactive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCatalogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCatalogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grilleTarifaireId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gammeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCatalogItem(): CatalogItem {
  return { prixFinal: 0, enPromotion: false };
}

export const CatalogItem: MessageFns<CatalogItem> = {
  encode(message: CatalogItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produit !== undefined) {
      Produit.encode(message.produit, writer.uint32(10).fork()).join();
    }
    if (message.prix !== undefined) {
      PrixProduit.encode(message.prix, writer.uint32(18).fork()).join();
    }
    if (message.prixFinal !== 0) {
      writer.uint32(25).double(message.prixFinal);
    }
    if (message.enPromotion !== false) {
      writer.uint32(32).bool(message.enPromotion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produit = Produit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prix = PrixProduit.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.prixFinal = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.enPromotion = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCatalogResponse(): GetCatalogResponse {
  return { items: [] };
}

export const GetCatalogResponse: MessageFns<GetCatalogResponse> = {
  encode(message: GetCatalogResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      CatalogItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.grilleUtilisee !== undefined) {
      GrilleTarifaire.encode(message.grilleUtilisee, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCatalogResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCatalogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(CatalogItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grilleUtilisee = GrilleTarifaire.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculatePriceRequest(): CalculatePriceRequest {
  return { produitId: "", grilleTarifaireId: "", quantite: 0, remiseAdditionnelle: 0 };
}

export const CalculatePriceRequest: MessageFns<CalculatePriceRequest> = {
  encode(message: CalculatePriceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.produitId !== "") {
      writer.uint32(10).string(message.produitId);
    }
    if (message.grilleTarifaireId !== "") {
      writer.uint32(18).string(message.grilleTarifaireId);
    }
    if (message.quantite !== 0) {
      writer.uint32(24).int32(message.quantite);
    }
    if (message.remiseAdditionnelle !== 0) {
      writer.uint32(33).double(message.remiseAdditionnelle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePriceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.produitId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grilleTarifaireId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantite = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.remiseAdditionnelle = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCalculatePriceResponse(): CalculatePriceResponse {
  return { prixUnitaire: 0, prixApresRemise: 0, prixTotalHt: 0, tva: 0, prixTotalTtc: 0, promotionAppliquee: false };
}

export const CalculatePriceResponse: MessageFns<CalculatePriceResponse> = {
  encode(message: CalculatePriceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prixUnitaire !== 0) {
      writer.uint32(9).double(message.prixUnitaire);
    }
    if (message.prixApresRemise !== 0) {
      writer.uint32(17).double(message.prixApresRemise);
    }
    if (message.prixTotalHt !== 0) {
      writer.uint32(25).double(message.prixTotalHt);
    }
    if (message.tva !== 0) {
      writer.uint32(33).double(message.tva);
    }
    if (message.prixTotalTtc !== 0) {
      writer.uint32(41).double(message.prixTotalTtc);
    }
    if (message.promotionAppliquee !== false) {
      writer.uint32(48).bool(message.promotionAppliquee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CalculatePriceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCalculatePriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.prixUnitaire = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.prixApresRemise = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.prixTotalHt = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.tva = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.prixTotalTtc = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.promotionAppliquee = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface GammeServiceClient {
  create(request: CreateGammeRequest, metadata?: Metadata): Observable<Gamme>;

  update(request: UpdateGammeRequest, metadata?: Metadata): Observable<Gamme>;

  get(request: GetGammeRequest, metadata?: Metadata): Observable<Gamme>;

  list(request: ListGammesRequest, metadata?: Metadata): Observable<ListGammesResponse>;

  delete(request: DeleteGammeRequest, metadata?: Metadata): Observable<DeleteGammeResponse>;
}

export interface GammeServiceController {
  create(request: CreateGammeRequest, metadata?: Metadata): Promise<Gamme> | Observable<Gamme> | Gamme;

  update(request: UpdateGammeRequest, metadata?: Metadata): Promise<Gamme> | Observable<Gamme> | Gamme;

  get(request: GetGammeRequest, metadata?: Metadata): Promise<Gamme> | Observable<Gamme> | Gamme;

  list(
    request: ListGammesRequest,
    metadata?: Metadata,
  ): Promise<ListGammesResponse> | Observable<ListGammesResponse> | ListGammesResponse;

  delete(
    request: DeleteGammeRequest,
    metadata?: Metadata,
  ): Promise<DeleteGammeResponse> | Observable<DeleteGammeResponse> | DeleteGammeResponse;
}

export function GammeServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("GammeService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("GammeService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const GAMME_SERVICE_NAME = "GammeService";

export type GammeServiceService = typeof GammeServiceService;
export const GammeServiceService = {
  create: {
    path: "/products.GammeService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGammeRequest): Buffer => Buffer.from(CreateGammeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGammeRequest => CreateGammeRequest.decode(value),
    responseSerialize: (value: Gamme): Buffer => Buffer.from(Gamme.encode(value).finish()),
    responseDeserialize: (value: Buffer): Gamme => Gamme.decode(value),
  },
  update: {
    path: "/products.GammeService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateGammeRequest): Buffer => Buffer.from(UpdateGammeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateGammeRequest => UpdateGammeRequest.decode(value),
    responseSerialize: (value: Gamme): Buffer => Buffer.from(Gamme.encode(value).finish()),
    responseDeserialize: (value: Buffer): Gamme => Gamme.decode(value),
  },
  get: {
    path: "/products.GammeService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGammeRequest): Buffer => Buffer.from(GetGammeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGammeRequest => GetGammeRequest.decode(value),
    responseSerialize: (value: Gamme): Buffer => Buffer.from(Gamme.encode(value).finish()),
    responseDeserialize: (value: Buffer): Gamme => Gamme.decode(value),
  },
  list: {
    path: "/products.GammeService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListGammesRequest): Buffer => Buffer.from(ListGammesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListGammesRequest => ListGammesRequest.decode(value),
    responseSerialize: (value: ListGammesResponse): Buffer => Buffer.from(ListGammesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListGammesResponse => ListGammesResponse.decode(value),
  },
  delete: {
    path: "/products.GammeService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteGammeRequest): Buffer => Buffer.from(DeleteGammeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteGammeRequest => DeleteGammeRequest.decode(value),
    responseSerialize: (value: DeleteGammeResponse): Buffer => Buffer.from(DeleteGammeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteGammeResponse => DeleteGammeResponse.decode(value),
  },
} as const;

export interface GammeServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateGammeRequest, Gamme>;
  update: handleUnaryCall<UpdateGammeRequest, Gamme>;
  get: handleUnaryCall<GetGammeRequest, Gamme>;
  list: handleUnaryCall<ListGammesRequest, ListGammesResponse>;
  delete: handleUnaryCall<DeleteGammeRequest, DeleteGammeResponse>;
}

export interface ProduitServiceClient {
  create(request: CreateProduitRequest, metadata?: Metadata): Observable<Produit>;

  update(request: UpdateProduitRequest, metadata?: Metadata): Observable<Produit>;

  get(request: GetProduitRequest, metadata?: Metadata): Observable<Produit>;

  getBySku(request: GetProduitBySkuRequest, metadata?: Metadata): Observable<Produit>;

  list(request: ListProduitsRequest, metadata?: Metadata): Observable<ListProduitsResponse>;

  delete(request: DeleteProduitRequest, metadata?: Metadata): Observable<DeleteProduitResponse>;

  setPromotion(request: SetPromotionRequest, metadata?: Metadata): Observable<Produit>;

  clearPromotion(request: ClearPromotionRequest, metadata?: Metadata): Observable<Produit>;
}

export interface ProduitServiceController {
  create(request: CreateProduitRequest, metadata?: Metadata): Promise<Produit> | Observable<Produit> | Produit;

  update(request: UpdateProduitRequest, metadata?: Metadata): Promise<Produit> | Observable<Produit> | Produit;

  get(request: GetProduitRequest, metadata?: Metadata): Promise<Produit> | Observable<Produit> | Produit;

  getBySku(request: GetProduitBySkuRequest, metadata?: Metadata): Promise<Produit> | Observable<Produit> | Produit;

  list(
    request: ListProduitsRequest,
    metadata?: Metadata,
  ): Promise<ListProduitsResponse> | Observable<ListProduitsResponse> | ListProduitsResponse;

  delete(
    request: DeleteProduitRequest,
    metadata?: Metadata,
  ): Promise<DeleteProduitResponse> | Observable<DeleteProduitResponse> | DeleteProduitResponse;

  setPromotion(request: SetPromotionRequest, metadata?: Metadata): Promise<Produit> | Observable<Produit> | Produit;

  clearPromotion(request: ClearPromotionRequest, metadata?: Metadata): Promise<Produit> | Observable<Produit> | Produit;
}

export function ProduitServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "create",
      "update",
      "get",
      "getBySku",
      "list",
      "delete",
      "setPromotion",
      "clearPromotion",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProduitService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProduitService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUIT_SERVICE_NAME = "ProduitService";

export type ProduitServiceService = typeof ProduitServiceService;
export const ProduitServiceService = {
  create: {
    path: "/products.ProduitService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProduitRequest): Buffer => Buffer.from(CreateProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProduitRequest => CreateProduitRequest.decode(value),
    responseSerialize: (value: Produit): Buffer => Buffer.from(Produit.encode(value).finish()),
    responseDeserialize: (value: Buffer): Produit => Produit.decode(value),
  },
  update: {
    path: "/products.ProduitService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProduitRequest): Buffer => Buffer.from(UpdateProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProduitRequest => UpdateProduitRequest.decode(value),
    responseSerialize: (value: Produit): Buffer => Buffer.from(Produit.encode(value).finish()),
    responseDeserialize: (value: Buffer): Produit => Produit.decode(value),
  },
  get: {
    path: "/products.ProduitService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProduitRequest): Buffer => Buffer.from(GetProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProduitRequest => GetProduitRequest.decode(value),
    responseSerialize: (value: Produit): Buffer => Buffer.from(Produit.encode(value).finish()),
    responseDeserialize: (value: Buffer): Produit => Produit.decode(value),
  },
  getBySku: {
    path: "/products.ProduitService/GetBySku",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProduitBySkuRequest): Buffer =>
      Buffer.from(GetProduitBySkuRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProduitBySkuRequest => GetProduitBySkuRequest.decode(value),
    responseSerialize: (value: Produit): Buffer => Buffer.from(Produit.encode(value).finish()),
    responseDeserialize: (value: Buffer): Produit => Produit.decode(value),
  },
  list: {
    path: "/products.ProduitService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProduitsRequest): Buffer => Buffer.from(ListProduitsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProduitsRequest => ListProduitsRequest.decode(value),
    responseSerialize: (value: ListProduitsResponse): Buffer =>
      Buffer.from(ListProduitsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProduitsResponse => ListProduitsResponse.decode(value),
  },
  delete: {
    path: "/products.ProduitService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProduitRequest): Buffer => Buffer.from(DeleteProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteProduitRequest => DeleteProduitRequest.decode(value),
    responseSerialize: (value: DeleteProduitResponse): Buffer =>
      Buffer.from(DeleteProduitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteProduitResponse => DeleteProduitResponse.decode(value),
  },
  setPromotion: {
    path: "/products.ProduitService/SetPromotion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetPromotionRequest): Buffer => Buffer.from(SetPromotionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SetPromotionRequest => SetPromotionRequest.decode(value),
    responseSerialize: (value: Produit): Buffer => Buffer.from(Produit.encode(value).finish()),
    responseDeserialize: (value: Buffer): Produit => Produit.decode(value),
  },
  clearPromotion: {
    path: "/products.ProduitService/ClearPromotion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearPromotionRequest): Buffer =>
      Buffer.from(ClearPromotionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ClearPromotionRequest => ClearPromotionRequest.decode(value),
    responseSerialize: (value: Produit): Buffer => Buffer.from(Produit.encode(value).finish()),
    responseDeserialize: (value: Buffer): Produit => Produit.decode(value),
  },
} as const;

export interface ProduitServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateProduitRequest, Produit>;
  update: handleUnaryCall<UpdateProduitRequest, Produit>;
  get: handleUnaryCall<GetProduitRequest, Produit>;
  getBySku: handleUnaryCall<GetProduitBySkuRequest, Produit>;
  list: handleUnaryCall<ListProduitsRequest, ListProduitsResponse>;
  delete: handleUnaryCall<DeleteProduitRequest, DeleteProduitResponse>;
  setPromotion: handleUnaryCall<SetPromotionRequest, Produit>;
  clearPromotion: handleUnaryCall<ClearPromotionRequest, Produit>;
}

export interface ProduitVersionServiceClient {
  create(request: CreateProduitVersionRequest, metadata?: Metadata): Observable<ProduitVersion>;

  update(request: UpdateProduitVersionRequest, metadata?: Metadata): Observable<ProduitVersion>;

  get(request: GetProduitVersionRequest, metadata?: Metadata): Observable<ProduitVersion>;

  listByProduit(request: ListProduitVersionsRequest, metadata?: Metadata): Observable<ListProduitVersionsResponse>;
}

export interface ProduitVersionServiceController {
  create(
    request: CreateProduitVersionRequest,
    metadata?: Metadata,
  ): Promise<ProduitVersion> | Observable<ProduitVersion> | ProduitVersion;

  update(
    request: UpdateProduitVersionRequest,
    metadata?: Metadata,
  ): Promise<ProduitVersion> | Observable<ProduitVersion> | ProduitVersion;

  get(
    request: GetProduitVersionRequest,
    metadata?: Metadata,
  ): Promise<ProduitVersion> | Observable<ProduitVersion> | ProduitVersion;

  listByProduit(
    request: ListProduitVersionsRequest,
    metadata?: Metadata,
  ): Promise<ListProduitVersionsResponse> | Observable<ListProduitVersionsResponse> | ListProduitVersionsResponse;
}

export function ProduitVersionServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "listByProduit"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProduitVersionService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProduitVersionService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUIT_VERSION_SERVICE_NAME = "ProduitVersionService";

export type ProduitVersionServiceService = typeof ProduitVersionServiceService;
export const ProduitVersionServiceService = {
  create: {
    path: "/products.ProduitVersionService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProduitVersionRequest): Buffer =>
      Buffer.from(CreateProduitVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProduitVersionRequest => CreateProduitVersionRequest.decode(value),
    responseSerialize: (value: ProduitVersion): Buffer => Buffer.from(ProduitVersion.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitVersion => ProduitVersion.decode(value),
  },
  update: {
    path: "/products.ProduitVersionService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProduitVersionRequest): Buffer =>
      Buffer.from(UpdateProduitVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProduitVersionRequest => UpdateProduitVersionRequest.decode(value),
    responseSerialize: (value: ProduitVersion): Buffer => Buffer.from(ProduitVersion.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitVersion => ProduitVersion.decode(value),
  },
  get: {
    path: "/products.ProduitVersionService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProduitVersionRequest): Buffer =>
      Buffer.from(GetProduitVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProduitVersionRequest => GetProduitVersionRequest.decode(value),
    responseSerialize: (value: ProduitVersion): Buffer => Buffer.from(ProduitVersion.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitVersion => ProduitVersion.decode(value),
  },
  listByProduit: {
    path: "/products.ProduitVersionService/ListByProduit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProduitVersionsRequest): Buffer =>
      Buffer.from(ListProduitVersionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProduitVersionsRequest => ListProduitVersionsRequest.decode(value),
    responseSerialize: (value: ListProduitVersionsResponse): Buffer =>
      Buffer.from(ListProduitVersionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProduitVersionsResponse => ListProduitVersionsResponse.decode(value),
  },
} as const;

export interface ProduitVersionServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateProduitVersionRequest, ProduitVersion>;
  update: handleUnaryCall<UpdateProduitVersionRequest, ProduitVersion>;
  get: handleUnaryCall<GetProduitVersionRequest, ProduitVersion>;
  listByProduit: handleUnaryCall<ListProduitVersionsRequest, ListProduitVersionsResponse>;
}

export interface ProduitDocumentServiceClient {
  create(request: CreateProduitDocumentRequest, metadata?: Metadata): Observable<ProduitDocument>;

  update(request: UpdateProduitDocumentRequest, metadata?: Metadata): Observable<ProduitDocument>;

  get(request: GetProduitDocumentRequest, metadata?: Metadata): Observable<ProduitDocument>;

  listByVersion(request: ListProduitDocumentsRequest, metadata?: Metadata): Observable<ListProduitDocumentsResponse>;
}

export interface ProduitDocumentServiceController {
  create(
    request: CreateProduitDocumentRequest,
    metadata?: Metadata,
  ): Promise<ProduitDocument> | Observable<ProduitDocument> | ProduitDocument;

  update(
    request: UpdateProduitDocumentRequest,
    metadata?: Metadata,
  ): Promise<ProduitDocument> | Observable<ProduitDocument> | ProduitDocument;

  get(
    request: GetProduitDocumentRequest,
    metadata?: Metadata,
  ): Promise<ProduitDocument> | Observable<ProduitDocument> | ProduitDocument;

  listByVersion(
    request: ListProduitDocumentsRequest,
    metadata?: Metadata,
  ): Promise<ListProduitDocumentsResponse> | Observable<ListProduitDocumentsResponse> | ListProduitDocumentsResponse;
}

export function ProduitDocumentServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "listByVersion"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProduitDocumentService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProduitDocumentService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUIT_DOCUMENT_SERVICE_NAME = "ProduitDocumentService";

export type ProduitDocumentServiceService = typeof ProduitDocumentServiceService;
export const ProduitDocumentServiceService = {
  create: {
    path: "/products.ProduitDocumentService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProduitDocumentRequest): Buffer =>
      Buffer.from(CreateProduitDocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProduitDocumentRequest => CreateProduitDocumentRequest.decode(value),
    responseSerialize: (value: ProduitDocument): Buffer => Buffer.from(ProduitDocument.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitDocument => ProduitDocument.decode(value),
  },
  update: {
    path: "/products.ProduitDocumentService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProduitDocumentRequest): Buffer =>
      Buffer.from(UpdateProduitDocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProduitDocumentRequest => UpdateProduitDocumentRequest.decode(value),
    responseSerialize: (value: ProduitDocument): Buffer => Buffer.from(ProduitDocument.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitDocument => ProduitDocument.decode(value),
  },
  get: {
    path: "/products.ProduitDocumentService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProduitDocumentRequest): Buffer =>
      Buffer.from(GetProduitDocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProduitDocumentRequest => GetProduitDocumentRequest.decode(value),
    responseSerialize: (value: ProduitDocument): Buffer => Buffer.from(ProduitDocument.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitDocument => ProduitDocument.decode(value),
  },
  listByVersion: {
    path: "/products.ProduitDocumentService/ListByVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProduitDocumentsRequest): Buffer =>
      Buffer.from(ListProduitDocumentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProduitDocumentsRequest => ListProduitDocumentsRequest.decode(value),
    responseSerialize: (value: ListProduitDocumentsResponse): Buffer =>
      Buffer.from(ListProduitDocumentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProduitDocumentsResponse => ListProduitDocumentsResponse.decode(value),
  },
} as const;

export interface ProduitDocumentServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateProduitDocumentRequest, ProduitDocument>;
  update: handleUnaryCall<UpdateProduitDocumentRequest, ProduitDocument>;
  get: handleUnaryCall<GetProduitDocumentRequest, ProduitDocument>;
  listByVersion: handleUnaryCall<ListProduitDocumentsRequest, ListProduitDocumentsResponse>;
}

export interface ProduitPublicationServiceClient {
  create(request: CreateProduitPublicationRequest, metadata?: Metadata): Observable<ProduitPublication>;

  update(request: UpdateProduitPublicationRequest, metadata?: Metadata): Observable<ProduitPublication>;

  get(request: GetProduitPublicationRequest, metadata?: Metadata): Observable<ProduitPublication>;

  listByVersion(
    request: ListProduitPublicationsByVersionRequest,
    metadata?: Metadata,
  ): Observable<ListProduitPublicationsResponse>;

  listBySociete(
    request: ListProduitPublicationsBySocieteRequest,
    metadata?: Metadata,
  ): Observable<ListProduitPublicationsResponse>;
}

export interface ProduitPublicationServiceController {
  create(
    request: CreateProduitPublicationRequest,
    metadata?: Metadata,
  ): Promise<ProduitPublication> | Observable<ProduitPublication> | ProduitPublication;

  update(
    request: UpdateProduitPublicationRequest,
    metadata?: Metadata,
  ): Promise<ProduitPublication> | Observable<ProduitPublication> | ProduitPublication;

  get(
    request: GetProduitPublicationRequest,
    metadata?: Metadata,
  ): Promise<ProduitPublication> | Observable<ProduitPublication> | ProduitPublication;

  listByVersion(
    request: ListProduitPublicationsByVersionRequest,
    metadata?: Metadata,
  ):
    | Promise<ListProduitPublicationsResponse>
    | Observable<ListProduitPublicationsResponse>
    | ListProduitPublicationsResponse;

  listBySociete(
    request: ListProduitPublicationsBySocieteRequest,
    metadata?: Metadata,
  ):
    | Promise<ListProduitPublicationsResponse>
    | Observable<ListProduitPublicationsResponse>
    | ListProduitPublicationsResponse;
}

export function ProduitPublicationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "listByVersion", "listBySociete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProduitPublicationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProduitPublicationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUIT_PUBLICATION_SERVICE_NAME = "ProduitPublicationService";

export type ProduitPublicationServiceService = typeof ProduitPublicationServiceService;
export const ProduitPublicationServiceService = {
  create: {
    path: "/products.ProduitPublicationService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProduitPublicationRequest): Buffer =>
      Buffer.from(CreateProduitPublicationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProduitPublicationRequest =>
      CreateProduitPublicationRequest.decode(value),
    responseSerialize: (value: ProduitPublication): Buffer => Buffer.from(ProduitPublication.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitPublication => ProduitPublication.decode(value),
  },
  update: {
    path: "/products.ProduitPublicationService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProduitPublicationRequest): Buffer =>
      Buffer.from(UpdateProduitPublicationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateProduitPublicationRequest =>
      UpdateProduitPublicationRequest.decode(value),
    responseSerialize: (value: ProduitPublication): Buffer => Buffer.from(ProduitPublication.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitPublication => ProduitPublication.decode(value),
  },
  get: {
    path: "/products.ProduitPublicationService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProduitPublicationRequest): Buffer =>
      Buffer.from(GetProduitPublicationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetProduitPublicationRequest => GetProduitPublicationRequest.decode(value),
    responseSerialize: (value: ProduitPublication): Buffer => Buffer.from(ProduitPublication.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProduitPublication => ProduitPublication.decode(value),
  },
  listByVersion: {
    path: "/products.ProduitPublicationService/ListByVersion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProduitPublicationsByVersionRequest): Buffer =>
      Buffer.from(ListProduitPublicationsByVersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProduitPublicationsByVersionRequest =>
      ListProduitPublicationsByVersionRequest.decode(value),
    responseSerialize: (value: ListProduitPublicationsResponse): Buffer =>
      Buffer.from(ListProduitPublicationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProduitPublicationsResponse =>
      ListProduitPublicationsResponse.decode(value),
  },
  listBySociete: {
    path: "/products.ProduitPublicationService/ListBySociete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProduitPublicationsBySocieteRequest): Buffer =>
      Buffer.from(ListProduitPublicationsBySocieteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListProduitPublicationsBySocieteRequest =>
      ListProduitPublicationsBySocieteRequest.decode(value),
    responseSerialize: (value: ListProduitPublicationsResponse): Buffer =>
      Buffer.from(ListProduitPublicationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProduitPublicationsResponse =>
      ListProduitPublicationsResponse.decode(value),
  },
} as const;

export interface ProduitPublicationServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateProduitPublicationRequest, ProduitPublication>;
  update: handleUnaryCall<UpdateProduitPublicationRequest, ProduitPublication>;
  get: handleUnaryCall<GetProduitPublicationRequest, ProduitPublication>;
  listByVersion: handleUnaryCall<ListProduitPublicationsByVersionRequest, ListProduitPublicationsResponse>;
  listBySociete: handleUnaryCall<ListProduitPublicationsBySocieteRequest, ListProduitPublicationsResponse>;
}

export interface GrilleTarifaireServiceClient {
  create(request: CreateGrilleTarifaireRequest, metadata?: Metadata): Observable<GrilleTarifaire>;

  update(request: UpdateGrilleTarifaireRequest, metadata?: Metadata): Observable<GrilleTarifaire>;

  get(request: GetGrilleTarifaireRequest, metadata?: Metadata): Observable<GrilleTarifaire>;

  getActive(request: GetGrilleTarifaireActiveRequest, metadata?: Metadata): Observable<GrilleTarifaire>;

  list(request: ListGrillesTarifairesRequest, metadata?: Metadata): Observable<ListGrillesTarifairesResponse>;

  delete(request: DeleteGrilleTarifaireRequest, metadata?: Metadata): Observable<DeleteGrilleTarifaireResponse>;

  setParDefaut(request: SetGrilleParDefautRequest, metadata?: Metadata): Observable<GrilleTarifaire>;
}

export interface GrilleTarifaireServiceController {
  create(
    request: CreateGrilleTarifaireRequest,
    metadata?: Metadata,
  ): Promise<GrilleTarifaire> | Observable<GrilleTarifaire> | GrilleTarifaire;

  update(
    request: UpdateGrilleTarifaireRequest,
    metadata?: Metadata,
  ): Promise<GrilleTarifaire> | Observable<GrilleTarifaire> | GrilleTarifaire;

  get(
    request: GetGrilleTarifaireRequest,
    metadata?: Metadata,
  ): Promise<GrilleTarifaire> | Observable<GrilleTarifaire> | GrilleTarifaire;

  getActive(
    request: GetGrilleTarifaireActiveRequest,
    metadata?: Metadata,
  ): Promise<GrilleTarifaire> | Observable<GrilleTarifaire> | GrilleTarifaire;

  list(
    request: ListGrillesTarifairesRequest,
    metadata?: Metadata,
  ): Promise<ListGrillesTarifairesResponse> | Observable<ListGrillesTarifairesResponse> | ListGrillesTarifairesResponse;

  delete(
    request: DeleteGrilleTarifaireRequest,
    metadata?: Metadata,
  ): Promise<DeleteGrilleTarifaireResponse> | Observable<DeleteGrilleTarifaireResponse> | DeleteGrilleTarifaireResponse;

  setParDefaut(
    request: SetGrilleParDefautRequest,
    metadata?: Metadata,
  ): Promise<GrilleTarifaire> | Observable<GrilleTarifaire> | GrilleTarifaire;
}

export function GrilleTarifaireServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getActive", "list", "delete", "setParDefaut"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("GrilleTarifaireService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("GrilleTarifaireService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const GRILLE_TARIFAIRE_SERVICE_NAME = "GrilleTarifaireService";

export type GrilleTarifaireServiceService = typeof GrilleTarifaireServiceService;
export const GrilleTarifaireServiceService = {
  create: {
    path: "/products.GrilleTarifaireService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateGrilleTarifaireRequest): Buffer =>
      Buffer.from(CreateGrilleTarifaireRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateGrilleTarifaireRequest => CreateGrilleTarifaireRequest.decode(value),
    responseSerialize: (value: GrilleTarifaire): Buffer => Buffer.from(GrilleTarifaire.encode(value).finish()),
    responseDeserialize: (value: Buffer): GrilleTarifaire => GrilleTarifaire.decode(value),
  },
  update: {
    path: "/products.GrilleTarifaireService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateGrilleTarifaireRequest): Buffer =>
      Buffer.from(UpdateGrilleTarifaireRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateGrilleTarifaireRequest => UpdateGrilleTarifaireRequest.decode(value),
    responseSerialize: (value: GrilleTarifaire): Buffer => Buffer.from(GrilleTarifaire.encode(value).finish()),
    responseDeserialize: (value: Buffer): GrilleTarifaire => GrilleTarifaire.decode(value),
  },
  get: {
    path: "/products.GrilleTarifaireService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGrilleTarifaireRequest): Buffer =>
      Buffer.from(GetGrilleTarifaireRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGrilleTarifaireRequest => GetGrilleTarifaireRequest.decode(value),
    responseSerialize: (value: GrilleTarifaire): Buffer => Buffer.from(GrilleTarifaire.encode(value).finish()),
    responseDeserialize: (value: Buffer): GrilleTarifaire => GrilleTarifaire.decode(value),
  },
  getActive: {
    path: "/products.GrilleTarifaireService/GetActive",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetGrilleTarifaireActiveRequest): Buffer =>
      Buffer.from(GetGrilleTarifaireActiveRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetGrilleTarifaireActiveRequest =>
      GetGrilleTarifaireActiveRequest.decode(value),
    responseSerialize: (value: GrilleTarifaire): Buffer => Buffer.from(GrilleTarifaire.encode(value).finish()),
    responseDeserialize: (value: Buffer): GrilleTarifaire => GrilleTarifaire.decode(value),
  },
  list: {
    path: "/products.GrilleTarifaireService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListGrillesTarifairesRequest): Buffer =>
      Buffer.from(ListGrillesTarifairesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListGrillesTarifairesRequest => ListGrillesTarifairesRequest.decode(value),
    responseSerialize: (value: ListGrillesTarifairesResponse): Buffer =>
      Buffer.from(ListGrillesTarifairesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListGrillesTarifairesResponse => ListGrillesTarifairesResponse.decode(value),
  },
  delete: {
    path: "/products.GrilleTarifaireService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteGrilleTarifaireRequest): Buffer =>
      Buffer.from(DeleteGrilleTarifaireRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteGrilleTarifaireRequest => DeleteGrilleTarifaireRequest.decode(value),
    responseSerialize: (value: DeleteGrilleTarifaireResponse): Buffer =>
      Buffer.from(DeleteGrilleTarifaireResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteGrilleTarifaireResponse => DeleteGrilleTarifaireResponse.decode(value),
  },
  setParDefaut: {
    path: "/products.GrilleTarifaireService/SetParDefaut",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SetGrilleParDefautRequest): Buffer =>
      Buffer.from(SetGrilleParDefautRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SetGrilleParDefautRequest => SetGrilleParDefautRequest.decode(value),
    responseSerialize: (value: GrilleTarifaire): Buffer => Buffer.from(GrilleTarifaire.encode(value).finish()),
    responseDeserialize: (value: Buffer): GrilleTarifaire => GrilleTarifaire.decode(value),
  },
} as const;

export interface GrilleTarifaireServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateGrilleTarifaireRequest, GrilleTarifaire>;
  update: handleUnaryCall<UpdateGrilleTarifaireRequest, GrilleTarifaire>;
  get: handleUnaryCall<GetGrilleTarifaireRequest, GrilleTarifaire>;
  getActive: handleUnaryCall<GetGrilleTarifaireActiveRequest, GrilleTarifaire>;
  list: handleUnaryCall<ListGrillesTarifairesRequest, ListGrillesTarifairesResponse>;
  delete: handleUnaryCall<DeleteGrilleTarifaireRequest, DeleteGrilleTarifaireResponse>;
  setParDefaut: handleUnaryCall<SetGrilleParDefautRequest, GrilleTarifaire>;
}

export interface PrixProduitServiceClient {
  create(request: CreatePrixProduitRequest, metadata?: Metadata): Observable<PrixProduit>;

  update(request: UpdatePrixProduitRequest, metadata?: Metadata): Observable<PrixProduit>;

  get(request: GetPrixProduitRequest, metadata?: Metadata): Observable<PrixProduit>;

  getForProduit(request: GetPrixForProduitRequest, metadata?: Metadata): Observable<PrixProduit>;

  list(request: ListPrixProduitsRequest, metadata?: Metadata): Observable<ListPrixProduitsResponse>;

  delete(request: DeletePrixProduitRequest, metadata?: Metadata): Observable<DeletePrixProduitResponse>;

  bulkCreate(request: BulkCreatePrixProduitsRequest, metadata?: Metadata): Observable<BulkCreatePrixProduitsResponse>;
}

export interface PrixProduitServiceController {
  create(
    request: CreatePrixProduitRequest,
    metadata?: Metadata,
  ): Promise<PrixProduit> | Observable<PrixProduit> | PrixProduit;

  update(
    request: UpdatePrixProduitRequest,
    metadata?: Metadata,
  ): Promise<PrixProduit> | Observable<PrixProduit> | PrixProduit;

  get(
    request: GetPrixProduitRequest,
    metadata?: Metadata,
  ): Promise<PrixProduit> | Observable<PrixProduit> | PrixProduit;

  getForProduit(
    request: GetPrixForProduitRequest,
    metadata?: Metadata,
  ): Promise<PrixProduit> | Observable<PrixProduit> | PrixProduit;

  list(
    request: ListPrixProduitsRequest,
    metadata?: Metadata,
  ): Promise<ListPrixProduitsResponse> | Observable<ListPrixProduitsResponse> | ListPrixProduitsResponse;

  delete(
    request: DeletePrixProduitRequest,
    metadata?: Metadata,
  ): Promise<DeletePrixProduitResponse> | Observable<DeletePrixProduitResponse> | DeletePrixProduitResponse;

  bulkCreate(
    request: BulkCreatePrixProduitsRequest,
    metadata?: Metadata,
  ):
    | Promise<BulkCreatePrixProduitsResponse>
    | Observable<BulkCreatePrixProduitsResponse>
    | BulkCreatePrixProduitsResponse;
}

export function PrixProduitServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getForProduit", "list", "delete", "bulkCreate"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PrixProduitService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PrixProduitService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRIX_PRODUIT_SERVICE_NAME = "PrixProduitService";

export type PrixProduitServiceService = typeof PrixProduitServiceService;
export const PrixProduitServiceService = {
  create: {
    path: "/products.PrixProduitService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePrixProduitRequest): Buffer =>
      Buffer.from(CreatePrixProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePrixProduitRequest => CreatePrixProduitRequest.decode(value),
    responseSerialize: (value: PrixProduit): Buffer => Buffer.from(PrixProduit.encode(value).finish()),
    responseDeserialize: (value: Buffer): PrixProduit => PrixProduit.decode(value),
  },
  update: {
    path: "/products.PrixProduitService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePrixProduitRequest): Buffer =>
      Buffer.from(UpdatePrixProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePrixProduitRequest => UpdatePrixProduitRequest.decode(value),
    responseSerialize: (value: PrixProduit): Buffer => Buffer.from(PrixProduit.encode(value).finish()),
    responseDeserialize: (value: Buffer): PrixProduit => PrixProduit.decode(value),
  },
  get: {
    path: "/products.PrixProduitService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPrixProduitRequest): Buffer =>
      Buffer.from(GetPrixProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPrixProduitRequest => GetPrixProduitRequest.decode(value),
    responseSerialize: (value: PrixProduit): Buffer => Buffer.from(PrixProduit.encode(value).finish()),
    responseDeserialize: (value: Buffer): PrixProduit => PrixProduit.decode(value),
  },
  getForProduit: {
    path: "/products.PrixProduitService/GetForProduit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPrixForProduitRequest): Buffer =>
      Buffer.from(GetPrixForProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPrixForProduitRequest => GetPrixForProduitRequest.decode(value),
    responseSerialize: (value: PrixProduit): Buffer => Buffer.from(PrixProduit.encode(value).finish()),
    responseDeserialize: (value: Buffer): PrixProduit => PrixProduit.decode(value),
  },
  list: {
    path: "/products.PrixProduitService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPrixProduitsRequest): Buffer =>
      Buffer.from(ListPrixProduitsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPrixProduitsRequest => ListPrixProduitsRequest.decode(value),
    responseSerialize: (value: ListPrixProduitsResponse): Buffer =>
      Buffer.from(ListPrixProduitsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPrixProduitsResponse => ListPrixProduitsResponse.decode(value),
  },
  delete: {
    path: "/products.PrixProduitService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePrixProduitRequest): Buffer =>
      Buffer.from(DeletePrixProduitRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeletePrixProduitRequest => DeletePrixProduitRequest.decode(value),
    responseSerialize: (value: DeletePrixProduitResponse): Buffer =>
      Buffer.from(DeletePrixProduitResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeletePrixProduitResponse => DeletePrixProduitResponse.decode(value),
  },
  bulkCreate: {
    path: "/products.PrixProduitService/BulkCreate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BulkCreatePrixProduitsRequest): Buffer =>
      Buffer.from(BulkCreatePrixProduitsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BulkCreatePrixProduitsRequest => BulkCreatePrixProduitsRequest.decode(value),
    responseSerialize: (value: BulkCreatePrixProduitsResponse): Buffer =>
      Buffer.from(BulkCreatePrixProduitsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BulkCreatePrixProduitsResponse =>
      BulkCreatePrixProduitsResponse.decode(value),
  },
} as const;

export interface PrixProduitServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreatePrixProduitRequest, PrixProduit>;
  update: handleUnaryCall<UpdatePrixProduitRequest, PrixProduit>;
  get: handleUnaryCall<GetPrixProduitRequest, PrixProduit>;
  getForProduit: handleUnaryCall<GetPrixForProduitRequest, PrixProduit>;
  list: handleUnaryCall<ListPrixProduitsRequest, ListPrixProduitsResponse>;
  delete: handleUnaryCall<DeletePrixProduitRequest, DeletePrixProduitResponse>;
  bulkCreate: handleUnaryCall<BulkCreatePrixProduitsRequest, BulkCreatePrixProduitsResponse>;
}

export interface CatalogServiceClient {
  getCatalog(request: GetCatalogRequest, metadata?: Metadata): Observable<GetCatalogResponse>;

  calculatePrice(request: CalculatePriceRequest, metadata?: Metadata): Observable<CalculatePriceResponse>;
}

export interface CatalogServiceController {
  getCatalog(
    request: GetCatalogRequest,
    metadata?: Metadata,
  ): Promise<GetCatalogResponse> | Observable<GetCatalogResponse> | GetCatalogResponse;

  calculatePrice(
    request: CalculatePriceRequest,
    metadata?: Metadata,
  ): Promise<CalculatePriceResponse> | Observable<CalculatePriceResponse> | CalculatePriceResponse;
}

export function CatalogServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["getCatalog", "calculatePrice"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("CatalogService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("CatalogService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CATALOG_SERVICE_NAME = "CatalogService";

export type CatalogServiceService = typeof CatalogServiceService;
export const CatalogServiceService = {
  getCatalog: {
    path: "/products.CatalogService/GetCatalog",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCatalogRequest): Buffer => Buffer.from(GetCatalogRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCatalogRequest => GetCatalogRequest.decode(value),
    responseSerialize: (value: GetCatalogResponse): Buffer => Buffer.from(GetCatalogResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetCatalogResponse => GetCatalogResponse.decode(value),
  },
  calculatePrice: {
    path: "/products.CatalogService/CalculatePrice",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CalculatePriceRequest): Buffer =>
      Buffer.from(CalculatePriceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CalculatePriceRequest => CalculatePriceRequest.decode(value),
    responseSerialize: (value: CalculatePriceResponse): Buffer =>
      Buffer.from(CalculatePriceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CalculatePriceResponse => CalculatePriceResponse.decode(value),
  },
} as const;

export interface CatalogServiceServer extends UntypedServiceImplementation {
  getCatalog: handleUnaryCall<GetCatalogRequest, GetCatalogResponse>;
  calculatePrice: handleUnaryCall<CalculatePriceRequest, CalculatePriceResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
