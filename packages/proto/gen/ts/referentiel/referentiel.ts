// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: referentiel/referentiel.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export interface ConditionPaiement {
  id: string;
  code: string;
  nom: string;
  description: string;
  delaiJours: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateConditionPaiementRequest {
  code: string;
  nom: string;
  description: string;
  delaiJours: number;
}

export interface UpdateConditionPaiementRequest {
  id: string;
  code: string;
  nom: string;
  description: string;
  delaiJours: number;
}

export interface GetConditionPaiementRequest {
  id: string;
}

export interface GetConditionPaiementByCodeRequest {
  code: string;
}

export interface ListConditionPaiementRequest {
  search: string;
  pagination?: Pagination | undefined;
}

export interface DeleteConditionPaiementRequest {
  id: string;
}

export interface ListConditionPaiementResponse {
  conditions: ConditionPaiement[];
  pagination?: PaginationResult | undefined;
}

export interface StatutClient {
  id: string;
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
  createdAt: string;
  updatedAt: string;
}

export interface CreateStatutClientRequest {
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
}

export interface UpdateStatutClientRequest {
  id: string;
  code: string;
  nom: string;
  description: string;
  ordreAffichage: number;
}

export interface GetStatutClientRequest {
  id: string;
}

export interface GetStatutClientByCodeRequest {
  code: string;
}

export interface ListStatutClientRequest {
  search: string;
  pagination?: Pagination | undefined;
}

export interface DeleteStatutClientRequest {
  id: string;
}

export interface ListStatutClientResponse {
  statuts: StatutClient[];
  pagination?: PaginationResult | undefined;
}

export interface FacturationPar {
  id: string;
  code: string;
  nom: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateFacturationParRequest {
  code: string;
  nom: string;
  description: string;
}

export interface UpdateFacturationParRequest {
  id: string;
  code: string;
  nom: string;
  description: string;
}

export interface GetFacturationParRequest {
  id: string;
}

export interface GetFacturationParByCodeRequest {
  code: string;
}

export interface ListFacturationParRequest {
  search: string;
  pagination?: Pagination | undefined;
}

export interface DeleteFacturationParRequest {
  id: string;
}

export interface ListFacturationParResponse {
  facturations: FacturationPar[];
  pagination?: PaginationResult | undefined;
}

export interface PeriodeFacturation {
  id: string;
  code: string;
  nom: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreatePeriodeFacturationRequest {
  code: string;
  nom: string;
  description: string;
}

export interface UpdatePeriodeFacturationRequest {
  id: string;
  code: string;
  nom: string;
  description: string;
}

export interface GetPeriodeFacturationRequest {
  id: string;
}

export interface GetPeriodeFacturationByCodeRequest {
  code: string;
}

export interface ListPeriodeFacturationRequest {
  search: string;
  pagination?: Pagination | undefined;
}

export interface DeletePeriodeFacturationRequest {
  id: string;
}

export interface ListPeriodeFacturationResponse {
  periodes: PeriodeFacturation[];
  pagination?: PaginationResult | undefined;
}

export interface EmissionFacture {
  id: string;
  code: string;
  nom: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateEmissionFactureRequest {
  code: string;
  nom: string;
  description: string;
}

export interface UpdateEmissionFactureRequest {
  id: string;
  code: string;
  nom: string;
  description: string;
}

export interface GetEmissionFactureRequest {
  id: string;
}

export interface GetEmissionFactureByCodeRequest {
  code: string;
}

export interface ListEmissionFactureRequest {
  search: string;
  pagination?: Pagination | undefined;
}

export interface DeleteEmissionFactureRequest {
  id: string;
}

export interface ListEmissionFactureResponse {
  emissions: EmissionFacture[];
  pagination?: PaginationResult | undefined;
}

export interface TransporteurCompte {
  id: string;
  type: string;
  organisationId: string;
  contractNumber: string;
  labelFormat: string;
  actif: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateTransporteurCompteRequest {
  type: string;
  organisationId: string;
  contractNumber: string;
  password: string;
  labelFormat: string;
}

export interface UpdateTransporteurCompteRequest {
  id: string;
  contractNumber: string;
  password: string;
  labelFormat: string;
}

export interface GetTransporteurCompteRequest {
  id: string;
}

export interface ListTransporteurByOrganisationRequest {
  organisationId: string;
  actif: boolean;
  pagination?: Pagination | undefined;
}

export interface ListTransporteurCompteRequest {
  type: string;
  actif: boolean;
  pagination?: Pagination | undefined;
}

export interface ActivateTransporteurRequest {
  id: string;
}

export interface DeleteTransporteurCompteRequest {
  id: string;
}

export interface ListTransporteurCompteResponse {
  transporteurs: TransporteurCompte[];
  pagination?: PaginationResult | undefined;
}

/** ========== COMMON MESSAGES ========== */
export interface Pagination {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResult {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface DeleteResponse {
  success: boolean;
}

function createBaseConditionPaiement(): ConditionPaiement {
  return { id: "", code: "", nom: "", description: "", delaiJours: 0, createdAt: "", updatedAt: "" };
}

export const ConditionPaiement: MessageFns<ConditionPaiement> = {
  encode(message: ConditionPaiement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.delaiJours !== 0) {
      writer.uint32(40).int32(message.delaiJours);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionPaiement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionPaiement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.delaiJours = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateConditionPaiementRequest(): CreateConditionPaiementRequest {
  return { code: "", nom: "", description: "", delaiJours: 0 };
}

export const CreateConditionPaiementRequest: MessageFns<CreateConditionPaiementRequest> = {
  encode(message: CreateConditionPaiementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.delaiJours !== 0) {
      writer.uint32(32).int32(message.delaiJours);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConditionPaiementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConditionPaiementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.delaiJours = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateConditionPaiementRequest(): UpdateConditionPaiementRequest {
  return { id: "", code: "", nom: "", description: "", delaiJours: 0 };
}

export const UpdateConditionPaiementRequest: MessageFns<UpdateConditionPaiementRequest> = {
  encode(message: UpdateConditionPaiementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.delaiJours !== 0) {
      writer.uint32(40).int32(message.delaiJours);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConditionPaiementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConditionPaiementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.delaiJours = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetConditionPaiementRequest(): GetConditionPaiementRequest {
  return { id: "" };
}

export const GetConditionPaiementRequest: MessageFns<GetConditionPaiementRequest> = {
  encode(message: GetConditionPaiementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConditionPaiementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConditionPaiementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetConditionPaiementByCodeRequest(): GetConditionPaiementByCodeRequest {
  return { code: "" };
}

export const GetConditionPaiementByCodeRequest: MessageFns<GetConditionPaiementByCodeRequest> = {
  encode(message: GetConditionPaiementByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConditionPaiementByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConditionPaiementByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListConditionPaiementRequest(): ListConditionPaiementRequest {
  return { search: "" };
}

export const ListConditionPaiementRequest: MessageFns<ListConditionPaiementRequest> = {
  encode(message: ListConditionPaiementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConditionPaiementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConditionPaiementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteConditionPaiementRequest(): DeleteConditionPaiementRequest {
  return { id: "" };
}

export const DeleteConditionPaiementRequest: MessageFns<DeleteConditionPaiementRequest> = {
  encode(message: DeleteConditionPaiementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConditionPaiementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConditionPaiementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListConditionPaiementResponse(): ListConditionPaiementResponse {
  return { conditions: [] };
}

export const ListConditionPaiementResponse: MessageFns<ListConditionPaiementResponse> = {
  encode(message: ListConditionPaiementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conditions) {
      ConditionPaiement.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConditionPaiementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConditionPaiementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conditions.push(ConditionPaiement.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatutClient(): StatutClient {
  return { id: "", code: "", nom: "", description: "", ordreAffichage: 0, createdAt: "", updatedAt: "" };
}

export const StatutClient: MessageFns<StatutClient> = {
  encode(message: StatutClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(40).int32(message.ordreAffichage);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(58).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatutClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatutClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStatutClientRequest(): CreateStatutClientRequest {
  return { code: "", nom: "", description: "", ordreAffichage: 0 };
}

export const CreateStatutClientRequest: MessageFns<CreateStatutClientRequest> = {
  encode(message: CreateStatutClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(32).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStatutClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStatutClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateStatutClientRequest(): UpdateStatutClientRequest {
  return { id: "", code: "", nom: "", description: "", ordreAffichage: 0 };
}

export const UpdateStatutClientRequest: MessageFns<UpdateStatutClientRequest> = {
  encode(message: UpdateStatutClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.ordreAffichage !== 0) {
      writer.uint32(40).int32(message.ordreAffichage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStatutClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStatutClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ordreAffichage = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutClientRequest(): GetStatutClientRequest {
  return { id: "" };
}

export const GetStatutClientRequest: MessageFns<GetStatutClientRequest> = {
  encode(message: GetStatutClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatutClientByCodeRequest(): GetStatutClientByCodeRequest {
  return { code: "" };
}

export const GetStatutClientByCodeRequest: MessageFns<GetStatutClientByCodeRequest> = {
  encode(message: GetStatutClientByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatutClientByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatutClientByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListStatutClientRequest(): ListStatutClientRequest {
  return { search: "" };
}

export const ListStatutClientRequest: MessageFns<ListStatutClientRequest> = {
  encode(message: ListStatutClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStatutClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStatutClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteStatutClientRequest(): DeleteStatutClientRequest {
  return { id: "" };
}

export const DeleteStatutClientRequest: MessageFns<DeleteStatutClientRequest> = {
  encode(message: DeleteStatutClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteStatutClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStatutClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListStatutClientResponse(): ListStatutClientResponse {
  return { statuts: [] };
}

export const ListStatutClientResponse: MessageFns<ListStatutClientResponse> = {
  encode(message: ListStatutClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.statuts) {
      StatutClient.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListStatutClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListStatutClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statuts.push(StatutClient.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFacturationPar(): FacturationPar {
  return { id: "", code: "", nom: "", description: "", createdAt: "", updatedAt: "" };
}

export const FacturationPar: MessageFns<FacturationPar> = {
  encode(message: FacturationPar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FacturationPar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacturationPar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateFacturationParRequest(): CreateFacturationParRequest {
  return { code: "", nom: "", description: "" };
}

export const CreateFacturationParRequest: MessageFns<CreateFacturationParRequest> = {
  encode(message: CreateFacturationParRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFacturationParRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFacturationParRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateFacturationParRequest(): UpdateFacturationParRequest {
  return { id: "", code: "", nom: "", description: "" };
}

export const UpdateFacturationParRequest: MessageFns<UpdateFacturationParRequest> = {
  encode(message: UpdateFacturationParRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFacturationParRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFacturationParRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetFacturationParRequest(): GetFacturationParRequest {
  return { id: "" };
}

export const GetFacturationParRequest: MessageFns<GetFacturationParRequest> = {
  encode(message: GetFacturationParRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFacturationParRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFacturationParRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetFacturationParByCodeRequest(): GetFacturationParByCodeRequest {
  return { code: "" };
}

export const GetFacturationParByCodeRequest: MessageFns<GetFacturationParByCodeRequest> = {
  encode(message: GetFacturationParByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFacturationParByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFacturationParByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListFacturationParRequest(): ListFacturationParRequest {
  return { search: "" };
}

export const ListFacturationParRequest: MessageFns<ListFacturationParRequest> = {
  encode(message: ListFacturationParRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFacturationParRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFacturationParRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteFacturationParRequest(): DeleteFacturationParRequest {
  return { id: "" };
}

export const DeleteFacturationParRequest: MessageFns<DeleteFacturationParRequest> = {
  encode(message: DeleteFacturationParRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFacturationParRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFacturationParRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListFacturationParResponse(): ListFacturationParResponse {
  return { facturations: [] };
}

export const ListFacturationParResponse: MessageFns<ListFacturationParResponse> = {
  encode(message: ListFacturationParResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.facturations) {
      FacturationPar.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFacturationParResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFacturationParResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.facturations.push(FacturationPar.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePeriodeFacturation(): PeriodeFacturation {
  return { id: "", code: "", nom: "", description: "", createdAt: "", updatedAt: "" };
}

export const PeriodeFacturation: MessageFns<PeriodeFacturation> = {
  encode(message: PeriodeFacturation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeriodeFacturation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeriodeFacturation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePeriodeFacturationRequest(): CreatePeriodeFacturationRequest {
  return { code: "", nom: "", description: "" };
}

export const CreatePeriodeFacturationRequest: MessageFns<CreatePeriodeFacturationRequest> = {
  encode(message: CreatePeriodeFacturationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePeriodeFacturationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePeriodeFacturationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePeriodeFacturationRequest(): UpdatePeriodeFacturationRequest {
  return { id: "", code: "", nom: "", description: "" };
}

export const UpdatePeriodeFacturationRequest: MessageFns<UpdatePeriodeFacturationRequest> = {
  encode(message: UpdatePeriodeFacturationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePeriodeFacturationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePeriodeFacturationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPeriodeFacturationRequest(): GetPeriodeFacturationRequest {
  return { id: "" };
}

export const GetPeriodeFacturationRequest: MessageFns<GetPeriodeFacturationRequest> = {
  encode(message: GetPeriodeFacturationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeriodeFacturationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeriodeFacturationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPeriodeFacturationByCodeRequest(): GetPeriodeFacturationByCodeRequest {
  return { code: "" };
}

export const GetPeriodeFacturationByCodeRequest: MessageFns<GetPeriodeFacturationByCodeRequest> = {
  encode(message: GetPeriodeFacturationByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPeriodeFacturationByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPeriodeFacturationByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPeriodeFacturationRequest(): ListPeriodeFacturationRequest {
  return { search: "" };
}

export const ListPeriodeFacturationRequest: MessageFns<ListPeriodeFacturationRequest> = {
  encode(message: ListPeriodeFacturationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPeriodeFacturationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPeriodeFacturationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeletePeriodeFacturationRequest(): DeletePeriodeFacturationRequest {
  return { id: "" };
}

export const DeletePeriodeFacturationRequest: MessageFns<DeletePeriodeFacturationRequest> = {
  encode(message: DeletePeriodeFacturationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePeriodeFacturationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePeriodeFacturationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPeriodeFacturationResponse(): ListPeriodeFacturationResponse {
  return { periodes: [] };
}

export const ListPeriodeFacturationResponse: MessageFns<ListPeriodeFacturationResponse> = {
  encode(message: ListPeriodeFacturationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.periodes) {
      PeriodeFacturation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPeriodeFacturationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPeriodeFacturationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.periodes.push(PeriodeFacturation.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEmissionFacture(): EmissionFacture {
  return { id: "", code: "", nom: "", description: "", createdAt: "", updatedAt: "" };
}

export const EmissionFacture: MessageFns<EmissionFacture> = {
  encode(message: EmissionFacture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmissionFacture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmissionFacture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateEmissionFactureRequest(): CreateEmissionFactureRequest {
  return { code: "", nom: "", description: "" };
}

export const CreateEmissionFactureRequest: MessageFns<CreateEmissionFactureRequest> = {
  encode(message: CreateEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateEmissionFactureRequest(): UpdateEmissionFactureRequest {
  return { id: "", code: "", nom: "", description: "" };
}

export const UpdateEmissionFactureRequest: MessageFns<UpdateEmissionFactureRequest> = {
  encode(message: UpdateEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetEmissionFactureRequest(): GetEmissionFactureRequest {
  return { id: "" };
}

export const GetEmissionFactureRequest: MessageFns<GetEmissionFactureRequest> = {
  encode(message: GetEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetEmissionFactureByCodeRequest(): GetEmissionFactureByCodeRequest {
  return { code: "" };
}

export const GetEmissionFactureByCodeRequest: MessageFns<GetEmissionFactureByCodeRequest> = {
  encode(message: GetEmissionFactureByCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEmissionFactureByCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEmissionFactureByCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListEmissionFactureRequest(): ListEmissionFactureRequest {
  return { search: "" };
}

export const ListEmissionFactureRequest: MessageFns<ListEmissionFactureRequest> = {
  encode(message: ListEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteEmissionFactureRequest(): DeleteEmissionFactureRequest {
  return { id: "" };
}

export const DeleteEmissionFactureRequest: MessageFns<DeleteEmissionFactureRequest> = {
  encode(message: DeleteEmissionFactureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEmissionFactureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEmissionFactureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListEmissionFactureResponse(): ListEmissionFactureResponse {
  return { emissions: [] };
}

export const ListEmissionFactureResponse: MessageFns<ListEmissionFactureResponse> = {
  encode(message: ListEmissionFactureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.emissions) {
      EmissionFacture.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEmissionFactureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEmissionFactureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emissions.push(EmissionFacture.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTransporteurCompte(): TransporteurCompte {
  return {
    id: "",
    type: "",
    organisationId: "",
    contractNumber: "",
    labelFormat: "",
    actif: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const TransporteurCompte: MessageFns<TransporteurCompte> = {
  encode(message: TransporteurCompte, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    if (message.contractNumber !== "") {
      writer.uint32(34).string(message.contractNumber);
    }
    if (message.labelFormat !== "") {
      writer.uint32(42).string(message.labelFormat);
    }
    if (message.actif !== false) {
      writer.uint32(48).bool(message.actif);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransporteurCompte {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransporteurCompte();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contractNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.labelFormat = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateTransporteurCompteRequest(): CreateTransporteurCompteRequest {
  return { type: "", organisationId: "", contractNumber: "", password: "", labelFormat: "" };
}

export const CreateTransporteurCompteRequest: MessageFns<CreateTransporteurCompteRequest> = {
  encode(message: CreateTransporteurCompteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.contractNumber !== "") {
      writer.uint32(26).string(message.contractNumber);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    if (message.labelFormat !== "") {
      writer.uint32(42).string(message.labelFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTransporteurCompteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTransporteurCompteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contractNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.labelFormat = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateTransporteurCompteRequest(): UpdateTransporteurCompteRequest {
  return { id: "", contractNumber: "", password: "", labelFormat: "" };
}

export const UpdateTransporteurCompteRequest: MessageFns<UpdateTransporteurCompteRequest> = {
  encode(message: UpdateTransporteurCompteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contractNumber !== "") {
      writer.uint32(18).string(message.contractNumber);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.labelFormat !== "") {
      writer.uint32(34).string(message.labelFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTransporteurCompteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTransporteurCompteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.labelFormat = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetTransporteurCompteRequest(): GetTransporteurCompteRequest {
  return { id: "" };
}

export const GetTransporteurCompteRequest: MessageFns<GetTransporteurCompteRequest> = {
  encode(message: GetTransporteurCompteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransporteurCompteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransporteurCompteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTransporteurByOrganisationRequest(): ListTransporteurByOrganisationRequest {
  return { organisationId: "", actif: false };
}

export const ListTransporteurByOrganisationRequest: MessageFns<ListTransporteurByOrganisationRequest> = {
  encode(message: ListTransporteurByOrganisationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.actif !== false) {
      writer.uint32(16).bool(message.actif);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransporteurByOrganisationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransporteurByOrganisationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTransporteurCompteRequest(): ListTransporteurCompteRequest {
  return { type: "", actif: false };
}

export const ListTransporteurCompteRequest: MessageFns<ListTransporteurCompteRequest> = {
  encode(message: ListTransporteurCompteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.actif !== false) {
      writer.uint32(16).bool(message.actif);
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransporteurCompteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransporteurCompteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseActivateTransporteurRequest(): ActivateTransporteurRequest {
  return { id: "" };
}

export const ActivateTransporteurRequest: MessageFns<ActivateTransporteurRequest> = {
  encode(message: ActivateTransporteurRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateTransporteurRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateTransporteurRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteTransporteurCompteRequest(): DeleteTransporteurCompteRequest {
  return { id: "" };
}

export const DeleteTransporteurCompteRequest: MessageFns<DeleteTransporteurCompteRequest> = {
  encode(message: DeleteTransporteurCompteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTransporteurCompteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTransporteurCompteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListTransporteurCompteResponse(): ListTransporteurCompteResponse {
  return { transporteurs: [] };
}

export const ListTransporteurCompteResponse: MessageFns<ListTransporteurCompteResponse> = {
  encode(message: ListTransporteurCompteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transporteurs) {
      TransporteurCompte.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResult.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransporteurCompteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransporteurCompteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transporteurs.push(TransporteurCompte.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePagination(): Pagination {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const Pagination: MessageFns<Pagination> = {
  encode(message: Pagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResult(): PaginationResult {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResult: MessageFns<PaginationResult> = {
  encode(message: PaginationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ========== CONDITION PAIEMENT SERVICE ========== */

export interface ConditionPaiementServiceClient {
  create(request: CreateConditionPaiementRequest, metadata?: Metadata): Observable<ConditionPaiement>;

  update(request: UpdateConditionPaiementRequest, metadata?: Metadata): Observable<ConditionPaiement>;

  get(request: GetConditionPaiementRequest, metadata?: Metadata): Observable<ConditionPaiement>;

  getByCode(request: GetConditionPaiementByCodeRequest, metadata?: Metadata): Observable<ConditionPaiement>;

  list(request: ListConditionPaiementRequest, metadata?: Metadata): Observable<ListConditionPaiementResponse>;

  delete(request: DeleteConditionPaiementRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== CONDITION PAIEMENT SERVICE ========== */

export interface ConditionPaiementServiceController {
  create(
    request: CreateConditionPaiementRequest,
    metadata?: Metadata,
  ): Promise<ConditionPaiement> | Observable<ConditionPaiement> | ConditionPaiement;

  update(
    request: UpdateConditionPaiementRequest,
    metadata?: Metadata,
  ): Promise<ConditionPaiement> | Observable<ConditionPaiement> | ConditionPaiement;

  get(
    request: GetConditionPaiementRequest,
    metadata?: Metadata,
  ): Promise<ConditionPaiement> | Observable<ConditionPaiement> | ConditionPaiement;

  getByCode(
    request: GetConditionPaiementByCodeRequest,
    metadata?: Metadata,
  ): Promise<ConditionPaiement> | Observable<ConditionPaiement> | ConditionPaiement;

  list(
    request: ListConditionPaiementRequest,
    metadata?: Metadata,
  ): Promise<ListConditionPaiementResponse> | Observable<ListConditionPaiementResponse> | ListConditionPaiementResponse;

  delete(
    request: DeleteConditionPaiementRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function ConditionPaiementServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ConditionPaiementService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ConditionPaiementService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CONDITION_PAIEMENT_SERVICE_NAME = "ConditionPaiementService";

/** ========== CONDITION PAIEMENT SERVICE ========== */
export type ConditionPaiementServiceService = typeof ConditionPaiementServiceService;
export const ConditionPaiementServiceService = {
  create: {
    path: "/referentiel.ConditionPaiementService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateConditionPaiementRequest): Buffer =>
      Buffer.from(CreateConditionPaiementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateConditionPaiementRequest => CreateConditionPaiementRequest.decode(value),
    responseSerialize: (value: ConditionPaiement): Buffer => Buffer.from(ConditionPaiement.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConditionPaiement => ConditionPaiement.decode(value),
  },
  update: {
    path: "/referentiel.ConditionPaiementService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateConditionPaiementRequest): Buffer =>
      Buffer.from(UpdateConditionPaiementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateConditionPaiementRequest => UpdateConditionPaiementRequest.decode(value),
    responseSerialize: (value: ConditionPaiement): Buffer => Buffer.from(ConditionPaiement.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConditionPaiement => ConditionPaiement.decode(value),
  },
  get: {
    path: "/referentiel.ConditionPaiementService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConditionPaiementRequest): Buffer =>
      Buffer.from(GetConditionPaiementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetConditionPaiementRequest => GetConditionPaiementRequest.decode(value),
    responseSerialize: (value: ConditionPaiement): Buffer => Buffer.from(ConditionPaiement.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConditionPaiement => ConditionPaiement.decode(value),
  },
  getByCode: {
    path: "/referentiel.ConditionPaiementService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConditionPaiementByCodeRequest): Buffer =>
      Buffer.from(GetConditionPaiementByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetConditionPaiementByCodeRequest =>
      GetConditionPaiementByCodeRequest.decode(value),
    responseSerialize: (value: ConditionPaiement): Buffer => Buffer.from(ConditionPaiement.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConditionPaiement => ConditionPaiement.decode(value),
  },
  list: {
    path: "/referentiel.ConditionPaiementService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListConditionPaiementRequest): Buffer =>
      Buffer.from(ListConditionPaiementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListConditionPaiementRequest => ListConditionPaiementRequest.decode(value),
    responseSerialize: (value: ListConditionPaiementResponse): Buffer =>
      Buffer.from(ListConditionPaiementResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListConditionPaiementResponse => ListConditionPaiementResponse.decode(value),
  },
  delete: {
    path: "/referentiel.ConditionPaiementService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteConditionPaiementRequest): Buffer =>
      Buffer.from(DeleteConditionPaiementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteConditionPaiementRequest => DeleteConditionPaiementRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface ConditionPaiementServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateConditionPaiementRequest, ConditionPaiement>;
  update: handleUnaryCall<UpdateConditionPaiementRequest, ConditionPaiement>;
  get: handleUnaryCall<GetConditionPaiementRequest, ConditionPaiement>;
  getByCode: handleUnaryCall<GetConditionPaiementByCodeRequest, ConditionPaiement>;
  list: handleUnaryCall<ListConditionPaiementRequest, ListConditionPaiementResponse>;
  delete: handleUnaryCall<DeleteConditionPaiementRequest, DeleteResponse>;
}

/** ========== STATUT CLIENT SERVICE ========== */

export interface StatutClientServiceClient {
  create(request: CreateStatutClientRequest, metadata?: Metadata): Observable<StatutClient>;

  update(request: UpdateStatutClientRequest, metadata?: Metadata): Observable<StatutClient>;

  get(request: GetStatutClientRequest, metadata?: Metadata): Observable<StatutClient>;

  getByCode(request: GetStatutClientByCodeRequest, metadata?: Metadata): Observable<StatutClient>;

  list(request: ListStatutClientRequest, metadata?: Metadata): Observable<ListStatutClientResponse>;

  delete(request: DeleteStatutClientRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== STATUT CLIENT SERVICE ========== */

export interface StatutClientServiceController {
  create(
    request: CreateStatutClientRequest,
    metadata?: Metadata,
  ): Promise<StatutClient> | Observable<StatutClient> | StatutClient;

  update(
    request: UpdateStatutClientRequest,
    metadata?: Metadata,
  ): Promise<StatutClient> | Observable<StatutClient> | StatutClient;

  get(
    request: GetStatutClientRequest,
    metadata?: Metadata,
  ): Promise<StatutClient> | Observable<StatutClient> | StatutClient;

  getByCode(
    request: GetStatutClientByCodeRequest,
    metadata?: Metadata,
  ): Promise<StatutClient> | Observable<StatutClient> | StatutClient;

  list(
    request: ListStatutClientRequest,
    metadata?: Metadata,
  ): Promise<ListStatutClientResponse> | Observable<ListStatutClientResponse> | ListStatutClientResponse;

  delete(
    request: DeleteStatutClientRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function StatutClientServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("StatutClientService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("StatutClientService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const STATUT_CLIENT_SERVICE_NAME = "StatutClientService";

/** ========== STATUT CLIENT SERVICE ========== */
export type StatutClientServiceService = typeof StatutClientServiceService;
export const StatutClientServiceService = {
  create: {
    path: "/referentiel.StatutClientService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStatutClientRequest): Buffer =>
      Buffer.from(CreateStatutClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateStatutClientRequest => CreateStatutClientRequest.decode(value),
    responseSerialize: (value: StatutClient): Buffer => Buffer.from(StatutClient.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutClient => StatutClient.decode(value),
  },
  update: {
    path: "/referentiel.StatutClientService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateStatutClientRequest): Buffer =>
      Buffer.from(UpdateStatutClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateStatutClientRequest => UpdateStatutClientRequest.decode(value),
    responseSerialize: (value: StatutClient): Buffer => Buffer.from(StatutClient.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutClient => StatutClient.decode(value),
  },
  get: {
    path: "/referentiel.StatutClientService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutClientRequest): Buffer =>
      Buffer.from(GetStatutClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutClientRequest => GetStatutClientRequest.decode(value),
    responseSerialize: (value: StatutClient): Buffer => Buffer.from(StatutClient.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutClient => StatutClient.decode(value),
  },
  getByCode: {
    path: "/referentiel.StatutClientService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatutClientByCodeRequest): Buffer =>
      Buffer.from(GetStatutClientByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatutClientByCodeRequest => GetStatutClientByCodeRequest.decode(value),
    responseSerialize: (value: StatutClient): Buffer => Buffer.from(StatutClient.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatutClient => StatutClient.decode(value),
  },
  list: {
    path: "/referentiel.StatutClientService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListStatutClientRequest): Buffer =>
      Buffer.from(ListStatutClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListStatutClientRequest => ListStatutClientRequest.decode(value),
    responseSerialize: (value: ListStatutClientResponse): Buffer =>
      Buffer.from(ListStatutClientResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListStatutClientResponse => ListStatutClientResponse.decode(value),
  },
  delete: {
    path: "/referentiel.StatutClientService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteStatutClientRequest): Buffer =>
      Buffer.from(DeleteStatutClientRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteStatutClientRequest => DeleteStatutClientRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface StatutClientServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateStatutClientRequest, StatutClient>;
  update: handleUnaryCall<UpdateStatutClientRequest, StatutClient>;
  get: handleUnaryCall<GetStatutClientRequest, StatutClient>;
  getByCode: handleUnaryCall<GetStatutClientByCodeRequest, StatutClient>;
  list: handleUnaryCall<ListStatutClientRequest, ListStatutClientResponse>;
  delete: handleUnaryCall<DeleteStatutClientRequest, DeleteResponse>;
}

/** ========== FACTURATION PAR SERVICE ========== */

export interface FacturationParServiceClient {
  create(request: CreateFacturationParRequest, metadata?: Metadata): Observable<FacturationPar>;

  update(request: UpdateFacturationParRequest, metadata?: Metadata): Observable<FacturationPar>;

  get(request: GetFacturationParRequest, metadata?: Metadata): Observable<FacturationPar>;

  getByCode(request: GetFacturationParByCodeRequest, metadata?: Metadata): Observable<FacturationPar>;

  list(request: ListFacturationParRequest, metadata?: Metadata): Observable<ListFacturationParResponse>;

  delete(request: DeleteFacturationParRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== FACTURATION PAR SERVICE ========== */

export interface FacturationParServiceController {
  create(
    request: CreateFacturationParRequest,
    metadata?: Metadata,
  ): Promise<FacturationPar> | Observable<FacturationPar> | FacturationPar;

  update(
    request: UpdateFacturationParRequest,
    metadata?: Metadata,
  ): Promise<FacturationPar> | Observable<FacturationPar> | FacturationPar;

  get(
    request: GetFacturationParRequest,
    metadata?: Metadata,
  ): Promise<FacturationPar> | Observable<FacturationPar> | FacturationPar;

  getByCode(
    request: GetFacturationParByCodeRequest,
    metadata?: Metadata,
  ): Promise<FacturationPar> | Observable<FacturationPar> | FacturationPar;

  list(
    request: ListFacturationParRequest,
    metadata?: Metadata,
  ): Promise<ListFacturationParResponse> | Observable<ListFacturationParResponse> | ListFacturationParResponse;

  delete(
    request: DeleteFacturationParRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function FacturationParServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("FacturationParService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("FacturationParService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const FACTURATION_PAR_SERVICE_NAME = "FacturationParService";

/** ========== FACTURATION PAR SERVICE ========== */
export type FacturationParServiceService = typeof FacturationParServiceService;
export const FacturationParServiceService = {
  create: {
    path: "/referentiel.FacturationParService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateFacturationParRequest): Buffer =>
      Buffer.from(CreateFacturationParRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateFacturationParRequest => CreateFacturationParRequest.decode(value),
    responseSerialize: (value: FacturationPar): Buffer => Buffer.from(FacturationPar.encode(value).finish()),
    responseDeserialize: (value: Buffer): FacturationPar => FacturationPar.decode(value),
  },
  update: {
    path: "/referentiel.FacturationParService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateFacturationParRequest): Buffer =>
      Buffer.from(UpdateFacturationParRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateFacturationParRequest => UpdateFacturationParRequest.decode(value),
    responseSerialize: (value: FacturationPar): Buffer => Buffer.from(FacturationPar.encode(value).finish()),
    responseDeserialize: (value: Buffer): FacturationPar => FacturationPar.decode(value),
  },
  get: {
    path: "/referentiel.FacturationParService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFacturationParRequest): Buffer =>
      Buffer.from(GetFacturationParRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetFacturationParRequest => GetFacturationParRequest.decode(value),
    responseSerialize: (value: FacturationPar): Buffer => Buffer.from(FacturationPar.encode(value).finish()),
    responseDeserialize: (value: Buffer): FacturationPar => FacturationPar.decode(value),
  },
  getByCode: {
    path: "/referentiel.FacturationParService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetFacturationParByCodeRequest): Buffer =>
      Buffer.from(GetFacturationParByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetFacturationParByCodeRequest => GetFacturationParByCodeRequest.decode(value),
    responseSerialize: (value: FacturationPar): Buffer => Buffer.from(FacturationPar.encode(value).finish()),
    responseDeserialize: (value: Buffer): FacturationPar => FacturationPar.decode(value),
  },
  list: {
    path: "/referentiel.FacturationParService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListFacturationParRequest): Buffer =>
      Buffer.from(ListFacturationParRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListFacturationParRequest => ListFacturationParRequest.decode(value),
    responseSerialize: (value: ListFacturationParResponse): Buffer =>
      Buffer.from(ListFacturationParResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListFacturationParResponse => ListFacturationParResponse.decode(value),
  },
  delete: {
    path: "/referentiel.FacturationParService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteFacturationParRequest): Buffer =>
      Buffer.from(DeleteFacturationParRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteFacturationParRequest => DeleteFacturationParRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface FacturationParServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateFacturationParRequest, FacturationPar>;
  update: handleUnaryCall<UpdateFacturationParRequest, FacturationPar>;
  get: handleUnaryCall<GetFacturationParRequest, FacturationPar>;
  getByCode: handleUnaryCall<GetFacturationParByCodeRequest, FacturationPar>;
  list: handleUnaryCall<ListFacturationParRequest, ListFacturationParResponse>;
  delete: handleUnaryCall<DeleteFacturationParRequest, DeleteResponse>;
}

/** ========== PERIODE FACTURATION SERVICE ========== */

export interface PeriodeFacturationServiceClient {
  create(request: CreatePeriodeFacturationRequest, metadata?: Metadata): Observable<PeriodeFacturation>;

  update(request: UpdatePeriodeFacturationRequest, metadata?: Metadata): Observable<PeriodeFacturation>;

  get(request: GetPeriodeFacturationRequest, metadata?: Metadata): Observable<PeriodeFacturation>;

  getByCode(request: GetPeriodeFacturationByCodeRequest, metadata?: Metadata): Observable<PeriodeFacturation>;

  list(request: ListPeriodeFacturationRequest, metadata?: Metadata): Observable<ListPeriodeFacturationResponse>;

  delete(request: DeletePeriodeFacturationRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== PERIODE FACTURATION SERVICE ========== */

export interface PeriodeFacturationServiceController {
  create(
    request: CreatePeriodeFacturationRequest,
    metadata?: Metadata,
  ): Promise<PeriodeFacturation> | Observable<PeriodeFacturation> | PeriodeFacturation;

  update(
    request: UpdatePeriodeFacturationRequest,
    metadata?: Metadata,
  ): Promise<PeriodeFacturation> | Observable<PeriodeFacturation> | PeriodeFacturation;

  get(
    request: GetPeriodeFacturationRequest,
    metadata?: Metadata,
  ): Promise<PeriodeFacturation> | Observable<PeriodeFacturation> | PeriodeFacturation;

  getByCode(
    request: GetPeriodeFacturationByCodeRequest,
    metadata?: Metadata,
  ): Promise<PeriodeFacturation> | Observable<PeriodeFacturation> | PeriodeFacturation;

  list(
    request: ListPeriodeFacturationRequest,
    metadata?: Metadata,
  ):
    | Promise<ListPeriodeFacturationResponse>
    | Observable<ListPeriodeFacturationResponse>
    | ListPeriodeFacturationResponse;

  delete(
    request: DeletePeriodeFacturationRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function PeriodeFacturationServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PeriodeFacturationService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PeriodeFacturationService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PERIODE_FACTURATION_SERVICE_NAME = "PeriodeFacturationService";

/** ========== PERIODE FACTURATION SERVICE ========== */
export type PeriodeFacturationServiceService = typeof PeriodeFacturationServiceService;
export const PeriodeFacturationServiceService = {
  create: {
    path: "/referentiel.PeriodeFacturationService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePeriodeFacturationRequest): Buffer =>
      Buffer.from(CreatePeriodeFacturationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePeriodeFacturationRequest =>
      CreatePeriodeFacturationRequest.decode(value),
    responseSerialize: (value: PeriodeFacturation): Buffer => Buffer.from(PeriodeFacturation.encode(value).finish()),
    responseDeserialize: (value: Buffer): PeriodeFacturation => PeriodeFacturation.decode(value),
  },
  update: {
    path: "/referentiel.PeriodeFacturationService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePeriodeFacturationRequest): Buffer =>
      Buffer.from(UpdatePeriodeFacturationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePeriodeFacturationRequest =>
      UpdatePeriodeFacturationRequest.decode(value),
    responseSerialize: (value: PeriodeFacturation): Buffer => Buffer.from(PeriodeFacturation.encode(value).finish()),
    responseDeserialize: (value: Buffer): PeriodeFacturation => PeriodeFacturation.decode(value),
  },
  get: {
    path: "/referentiel.PeriodeFacturationService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPeriodeFacturationRequest): Buffer =>
      Buffer.from(GetPeriodeFacturationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPeriodeFacturationRequest => GetPeriodeFacturationRequest.decode(value),
    responseSerialize: (value: PeriodeFacturation): Buffer => Buffer.from(PeriodeFacturation.encode(value).finish()),
    responseDeserialize: (value: Buffer): PeriodeFacturation => PeriodeFacturation.decode(value),
  },
  getByCode: {
    path: "/referentiel.PeriodeFacturationService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPeriodeFacturationByCodeRequest): Buffer =>
      Buffer.from(GetPeriodeFacturationByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPeriodeFacturationByCodeRequest =>
      GetPeriodeFacturationByCodeRequest.decode(value),
    responseSerialize: (value: PeriodeFacturation): Buffer => Buffer.from(PeriodeFacturation.encode(value).finish()),
    responseDeserialize: (value: Buffer): PeriodeFacturation => PeriodeFacturation.decode(value),
  },
  list: {
    path: "/referentiel.PeriodeFacturationService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPeriodeFacturationRequest): Buffer =>
      Buffer.from(ListPeriodeFacturationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPeriodeFacturationRequest => ListPeriodeFacturationRequest.decode(value),
    responseSerialize: (value: ListPeriodeFacturationResponse): Buffer =>
      Buffer.from(ListPeriodeFacturationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPeriodeFacturationResponse =>
      ListPeriodeFacturationResponse.decode(value),
  },
  delete: {
    path: "/referentiel.PeriodeFacturationService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePeriodeFacturationRequest): Buffer =>
      Buffer.from(DeletePeriodeFacturationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeletePeriodeFacturationRequest =>
      DeletePeriodeFacturationRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface PeriodeFacturationServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreatePeriodeFacturationRequest, PeriodeFacturation>;
  update: handleUnaryCall<UpdatePeriodeFacturationRequest, PeriodeFacturation>;
  get: handleUnaryCall<GetPeriodeFacturationRequest, PeriodeFacturation>;
  getByCode: handleUnaryCall<GetPeriodeFacturationByCodeRequest, PeriodeFacturation>;
  list: handleUnaryCall<ListPeriodeFacturationRequest, ListPeriodeFacturationResponse>;
  delete: handleUnaryCall<DeletePeriodeFacturationRequest, DeleteResponse>;
}

/** ========== EMISSION FACTURE SERVICE ========== */

export interface EmissionFactureServiceClient {
  create(request: CreateEmissionFactureRequest, metadata?: Metadata): Observable<EmissionFacture>;

  update(request: UpdateEmissionFactureRequest, metadata?: Metadata): Observable<EmissionFacture>;

  get(request: GetEmissionFactureRequest, metadata?: Metadata): Observable<EmissionFacture>;

  getByCode(request: GetEmissionFactureByCodeRequest, metadata?: Metadata): Observable<EmissionFacture>;

  list(request: ListEmissionFactureRequest, metadata?: Metadata): Observable<ListEmissionFactureResponse>;

  delete(request: DeleteEmissionFactureRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== EMISSION FACTURE SERVICE ========== */

export interface EmissionFactureServiceController {
  create(
    request: CreateEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<EmissionFacture> | Observable<EmissionFacture> | EmissionFacture;

  update(
    request: UpdateEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<EmissionFacture> | Observable<EmissionFacture> | EmissionFacture;

  get(
    request: GetEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<EmissionFacture> | Observable<EmissionFacture> | EmissionFacture;

  getByCode(
    request: GetEmissionFactureByCodeRequest,
    metadata?: Metadata,
  ): Promise<EmissionFacture> | Observable<EmissionFacture> | EmissionFacture;

  list(
    request: ListEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<ListEmissionFactureResponse> | Observable<ListEmissionFactureResponse> | ListEmissionFactureResponse;

  delete(
    request: DeleteEmissionFactureRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function EmissionFactureServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "getByCode", "list", "delete"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("EmissionFactureService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("EmissionFactureService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const EMISSION_FACTURE_SERVICE_NAME = "EmissionFactureService";

/** ========== EMISSION FACTURE SERVICE ========== */
export type EmissionFactureServiceService = typeof EmissionFactureServiceService;
export const EmissionFactureServiceService = {
  create: {
    path: "/referentiel.EmissionFactureService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateEmissionFactureRequest): Buffer =>
      Buffer.from(CreateEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateEmissionFactureRequest => CreateEmissionFactureRequest.decode(value),
    responseSerialize: (value: EmissionFacture): Buffer => Buffer.from(EmissionFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmissionFacture => EmissionFacture.decode(value),
  },
  update: {
    path: "/referentiel.EmissionFactureService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEmissionFactureRequest): Buffer =>
      Buffer.from(UpdateEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateEmissionFactureRequest => UpdateEmissionFactureRequest.decode(value),
    responseSerialize: (value: EmissionFacture): Buffer => Buffer.from(EmissionFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmissionFacture => EmissionFacture.decode(value),
  },
  get: {
    path: "/referentiel.EmissionFactureService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmissionFactureRequest): Buffer =>
      Buffer.from(GetEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmissionFactureRequest => GetEmissionFactureRequest.decode(value),
    responseSerialize: (value: EmissionFacture): Buffer => Buffer.from(EmissionFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmissionFacture => EmissionFacture.decode(value),
  },
  getByCode: {
    path: "/referentiel.EmissionFactureService/GetByCode",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEmissionFactureByCodeRequest): Buffer =>
      Buffer.from(GetEmissionFactureByCodeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEmissionFactureByCodeRequest =>
      GetEmissionFactureByCodeRequest.decode(value),
    responseSerialize: (value: EmissionFacture): Buffer => Buffer.from(EmissionFacture.encode(value).finish()),
    responseDeserialize: (value: Buffer): EmissionFacture => EmissionFacture.decode(value),
  },
  list: {
    path: "/referentiel.EmissionFactureService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListEmissionFactureRequest): Buffer =>
      Buffer.from(ListEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListEmissionFactureRequest => ListEmissionFactureRequest.decode(value),
    responseSerialize: (value: ListEmissionFactureResponse): Buffer =>
      Buffer.from(ListEmissionFactureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListEmissionFactureResponse => ListEmissionFactureResponse.decode(value),
  },
  delete: {
    path: "/referentiel.EmissionFactureService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteEmissionFactureRequest): Buffer =>
      Buffer.from(DeleteEmissionFactureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteEmissionFactureRequest => DeleteEmissionFactureRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface EmissionFactureServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateEmissionFactureRequest, EmissionFacture>;
  update: handleUnaryCall<UpdateEmissionFactureRequest, EmissionFacture>;
  get: handleUnaryCall<GetEmissionFactureRequest, EmissionFacture>;
  getByCode: handleUnaryCall<GetEmissionFactureByCodeRequest, EmissionFacture>;
  list: handleUnaryCall<ListEmissionFactureRequest, ListEmissionFactureResponse>;
  delete: handleUnaryCall<DeleteEmissionFactureRequest, DeleteResponse>;
}

/** ========== TRANSPORTEUR COMPTE SERVICE ========== */

export interface TransporteurCompteServiceClient {
  create(request: CreateTransporteurCompteRequest, metadata?: Metadata): Observable<TransporteurCompte>;

  update(request: UpdateTransporteurCompteRequest, metadata?: Metadata): Observable<TransporteurCompte>;

  get(request: GetTransporteurCompteRequest, metadata?: Metadata): Observable<TransporteurCompte>;

  listByOrganisation(
    request: ListTransporteurByOrganisationRequest,
    metadata?: Metadata,
  ): Observable<ListTransporteurCompteResponse>;

  list(request: ListTransporteurCompteRequest, metadata?: Metadata): Observable<ListTransporteurCompteResponse>;

  activer(request: ActivateTransporteurRequest, metadata?: Metadata): Observable<TransporteurCompte>;

  desactiver(request: ActivateTransporteurRequest, metadata?: Metadata): Observable<TransporteurCompte>;

  delete(request: DeleteTransporteurCompteRequest, metadata?: Metadata): Observable<DeleteResponse>;
}

/** ========== TRANSPORTEUR COMPTE SERVICE ========== */

export interface TransporteurCompteServiceController {
  create(
    request: CreateTransporteurCompteRequest,
    metadata?: Metadata,
  ): Promise<TransporteurCompte> | Observable<TransporteurCompte> | TransporteurCompte;

  update(
    request: UpdateTransporteurCompteRequest,
    metadata?: Metadata,
  ): Promise<TransporteurCompte> | Observable<TransporteurCompte> | TransporteurCompte;

  get(
    request: GetTransporteurCompteRequest,
    metadata?: Metadata,
  ): Promise<TransporteurCompte> | Observable<TransporteurCompte> | TransporteurCompte;

  listByOrganisation(
    request: ListTransporteurByOrganisationRequest,
    metadata?: Metadata,
  ):
    | Promise<ListTransporteurCompteResponse>
    | Observable<ListTransporteurCompteResponse>
    | ListTransporteurCompteResponse;

  list(
    request: ListTransporteurCompteRequest,
    metadata?: Metadata,
  ):
    | Promise<ListTransporteurCompteResponse>
    | Observable<ListTransporteurCompteResponse>
    | ListTransporteurCompteResponse;

  activer(
    request: ActivateTransporteurRequest,
    metadata?: Metadata,
  ): Promise<TransporteurCompte> | Observable<TransporteurCompte> | TransporteurCompte;

  desactiver(
    request: ActivateTransporteurRequest,
    metadata?: Metadata,
  ): Promise<TransporteurCompte> | Observable<TransporteurCompte> | TransporteurCompte;

  delete(
    request: DeleteTransporteurCompteRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function TransporteurCompteServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "create",
      "update",
      "get",
      "listByOrganisation",
      "list",
      "activer",
      "desactiver",
      "delete",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("TransporteurCompteService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("TransporteurCompteService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const TRANSPORTEUR_COMPTE_SERVICE_NAME = "TransporteurCompteService";

/** ========== TRANSPORTEUR COMPTE SERVICE ========== */
export type TransporteurCompteServiceService = typeof TransporteurCompteServiceService;
export const TransporteurCompteServiceService = {
  create: {
    path: "/referentiel.TransporteurCompteService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateTransporteurCompteRequest): Buffer =>
      Buffer.from(CreateTransporteurCompteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateTransporteurCompteRequest =>
      CreateTransporteurCompteRequest.decode(value),
    responseSerialize: (value: TransporteurCompte): Buffer => Buffer.from(TransporteurCompte.encode(value).finish()),
    responseDeserialize: (value: Buffer): TransporteurCompte => TransporteurCompte.decode(value),
  },
  update: {
    path: "/referentiel.TransporteurCompteService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateTransporteurCompteRequest): Buffer =>
      Buffer.from(UpdateTransporteurCompteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateTransporteurCompteRequest =>
      UpdateTransporteurCompteRequest.decode(value),
    responseSerialize: (value: TransporteurCompte): Buffer => Buffer.from(TransporteurCompte.encode(value).finish()),
    responseDeserialize: (value: Buffer): TransporteurCompte => TransporteurCompte.decode(value),
  },
  get: {
    path: "/referentiel.TransporteurCompteService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTransporteurCompteRequest): Buffer =>
      Buffer.from(GetTransporteurCompteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetTransporteurCompteRequest => GetTransporteurCompteRequest.decode(value),
    responseSerialize: (value: TransporteurCompte): Buffer => Buffer.from(TransporteurCompte.encode(value).finish()),
    responseDeserialize: (value: Buffer): TransporteurCompte => TransporteurCompte.decode(value),
  },
  listByOrganisation: {
    path: "/referentiel.TransporteurCompteService/ListByOrganisation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTransporteurByOrganisationRequest): Buffer =>
      Buffer.from(ListTransporteurByOrganisationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTransporteurByOrganisationRequest =>
      ListTransporteurByOrganisationRequest.decode(value),
    responseSerialize: (value: ListTransporteurCompteResponse): Buffer =>
      Buffer.from(ListTransporteurCompteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTransporteurCompteResponse =>
      ListTransporteurCompteResponse.decode(value),
  },
  list: {
    path: "/referentiel.TransporteurCompteService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListTransporteurCompteRequest): Buffer =>
      Buffer.from(ListTransporteurCompteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListTransporteurCompteRequest => ListTransporteurCompteRequest.decode(value),
    responseSerialize: (value: ListTransporteurCompteResponse): Buffer =>
      Buffer.from(ListTransporteurCompteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListTransporteurCompteResponse =>
      ListTransporteurCompteResponse.decode(value),
  },
  activer: {
    path: "/referentiel.TransporteurCompteService/Activer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateTransporteurRequest): Buffer =>
      Buffer.from(ActivateTransporteurRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ActivateTransporteurRequest => ActivateTransporteurRequest.decode(value),
    responseSerialize: (value: TransporteurCompte): Buffer => Buffer.from(TransporteurCompte.encode(value).finish()),
    responseDeserialize: (value: Buffer): TransporteurCompte => TransporteurCompte.decode(value),
  },
  desactiver: {
    path: "/referentiel.TransporteurCompteService/Desactiver",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateTransporteurRequest): Buffer =>
      Buffer.from(ActivateTransporteurRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ActivateTransporteurRequest => ActivateTransporteurRequest.decode(value),
    responseSerialize: (value: TransporteurCompte): Buffer => Buffer.from(TransporteurCompte.encode(value).finish()),
    responseDeserialize: (value: Buffer): TransporteurCompte => TransporteurCompte.decode(value),
  },
  delete: {
    path: "/referentiel.TransporteurCompteService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteTransporteurCompteRequest): Buffer =>
      Buffer.from(DeleteTransporteurCompteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteTransporteurCompteRequest =>
      DeleteTransporteurCompteRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface TransporteurCompteServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateTransporteurCompteRequest, TransporteurCompte>;
  update: handleUnaryCall<UpdateTransporteurCompteRequest, TransporteurCompte>;
  get: handleUnaryCall<GetTransporteurCompteRequest, TransporteurCompte>;
  listByOrganisation: handleUnaryCall<ListTransporteurByOrganisationRequest, ListTransporteurCompteResponse>;
  list: handleUnaryCall<ListTransporteurCompteRequest, ListTransporteurCompteResponse>;
  activer: handleUnaryCall<ActivateTransporteurRequest, TransporteurCompte>;
  desactiver: handleUnaryCall<ActivateTransporteurRequest, TransporteurCompte>;
  delete: handleUnaryCall<DeleteTransporteurCompteRequest, DeleteResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
