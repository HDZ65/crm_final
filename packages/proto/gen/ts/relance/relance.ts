// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: relance/relance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export enum RelanceDeclencheur {
  DECLENCHEUR_UNSPECIFIED = 0,
  IMPAYE = 1,
  CONTRAT_BIENTOT_EXPIRE = 2,
  CONTRAT_EXPIRE = 3,
  NOUVEAU_CLIENT = 4,
  INACTIVITE_CLIENT = 5,
}

export enum RelanceActionType {
  ACTION_TYPE_UNSPECIFIED = 0,
  CREER_TACHE = 1,
  ENVOYER_EMAIL = 2,
  NOTIFICATION = 3,
  TACHE_ET_EMAIL = 4,
}

export enum Priorite {
  PRIORITE_UNSPECIFIED = 0,
  HAUTE = 1,
  MOYENNE = 2,
  BASSE = 3,
}

export enum RelanceResultat {
  RESULTAT_UNSPECIFIED = 0,
  SUCCES = 1,
  ECHEC = 2,
  IGNORE = 3,
}

export interface Empty {
}

export interface PaginationRequest {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResponse {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface RegleRelance {
  id: string;
  organisationId: string;
  nom: string;
  description: string;
  declencheur: RelanceDeclencheur;
  delaiJours: number;
  actionType: RelanceActionType;
  prioriteTache: Priorite;
  templateEmailId: string;
  templateTitreTache: string;
  templateDescriptionTache: string;
  assigneParDefaut: string;
  actif: boolean;
  ordre: number;
  metadata: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateRegleRelanceRequest {
  organisationId: string;
  nom: string;
  description: string;
  declencheur: RelanceDeclencheur;
  delaiJours: number;
  actionType: RelanceActionType;
  prioriteTache: Priorite;
  templateEmailId: string;
  templateTitreTache: string;
  templateDescriptionTache: string;
  assigneParDefaut: string;
  ordre: number;
}

export interface UpdateRegleRelanceRequest {
  id: string;
  nom?: string | undefined;
  description?: string | undefined;
  declencheur?: RelanceDeclencheur | undefined;
  delaiJours?: number | undefined;
  actionType?: RelanceActionType | undefined;
  prioriteTache?: Priorite | undefined;
  templateEmailId?: string | undefined;
  templateTitreTache?: string | undefined;
  templateDescriptionTache?: string | undefined;
  assigneParDefaut?: string | undefined;
  actif?: boolean | undefined;
  ordre?: number | undefined;
}

export interface GetRegleRelanceRequest {
  id: string;
}

export interface ListReglesRelanceRequest {
  organisationId: string;
  actif?: boolean | undefined;
  declencheur?: RelanceDeclencheur | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListReglesRelanceResponse {
  regles: RegleRelance[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteRegleRelanceRequest {
  id: string;
}

export interface DeleteRegleRelanceResponse {
  success: boolean;
}

export interface ActivateRegleRequest {
  id: string;
}

export interface DeactivateRegleRequest {
  id: string;
}

export interface HistoriqueRelance {
  id: string;
  organisationId: string;
  regleRelanceId: string;
  clientId: string;
  contratId: string;
  factureId: string;
  tacheCreeeId: string;
  dateExecution: string;
  resultat: RelanceResultat;
  messageErreur: string;
  metadata: string;
  createdAt: string;
  updatedAt: string;
  /** Relations */
  regle?: RegleRelance | undefined;
}

export interface CreateHistoriqueRelanceRequest {
  organisationId: string;
  regleRelanceId: string;
  clientId: string;
  contratId: string;
  factureId: string;
  tacheCreeeId: string;
  resultat: RelanceResultat;
  messageErreur: string;
  metadata: string;
}

export interface GetHistoriqueRelanceRequest {
  id: string;
}

export interface ListHistoriquesRelanceRequest {
  organisationId: string;
  regleRelanceId?: string | undefined;
  clientId?: string | undefined;
  contratId?: string | undefined;
  factureId?: string | undefined;
  resultat?: RelanceResultat | undefined;
  dateFrom?: string | undefined;
  dateTo?: string | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListHistoriquesRelanceResponse {
  historiques: HistoriqueRelance[];
  pagination?: PaginationResponse | undefined;
}

export interface DeleteHistoriqueRelanceRequest {
  id: string;
}

export interface DeleteHistoriqueRelanceResponse {
  success: boolean;
}

export interface ExistsForTodayRequest {
  regleRelanceId: string;
  clientId: string;
  contratId: string;
  factureId: string;
}

export interface ExistsForTodayResponse {
  exists: boolean;
}

export interface ExecuteRelancesRequest {
  organisationId: string;
}

export interface ExecuteRelancesResponse {
  success: boolean;
  message: string;
  relancesExecutees: number;
  relancesEchouees: number;
}

export interface ExecuteRegleRequest {
  regleId: string;
}

export interface ExecuteRegleResponse {
  success: boolean;
  message: string;
  actionsCreees: number;
}

/** Event data for relance triggers (received from other services) */
export interface RelanceEventData {
  organisationId: string;
  declencheur: RelanceDeclencheur;
  clientId: string;
  contratId: string;
  factureId: string;
  metadata: string;
}

export interface ProcessEventRequest {
  event?: RelanceEventData | undefined;
}

export interface ProcessEventResponse {
  success: boolean;
  message: string;
  actionsCreated: string[];
}

/** Statistics */
export interface GetStatistiquesRequest {
  organisationId: string;
  dateFrom: string;
  dateTo: string;
}

export interface GetStatistiquesResponse {
  totalRelances: number;
  relancesSucces: number;
  relancesEchec: number;
  relancesIgnore: number;
  statsParDeclencheur: StatParDeclencheur[];
}

export interface StatParDeclencheur {
  declencheur: RelanceDeclencheur;
  count: number;
  succes: number;
  echec: number;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRegleRelance(): RegleRelance {
  return {
    id: "",
    organisationId: "",
    nom: "",
    description: "",
    declencheur: 0,
    delaiJours: 0,
    actionType: 0,
    prioriteTache: 0,
    templateEmailId: "",
    templateTitreTache: "",
    templateDescriptionTache: "",
    assigneParDefaut: "",
    actif: false,
    ordre: 0,
    metadata: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const RegleRelance: MessageFns<RegleRelance> = {
  encode(message: RegleRelance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.nom !== "") {
      writer.uint32(26).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.declencheur !== 0) {
      writer.uint32(40).int32(message.declencheur);
    }
    if (message.delaiJours !== 0) {
      writer.uint32(48).int32(message.delaiJours);
    }
    if (message.actionType !== 0) {
      writer.uint32(56).int32(message.actionType);
    }
    if (message.prioriteTache !== 0) {
      writer.uint32(64).int32(message.prioriteTache);
    }
    if (message.templateEmailId !== "") {
      writer.uint32(74).string(message.templateEmailId);
    }
    if (message.templateTitreTache !== "") {
      writer.uint32(82).string(message.templateTitreTache);
    }
    if (message.templateDescriptionTache !== "") {
      writer.uint32(90).string(message.templateDescriptionTache);
    }
    if (message.assigneParDefaut !== "") {
      writer.uint32(98).string(message.assigneParDefaut);
    }
    if (message.actif !== false) {
      writer.uint32(104).bool(message.actif);
    }
    if (message.ordre !== 0) {
      writer.uint32(112).int32(message.ordre);
    }
    if (message.metadata !== "") {
      writer.uint32(122).string(message.metadata);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(138).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegleRelance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegleRelance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.declencheur = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.delaiJours = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.prioriteTache = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.templateEmailId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.templateTitreTache = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.templateDescriptionTache = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.assigneParDefaut = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateRegleRelanceRequest(): CreateRegleRelanceRequest {
  return {
    organisationId: "",
    nom: "",
    description: "",
    declencheur: 0,
    delaiJours: 0,
    actionType: 0,
    prioriteTache: 0,
    templateEmailId: "",
    templateTitreTache: "",
    templateDescriptionTache: "",
    assigneParDefaut: "",
    ordre: 0,
  };
}

export const CreateRegleRelanceRequest: MessageFns<CreateRegleRelanceRequest> = {
  encode(message: CreateRegleRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.nom !== "") {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.declencheur !== 0) {
      writer.uint32(32).int32(message.declencheur);
    }
    if (message.delaiJours !== 0) {
      writer.uint32(40).int32(message.delaiJours);
    }
    if (message.actionType !== 0) {
      writer.uint32(48).int32(message.actionType);
    }
    if (message.prioriteTache !== 0) {
      writer.uint32(56).int32(message.prioriteTache);
    }
    if (message.templateEmailId !== "") {
      writer.uint32(66).string(message.templateEmailId);
    }
    if (message.templateTitreTache !== "") {
      writer.uint32(74).string(message.templateTitreTache);
    }
    if (message.templateDescriptionTache !== "") {
      writer.uint32(82).string(message.templateDescriptionTache);
    }
    if (message.assigneParDefaut !== "") {
      writer.uint32(90).string(message.assigneParDefaut);
    }
    if (message.ordre !== 0) {
      writer.uint32(96).int32(message.ordre);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRegleRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRegleRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.declencheur = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.delaiJours = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.prioriteTache = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.templateEmailId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.templateTitreTache = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.templateDescriptionTache = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.assigneParDefaut = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateRegleRelanceRequest(): UpdateRegleRelanceRequest {
  return { id: "" };
}

export const UpdateRegleRelanceRequest: MessageFns<UpdateRegleRelanceRequest> = {
  encode(message: UpdateRegleRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.nom !== undefined) {
      writer.uint32(18).string(message.nom);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.declencheur !== undefined) {
      writer.uint32(32).int32(message.declencheur);
    }
    if (message.delaiJours !== undefined) {
      writer.uint32(40).int32(message.delaiJours);
    }
    if (message.actionType !== undefined) {
      writer.uint32(48).int32(message.actionType);
    }
    if (message.prioriteTache !== undefined) {
      writer.uint32(56).int32(message.prioriteTache);
    }
    if (message.templateEmailId !== undefined) {
      writer.uint32(66).string(message.templateEmailId);
    }
    if (message.templateTitreTache !== undefined) {
      writer.uint32(74).string(message.templateTitreTache);
    }
    if (message.templateDescriptionTache !== undefined) {
      writer.uint32(82).string(message.templateDescriptionTache);
    }
    if (message.assigneParDefaut !== undefined) {
      writer.uint32(90).string(message.assigneParDefaut);
    }
    if (message.actif !== undefined) {
      writer.uint32(96).bool(message.actif);
    }
    if (message.ordre !== undefined) {
      writer.uint32(104).int32(message.ordre);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRegleRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRegleRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.declencheur = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.delaiJours = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.prioriteTache = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.templateEmailId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.templateTitreTache = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.templateDescriptionTache = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.assigneParDefaut = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.ordre = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRegleRelanceRequest(): GetRegleRelanceRequest {
  return { id: "" };
}

export const GetRegleRelanceRequest: MessageFns<GetRegleRelanceRequest> = {
  encode(message: GetRegleRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRegleRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRegleRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListReglesRelanceRequest(): ListReglesRelanceRequest {
  return { organisationId: "" };
}

export const ListReglesRelanceRequest: MessageFns<ListReglesRelanceRequest> = {
  encode(message: ListReglesRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.actif !== undefined) {
      writer.uint32(16).bool(message.actif);
    }
    if (message.declencheur !== undefined) {
      writer.uint32(24).int32(message.declencheur);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReglesRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReglesRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actif = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.declencheur = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListReglesRelanceResponse(): ListReglesRelanceResponse {
  return { regles: [] };
}

export const ListReglesRelanceResponse: MessageFns<ListReglesRelanceResponse> = {
  encode(message: ListReglesRelanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.regles) {
      RegleRelance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReglesRelanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReglesRelanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regles.push(RegleRelance.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteRegleRelanceRequest(): DeleteRegleRelanceRequest {
  return { id: "" };
}

export const DeleteRegleRelanceRequest: MessageFns<DeleteRegleRelanceRequest> = {
  encode(message: DeleteRegleRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRegleRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRegleRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteRegleRelanceResponse(): DeleteRegleRelanceResponse {
  return { success: false };
}

export const DeleteRegleRelanceResponse: MessageFns<DeleteRegleRelanceResponse> = {
  encode(message: DeleteRegleRelanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRegleRelanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRegleRelanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseActivateRegleRequest(): ActivateRegleRequest {
  return { id: "" };
}

export const ActivateRegleRequest: MessageFns<ActivateRegleRequest> = {
  encode(message: ActivateRegleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateRegleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateRegleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeactivateRegleRequest(): DeactivateRegleRequest {
  return { id: "" };
}

export const DeactivateRegleRequest: MessageFns<DeactivateRegleRequest> = {
  encode(message: DeactivateRegleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeactivateRegleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeactivateRegleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHistoriqueRelance(): HistoriqueRelance {
  return {
    id: "",
    organisationId: "",
    regleRelanceId: "",
    clientId: "",
    contratId: "",
    factureId: "",
    tacheCreeeId: "",
    dateExecution: "",
    resultat: 0,
    messageErreur: "",
    metadata: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const HistoriqueRelance: MessageFns<HistoriqueRelance> = {
  encode(message: HistoriqueRelance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.regleRelanceId !== "") {
      writer.uint32(26).string(message.regleRelanceId);
    }
    if (message.clientId !== "") {
      writer.uint32(34).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(42).string(message.contratId);
    }
    if (message.factureId !== "") {
      writer.uint32(50).string(message.factureId);
    }
    if (message.tacheCreeeId !== "") {
      writer.uint32(58).string(message.tacheCreeeId);
    }
    if (message.dateExecution !== "") {
      writer.uint32(66).string(message.dateExecution);
    }
    if (message.resultat !== 0) {
      writer.uint32(72).int32(message.resultat);
    }
    if (message.messageErreur !== "") {
      writer.uint32(82).string(message.messageErreur);
    }
    if (message.metadata !== "") {
      writer.uint32(90).string(message.metadata);
    }
    if (message.createdAt !== "") {
      writer.uint32(98).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(106).string(message.updatedAt);
    }
    if (message.regle !== undefined) {
      RegleRelance.encode(message.regle, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoriqueRelance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoriqueRelance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.regleRelanceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tacheCreeeId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateExecution = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.resultat = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.messageErreur = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.regle = RegleRelance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateHistoriqueRelanceRequest(): CreateHistoriqueRelanceRequest {
  return {
    organisationId: "",
    regleRelanceId: "",
    clientId: "",
    contratId: "",
    factureId: "",
    tacheCreeeId: "",
    resultat: 0,
    messageErreur: "",
    metadata: "",
  };
}

export const CreateHistoriqueRelanceRequest: MessageFns<CreateHistoriqueRelanceRequest> = {
  encode(message: CreateHistoriqueRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.regleRelanceId !== "") {
      writer.uint32(18).string(message.regleRelanceId);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(34).string(message.contratId);
    }
    if (message.factureId !== "") {
      writer.uint32(42).string(message.factureId);
    }
    if (message.tacheCreeeId !== "") {
      writer.uint32(50).string(message.tacheCreeeId);
    }
    if (message.resultat !== 0) {
      writer.uint32(56).int32(message.resultat);
    }
    if (message.messageErreur !== "") {
      writer.uint32(66).string(message.messageErreur);
    }
    if (message.metadata !== "") {
      writer.uint32(74).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHistoriqueRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHistoriqueRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.regleRelanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tacheCreeeId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.resultat = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.messageErreur = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetHistoriqueRelanceRequest(): GetHistoriqueRelanceRequest {
  return { id: "" };
}

export const GetHistoriqueRelanceRequest: MessageFns<GetHistoriqueRelanceRequest> = {
  encode(message: GetHistoriqueRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHistoriqueRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHistoriqueRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHistoriquesRelanceRequest(): ListHistoriquesRelanceRequest {
  return { organisationId: "" };
}

export const ListHistoriquesRelanceRequest: MessageFns<ListHistoriquesRelanceRequest> = {
  encode(message: ListHistoriquesRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.regleRelanceId !== undefined) {
      writer.uint32(18).string(message.regleRelanceId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(26).string(message.clientId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(42).string(message.factureId);
    }
    if (message.resultat !== undefined) {
      writer.uint32(48).int32(message.resultat);
    }
    if (message.dateFrom !== undefined) {
      writer.uint32(58).string(message.dateFrom);
    }
    if (message.dateTo !== undefined) {
      writer.uint32(66).string(message.dateTo);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHistoriquesRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHistoriquesRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.regleRelanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.resultat = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dateFrom = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dateTo = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListHistoriquesRelanceResponse(): ListHistoriquesRelanceResponse {
  return { historiques: [] };
}

export const ListHistoriquesRelanceResponse: MessageFns<ListHistoriquesRelanceResponse> = {
  encode(message: ListHistoriquesRelanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.historiques) {
      HistoriqueRelance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHistoriquesRelanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHistoriquesRelanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.historiques.push(HistoriqueRelance.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteHistoriqueRelanceRequest(): DeleteHistoriqueRelanceRequest {
  return { id: "" };
}

export const DeleteHistoriqueRelanceRequest: MessageFns<DeleteHistoriqueRelanceRequest> = {
  encode(message: DeleteHistoriqueRelanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHistoriqueRelanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHistoriqueRelanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteHistoriqueRelanceResponse(): DeleteHistoriqueRelanceResponse {
  return { success: false };
}

export const DeleteHistoriqueRelanceResponse: MessageFns<DeleteHistoriqueRelanceResponse> = {
  encode(message: DeleteHistoriqueRelanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHistoriqueRelanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHistoriqueRelanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExistsForTodayRequest(): ExistsForTodayRequest {
  return { regleRelanceId: "", clientId: "", contratId: "", factureId: "" };
}

export const ExistsForTodayRequest: MessageFns<ExistsForTodayRequest> = {
  encode(message: ExistsForTodayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regleRelanceId !== "") {
      writer.uint32(10).string(message.regleRelanceId);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(26).string(message.contratId);
    }
    if (message.factureId !== "") {
      writer.uint32(34).string(message.factureId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExistsForTodayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExistsForTodayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regleRelanceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExistsForTodayResponse(): ExistsForTodayResponse {
  return { exists: false };
}

export const ExistsForTodayResponse: MessageFns<ExistsForTodayResponse> = {
  encode(message: ExistsForTodayResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExistsForTodayResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExistsForTodayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExecuteRelancesRequest(): ExecuteRelancesRequest {
  return { organisationId: "" };
}

export const ExecuteRelancesRequest: MessageFns<ExecuteRelancesRequest> = {
  encode(message: ExecuteRelancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteRelancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRelancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExecuteRelancesResponse(): ExecuteRelancesResponse {
  return { success: false, message: "", relancesExecutees: 0, relancesEchouees: 0 };
}

export const ExecuteRelancesResponse: MessageFns<ExecuteRelancesResponse> = {
  encode(message: ExecuteRelancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.relancesExecutees !== 0) {
      writer.uint32(24).int32(message.relancesExecutees);
    }
    if (message.relancesEchouees !== 0) {
      writer.uint32(32).int32(message.relancesEchouees);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteRelancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRelancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.relancesExecutees = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.relancesEchouees = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExecuteRegleRequest(): ExecuteRegleRequest {
  return { regleId: "" };
}

export const ExecuteRegleRequest: MessageFns<ExecuteRegleRequest> = {
  encode(message: ExecuteRegleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regleId !== "") {
      writer.uint32(10).string(message.regleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteRegleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRegleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExecuteRegleResponse(): ExecuteRegleResponse {
  return { success: false, message: "", actionsCreees: 0 };
}

export const ExecuteRegleResponse: MessageFns<ExecuteRegleResponse> = {
  encode(message: ExecuteRegleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.actionsCreees !== 0) {
      writer.uint32(24).int32(message.actionsCreees);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteRegleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteRegleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.actionsCreees = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRelanceEventData(): RelanceEventData {
  return { organisationId: "", declencheur: 0, clientId: "", contratId: "", factureId: "", metadata: "" };
}

export const RelanceEventData: MessageFns<RelanceEventData> = {
  encode(message: RelanceEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.declencheur !== 0) {
      writer.uint32(16).int32(message.declencheur);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.contratId !== "") {
      writer.uint32(34).string(message.contratId);
    }
    if (message.factureId !== "") {
      writer.uint32(42).string(message.factureId);
    }
    if (message.metadata !== "") {
      writer.uint32(50).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelanceEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelanceEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.declencheur = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessEventRequest(): ProcessEventRequest {
  return {};
}

export const ProcessEventRequest: MessageFns<ProcessEventRequest> = {
  encode(message: ProcessEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      RelanceEventData.encode(message.event, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = RelanceEventData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessEventResponse(): ProcessEventResponse {
  return { success: false, message: "", actionsCreated: [] };
}

export const ProcessEventResponse: MessageFns<ProcessEventResponse> = {
  encode(message: ProcessEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.actionsCreated) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.actionsCreated.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatistiquesRequest(): GetStatistiquesRequest {
  return { organisationId: "", dateFrom: "", dateTo: "" };
}

export const GetStatistiquesRequest: MessageFns<GetStatistiquesRequest> = {
  encode(message: GetStatistiquesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.dateFrom !== "") {
      writer.uint32(18).string(message.dateFrom);
    }
    if (message.dateTo !== "") {
      writer.uint32(26).string(message.dateTo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatistiquesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatistiquesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dateFrom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dateTo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetStatistiquesResponse(): GetStatistiquesResponse {
  return { totalRelances: 0, relancesSucces: 0, relancesEchec: 0, relancesIgnore: 0, statsParDeclencheur: [] };
}

export const GetStatistiquesResponse: MessageFns<GetStatistiquesResponse> = {
  encode(message: GetStatistiquesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalRelances !== 0) {
      writer.uint32(8).int32(message.totalRelances);
    }
    if (message.relancesSucces !== 0) {
      writer.uint32(16).int32(message.relancesSucces);
    }
    if (message.relancesEchec !== 0) {
      writer.uint32(24).int32(message.relancesEchec);
    }
    if (message.relancesIgnore !== 0) {
      writer.uint32(32).int32(message.relancesIgnore);
    }
    for (const v of message.statsParDeclencheur) {
      StatParDeclencheur.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatistiquesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatistiquesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalRelances = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.relancesSucces = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.relancesEchec = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.relancesIgnore = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.statsParDeclencheur.push(StatParDeclencheur.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStatParDeclencheur(): StatParDeclencheur {
  return { declencheur: 0, count: 0, succes: 0, echec: 0 };
}

export const StatParDeclencheur: MessageFns<StatParDeclencheur> = {
  encode(message: StatParDeclencheur, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.declencheur !== 0) {
      writer.uint32(8).int32(message.declencheur);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.succes !== 0) {
      writer.uint32(24).int32(message.succes);
    }
    if (message.echec !== 0) {
      writer.uint32(32).int32(message.echec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatParDeclencheur {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatParDeclencheur();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.declencheur = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.succes = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.echec = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface RegleRelanceServiceClient {
  create(request: CreateRegleRelanceRequest, metadata?: Metadata): Observable<RegleRelance>;

  update(request: UpdateRegleRelanceRequest, metadata?: Metadata): Observable<RegleRelance>;

  get(request: GetRegleRelanceRequest, metadata?: Metadata): Observable<RegleRelance>;

  list(request: ListReglesRelanceRequest, metadata?: Metadata): Observable<ListReglesRelanceResponse>;

  delete(request: DeleteRegleRelanceRequest, metadata?: Metadata): Observable<DeleteRegleRelanceResponse>;

  activate(request: ActivateRegleRequest, metadata?: Metadata): Observable<RegleRelance>;

  deactivate(request: DeactivateRegleRequest, metadata?: Metadata): Observable<RegleRelance>;
}

export interface RegleRelanceServiceController {
  create(
    request: CreateRegleRelanceRequest,
    metadata?: Metadata,
  ): Promise<RegleRelance> | Observable<RegleRelance> | RegleRelance;

  update(
    request: UpdateRegleRelanceRequest,
    metadata?: Metadata,
  ): Promise<RegleRelance> | Observable<RegleRelance> | RegleRelance;

  get(
    request: GetRegleRelanceRequest,
    metadata?: Metadata,
  ): Promise<RegleRelance> | Observable<RegleRelance> | RegleRelance;

  list(
    request: ListReglesRelanceRequest,
    metadata?: Metadata,
  ): Promise<ListReglesRelanceResponse> | Observable<ListReglesRelanceResponse> | ListReglesRelanceResponse;

  delete(
    request: DeleteRegleRelanceRequest,
    metadata?: Metadata,
  ): Promise<DeleteRegleRelanceResponse> | Observable<DeleteRegleRelanceResponse> | DeleteRegleRelanceResponse;

  activate(
    request: ActivateRegleRequest,
    metadata?: Metadata,
  ): Promise<RegleRelance> | Observable<RegleRelance> | RegleRelance;

  deactivate(
    request: DeactivateRegleRequest,
    metadata?: Metadata,
  ): Promise<RegleRelance> | Observable<RegleRelance> | RegleRelance;
}

export function RegleRelanceServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "update", "get", "list", "delete", "activate", "deactivate"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("RegleRelanceService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("RegleRelanceService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const REGLE_RELANCE_SERVICE_NAME = "RegleRelanceService";

export type RegleRelanceServiceService = typeof RegleRelanceServiceService;
export const RegleRelanceServiceService = {
  create: {
    path: "/relance.RegleRelanceService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRegleRelanceRequest): Buffer =>
      Buffer.from(CreateRegleRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateRegleRelanceRequest => CreateRegleRelanceRequest.decode(value),
    responseSerialize: (value: RegleRelance): Buffer => Buffer.from(RegleRelance.encode(value).finish()),
    responseDeserialize: (value: Buffer): RegleRelance => RegleRelance.decode(value),
  },
  update: {
    path: "/relance.RegleRelanceService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateRegleRelanceRequest): Buffer =>
      Buffer.from(UpdateRegleRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateRegleRelanceRequest => UpdateRegleRelanceRequest.decode(value),
    responseSerialize: (value: RegleRelance): Buffer => Buffer.from(RegleRelance.encode(value).finish()),
    responseDeserialize: (value: Buffer): RegleRelance => RegleRelance.decode(value),
  },
  get: {
    path: "/relance.RegleRelanceService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRegleRelanceRequest): Buffer =>
      Buffer.from(GetRegleRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRegleRelanceRequest => GetRegleRelanceRequest.decode(value),
    responseSerialize: (value: RegleRelance): Buffer => Buffer.from(RegleRelance.encode(value).finish()),
    responseDeserialize: (value: Buffer): RegleRelance => RegleRelance.decode(value),
  },
  list: {
    path: "/relance.RegleRelanceService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListReglesRelanceRequest): Buffer =>
      Buffer.from(ListReglesRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListReglesRelanceRequest => ListReglesRelanceRequest.decode(value),
    responseSerialize: (value: ListReglesRelanceResponse): Buffer =>
      Buffer.from(ListReglesRelanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListReglesRelanceResponse => ListReglesRelanceResponse.decode(value),
  },
  delete: {
    path: "/relance.RegleRelanceService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRegleRelanceRequest): Buffer =>
      Buffer.from(DeleteRegleRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRegleRelanceRequest => DeleteRegleRelanceRequest.decode(value),
    responseSerialize: (value: DeleteRegleRelanceResponse): Buffer =>
      Buffer.from(DeleteRegleRelanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteRegleRelanceResponse => DeleteRegleRelanceResponse.decode(value),
  },
  activate: {
    path: "/relance.RegleRelanceService/Activate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateRegleRequest): Buffer => Buffer.from(ActivateRegleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ActivateRegleRequest => ActivateRegleRequest.decode(value),
    responseSerialize: (value: RegleRelance): Buffer => Buffer.from(RegleRelance.encode(value).finish()),
    responseDeserialize: (value: Buffer): RegleRelance => RegleRelance.decode(value),
  },
  deactivate: {
    path: "/relance.RegleRelanceService/Deactivate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeactivateRegleRequest): Buffer =>
      Buffer.from(DeactivateRegleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeactivateRegleRequest => DeactivateRegleRequest.decode(value),
    responseSerialize: (value: RegleRelance): Buffer => Buffer.from(RegleRelance.encode(value).finish()),
    responseDeserialize: (value: Buffer): RegleRelance => RegleRelance.decode(value),
  },
} as const;

export interface RegleRelanceServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateRegleRelanceRequest, RegleRelance>;
  update: handleUnaryCall<UpdateRegleRelanceRequest, RegleRelance>;
  get: handleUnaryCall<GetRegleRelanceRequest, RegleRelance>;
  list: handleUnaryCall<ListReglesRelanceRequest, ListReglesRelanceResponse>;
  delete: handleUnaryCall<DeleteRegleRelanceRequest, DeleteRegleRelanceResponse>;
  activate: handleUnaryCall<ActivateRegleRequest, RegleRelance>;
  deactivate: handleUnaryCall<DeactivateRegleRequest, RegleRelance>;
}

export interface HistoriqueRelanceServiceClient {
  create(request: CreateHistoriqueRelanceRequest, metadata?: Metadata): Observable<HistoriqueRelance>;

  get(request: GetHistoriqueRelanceRequest, metadata?: Metadata): Observable<HistoriqueRelance>;

  list(request: ListHistoriquesRelanceRequest, metadata?: Metadata): Observable<ListHistoriquesRelanceResponse>;

  delete(request: DeleteHistoriqueRelanceRequest, metadata?: Metadata): Observable<DeleteHistoriqueRelanceResponse>;

  existsForToday(request: ExistsForTodayRequest, metadata?: Metadata): Observable<ExistsForTodayResponse>;
}

export interface HistoriqueRelanceServiceController {
  create(
    request: CreateHistoriqueRelanceRequest,
    metadata?: Metadata,
  ): Promise<HistoriqueRelance> | Observable<HistoriqueRelance> | HistoriqueRelance;

  get(
    request: GetHistoriqueRelanceRequest,
    metadata?: Metadata,
  ): Promise<HistoriqueRelance> | Observable<HistoriqueRelance> | HistoriqueRelance;

  list(
    request: ListHistoriquesRelanceRequest,
    metadata?: Metadata,
  ):
    | Promise<ListHistoriquesRelanceResponse>
    | Observable<ListHistoriquesRelanceResponse>
    | ListHistoriquesRelanceResponse;

  delete(
    request: DeleteHistoriqueRelanceRequest,
    metadata?: Metadata,
  ):
    | Promise<DeleteHistoriqueRelanceResponse>
    | Observable<DeleteHistoriqueRelanceResponse>
    | DeleteHistoriqueRelanceResponse;

  existsForToday(
    request: ExistsForTodayRequest,
    metadata?: Metadata,
  ): Promise<ExistsForTodayResponse> | Observable<ExistsForTodayResponse> | ExistsForTodayResponse;
}

export function HistoriqueRelanceServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "get", "list", "delete", "existsForToday"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("HistoriqueRelanceService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("HistoriqueRelanceService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const HISTORIQUE_RELANCE_SERVICE_NAME = "HistoriqueRelanceService";

export type HistoriqueRelanceServiceService = typeof HistoriqueRelanceServiceService;
export const HistoriqueRelanceServiceService = {
  create: {
    path: "/relance.HistoriqueRelanceService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateHistoriqueRelanceRequest): Buffer =>
      Buffer.from(CreateHistoriqueRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateHistoriqueRelanceRequest => CreateHistoriqueRelanceRequest.decode(value),
    responseSerialize: (value: HistoriqueRelance): Buffer => Buffer.from(HistoriqueRelance.encode(value).finish()),
    responseDeserialize: (value: Buffer): HistoriqueRelance => HistoriqueRelance.decode(value),
  },
  get: {
    path: "/relance.HistoriqueRelanceService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHistoriqueRelanceRequest): Buffer =>
      Buffer.from(GetHistoriqueRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetHistoriqueRelanceRequest => GetHistoriqueRelanceRequest.decode(value),
    responseSerialize: (value: HistoriqueRelance): Buffer => Buffer.from(HistoriqueRelance.encode(value).finish()),
    responseDeserialize: (value: Buffer): HistoriqueRelance => HistoriqueRelance.decode(value),
  },
  list: {
    path: "/relance.HistoriqueRelanceService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListHistoriquesRelanceRequest): Buffer =>
      Buffer.from(ListHistoriquesRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListHistoriquesRelanceRequest => ListHistoriquesRelanceRequest.decode(value),
    responseSerialize: (value: ListHistoriquesRelanceResponse): Buffer =>
      Buffer.from(ListHistoriquesRelanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHistoriquesRelanceResponse =>
      ListHistoriquesRelanceResponse.decode(value),
  },
  delete: {
    path: "/relance.HistoriqueRelanceService/Delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteHistoriqueRelanceRequest): Buffer =>
      Buffer.from(DeleteHistoriqueRelanceRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteHistoriqueRelanceRequest => DeleteHistoriqueRelanceRequest.decode(value),
    responseSerialize: (value: DeleteHistoriqueRelanceResponse): Buffer =>
      Buffer.from(DeleteHistoriqueRelanceResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteHistoriqueRelanceResponse =>
      DeleteHistoriqueRelanceResponse.decode(value),
  },
  existsForToday: {
    path: "/relance.HistoriqueRelanceService/ExistsForToday",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExistsForTodayRequest): Buffer =>
      Buffer.from(ExistsForTodayRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExistsForTodayRequest => ExistsForTodayRequest.decode(value),
    responseSerialize: (value: ExistsForTodayResponse): Buffer =>
      Buffer.from(ExistsForTodayResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExistsForTodayResponse => ExistsForTodayResponse.decode(value),
  },
} as const;

export interface HistoriqueRelanceServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<CreateHistoriqueRelanceRequest, HistoriqueRelance>;
  get: handleUnaryCall<GetHistoriqueRelanceRequest, HistoriqueRelance>;
  list: handleUnaryCall<ListHistoriquesRelanceRequest, ListHistoriquesRelanceResponse>;
  delete: handleUnaryCall<DeleteHistoriqueRelanceRequest, DeleteHistoriqueRelanceResponse>;
  existsForToday: handleUnaryCall<ExistsForTodayRequest, ExistsForTodayResponse>;
}

export interface RelanceEngineServiceClient {
  executeRelances(request: ExecuteRelancesRequest, metadata?: Metadata): Observable<ExecuteRelancesResponse>;

  executeRegle(request: ExecuteRegleRequest, metadata?: Metadata): Observable<ExecuteRegleResponse>;

  processEvent(request: ProcessEventRequest, metadata?: Metadata): Observable<ProcessEventResponse>;

  getStatistiques(request: GetStatistiquesRequest, metadata?: Metadata): Observable<GetStatistiquesResponse>;
}

export interface RelanceEngineServiceController {
  executeRelances(
    request: ExecuteRelancesRequest,
    metadata?: Metadata,
  ): Promise<ExecuteRelancesResponse> | Observable<ExecuteRelancesResponse> | ExecuteRelancesResponse;

  executeRegle(
    request: ExecuteRegleRequest,
    metadata?: Metadata,
  ): Promise<ExecuteRegleResponse> | Observable<ExecuteRegleResponse> | ExecuteRegleResponse;

  processEvent(
    request: ProcessEventRequest,
    metadata?: Metadata,
  ): Promise<ProcessEventResponse> | Observable<ProcessEventResponse> | ProcessEventResponse;

  getStatistiques(
    request: GetStatistiquesRequest,
    metadata?: Metadata,
  ): Promise<GetStatistiquesResponse> | Observable<GetStatistiquesResponse> | GetStatistiquesResponse;
}

export function RelanceEngineServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["executeRelances", "executeRegle", "processEvent", "getStatistiques"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("RelanceEngineService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("RelanceEngineService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const RELANCE_ENGINE_SERVICE_NAME = "RelanceEngineService";

export type RelanceEngineServiceService = typeof RelanceEngineServiceService;
export const RelanceEngineServiceService = {
  executeRelances: {
    path: "/relance.RelanceEngineService/ExecuteRelances",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteRelancesRequest): Buffer =>
      Buffer.from(ExecuteRelancesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecuteRelancesRequest => ExecuteRelancesRequest.decode(value),
    responseSerialize: (value: ExecuteRelancesResponse): Buffer =>
      Buffer.from(ExecuteRelancesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecuteRelancesResponse => ExecuteRelancesResponse.decode(value),
  },
  executeRegle: {
    path: "/relance.RelanceEngineService/ExecuteRegle",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteRegleRequest): Buffer => Buffer.from(ExecuteRegleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecuteRegleRequest => ExecuteRegleRequest.decode(value),
    responseSerialize: (value: ExecuteRegleResponse): Buffer =>
      Buffer.from(ExecuteRegleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecuteRegleResponse => ExecuteRegleResponse.decode(value),
  },
  processEvent: {
    path: "/relance.RelanceEngineService/ProcessEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessEventRequest): Buffer => Buffer.from(ProcessEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessEventRequest => ProcessEventRequest.decode(value),
    responseSerialize: (value: ProcessEventResponse): Buffer =>
      Buffer.from(ProcessEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessEventResponse => ProcessEventResponse.decode(value),
  },
  getStatistiques: {
    path: "/relance.RelanceEngineService/GetStatistiques",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatistiquesRequest): Buffer =>
      Buffer.from(GetStatistiquesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetStatistiquesRequest => GetStatistiquesRequest.decode(value),
    responseSerialize: (value: GetStatistiquesResponse): Buffer =>
      Buffer.from(GetStatistiquesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetStatistiquesResponse => GetStatistiquesResponse.decode(value),
  },
} as const;

export interface RelanceEngineServiceServer extends UntypedServiceImplementation {
  executeRelances: handleUnaryCall<ExecuteRelancesRequest, ExecuteRelancesResponse>;
  executeRegle: handleUnaryCall<ExecuteRegleRequest, ExecuteRegleResponse>;
  processEvent: handleUnaryCall<ProcessEventRequest, ProcessEventResponse>;
  getStatistiques: handleUnaryCall<GetStatistiquesRequest, GetStatistiquesResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
