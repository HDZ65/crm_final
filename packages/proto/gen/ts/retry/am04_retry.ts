// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: retry/am04_retry.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp";

/** Rejection reason codes (SEPA return reason codes) */
export enum RejectionReasonCode {
  REJECTION_REASON_CODE_UNSPECIFIED = 0,
  /** AM04_ACCOUNT_CLOSED - AM04 - Account closed/invalid - RETRYABLE */
  AM04_ACCOUNT_CLOSED = 1,
  /** AC04_ACCOUNT_CLOSED - Other retryable codes */
  AC04_ACCOUNT_CLOSED = 2,
  /** AC06_ACCOUNT_BLOCKED - Account blocked */
  AC06_ACCOUNT_BLOCKED = 3,
  /** AG01_TRANSACTION_FORBIDDEN - Transaction forbidden */
  AG01_TRANSACTION_FORBIDDEN = 4,
  /** AG02_INVALID_FORMAT - Invalid bank operation code */
  AG02_INVALID_FORMAT = 5,
  /** BE04_MISSING_CREDITOR_ADDRESS - Missing creditor address */
  BE04_MISSING_CREDITOR_ADDRESS = 6,
  /** FF01_INVALID_FILE_FORMAT - Invalid file format */
  FF01_INVALID_FILE_FORMAT = 7,
  /** MD01_NO_MANDATE - No mandate */
  MD01_NO_MANDATE = 8,
  /** MD02_MISSING_MANDATORY_INFO - Missing mandatory infos */
  MD02_MISSING_MANDATORY_INFO = 9,
  /** MD06_REFUND_REQUEST - Refund request by end customer */
  MD06_REFUND_REQUEST = 10,
  /** MD07_END_CUSTOMER_DECEASED - End customer deceased */
  MD07_END_CUSTOMER_DECEASED = 11,
  /** MS02_NOT_SPECIFIED_REASON - Reason not specified by customer */
  MS02_NOT_SPECIFIED_REASON = 12,
  /** MS03_AGENT_REASON - Reason not specified by agent */
  MS03_AGENT_REASON = 13,
  /** RC01_INVALID_BIC - Bank identifier incorrect */
  RC01_INVALID_BIC = 14,
  /** RR01_MISSING_DEBTOR_ACCOUNT - Missing debtor account/ID */
  RR01_MISSING_DEBTOR_ACCOUNT = 15,
  /** RR02_MISSING_DEBTOR_NAME - Missing debtor name/address */
  RR02_MISSING_DEBTOR_NAME = 16,
  /** RR03_MISSING_CREDITOR_NAME - Missing creditor name/address */
  RR03_MISSING_CREDITOR_NAME = 17,
  /** RR04_REGULATORY_REASON - Regulatory reason */
  RR04_REGULATORY_REASON = 18,
  /** SL01_SPECIFIC_SERVICE_PROVIDER - Due to specific service offered */
  SL01_SPECIFIC_SERVICE_PROVIDER = 19,
  /** TM01_CUT_OFF_TIME - File received after cut-off time */
  TM01_CUT_OFF_TIME = 20,
  /** AC01_IBAN_INVALID - Non-retryable codes */
  AC01_IBAN_INVALID = 50,
  /** AC13_DEBTOR_ACCOUNT_TYPE - Invalid debtor account type - NOT RETRYABLE */
  AC13_DEBTOR_ACCOUNT_TYPE = 51,
  /** CNOR_CREDITOR_NOT_ON_WHITELIST - Creditor bank not registered - NOT RETRYABLE */
  CNOR_CREDITOR_NOT_ON_WHITELIST = 52,
  /** DNOR_DEBTOR_NOT_ON_WHITELIST - Debtor bank not registered - NOT RETRYABLE */
  DNOR_DEBTOR_NOT_ON_WHITELIST = 53,
  /** FF05_DUPLICATE_ENTRY - Duplicate - NOT RETRYABLE */
  FF05_DUPLICATE_ENTRY = 54,
  /** FOCR_FOLLOWING_CANCELLATION - Following cancellation request - NOT RETRYABLE */
  FOCR_FOLLOWING_CANCELLATION = 55,
}

/** Retry eligibility decision */
export enum RetryEligibility {
  RETRY_ELIGIBILITY_UNSPECIFIED = 0,
  /** ELIGIBLE - Can retry */
  ELIGIBLE = 1,
  /** NOT_ELIGIBLE_REASON_CODE - Reason code is non-retryable */
  NOT_ELIGIBLE_REASON_CODE = 2,
  /** NOT_ELIGIBLE_MAX_ATTEMPTS - Max attempts reached */
  NOT_ELIGIBLE_MAX_ATTEMPTS = 3,
  /** NOT_ELIGIBLE_PAYMENT_SETTLED - Payment already settled elsewhere */
  NOT_ELIGIBLE_PAYMENT_SETTLED = 4,
  /** NOT_ELIGIBLE_CONTRACT_CANCELLED - Contract cancelled */
  NOT_ELIGIBLE_CONTRACT_CANCELLED = 5,
  /** NOT_ELIGIBLE_MANDATE_REVOKED - Mandate revoked */
  NOT_ELIGIBLE_MANDATE_REVOKED = 6,
  /** NOT_ELIGIBLE_CLIENT_BLOCKED - Client blocked/blacklisted */
  NOT_ELIGIBLE_CLIENT_BLOCKED = 7,
  /** NOT_ELIGIBLE_MANUAL_CANCEL - Manually cancelled by admin */
  NOT_ELIGIBLE_MANUAL_CANCEL = 8,
}

/** Retry attempt status */
export enum RetryAttemptStatus {
  RETRY_ATTEMPT_STATUS_UNSPECIFIED = 0,
  /** SCHEDULED - Planned for future date */
  SCHEDULED = 1,
  /** IN_PROGRESS - Currently being processed */
  IN_PROGRESS = 2,
  /** SUBMITTED - Submitted to PSP, awaiting confirmation */
  SUBMITTED = 3,
  /** SUCCEEDED - Payment successful */
  SUCCEEDED = 4,
  /** FAILED - Payment failed (may trigger next retry) */
  FAILED = 5,
  /** CANCELLED - Manually cancelled */
  CANCELLED = 6,
  /** SKIPPED - Skipped due to condition (e.g., payment settled) */
  SKIPPED = 7,
}

/** Retry job status (scheduler batch) */
export enum RetryJobStatus {
  RETRY_JOB_STATUS_UNSPECIFIED = 0,
  /** JOB_PENDING - Waiting to be picked up */
  JOB_PENDING = 1,
  /** JOB_RUNNING - Currently executing */
  JOB_RUNNING = 2,
  /** JOB_COMPLETED - Finished successfully */
  JOB_COMPLETED = 3,
  /** JOB_FAILED - Failed with errors */
  JOB_FAILED = 4,
  /** JOB_PARTIAL - Completed with some failures */
  JOB_PARTIAL = 5,
}

/** Reminder channel */
export enum ReminderChannel {
  REMINDER_CHANNEL_UNSPECIFIED = 0,
  EMAIL = 1,
  SMS = 2,
  /** PHONE_CALL - Task for call center */
  PHONE_CALL = 3,
  PUSH_NOTIFICATION = 4,
  POSTAL_MAIL = 5,
}

/** Reminder status */
export enum ReminderStatus {
  REMINDER_STATUS_UNSPECIFIED = 0,
  /** REMINDER_PENDING - Queued for sending */
  REMINDER_PENDING = 1,
  /** REMINDER_SENT - Sent to provider */
  REMINDER_SENT = 2,
  /** REMINDER_DELIVERED - Confirmed delivered */
  REMINDER_DELIVERED = 3,
  /** REMINDER_FAILED - Delivery failed */
  REMINDER_FAILED = 4,
  /** REMINDER_CANCELLED - Cancelled before sending */
  REMINDER_CANCELLED = 5,
  /** REMINDER_BOUNCED - Bounced (email) */
  REMINDER_BOUNCED = 6,
  /** REMINDER_OPENED - Opened (email tracking) */
  REMINDER_OPENED = 7,
  /** REMINDER_CLICKED - Link clicked (email tracking) */
  REMINDER_CLICKED = 8,
}

/** Reminder trigger type */
export enum ReminderTrigger {
  REMINDER_TRIGGER_UNSPECIFIED = 0,
  /** ON_AM04_RECEIVED - When AM04 rejection received */
  ON_AM04_RECEIVED = 1,
  /** BEFORE_RETRY - X days before scheduled retry */
  BEFORE_RETRY = 2,
  /** AFTER_RETRY_FAILED - After a retry attempt failed */
  AFTER_RETRY_FAILED = 3,
  /** AFTER_ALL_RETRIES_EXHAUSTED - All retries failed */
  AFTER_ALL_RETRIES_EXHAUSTED = 4,
  /** MANUAL - Manually triggered by admin */
  MANUAL = 5,
}

/** Policy defining retry behavior for a given context */
export interface RetryPolicy {
  id: string;
  organisationId: string;
  /** Scope (optional, for policy inheritance) */
  societeId?:
    | string
    | undefined;
  /** If set, applies to this product */
  productId?:
    | string
    | undefined;
  /** If set, applies to this channel */
  channelId?:
    | string
    | undefined;
  /** Policy name and description */
  name: string;
  description: string;
  /** Retry schedule (days after rejection) */
  retryDelaysDays: number[];
  /** Limits */
  maxAttempts: number;
  /** Maximum days from first rejection (default: 30) */
  maxTotalDays: number;
  /** Conditions */
  retryOnAm04: boolean;
  /** Additional retryable codes */
  retryableCodes: RejectionReasonCode[];
  /** Explicit non-retryable codes */
  nonRetryableCodes: RejectionReasonCode[];
  /** Stop conditions */
  stopOnPaymentSettled: boolean;
  /** Stop if contract cancelled */
  stopOnContractCancelled: boolean;
  /** Stop if mandate revoked */
  stopOnMandateRevoked: boolean;
  /** Backoff strategy (for future extensibility) */
  backoffStrategy: string;
  /** Active status */
  isActive: boolean;
  /** Default policy for organisation */
  isDefault: boolean;
  /** Priority (higher = more specific) */
  priority: number;
  /** Audit */
  createdAt: string;
  updatedAt: string;
  createdBy: string;
  updatedBy: string;
}

/** A retry schedule for a specific rejected payment */
export interface RetrySchedule {
  id: string;
  organisationId: string;
  societeId: string;
  /** Source payment reference */
  originalPaymentId: string;
  /** Reference to payment schedule */
  scheduleId: string;
  /** Invoice if applicable */
  factureId?:
    | string
    | undefined;
  /** Contract if applicable */
  contratId?:
    | string
    | undefined;
  /** Client reference */
  clientId: string;
  /** Rejection info */
  rejectionCode: RejectionReasonCode;
  /** Raw code from PSP */
  rejectionRawCode: string;
  rejectionMessage: string;
  rejectionDate?:
    | Timestamp
    | undefined;
  /** Policy applied */
  retryPolicyId: string;
  /** Amount */
  amountCents: number;
  currency: string;
  /** Eligibility */
  eligibility: RetryEligibility;
  eligibilityReason: string;
  /** Current state */
  currentAttempt: number;
  maxAttempts: number;
  nextRetryDate?:
    | Timestamp
    | undefined;
  /** Final outcome */
  isResolved: boolean;
  /** Why it was resolved */
  resolutionReason?: string | undefined;
  resolvedAt?:
    | Timestamp
    | undefined;
  /** Idempotency */
  idempotencyKey: string;
  /** Audit */
  createdAt: string;
  updatedAt: string;
  metadata: { [key: string]: string };
}

export interface RetrySchedule_MetadataEntry {
  key: string;
  value: string;
}

/** Individual retry attempt */
export interface RetryAttempt {
  id: string;
  retryScheduleId: string;
  /** Attempt info */
  attemptNumber: number;
  plannedDate?: Timestamp | undefined;
  executedAt?:
    | Timestamp
    | undefined;
  /** Status */
  status: RetryAttemptStatus;
  /** Execution details */
  paymentIntentId?:
    | string
    | undefined;
  /** PSP payment reference */
  pspPaymentId?:
    | string
    | undefined;
  /** Raw PSP response (JSON) */
  pspResponse?:
    | string
    | undefined;
  /** Result */
  errorCode?: string | undefined;
  errorMessage?:
    | string
    | undefined;
  /** If failed with new code */
  newRejectionCode?:
    | RejectionReasonCode
    | undefined;
  /** Retry job reference */
  retryJobId?:
    | string
    | undefined;
  /** Idempotency */
  idempotencyKey: string;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

/** Batch job for scheduler execution */
export interface RetryJob {
  id: string;
  organisationId: string;
  /** Job parameters */
  targetDate?:
    | Timestamp
    | undefined;
  /** Timezone for cutoff (e.g., "Europe/Paris") */
  timezone: string;
  /** Cutoff time (e.g., "10:00:00") */
  cutoffTime: string;
  /** Execution */
  scheduledAt?: Timestamp | undefined;
  startedAt?: Timestamp | undefined;
  completedAt?:
    | Timestamp
    | undefined;
  /** Status */
  status: RetryJobStatus;
  /** Results */
  totalAttempts: number;
  successfulAttempts: number;
  failedAttempts: number;
  skippedAttempts: number;
  /** Error tracking */
  errorMessage?: string | undefined;
  failedScheduleIds: string[];
  /** Idempotency */
  idempotencyKey: string;
  /** Trigger */
  triggeredBy: string;
  isManual: boolean;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

/** Policy defining reminder behavior */
export interface ReminderPolicy {
  id: string;
  organisationId: string;
  /** Scope */
  societeId?:
    | string
    | undefined;
  /** Policy name */
  name: string;
  description: string;
  /** Trigger rules */
  triggerRules: ReminderTriggerRule[];
  /** Anti-spam / rate limiting */
  cooldownHours: number;
  /** Max reminders per day per client */
  maxRemindersPerDay: number;
  /** Max reminders per week per client */
  maxRemindersPerWeek: number;
  /** Time windows (hours in 24h format) */
  allowedStartHour: number;
  /** e.g., 19 (7:00 PM) */
  allowedEndHour: number;
  /** 0=Sunday, 1=Monday, ..., 6=Saturday */
  allowedDaysOfWeek: number[];
  /** Opt-out handling */
  respectOptOut: boolean;
  /** Active status */
  isActive: boolean;
  isDefault: boolean;
  priority: number;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

/** Trigger rule within a reminder policy */
export interface ReminderTriggerRule {
  id: string;
  trigger: ReminderTrigger;
  channel: ReminderChannel;
  /** Email/SMS template reference */
  templateId: string;
  /** Timing */
  delayHours: number;
  /** For BEFORE_RETRY trigger */
  daysBeforeRetry?:
    | number
    | undefined;
  /** Priority */
  order: number;
  /** Conditions */
  onlyIfNoResponse: boolean;
  /** Only on first AM04, not subsequent */
  onlyFirstRejection: boolean;
}

/** Individual reminder instance */
export interface Reminder {
  id: string;
  organisationId: string;
  societeId: string;
  /** References */
  retryScheduleId: string;
  /** If triggered by specific attempt */
  retryAttemptId?: string | undefined;
  clientId: string;
  /** Policy */
  reminderPolicyId: string;
  triggerRuleId: string;
  /** Channel and content */
  channel: ReminderChannel;
  templateId: string;
  templateVariables: { [key: string]: string };
  /** Trigger */
  trigger: ReminderTrigger;
  /** Scheduling */
  plannedAt?: Timestamp | undefined;
  sentAt?: Timestamp | undefined;
  deliveredAt?:
    | Timestamp
    | undefined;
  /** Status */
  status: ReminderStatus;
  /** Delivery details */
  providerName?:
    | string
    | undefined;
  /** Provider's tracking ID */
  providerMessageId?:
    | string
    | undefined;
  /** Raw status from provider */
  deliveryStatusRaw?:
    | string
    | undefined;
  /** Error handling */
  errorCode?: string | undefined;
  errorMessage?:
    | string
    | undefined;
  /** Delivery retry count */
  retryCount: number;
  /** Idempotency */
  idempotencyKey: string;
  /** Audit */
  createdAt: string;
  updatedAt: string;
}

export interface Reminder_TemplateVariablesEntry {
  key: string;
  value: string;
}

/** Append-only audit log for all retry/reminder actions */
export interface RetryAuditLog {
  id: string;
  organisationId: string;
  /** What changed */
  entityType: string;
  entityId: string;
  /** "CREATED", "UPDATED", "STATUS_CHANGED", etc. */
  action: string;
  /** Change details */
  oldValue?:
    | string
    | undefined;
  /** JSON of new state */
  newValue: string;
  /** Comma-separated field names */
  changedFields?:
    | string
    | undefined;
  /** Context */
  retryScheduleId?: string | undefined;
  retryAttemptId?: string | undefined;
  reminderId?: string | undefined;
  paymentId?:
    | string
    | undefined;
  /** Actor */
  actorType: string;
  /** User ID if applicable */
  actorId?: string | undefined;
  actorIp: string;
  /** Timestamp (immutable) */
  timestamp?:
    | Timestamp
    | undefined;
  /** Additional context */
  metadata: { [key: string]: string };
}

export interface RetryAuditLog_MetadataEntry {
  key: string;
  value: string;
}

/** Event: Payment rejected (input event) */
export interface PaymentRejectedEvent {
  eventId: string;
  organisationId: string;
  societeId: string;
  /** Payment info */
  paymentId: string;
  scheduleId: string;
  factureId?: string | undefined;
  contratId?: string | undefined;
  clientId: string;
  /** Rejection details */
  reasonCode: string;
  reasonMessage: string;
  /** Amount */
  amountCents: number;
  currency: string;
  /** PSP info */
  pspName: string;
  pspPaymentId?:
    | string
    | undefined;
  /** JSON */
  pspRawResponse?:
    | string
    | undefined;
  /** Timestamps */
  rejectedAt?: Timestamp | undefined;
  eventTimestamp?:
    | Timestamp
    | undefined;
  /** Idempotency */
  idempotencyKey: string;
}

/** Event: Retry scheduled */
export interface RetryScheduledEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  plannedDate?: Timestamp | undefined;
  clientId: string;
  amountCents: number;
  currency: string;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Retry executed */
export interface RetryExecutedEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  status: RetryAttemptStatus;
  paymentIntentId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  executedAt?: Timestamp | undefined;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Retry succeeded */
export interface RetrySucceededEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  paymentIntentId: string;
  amountCents: number;
  currency: string;
  succeededAt?: Timestamp | undefined;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Retry failed */
export interface RetryFailedEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId: string;
  attemptNumber: number;
  errorCode: string;
  errorMessage: string;
  newRejectionCode?: RejectionReasonCode | undefined;
  hasMoreAttempts: boolean;
  nextRetryDate?: Timestamp | undefined;
  failedAt?: Timestamp | undefined;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Retry cancelled */
export interface RetryCancelledEvent {
  eventId: string;
  retryScheduleId: string;
  retryAttemptId?: string | undefined;
  cancellationReason: string;
  /** User ID or "SYSTEM" */
  cancelledBy: string;
  cancelledAt?: Timestamp | undefined;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Reminder planned */
export interface ReminderPlannedEvent {
  eventId: string;
  reminderId: string;
  retryScheduleId: string;
  channel: ReminderChannel;
  trigger: ReminderTrigger;
  plannedAt?: Timestamp | undefined;
  clientId: string;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Reminder sent */
export interface ReminderSentEvent {
  eventId: string;
  reminderId: string;
  channel: ReminderChannel;
  providerName: string;
  providerMessageId?: string | undefined;
  sentAt?: Timestamp | undefined;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Reminder failed */
export interface ReminderFailedEvent {
  eventId: string;
  reminderId: string;
  channel: ReminderChannel;
  errorCode: string;
  errorMessage: string;
  retryCount: number;
  willRetry: boolean;
  failedAt?: Timestamp | undefined;
  eventTimestamp?: Timestamp | undefined;
}

/** Event: Reminder cancelled */
export interface ReminderCancelledEvent {
  eventId: string;
  reminderId: string;
  cancellationReason: string;
  cancelledBy: string;
  cancelledAt?: Timestamp | undefined;
  eventTimestamp?: Timestamp | undefined;
}

/** Typed error responses */
export interface RetryError {
  code: string;
  message: string;
  details: { [key: string]: string };
}

export interface RetryError_DetailsEntry {
  key: string;
  value: string;
}

function createBaseRetryPolicy(): RetryPolicy {
  return {
    id: "",
    organisationId: "",
    name: "",
    description: "",
    retryDelaysDays: [],
    maxAttempts: 0,
    maxTotalDays: 0,
    retryOnAm04: false,
    retryableCodes: [],
    nonRetryableCodes: [],
    stopOnPaymentSettled: false,
    stopOnContractCancelled: false,
    stopOnMandateRevoked: false,
    backoffStrategy: "",
    isActive: false,
    isDefault: false,
    priority: 0,
    createdAt: "",
    updatedAt: "",
    createdBy: "",
    updatedBy: "",
  };
}

export const RetryPolicy: MessageFns<RetryPolicy> = {
  encode(message: RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(26).string(message.societeId);
    }
    if (message.productId !== undefined) {
      writer.uint32(34).string(message.productId);
    }
    if (message.channelId !== undefined) {
      writer.uint32(42).string(message.channelId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    writer.uint32(66).fork();
    for (const v of message.retryDelaysDays) {
      writer.int32(v);
    }
    writer.join();
    if (message.maxAttempts !== 0) {
      writer.uint32(72).int32(message.maxAttempts);
    }
    if (message.maxTotalDays !== 0) {
      writer.uint32(80).int32(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== false) {
      writer.uint32(88).bool(message.retryOnAm04);
    }
    writer.uint32(98).fork();
    for (const v of message.retryableCodes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(106).fork();
    for (const v of message.nonRetryableCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.stopOnPaymentSettled !== false) {
      writer.uint32(112).bool(message.stopOnPaymentSettled);
    }
    if (message.stopOnContractCancelled !== false) {
      writer.uint32(120).bool(message.stopOnContractCancelled);
    }
    if (message.stopOnMandateRevoked !== false) {
      writer.uint32(128).bool(message.stopOnMandateRevoked);
    }
    if (message.backoffStrategy !== "") {
      writer.uint32(138).string(message.backoffStrategy);
    }
    if (message.isActive !== false) {
      writer.uint32(144).bool(message.isActive);
    }
    if (message.isDefault !== false) {
      writer.uint32(152).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(160).int32(message.priority);
    }
    if (message.createdAt !== "") {
      writer.uint32(170).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(178).string(message.updatedAt);
    }
    if (message.createdBy !== "") {
      writer.uint32(186).string(message.createdBy);
    }
    if (message.updatedBy !== "") {
      writer.uint32(194).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.retryDelaysDays.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryDelaysDays.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxTotalDays = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.retryOnAm04 = reader.bool();
          continue;
        }
        case 12: {
          if (tag === 96) {
            message.retryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 13: {
          if (tag === 104) {
            message.nonRetryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nonRetryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.stopOnPaymentSettled = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.stopOnContractCancelled = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.stopOnMandateRevoked = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.backoffStrategy = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetrySchedule(): RetrySchedule {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    originalPaymentId: "",
    scheduleId: "",
    clientId: "",
    rejectionCode: 0,
    rejectionRawCode: "",
    rejectionMessage: "",
    retryPolicyId: "",
    amountCents: 0,
    currency: "",
    eligibility: 0,
    eligibilityReason: "",
    currentAttempt: 0,
    maxAttempts: 0,
    isResolved: false,
    idempotencyKey: "",
    createdAt: "",
    updatedAt: "",
    metadata: {},
  };
}

export const RetrySchedule: MessageFns<RetrySchedule> = {
  encode(message: RetrySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.originalPaymentId !== "") {
      writer.uint32(34).string(message.originalPaymentId);
    }
    if (message.scheduleId !== "") {
      writer.uint32(42).string(message.scheduleId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(50).string(message.factureId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(58).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(66).string(message.clientId);
    }
    if (message.rejectionCode !== 0) {
      writer.uint32(72).int32(message.rejectionCode);
    }
    if (message.rejectionRawCode !== "") {
      writer.uint32(82).string(message.rejectionRawCode);
    }
    if (message.rejectionMessage !== "") {
      writer.uint32(90).string(message.rejectionMessage);
    }
    if (message.rejectionDate !== undefined) {
      Timestamp.encode(message.rejectionDate, writer.uint32(98).fork()).join();
    }
    if (message.retryPolicyId !== "") {
      writer.uint32(106).string(message.retryPolicyId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(112).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(122).string(message.currency);
    }
    if (message.eligibility !== 0) {
      writer.uint32(128).int32(message.eligibility);
    }
    if (message.eligibilityReason !== "") {
      writer.uint32(138).string(message.eligibilityReason);
    }
    if (message.currentAttempt !== 0) {
      writer.uint32(144).int32(message.currentAttempt);
    }
    if (message.maxAttempts !== 0) {
      writer.uint32(152).int32(message.maxAttempts);
    }
    if (message.nextRetryDate !== undefined) {
      Timestamp.encode(message.nextRetryDate, writer.uint32(162).fork()).join();
    }
    if (message.isResolved !== false) {
      writer.uint32(168).bool(message.isResolved);
    }
    if (message.resolutionReason !== undefined) {
      writer.uint32(178).string(message.resolutionReason);
    }
    if (message.resolvedAt !== undefined) {
      Timestamp.encode(message.resolvedAt, writer.uint32(186).fork()).join();
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(194).string(message.idempotencyKey);
    }
    if (message.createdAt !== "") {
      writer.uint32(202).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(210).string(message.updatedAt);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      RetrySchedule_MetadataEntry.encode({ key: key as any, value }, writer.uint32(218).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originalPaymentId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.rejectionCode = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.rejectionRawCode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.rejectionMessage = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.rejectionDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.retryPolicyId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.eligibilityReason = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.currentAttempt = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.nextRetryDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.isResolved = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.resolutionReason = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.resolvedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          const entry27 = RetrySchedule_MetadataEntry.decode(reader, reader.uint32());
          if (entry27.value !== undefined) {
            message.metadata[entry27.key] = entry27.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetrySchedule_MetadataEntry(): RetrySchedule_MetadataEntry {
  return { key: "", value: "" };
}

export const RetrySchedule_MetadataEntry: MessageFns<RetrySchedule_MetadataEntry> = {
  encode(message: RetrySchedule_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrySchedule_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrySchedule_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryAttempt(): RetryAttempt {
  return { id: "", retryScheduleId: "", attemptNumber: 0, status: 0, idempotencyKey: "", createdAt: "", updatedAt: "" };
}

export const RetryAttempt: MessageFns<RetryAttempt> = {
  encode(message: RetryAttempt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(24).int32(message.attemptNumber);
    }
    if (message.plannedDate !== undefined) {
      Timestamp.encode(message.plannedDate, writer.uint32(34).fork()).join();
    }
    if (message.executedAt !== undefined) {
      Timestamp.encode(message.executedAt, writer.uint32(42).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(58).string(message.paymentIntentId);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(66).string(message.pspPaymentId);
    }
    if (message.pspResponse !== undefined) {
      writer.uint32(74).string(message.pspResponse);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(82).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(90).string(message.errorMessage);
    }
    if (message.newRejectionCode !== undefined) {
      writer.uint32(96).int32(message.newRejectionCode);
    }
    if (message.retryJobId !== undefined) {
      writer.uint32(106).string(message.retryJobId);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(114).string(message.idempotencyKey);
    }
    if (message.createdAt !== "") {
      writer.uint32(122).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(130).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryAttempt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAttempt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.plannedDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.executedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pspResponse = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.newRejectionCode = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.retryJobId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryJob(): RetryJob {
  return {
    id: "",
    organisationId: "",
    timezone: "",
    cutoffTime: "",
    status: 0,
    totalAttempts: 0,
    successfulAttempts: 0,
    failedAttempts: 0,
    skippedAttempts: 0,
    failedScheduleIds: [],
    idempotencyKey: "",
    triggeredBy: "",
    isManual: false,
    createdAt: "",
    updatedAt: "",
  };
}

export const RetryJob: MessageFns<RetryJob> = {
  encode(message: RetryJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.targetDate !== undefined) {
      Timestamp.encode(message.targetDate, writer.uint32(26).fork()).join();
    }
    if (message.timezone !== "") {
      writer.uint32(34).string(message.timezone);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(42).string(message.cutoffTime);
    }
    if (message.scheduledAt !== undefined) {
      Timestamp.encode(message.scheduledAt, writer.uint32(50).fork()).join();
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(message.startedAt, writer.uint32(58).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(message.completedAt, writer.uint32(66).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    if (message.totalAttempts !== 0) {
      writer.uint32(80).int32(message.totalAttempts);
    }
    if (message.successfulAttempts !== 0) {
      writer.uint32(88).int32(message.successfulAttempts);
    }
    if (message.failedAttempts !== 0) {
      writer.uint32(96).int32(message.failedAttempts);
    }
    if (message.skippedAttempts !== 0) {
      writer.uint32(104).int32(message.skippedAttempts);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(114).string(message.errorMessage);
    }
    for (const v of message.failedScheduleIds) {
      writer.uint32(122).string(v!);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(130).string(message.idempotencyKey);
    }
    if (message.triggeredBy !== "") {
      writer.uint32(138).string(message.triggeredBy);
    }
    if (message.isManual !== false) {
      writer.uint32(144).bool(message.isManual);
    }
    if (message.createdAt !== "") {
      writer.uint32(154).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(162).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scheduledAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.startedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.completedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.totalAttempts = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.successfulAttempts = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.failedAttempts = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.skippedAttempts = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.failedScheduleIds.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.triggeredBy = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.isManual = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderPolicy(): ReminderPolicy {
  return {
    id: "",
    organisationId: "",
    name: "",
    description: "",
    triggerRules: [],
    cooldownHours: 0,
    maxRemindersPerDay: 0,
    maxRemindersPerWeek: 0,
    allowedStartHour: 0,
    allowedEndHour: 0,
    allowedDaysOfWeek: [],
    respectOptOut: false,
    isActive: false,
    isDefault: false,
    priority: 0,
    createdAt: "",
    updatedAt: "",
  };
}

export const ReminderPolicy: MessageFns<ReminderPolicy> = {
  encode(message: ReminderPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(26).string(message.societeId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.triggerRules) {
      ReminderTriggerRule.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.cooldownHours !== 0) {
      writer.uint32(56).int32(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== 0) {
      writer.uint32(64).int32(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== 0) {
      writer.uint32(72).int32(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== 0) {
      writer.uint32(80).int32(message.allowedStartHour);
    }
    if (message.allowedEndHour !== 0) {
      writer.uint32(88).int32(message.allowedEndHour);
    }
    writer.uint32(98).fork();
    for (const v of message.allowedDaysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    if (message.respectOptOut !== false) {
      writer.uint32(104).bool(message.respectOptOut);
    }
    if (message.isActive !== false) {
      writer.uint32(112).bool(message.isActive);
    }
    if (message.isDefault !== false) {
      writer.uint32(120).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(128).int32(message.priority);
    }
    if (message.createdAt !== "") {
      writer.uint32(138).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(146).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.triggerRules.push(ReminderTriggerRule.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cooldownHours = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxRemindersPerDay = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxRemindersPerWeek = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowedStartHour = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.allowedEndHour = reader.int32();
          continue;
        }
        case 12: {
          if (tag === 96) {
            message.allowedDaysOfWeek.push(reader.int32());

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedDaysOfWeek.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.respectOptOut = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderTriggerRule(): ReminderTriggerRule {
  return {
    id: "",
    trigger: 0,
    channel: 0,
    templateId: "",
    delayHours: 0,
    order: 0,
    onlyIfNoResponse: false,
    onlyFirstRejection: false,
  };
}

export const ReminderTriggerRule: MessageFns<ReminderTriggerRule> = {
  encode(message: ReminderTriggerRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.trigger !== 0) {
      writer.uint32(16).int32(message.trigger);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.templateId !== "") {
      writer.uint32(34).string(message.templateId);
    }
    if (message.delayHours !== 0) {
      writer.uint32(40).int32(message.delayHours);
    }
    if (message.daysBeforeRetry !== undefined) {
      writer.uint32(48).int32(message.daysBeforeRetry);
    }
    if (message.order !== 0) {
      writer.uint32(56).int32(message.order);
    }
    if (message.onlyIfNoResponse !== false) {
      writer.uint32(64).bool(message.onlyIfNoResponse);
    }
    if (message.onlyFirstRejection !== false) {
      writer.uint32(72).bool(message.onlyFirstRejection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderTriggerRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderTriggerRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trigger = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.templateId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.delayHours = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.daysBeforeRetry = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.onlyIfNoResponse = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.onlyFirstRejection = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminder(): Reminder {
  return {
    id: "",
    organisationId: "",
    societeId: "",
    retryScheduleId: "",
    clientId: "",
    reminderPolicyId: "",
    triggerRuleId: "",
    channel: 0,
    templateId: "",
    templateVariables: {},
    trigger: 0,
    status: 0,
    retryCount: 0,
    idempotencyKey: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Reminder: MessageFns<Reminder> = {
  encode(message: Reminder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(34).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== undefined) {
      writer.uint32(42).string(message.retryAttemptId);
    }
    if (message.clientId !== "") {
      writer.uint32(50).string(message.clientId);
    }
    if (message.reminderPolicyId !== "") {
      writer.uint32(58).string(message.reminderPolicyId);
    }
    if (message.triggerRuleId !== "") {
      writer.uint32(66).string(message.triggerRuleId);
    }
    if (message.channel !== 0) {
      writer.uint32(72).int32(message.channel);
    }
    if (message.templateId !== "") {
      writer.uint32(82).string(message.templateId);
    }
    globalThis.Object.entries(message.templateVariables).forEach(([key, value]: [string, string]) => {
      Reminder_TemplateVariablesEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.trigger !== 0) {
      writer.uint32(96).int32(message.trigger);
    }
    if (message.plannedAt !== undefined) {
      Timestamp.encode(message.plannedAt, writer.uint32(106).fork()).join();
    }
    if (message.sentAt !== undefined) {
      Timestamp.encode(message.sentAt, writer.uint32(114).fork()).join();
    }
    if (message.deliveredAt !== undefined) {
      Timestamp.encode(message.deliveredAt, writer.uint32(122).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(128).int32(message.status);
    }
    if (message.providerName !== undefined) {
      writer.uint32(138).string(message.providerName);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(146).string(message.providerMessageId);
    }
    if (message.deliveryStatusRaw !== undefined) {
      writer.uint32(154).string(message.deliveryStatusRaw);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(162).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(170).string(message.errorMessage);
    }
    if (message.retryCount !== 0) {
      writer.uint32(176).int32(message.retryCount);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(186).string(message.idempotencyKey);
    }
    if (message.createdAt !== "") {
      writer.uint32(194).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(202).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reminder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reminderPolicyId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.triggerRuleId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.templateId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = Reminder_TemplateVariablesEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.templateVariables[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.trigger = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.plannedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.sentAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.deliveredAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.providerName = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.deliveryStatusRaw = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminder_TemplateVariablesEntry(): Reminder_TemplateVariablesEntry {
  return { key: "", value: "" };
}

export const Reminder_TemplateVariablesEntry: MessageFns<Reminder_TemplateVariablesEntry> = {
  encode(message: Reminder_TemplateVariablesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reminder_TemplateVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminder_TemplateVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryAuditLog(): RetryAuditLog {
  return {
    id: "",
    organisationId: "",
    entityType: "",
    entityId: "",
    action: "",
    newValue: "",
    actorType: "",
    actorIp: "",
    metadata: {},
  };
}

export const RetryAuditLog: MessageFns<RetryAuditLog> = {
  encode(message: RetryAuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.entityId !== "") {
      writer.uint32(34).string(message.entityId);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.oldValue !== undefined) {
      writer.uint32(50).string(message.oldValue);
    }
    if (message.newValue !== "") {
      writer.uint32(58).string(message.newValue);
    }
    if (message.changedFields !== undefined) {
      writer.uint32(66).string(message.changedFields);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(74).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== undefined) {
      writer.uint32(82).string(message.retryAttemptId);
    }
    if (message.reminderId !== undefined) {
      writer.uint32(90).string(message.reminderId);
    }
    if (message.paymentId !== undefined) {
      writer.uint32(98).string(message.paymentId);
    }
    if (message.actorType !== "") {
      writer.uint32(106).string(message.actorType);
    }
    if (message.actorId !== undefined) {
      writer.uint32(114).string(message.actorId);
    }
    if (message.actorIp !== "") {
      writer.uint32(122).string(message.actorIp);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(message.timestamp, writer.uint32(130).fork()).join();
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      RetryAuditLog_MetadataEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryAuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oldValue = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.newValue = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.changedFields = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.actorType = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.actorId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.actorIp = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.timestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          const entry17 = RetryAuditLog_MetadataEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.metadata[entry17.key] = entry17.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryAuditLog_MetadataEntry(): RetryAuditLog_MetadataEntry {
  return { key: "", value: "" };
}

export const RetryAuditLog_MetadataEntry: MessageFns<RetryAuditLog_MetadataEntry> = {
  encode(message: RetryAuditLog_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryAuditLog_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAuditLog_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaymentRejectedEvent(): PaymentRejectedEvent {
  return {
    eventId: "",
    organisationId: "",
    societeId: "",
    paymentId: "",
    scheduleId: "",
    clientId: "",
    reasonCode: "",
    reasonMessage: "",
    amountCents: 0,
    currency: "",
    pspName: "",
    idempotencyKey: "",
  };
}

export const PaymentRejectedEvent: MessageFns<PaymentRejectedEvent> = {
  encode(message: PaymentRejectedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.societeId !== "") {
      writer.uint32(26).string(message.societeId);
    }
    if (message.paymentId !== "") {
      writer.uint32(34).string(message.paymentId);
    }
    if (message.scheduleId !== "") {
      writer.uint32(42).string(message.scheduleId);
    }
    if (message.factureId !== undefined) {
      writer.uint32(50).string(message.factureId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(58).string(message.contratId);
    }
    if (message.clientId !== "") {
      writer.uint32(66).string(message.clientId);
    }
    if (message.reasonCode !== "") {
      writer.uint32(74).string(message.reasonCode);
    }
    if (message.reasonMessage !== "") {
      writer.uint32(82).string(message.reasonMessage);
    }
    if (message.amountCents !== 0) {
      writer.uint32(88).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(98).string(message.currency);
    }
    if (message.pspName !== "") {
      writer.uint32(106).string(message.pspName);
    }
    if (message.pspPaymentId !== undefined) {
      writer.uint32(114).string(message.pspPaymentId);
    }
    if (message.pspRawResponse !== undefined) {
      writer.uint32(122).string(message.pspRawResponse);
    }
    if (message.rejectedAt !== undefined) {
      Timestamp.encode(message.rejectedAt, writer.uint32(130).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(138).fork()).join();
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(146).string(message.idempotencyKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentRejectedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentRejectedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheduleId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.factureId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.reasonCode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.reasonMessage = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.pspName = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.pspPaymentId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pspRawResponse = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.rejectedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryScheduledEvent(): RetryScheduledEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: "",
    attemptNumber: 0,
    clientId: "",
    amountCents: 0,
    currency: "",
  };
}

export const RetryScheduledEvent: MessageFns<RetryScheduledEvent> = {
  encode(message: RetryScheduledEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.plannedDate !== undefined) {
      Timestamp.encode(message.plannedDate, writer.uint32(42).fork()).join();
    }
    if (message.clientId !== "") {
      writer.uint32(50).string(message.clientId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(56).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(66).string(message.currency);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryScheduledEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryScheduledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.plannedDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryExecutedEvent(): RetryExecutedEvent {
  return { eventId: "", retryScheduleId: "", retryAttemptId: "", attemptNumber: 0, status: 0 };
}

export const RetryExecutedEvent: MessageFns<RetryExecutedEvent> = {
  encode(message: RetryExecutedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.paymentIntentId !== undefined) {
      writer.uint32(50).string(message.paymentIntentId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(58).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(66).string(message.errorMessage);
    }
    if (message.executedAt !== undefined) {
      Timestamp.encode(message.executedAt, writer.uint32(74).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryExecutedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryExecutedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.executedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetrySucceededEvent(): RetrySucceededEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: "",
    attemptNumber: 0,
    paymentIntentId: "",
    amountCents: 0,
    currency: "",
  };
}

export const RetrySucceededEvent: MessageFns<RetrySucceededEvent> = {
  encode(message: RetrySucceededEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.paymentIntentId !== "") {
      writer.uint32(42).string(message.paymentIntentId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(48).int64(message.amountCents);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.succeededAt !== undefined) {
      Timestamp.encode(message.succeededAt, writer.uint32(66).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrySucceededEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrySucceededEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.paymentIntentId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.amountCents = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.succeededAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryFailedEvent(): RetryFailedEvent {
  return {
    eventId: "",
    retryScheduleId: "",
    retryAttemptId: "",
    attemptNumber: 0,
    errorCode: "",
    errorMessage: "",
    hasMoreAttempts: false,
  };
}

export const RetryFailedEvent: MessageFns<RetryFailedEvent> = {
  encode(message: RetryFailedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.attemptNumber !== 0) {
      writer.uint32(32).int32(message.attemptNumber);
    }
    if (message.errorCode !== "") {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(50).string(message.errorMessage);
    }
    if (message.newRejectionCode !== undefined) {
      writer.uint32(56).int32(message.newRejectionCode);
    }
    if (message.hasMoreAttempts !== false) {
      writer.uint32(64).bool(message.hasMoreAttempts);
    }
    if (message.nextRetryDate !== undefined) {
      Timestamp.encode(message.nextRetryDate, writer.uint32(74).fork()).join();
    }
    if (message.failedAt !== undefined) {
      Timestamp.encode(message.failedAt, writer.uint32(82).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryFailedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryFailedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attemptNumber = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.newRejectionCode = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.hasMoreAttempts = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.nextRetryDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.failedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryCancelledEvent(): RetryCancelledEvent {
  return { eventId: "", retryScheduleId: "", cancellationReason: "", cancelledBy: "" };
}

export const RetryCancelledEvent: MessageFns<RetryCancelledEvent> = {
  encode(message: RetryCancelledEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== undefined) {
      writer.uint32(26).string(message.retryAttemptId);
    }
    if (message.cancellationReason !== "") {
      writer.uint32(34).string(message.cancellationReason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(42).string(message.cancelledBy);
    }
    if (message.cancelledAt !== undefined) {
      Timestamp.encode(message.cancelledAt, writer.uint32(50).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryCancelledEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryCancelledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cancellationReason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cancelledAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderPlannedEvent(): ReminderPlannedEvent {
  return { eventId: "", reminderId: "", retryScheduleId: "", channel: 0, trigger: 0, clientId: "" };
}

export const ReminderPlannedEvent: MessageFns<ReminderPlannedEvent> = {
  encode(message: ReminderPlannedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.retryScheduleId !== "") {
      writer.uint32(26).string(message.retryScheduleId);
    }
    if (message.channel !== 0) {
      writer.uint32(32).int32(message.channel);
    }
    if (message.trigger !== 0) {
      writer.uint32(40).int32(message.trigger);
    }
    if (message.plannedAt !== undefined) {
      Timestamp.encode(message.plannedAt, writer.uint32(50).fork()).join();
    }
    if (message.clientId !== "") {
      writer.uint32(58).string(message.clientId);
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderPlannedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderPlannedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.trigger = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.plannedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderSentEvent(): ReminderSentEvent {
  return { eventId: "", reminderId: "", channel: 0, providerName: "" };
}

export const ReminderSentEvent: MessageFns<ReminderSentEvent> = {
  encode(message: ReminderSentEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.providerName !== "") {
      writer.uint32(34).string(message.providerName);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(42).string(message.providerMessageId);
    }
    if (message.sentAt !== undefined) {
      Timestamp.encode(message.sentAt, writer.uint32(50).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderSentEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderSentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sentAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderFailedEvent(): ReminderFailedEvent {
  return { eventId: "", reminderId: "", channel: 0, errorCode: "", errorMessage: "", retryCount: 0, willRetry: false };
}

export const ReminderFailedEvent: MessageFns<ReminderFailedEvent> = {
  encode(message: ReminderFailedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.errorCode !== "") {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    if (message.retryCount !== 0) {
      writer.uint32(48).int32(message.retryCount);
    }
    if (message.willRetry !== false) {
      writer.uint32(56).bool(message.willRetry);
    }
    if (message.failedAt !== undefined) {
      Timestamp.encode(message.failedAt, writer.uint32(66).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderFailedEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderFailedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.willRetry = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.failedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderCancelledEvent(): ReminderCancelledEvent {
  return { eventId: "", reminderId: "", cancellationReason: "", cancelledBy: "" };
}

export const ReminderCancelledEvent: MessageFns<ReminderCancelledEvent> = {
  encode(message: ReminderCancelledEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.reminderId !== "") {
      writer.uint32(18).string(message.reminderId);
    }
    if (message.cancellationReason !== "") {
      writer.uint32(26).string(message.cancellationReason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(34).string(message.cancelledBy);
    }
    if (message.cancelledAt !== undefined) {
      Timestamp.encode(message.cancelledAt, writer.uint32(42).fork()).join();
    }
    if (message.eventTimestamp !== undefined) {
      Timestamp.encode(message.eventTimestamp, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderCancelledEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderCancelledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cancellationReason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cancelledAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.eventTimestamp = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryError(): RetryError {
  return { code: "", message: "", details: {} };
}

export const RetryError: MessageFns<RetryError> = {
  encode(message: RetryError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    globalThis.Object.entries(message.details).forEach(([key, value]: [string, string]) => {
      RetryError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = RetryError_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryError_DetailsEntry(): RetryError_DetailsEntry {
  return { key: "", value: "" };
}

export const RetryError_DetailsEntry: MessageFns<RetryError_DetailsEntry> = {
  encode(message: RetryError_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryError_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
