// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: retry/am04_retry_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "../google/protobuf/timestamp";
import {
  PaymentRejectedEvent,
  RejectionReasonCode,
  Reminder,
  ReminderChannel,
  ReminderPolicy,
  ReminderStatus,
  ReminderTriggerRule,
  RetryAttempt,
  RetryAuditLog,
  RetryEligibility,
  RetryJob,
  RetryJobStatus,
  RetryPolicy,
  RetrySchedule,
} from "./am04_retry";

export interface DeleteResponse {
  success: boolean;
  message: string;
}

export interface PaginationRequest {
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
}

export interface PaginationResponse {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface GetRetryPolicyRequest {
  id: string;
}

export interface RetryPolicyResponse {
  policy?: RetryPolicy | undefined;
}

export interface ListRetryPoliciesRequest {
  organisationId: string;
  societeId?: string | undefined;
  activeOnly?: boolean | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListRetryPoliciesResponse {
  policies: RetryPolicy[];
  pagination?: PaginationResponse | undefined;
}

export interface CreateRetryPolicyRequest {
  organisationId: string;
  societeId?: string | undefined;
  productId?: string | undefined;
  channelId?: string | undefined;
  name: string;
  description: string;
  retryDelaysDays: number[];
  maxAttempts: number;
  maxTotalDays: number;
  retryOnAm04: boolean;
  retryableCodes: RejectionReasonCode[];
  nonRetryableCodes: RejectionReasonCode[];
  stopOnPaymentSettled: boolean;
  stopOnContractCancelled: boolean;
  stopOnMandateRevoked: boolean;
  backoffStrategy: string;
  isDefault: boolean;
  priority: number;
}

export interface UpdateRetryPolicyRequest {
  id: string;
  name?: string | undefined;
  description?: string | undefined;
  retryDelaysDays: number[];
  maxAttempts?: number | undefined;
  maxTotalDays?: number | undefined;
  retryOnAm04?: boolean | undefined;
  retryableCodes: RejectionReasonCode[];
  nonRetryableCodes: RejectionReasonCode[];
  stopOnPaymentSettled?: boolean | undefined;
  stopOnContractCancelled?: boolean | undefined;
  stopOnMandateRevoked?: boolean | undefined;
  backoffStrategy?: string | undefined;
  isActive?: boolean | undefined;
  isDefault?: boolean | undefined;
  priority?: number | undefined;
}

export interface DeleteRetryPolicyRequest {
  id: string;
}

export interface GetRetryScheduleRequest {
  id: string;
}

export interface RetryScheduleResponse {
  schedule?: RetrySchedule | undefined;
  attempts: RetryAttempt[];
  reminders: Reminder[];
}

export interface ListRetrySchedulesRequest {
  organisationId: string;
  societeId?: string | undefined;
  clientId?: string | undefined;
  contratId?: string | undefined;
  eligibility?: RetryEligibility | undefined;
  isResolved?: boolean | undefined;
  fromDate?: Timestamp | undefined;
  toDate?: Timestamp | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListRetrySchedulesResponse {
  schedules: RetrySchedule[];
  pagination?: PaginationResponse | undefined;
}

export interface CancelRetryScheduleRequest {
  id: string;
  reason: string;
  cancelledBy: string;
}

export interface ReplanRetryScheduleRequest {
  id: string;
  newRetryDate?: Timestamp | undefined;
  reason: string;
  replannedBy: string;
}

export interface GetRetryAttemptRequest {
  id: string;
}

export interface RetryAttemptResponse {
  attempt?: RetryAttempt | undefined;
}

export interface ListRetryAttemptsRequest {
  retryScheduleId: string;
  pagination?: PaginationRequest | undefined;
}

export interface ListRetryAttemptsResponse {
  attempts: RetryAttempt[];
  pagination?: PaginationResponse | undefined;
}

export interface RunNowRequest {
  organisationId: string;
  retryScheduleId?: string | undefined;
  triggeredBy: string;
  dryRun: boolean;
}

export interface RunNowResponse {
  jobId: string;
  status: RetryJobStatus;
  message: string;
  scheduledCount: number;
}

export interface GetRetryJobStatusRequest {
  jobId: string;
}

export interface RetryJobResponse {
  job?: RetryJob | undefined;
}

export interface ListRetryJobsRequest {
  organisationId: string;
  status?: RetryJobStatus | undefined;
  fromDate?: Timestamp | undefined;
  toDate?: Timestamp | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListRetryJobsResponse {
  jobs: RetryJob[];
  pagination?: PaginationResponse | undefined;
}

export interface GetRetryMetricsRequest {
  organisationId: string;
  societeId?: string | undefined;
  fromDate?: Timestamp | undefined;
  toDate?: Timestamp | undefined;
}

export interface RetryMetricsResponse {
  totalRejections: number;
  am04Rejections: number;
  otherRejections: number;
  totalRetrySchedules: number;
  eligibleForRetry: number;
  notEligible: number;
  totalRetryAttempts: number;
  successfulRetries: number;
  failedRetries: number;
  pendingRetries: number;
  successRate: number;
  am04Rate: number;
  totalAmountRecoveredCents: number;
  totalAmountPendingCents: number;
  rejectionCodeBreakdown: RejectionCodeMetric[];
  dailyMetrics: DailyRetryMetric[];
}

export interface RejectionCodeMetric {
  code: RejectionReasonCode;
  codeRaw: string;
  count: number;
  percentage: number;
}

export interface DailyRetryMetric {
  date: string;
  rejections: number;
  retriesScheduled: number;
  retriesExecuted: number;
  retriesSucceeded: number;
  retriesFailed: number;
}

export interface GetAuditLogsRequest {
  organisationId: string;
  entityType?: string | undefined;
  entityId?: string | undefined;
  action?: string | undefined;
  fromDate?: Timestamp | undefined;
  toDate?: Timestamp | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface AuditLogsResponse {
  logs: RetryAuditLog[];
  pagination?: PaginationResponse | undefined;
}

export interface ProcessDueRetriesRequest {
  organisationId: string;
  targetDate?: Timestamp | undefined;
  timezone: string;
  cutoffTime: string;
  dryRun: boolean;
}

export interface ProcessDueRetriesResponse {
  jobId: string;
  status: RetryJobStatus;
  totalProcessed: number;
  successful: number;
  failed: number;
  skipped: number;
  results: ProcessedRetryResult[];
}

export interface ProcessedRetryResult {
  retryScheduleId: string;
  retryAttemptId: string;
  success: boolean;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface CheckEligibilityRequest {
  paymentId: string;
  rejectionCode: string;
  organisationId: string;
  societeId?: string | undefined;
  contratId?: string | undefined;
  clientId?: string | undefined;
}

export interface CheckEligibilityResponse {
  eligibility: RetryEligibility;
  reason: string;
  applicablePolicyId?: string | undefined;
  firstRetryDate?: Timestamp | undefined;
}

export interface HandleRejectionResponse {
  processed: boolean;
  retryScheduleId?: string | undefined;
  eligibility: RetryEligibility;
  message: string;
  reminderIds: string[];
}

export interface GetReminderPolicyRequest {
  id: string;
}

export interface ReminderPolicyResponse {
  policy?: ReminderPolicy | undefined;
}

export interface ListReminderPoliciesRequest {
  organisationId: string;
  societeId?: string | undefined;
  activeOnly?: boolean | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListReminderPoliciesResponse {
  policies: ReminderPolicy[];
  pagination?: PaginationResponse | undefined;
}

export interface CreateReminderPolicyRequest {
  organisationId: string;
  societeId?: string | undefined;
  name: string;
  description: string;
  triggerRules: ReminderTriggerRule[];
  cooldownHours: number;
  maxRemindersPerDay: number;
  maxRemindersPerWeek: number;
  allowedStartHour: number;
  allowedEndHour: number;
  allowedDaysOfWeek: number[];
  respectOptOut: boolean;
  isDefault: boolean;
  priority: number;
}

export interface UpdateReminderPolicyRequest {
  id: string;
  name?: string | undefined;
  description?: string | undefined;
  triggerRules: ReminderTriggerRule[];
  cooldownHours?: number | undefined;
  maxRemindersPerDay?: number | undefined;
  maxRemindersPerWeek?: number | undefined;
  allowedStartHour?: number | undefined;
  allowedEndHour?: number | undefined;
  allowedDaysOfWeek: number[];
  respectOptOut?: boolean | undefined;
  isActive?: boolean | undefined;
  isDefault?: boolean | undefined;
  priority?: number | undefined;
}

export interface DeleteReminderPolicyRequest {
  id: string;
}

export interface GetReminderRequest {
  id: string;
}

export interface ReminderResponse {
  reminder?: Reminder | undefined;
}

export interface ListRemindersRequest {
  organisationId: string;
  retryScheduleId?: string | undefined;
  clientId?: string | undefined;
  channel?: ReminderChannel | undefined;
  status?: ReminderStatus | undefined;
  fromDate?: Timestamp | undefined;
  toDate?: Timestamp | undefined;
  pagination?: PaginationRequest | undefined;
}

export interface ListRemindersResponse {
  reminders: Reminder[];
  pagination?: PaginationResponse | undefined;
}

export interface CancelReminderRequest {
  id: string;
  reason: string;
  cancelledBy: string;
}

export interface SendReminderRequest {
  id: string;
  force: boolean;
}

export interface SendReminderResponse {
  success: boolean;
  message: string;
  providerMessageId?: string | undefined;
  errorCode?: string | undefined;
}

export interface ProcessDueRemindersRequest {
  organisationId: string;
  targetTime?: Timestamp | undefined;
  timezone: string;
  dryRun: boolean;
}

export interface ProcessDueRemindersResponse {
  totalProcessed: number;
  sent: number;
  failed: number;
  skipped: number;
  results: ProcessedReminderResult[];
}

export interface ProcessedReminderResult {
  reminderId: string;
  success: boolean;
  channel: ReminderChannel;
  providerMessageId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
  skipReason?: string | undefined;
}

export interface UpdateDeliveryStatusRequest {
  reminderId: string;
  status: ReminderStatus;
  providerMessageId?: string | undefined;
  deliveryStatusRaw?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false, message: "" };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, limit: 0, sortBy: "", sortOrder: "" };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRetryPolicyRequest(): GetRetryPolicyRequest {
  return { id: "" };
}

export const GetRetryPolicyRequest: MessageFns<GetRetryPolicyRequest> = {
  encode(message: GetRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryPolicyResponse(): RetryPolicyResponse {
  return {};
}

export const RetryPolicyResponse: MessageFns<RetryPolicyResponse> = {
  encode(message: RetryPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      RetryPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetryPoliciesRequest(): ListRetryPoliciesRequest {
  return { organisationId: "" };
}

export const ListRetryPoliciesRequest: MessageFns<ListRetryPoliciesRequest> = {
  encode(message: ListRetryPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.activeOnly !== undefined) {
      writer.uint32(24).bool(message.activeOnly);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetryPoliciesResponse(): ListRetryPoliciesResponse {
  return { policies: [] };
}

export const ListRetryPoliciesResponse: MessageFns<ListRetryPoliciesResponse> = {
  encode(message: ListRetryPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policies) {
      RetryPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policies.push(RetryPolicy.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateRetryPolicyRequest(): CreateRetryPolicyRequest {
  return {
    organisationId: "",
    name: "",
    description: "",
    retryDelaysDays: [],
    maxAttempts: 0,
    maxTotalDays: 0,
    retryOnAm04: false,
    retryableCodes: [],
    nonRetryableCodes: [],
    stopOnPaymentSettled: false,
    stopOnContractCancelled: false,
    stopOnMandateRevoked: false,
    backoffStrategy: "",
    isDefault: false,
    priority: 0,
  };
}

export const CreateRetryPolicyRequest: MessageFns<CreateRetryPolicyRequest> = {
  encode(message: CreateRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.productId !== undefined) {
      writer.uint32(26).string(message.productId);
    }
    if (message.channelId !== undefined) {
      writer.uint32(34).string(message.channelId);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    writer.uint32(58).fork();
    for (const v of message.retryDelaysDays) {
      writer.int32(v);
    }
    writer.join();
    if (message.maxAttempts !== 0) {
      writer.uint32(64).int32(message.maxAttempts);
    }
    if (message.maxTotalDays !== 0) {
      writer.uint32(72).int32(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== false) {
      writer.uint32(80).bool(message.retryOnAm04);
    }
    writer.uint32(90).fork();
    for (const v of message.retryableCodes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(98).fork();
    for (const v of message.nonRetryableCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.stopOnPaymentSettled !== false) {
      writer.uint32(104).bool(message.stopOnPaymentSettled);
    }
    if (message.stopOnContractCancelled !== false) {
      writer.uint32(112).bool(message.stopOnContractCancelled);
    }
    if (message.stopOnMandateRevoked !== false) {
      writer.uint32(120).bool(message.stopOnMandateRevoked);
    }
    if (message.backoffStrategy !== "") {
      writer.uint32(130).string(message.backoffStrategy);
    }
    if (message.isDefault !== false) {
      writer.uint32(136).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(144).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.retryDelaysDays.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryDelaysDays.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxTotalDays = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.retryOnAm04 = reader.bool();
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.retryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag === 96) {
            message.nonRetryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nonRetryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.stopOnPaymentSettled = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.stopOnContractCancelled = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.stopOnMandateRevoked = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.backoffStrategy = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateRetryPolicyRequest(): UpdateRetryPolicyRequest {
  return { id: "", retryDelaysDays: [], retryableCodes: [], nonRetryableCodes: [] };
}

export const UpdateRetryPolicyRequest: MessageFns<UpdateRetryPolicyRequest> = {
  encode(message: UpdateRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    writer.uint32(34).fork();
    for (const v of message.retryDelaysDays) {
      writer.int32(v);
    }
    writer.join();
    if (message.maxAttempts !== undefined) {
      writer.uint32(40).int32(message.maxAttempts);
    }
    if (message.maxTotalDays !== undefined) {
      writer.uint32(48).int32(message.maxTotalDays);
    }
    if (message.retryOnAm04 !== undefined) {
      writer.uint32(56).bool(message.retryOnAm04);
    }
    writer.uint32(66).fork();
    for (const v of message.retryableCodes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(74).fork();
    for (const v of message.nonRetryableCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.stopOnPaymentSettled !== undefined) {
      writer.uint32(80).bool(message.stopOnPaymentSettled);
    }
    if (message.stopOnContractCancelled !== undefined) {
      writer.uint32(88).bool(message.stopOnContractCancelled);
    }
    if (message.stopOnMandateRevoked !== undefined) {
      writer.uint32(96).bool(message.stopOnMandateRevoked);
    }
    if (message.backoffStrategy !== undefined) {
      writer.uint32(106).string(message.backoffStrategy);
    }
    if (message.isActive !== undefined) {
      writer.uint32(112).bool(message.isActive);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(120).bool(message.isDefault);
    }
    if (message.priority !== undefined) {
      writer.uint32(128).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.retryDelaysDays.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryDelaysDays.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxTotalDays = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.retryOnAm04 = reader.bool();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.retryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.retryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag === 72) {
            message.nonRetryableCodes.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nonRetryableCodes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.stopOnPaymentSettled = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.stopOnContractCancelled = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.stopOnMandateRevoked = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.backoffStrategy = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteRetryPolicyRequest(): DeleteRetryPolicyRequest {
  return { id: "" };
}

export const DeleteRetryPolicyRequest: MessageFns<DeleteRetryPolicyRequest> = {
  encode(message: DeleteRetryPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRetryPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRetryPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRetryScheduleRequest(): GetRetryScheduleRequest {
  return { id: "" };
}

export const GetRetryScheduleRequest: MessageFns<GetRetryScheduleRequest> = {
  encode(message: GetRetryScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryScheduleResponse(): RetryScheduleResponse {
  return { attempts: [], reminders: [] };
}

export const RetryScheduleResponse: MessageFns<RetryScheduleResponse> = {
  encode(message: RetryScheduleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schedule !== undefined) {
      RetrySchedule.encode(message.schedule, writer.uint32(10).fork()).join();
    }
    for (const v of message.attempts) {
      RetryAttempt.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.reminders) {
      Reminder.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryScheduleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryScheduleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedule = RetrySchedule.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attempts.push(RetryAttempt.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reminders.push(Reminder.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetrySchedulesRequest(): ListRetrySchedulesRequest {
  return { organisationId: "" };
}

export const ListRetrySchedulesRequest: MessageFns<ListRetrySchedulesRequest> = {
  encode(message: ListRetrySchedulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(26).string(message.clientId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(34).string(message.contratId);
    }
    if (message.eligibility !== undefined) {
      writer.uint32(40).int32(message.eligibility);
    }
    if (message.isResolved !== undefined) {
      writer.uint32(48).bool(message.isResolved);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(message.fromDate, writer.uint32(58).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(message.toDate, writer.uint32(66).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetrySchedulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetrySchedulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isResolved = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fromDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.toDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetrySchedulesResponse(): ListRetrySchedulesResponse {
  return { schedules: [] };
}

export const ListRetrySchedulesResponse: MessageFns<ListRetrySchedulesResponse> = {
  encode(message: ListRetrySchedulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.schedules) {
      RetrySchedule.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetrySchedulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetrySchedulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedules.push(RetrySchedule.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelRetryScheduleRequest(): CancelRetryScheduleRequest {
  return { id: "", reason: "", cancelledBy: "" };
}

export const CancelRetryScheduleRequest: MessageFns<CancelRetryScheduleRequest> = {
  encode(message: CancelRetryScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(26).string(message.cancelledBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRetryScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRetryScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReplanRetryScheduleRequest(): ReplanRetryScheduleRequest {
  return { id: "", reason: "", replannedBy: "" };
}

export const ReplanRetryScheduleRequest: MessageFns<ReplanRetryScheduleRequest> = {
  encode(message: ReplanRetryScheduleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.newRetryDate !== undefined) {
      Timestamp.encode(message.newRetryDate, writer.uint32(18).fork()).join();
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.replannedBy !== "") {
      writer.uint32(34).string(message.replannedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplanRetryScheduleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplanRetryScheduleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newRetryDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.replannedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRetryAttemptRequest(): GetRetryAttemptRequest {
  return { id: "" };
}

export const GetRetryAttemptRequest: MessageFns<GetRetryAttemptRequest> = {
  encode(message: GetRetryAttemptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryAttemptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryAttemptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryAttemptResponse(): RetryAttemptResponse {
  return {};
}

export const RetryAttemptResponse: MessageFns<RetryAttemptResponse> = {
  encode(message: RetryAttemptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attempt !== undefined) {
      RetryAttempt.encode(message.attempt, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryAttemptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAttemptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attempt = RetryAttempt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetryAttemptsRequest(): ListRetryAttemptsRequest {
  return { retryScheduleId: "" };
}

export const ListRetryAttemptsRequest: MessageFns<ListRetryAttemptsRequest> = {
  encode(message: ListRetryAttemptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryScheduleId !== "") {
      writer.uint32(10).string(message.retryScheduleId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryAttemptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryAttemptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetryAttemptsResponse(): ListRetryAttemptsResponse {
  return { attempts: [] };
}

export const ListRetryAttemptsResponse: MessageFns<ListRetryAttemptsResponse> = {
  encode(message: ListRetryAttemptsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attempts) {
      RetryAttempt.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryAttemptsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryAttemptsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attempts.push(RetryAttempt.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRunNowRequest(): RunNowRequest {
  return { organisationId: "", triggeredBy: "", dryRun: false };
}

export const RunNowRequest: MessageFns<RunNowRequest> = {
  encode(message: RunNowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.triggeredBy !== "") {
      writer.uint32(26).string(message.triggeredBy);
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunNowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunNowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.triggeredBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRunNowResponse(): RunNowResponse {
  return { jobId: "", status: 0, message: "", scheduledCount: 0 };
}

export const RunNowResponse: MessageFns<RunNowResponse> = {
  encode(message: RunNowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.scheduledCount !== 0) {
      writer.uint32(32).int32(message.scheduledCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunNowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunNowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scheduledCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRetryJobStatusRequest(): GetRetryJobStatusRequest {
  return { jobId: "" };
}

export const GetRetryJobStatusRequest: MessageFns<GetRetryJobStatusRequest> = {
  encode(message: GetRetryJobStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryJobStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryJobStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryJobResponse(): RetryJobResponse {
  return {};
}

export const RetryJobResponse: MessageFns<RetryJobResponse> = {
  encode(message: RetryJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      RetryJob.encode(message.job, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = RetryJob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetryJobsRequest(): ListRetryJobsRequest {
  return { organisationId: "" };
}

export const ListRetryJobsRequest: MessageFns<ListRetryJobsRequest> = {
  encode(message: ListRetryJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.status !== undefined) {
      writer.uint32(16).int32(message.status);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(message.fromDate, writer.uint32(26).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(message.toDate, writer.uint32(34).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetryJobsResponse(): ListRetryJobsResponse {
  return { jobs: [] };
}

export const ListRetryJobsResponse: MessageFns<ListRetryJobsResponse> = {
  encode(message: ListRetryJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      RetryJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetryJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetryJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(RetryJob.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRetryMetricsRequest(): GetRetryMetricsRequest {
  return { organisationId: "" };
}

export const GetRetryMetricsRequest: MessageFns<GetRetryMetricsRequest> = {
  encode(message: GetRetryMetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(message.fromDate, writer.uint32(26).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(message.toDate, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetryMetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetryMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRetryMetricsResponse(): RetryMetricsResponse {
  return {
    totalRejections: 0,
    am04Rejections: 0,
    otherRejections: 0,
    totalRetrySchedules: 0,
    eligibleForRetry: 0,
    notEligible: 0,
    totalRetryAttempts: 0,
    successfulRetries: 0,
    failedRetries: 0,
    pendingRetries: 0,
    successRate: 0,
    am04Rate: 0,
    totalAmountRecoveredCents: 0,
    totalAmountPendingCents: 0,
    rejectionCodeBreakdown: [],
    dailyMetrics: [],
  };
}

export const RetryMetricsResponse: MessageFns<RetryMetricsResponse> = {
  encode(message: RetryMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalRejections !== 0) {
      writer.uint32(8).int32(message.totalRejections);
    }
    if (message.am04Rejections !== 0) {
      writer.uint32(16).int32(message.am04Rejections);
    }
    if (message.otherRejections !== 0) {
      writer.uint32(24).int32(message.otherRejections);
    }
    if (message.totalRetrySchedules !== 0) {
      writer.uint32(32).int32(message.totalRetrySchedules);
    }
    if (message.eligibleForRetry !== 0) {
      writer.uint32(40).int32(message.eligibleForRetry);
    }
    if (message.notEligible !== 0) {
      writer.uint32(48).int32(message.notEligible);
    }
    if (message.totalRetryAttempts !== 0) {
      writer.uint32(56).int32(message.totalRetryAttempts);
    }
    if (message.successfulRetries !== 0) {
      writer.uint32(64).int32(message.successfulRetries);
    }
    if (message.failedRetries !== 0) {
      writer.uint32(72).int32(message.failedRetries);
    }
    if (message.pendingRetries !== 0) {
      writer.uint32(80).int32(message.pendingRetries);
    }
    if (message.successRate !== 0) {
      writer.uint32(89).double(message.successRate);
    }
    if (message.am04Rate !== 0) {
      writer.uint32(97).double(message.am04Rate);
    }
    if (message.totalAmountRecoveredCents !== 0) {
      writer.uint32(104).int64(message.totalAmountRecoveredCents);
    }
    if (message.totalAmountPendingCents !== 0) {
      writer.uint32(112).int64(message.totalAmountPendingCents);
    }
    for (const v of message.rejectionCodeBreakdown) {
      RejectionCodeMetric.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.dailyMetrics) {
      DailyRetryMetric.encode(v!, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalRejections = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.am04Rejections = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.otherRejections = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalRetrySchedules = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.eligibleForRetry = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.notEligible = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalRetryAttempts = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.successfulRetries = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.failedRetries = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.pendingRetries = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.successRate = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 97) {
            break;
          }

          message.am04Rate = reader.double();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.totalAmountRecoveredCents = longToNumber(reader.int64());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.totalAmountPendingCents = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.rejectionCodeBreakdown.push(RejectionCodeMetric.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dailyMetrics.push(DailyRetryMetric.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRejectionCodeMetric(): RejectionCodeMetric {
  return { code: 0, codeRaw: "", count: 0, percentage: 0 };
}

export const RejectionCodeMetric: MessageFns<RejectionCodeMetric> = {
  encode(message: RejectionCodeMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.codeRaw !== "") {
      writer.uint32(18).string(message.codeRaw);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.percentage !== 0) {
      writer.uint32(33).double(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectionCodeMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectionCodeMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.codeRaw = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.percentage = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDailyRetryMetric(): DailyRetryMetric {
  return { date: "", rejections: 0, retriesScheduled: 0, retriesExecuted: 0, retriesSucceeded: 0, retriesFailed: 0 };
}

export const DailyRetryMetric: MessageFns<DailyRetryMetric> = {
  encode(message: DailyRetryMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.rejections !== 0) {
      writer.uint32(16).int32(message.rejections);
    }
    if (message.retriesScheduled !== 0) {
      writer.uint32(24).int32(message.retriesScheduled);
    }
    if (message.retriesExecuted !== 0) {
      writer.uint32(32).int32(message.retriesExecuted);
    }
    if (message.retriesSucceeded !== 0) {
      writer.uint32(40).int32(message.retriesSucceeded);
    }
    if (message.retriesFailed !== 0) {
      writer.uint32(48).int32(message.retriesFailed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyRetryMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyRetryMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rejections = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.retriesScheduled = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.retriesExecuted = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.retriesSucceeded = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.retriesFailed = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuditLogsRequest(): GetAuditLogsRequest {
  return { organisationId: "" };
}

export const GetAuditLogsRequest: MessageFns<GetAuditLogsRequest> = {
  encode(message: GetAuditLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.entityType !== undefined) {
      writer.uint32(18).string(message.entityType);
    }
    if (message.entityId !== undefined) {
      writer.uint32(26).string(message.entityId);
    }
    if (message.action !== undefined) {
      writer.uint32(34).string(message.action);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(message.fromDate, writer.uint32(42).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(message.toDate, writer.uint32(50).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuditLogsResponse(): AuditLogsResponse {
  return { logs: [] };
}

export const AuditLogsResponse: MessageFns<AuditLogsResponse> = {
  encode(message: AuditLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      RetryAuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(RetryAuditLog.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessDueRetriesRequest(): ProcessDueRetriesRequest {
  return { organisationId: "", timezone: "", cutoffTime: "", dryRun: false };
}

export const ProcessDueRetriesRequest: MessageFns<ProcessDueRetriesRequest> = {
  encode(message: ProcessDueRetriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.targetDate !== undefined) {
      Timestamp.encode(message.targetDate, writer.uint32(18).fork()).join();
    }
    if (message.timezone !== "") {
      writer.uint32(26).string(message.timezone);
    }
    if (message.cutoffTime !== "") {
      writer.uint32(34).string(message.cutoffTime);
    }
    if (message.dryRun !== false) {
      writer.uint32(40).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRetriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRetriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cutoffTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessDueRetriesResponse(): ProcessDueRetriesResponse {
  return { jobId: "", status: 0, totalProcessed: 0, successful: 0, failed: 0, skipped: 0, results: [] };
}

export const ProcessDueRetriesResponse: MessageFns<ProcessDueRetriesResponse> = {
  encode(message: ProcessDueRetriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.totalProcessed !== 0) {
      writer.uint32(24).int32(message.totalProcessed);
    }
    if (message.successful !== 0) {
      writer.uint32(32).int32(message.successful);
    }
    if (message.failed !== 0) {
      writer.uint32(40).int32(message.failed);
    }
    if (message.skipped !== 0) {
      writer.uint32(48).int32(message.skipped);
    }
    for (const v of message.results) {
      ProcessedRetryResult.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRetriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRetriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalProcessed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.successful = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.failed = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.skipped = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.results.push(ProcessedRetryResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessedRetryResult(): ProcessedRetryResult {
  return { retryScheduleId: "", retryAttemptId: "", success: false };
}

export const ProcessedRetryResult: MessageFns<ProcessedRetryResult> = {
  encode(message: ProcessedRetryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryScheduleId !== "") {
      writer.uint32(10).string(message.retryScheduleId);
    }
    if (message.retryAttemptId !== "") {
      writer.uint32(18).string(message.retryAttemptId);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessedRetryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedRetryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryAttemptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckEligibilityRequest(): CheckEligibilityRequest {
  return { paymentId: "", rejectionCode: "", organisationId: "" };
}

export const CheckEligibilityRequest: MessageFns<CheckEligibilityRequest> = {
  encode(message: CheckEligibilityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.rejectionCode !== "") {
      writer.uint32(18).string(message.rejectionCode);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(34).string(message.societeId);
    }
    if (message.contratId !== undefined) {
      writer.uint32(42).string(message.contratId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(50).string(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckEligibilityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckEligibilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rejectionCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contratId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckEligibilityResponse(): CheckEligibilityResponse {
  return { eligibility: 0, reason: "" };
}

export const CheckEligibilityResponse: MessageFns<CheckEligibilityResponse> = {
  encode(message: CheckEligibilityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eligibility !== 0) {
      writer.uint32(8).int32(message.eligibility);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.applicablePolicyId !== undefined) {
      writer.uint32(26).string(message.applicablePolicyId);
    }
    if (message.firstRetryDate !== undefined) {
      Timestamp.encode(message.firstRetryDate, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckEligibilityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckEligibilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.applicablePolicyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstRetryDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHandleRejectionResponse(): HandleRejectionResponse {
  return { processed: false, eligibility: 0, message: "", reminderIds: [] };
}

export const HandleRejectionResponse: MessageFns<HandleRejectionResponse> = {
  encode(message: HandleRejectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processed !== false) {
      writer.uint32(8).bool(message.processed);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.eligibility !== 0) {
      writer.uint32(24).int32(message.eligibility);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    for (const v of message.reminderIds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandleRejectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandleRejectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eligibility = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reminderIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetReminderPolicyRequest(): GetReminderPolicyRequest {
  return { id: "" };
}

export const GetReminderPolicyRequest: MessageFns<GetReminderPolicyRequest> = {
  encode(message: GetReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderPolicyResponse(): ReminderPolicyResponse {
  return {};
}

export const ReminderPolicyResponse: MessageFns<ReminderPolicyResponse> = {
  encode(message: ReminderPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      ReminderPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = ReminderPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListReminderPoliciesRequest(): ListReminderPoliciesRequest {
  return { organisationId: "" };
}

export const ListReminderPoliciesRequest: MessageFns<ListReminderPoliciesRequest> = {
  encode(message: ListReminderPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.activeOnly !== undefined) {
      writer.uint32(24).bool(message.activeOnly);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReminderPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReminderPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListReminderPoliciesResponse(): ListReminderPoliciesResponse {
  return { policies: [] };
}

export const ListReminderPoliciesResponse: MessageFns<ListReminderPoliciesResponse> = {
  encode(message: ListReminderPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policies) {
      ReminderPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReminderPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReminderPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policies.push(ReminderPolicy.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateReminderPolicyRequest(): CreateReminderPolicyRequest {
  return {
    organisationId: "",
    name: "",
    description: "",
    triggerRules: [],
    cooldownHours: 0,
    maxRemindersPerDay: 0,
    maxRemindersPerWeek: 0,
    allowedStartHour: 0,
    allowedEndHour: 0,
    allowedDaysOfWeek: [],
    respectOptOut: false,
    isDefault: false,
    priority: 0,
  };
}

export const CreateReminderPolicyRequest: MessageFns<CreateReminderPolicyRequest> = {
  encode(message: CreateReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.societeId !== undefined) {
      writer.uint32(18).string(message.societeId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.triggerRules) {
      ReminderTriggerRule.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.cooldownHours !== 0) {
      writer.uint32(48).int32(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== 0) {
      writer.uint32(56).int32(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== 0) {
      writer.uint32(64).int32(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== 0) {
      writer.uint32(72).int32(message.allowedStartHour);
    }
    if (message.allowedEndHour !== 0) {
      writer.uint32(80).int32(message.allowedEndHour);
    }
    writer.uint32(90).fork();
    for (const v of message.allowedDaysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    if (message.respectOptOut !== false) {
      writer.uint32(96).bool(message.respectOptOut);
    }
    if (message.isDefault !== false) {
      writer.uint32(104).bool(message.isDefault);
    }
    if (message.priority !== 0) {
      writer.uint32(112).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.societeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.triggerRules.push(ReminderTriggerRule.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cooldownHours = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxRemindersPerDay = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxRemindersPerWeek = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowedStartHour = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowedEndHour = reader.int32();
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.allowedDaysOfWeek.push(reader.int32());

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedDaysOfWeek.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.respectOptOut = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateReminderPolicyRequest(): UpdateReminderPolicyRequest {
  return { id: "", triggerRules: [], allowedDaysOfWeek: [] };
}

export const UpdateReminderPolicyRequest: MessageFns<UpdateReminderPolicyRequest> = {
  encode(message: UpdateReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.triggerRules) {
      ReminderTriggerRule.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.cooldownHours !== undefined) {
      writer.uint32(40).int32(message.cooldownHours);
    }
    if (message.maxRemindersPerDay !== undefined) {
      writer.uint32(48).int32(message.maxRemindersPerDay);
    }
    if (message.maxRemindersPerWeek !== undefined) {
      writer.uint32(56).int32(message.maxRemindersPerWeek);
    }
    if (message.allowedStartHour !== undefined) {
      writer.uint32(64).int32(message.allowedStartHour);
    }
    if (message.allowedEndHour !== undefined) {
      writer.uint32(72).int32(message.allowedEndHour);
    }
    writer.uint32(82).fork();
    for (const v of message.allowedDaysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    if (message.respectOptOut !== undefined) {
      writer.uint32(88).bool(message.respectOptOut);
    }
    if (message.isActive !== undefined) {
      writer.uint32(96).bool(message.isActive);
    }
    if (message.isDefault !== undefined) {
      writer.uint32(104).bool(message.isDefault);
    }
    if (message.priority !== undefined) {
      writer.uint32(112).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.triggerRules.push(ReminderTriggerRule.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cooldownHours = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.maxRemindersPerDay = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxRemindersPerWeek = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.allowedStartHour = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowedEndHour = reader.int32();
          continue;
        }
        case 10: {
          if (tag === 80) {
            message.allowedDaysOfWeek.push(reader.int32());

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedDaysOfWeek.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.respectOptOut = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteReminderPolicyRequest(): DeleteReminderPolicyRequest {
  return { id: "" };
}

export const DeleteReminderPolicyRequest: MessageFns<DeleteReminderPolicyRequest> = {
  encode(message: DeleteReminderPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReminderPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReminderPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetReminderRequest(): GetReminderRequest {
  return { id: "" };
}

export const GetReminderRequest: MessageFns<GetReminderRequest> = {
  encode(message: GetReminderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReminderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReminderResponse(): ReminderResponse {
  return {};
}

export const ReminderResponse: MessageFns<ReminderResponse> = {
  encode(message: ReminderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reminder !== undefined) {
      Reminder.encode(message.reminder, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReminderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReminderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminder = Reminder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRemindersRequest(): ListRemindersRequest {
  return { organisationId: "" };
}

export const ListRemindersRequest: MessageFns<ListRemindersRequest> = {
  encode(message: ListRemindersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.retryScheduleId !== undefined) {
      writer.uint32(18).string(message.retryScheduleId);
    }
    if (message.clientId !== undefined) {
      writer.uint32(26).string(message.clientId);
    }
    if (message.channel !== undefined) {
      writer.uint32(32).int32(message.channel);
    }
    if (message.status !== undefined) {
      writer.uint32(40).int32(message.status);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(message.fromDate, writer.uint32(50).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(message.toDate, writer.uint32(58).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRemindersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRemindersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retryScheduleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fromDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.toDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRemindersResponse(): ListRemindersResponse {
  return { reminders: [] };
}

export const ListRemindersResponse: MessageFns<ListRemindersResponse> = {
  encode(message: ListRemindersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reminders) {
      Reminder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRemindersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRemindersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminders.push(Reminder.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelReminderRequest(): CancelReminderRequest {
  return { id: "", reason: "", cancelledBy: "" };
}

export const CancelReminderRequest: MessageFns<CancelReminderRequest> = {
  encode(message: CancelReminderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (message.cancelledBy !== "") {
      writer.uint32(26).string(message.cancelledBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelReminderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendReminderRequest(): SendReminderRequest {
  return { id: "", force: false };
}

export const SendReminderRequest: MessageFns<SendReminderRequest> = {
  encode(message: SendReminderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendReminderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSendReminderResponse(): SendReminderResponse {
  return { success: false, message: "" };
}

export const SendReminderResponse: MessageFns<SendReminderResponse> = {
  encode(message: SendReminderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(26).string(message.providerMessageId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendReminderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendReminderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessDueRemindersRequest(): ProcessDueRemindersRequest {
  return { organisationId: "", timezone: "", dryRun: false };
}

export const ProcessDueRemindersRequest: MessageFns<ProcessDueRemindersRequest> = {
  encode(message: ProcessDueRemindersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.targetTime !== undefined) {
      Timestamp.encode(message.targetTime, writer.uint32(18).fork()).join();
    }
    if (message.timezone !== "") {
      writer.uint32(26).string(message.timezone);
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRemindersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRemindersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetTime = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessDueRemindersResponse(): ProcessDueRemindersResponse {
  return { totalProcessed: 0, sent: 0, failed: 0, skipped: 0, results: [] };
}

export const ProcessDueRemindersResponse: MessageFns<ProcessDueRemindersResponse> = {
  encode(message: ProcessDueRemindersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalProcessed !== 0) {
      writer.uint32(8).int32(message.totalProcessed);
    }
    if (message.sent !== 0) {
      writer.uint32(16).int32(message.sent);
    }
    if (message.failed !== 0) {
      writer.uint32(24).int32(message.failed);
    }
    if (message.skipped !== 0) {
      writer.uint32(32).int32(message.skipped);
    }
    for (const v of message.results) {
      ProcessedReminderResult.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDueRemindersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDueRemindersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalProcessed = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failed = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.skipped = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.results.push(ProcessedReminderResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseProcessedReminderResult(): ProcessedReminderResult {
  return { reminderId: "", success: false, channel: 0 };
}

export const ProcessedReminderResult: MessageFns<ProcessedReminderResult> = {
  encode(message: ProcessedReminderResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reminderId !== "") {
      writer.uint32(10).string(message.reminderId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.channel !== 0) {
      writer.uint32(24).int32(message.channel);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(34).string(message.providerMessageId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(50).string(message.errorMessage);
    }
    if (message.skipReason !== undefined) {
      writer.uint32(58).string(message.skipReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessedReminderResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessedReminderResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.skipReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateDeliveryStatusRequest(): UpdateDeliveryStatusRequest {
  return { reminderId: "", status: 0 };
}

export const UpdateDeliveryStatusRequest: MessageFns<UpdateDeliveryStatusRequest> = {
  encode(message: UpdateDeliveryStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reminderId !== "") {
      writer.uint32(10).string(message.reminderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.providerMessageId !== undefined) {
      writer.uint32(26).string(message.providerMessageId);
    }
    if (message.deliveryStatusRaw !== undefined) {
      writer.uint32(34).string(message.deliveryStatusRaw);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(50).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeliveryStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeliveryStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reminderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerMessageId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deliveryStatusRaw = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface RetryAdminServiceClient {
  getRetryPolicy(request: GetRetryPolicyRequest, metadata?: Metadata): Observable<RetryPolicyResponse>;

  listRetryPolicies(request: ListRetryPoliciesRequest, metadata?: Metadata): Observable<ListRetryPoliciesResponse>;

  createRetryPolicy(request: CreateRetryPolicyRequest, metadata?: Metadata): Observable<RetryPolicyResponse>;

  updateRetryPolicy(request: UpdateRetryPolicyRequest, metadata?: Metadata): Observable<RetryPolicyResponse>;

  deleteRetryPolicy(request: DeleteRetryPolicyRequest, metadata?: Metadata): Observable<DeleteResponse>;

  getRetrySchedule(request: GetRetryScheduleRequest, metadata?: Metadata): Observable<RetryScheduleResponse>;

  listRetrySchedules(request: ListRetrySchedulesRequest, metadata?: Metadata): Observable<ListRetrySchedulesResponse>;

  cancelRetrySchedule(request: CancelRetryScheduleRequest, metadata?: Metadata): Observable<RetryScheduleResponse>;

  replanRetrySchedule(request: ReplanRetryScheduleRequest, metadata?: Metadata): Observable<RetryScheduleResponse>;

  getRetryAttempt(request: GetRetryAttemptRequest, metadata?: Metadata): Observable<RetryAttemptResponse>;

  listRetryAttempts(request: ListRetryAttemptsRequest, metadata?: Metadata): Observable<ListRetryAttemptsResponse>;

  runNow(request: RunNowRequest, metadata?: Metadata): Observable<RunNowResponse>;

  getRetryJobStatus(request: GetRetryJobStatusRequest, metadata?: Metadata): Observable<RetryJobResponse>;

  listRetryJobs(request: ListRetryJobsRequest, metadata?: Metadata): Observable<ListRetryJobsResponse>;

  getRetryMetrics(request: GetRetryMetricsRequest, metadata?: Metadata): Observable<RetryMetricsResponse>;

  getAuditLogs(request: GetAuditLogsRequest, metadata?: Metadata): Observable<AuditLogsResponse>;
}

export interface RetryAdminServiceController {
  getRetryPolicy(
    request: GetRetryPolicyRequest,
    metadata?: Metadata,
  ): Promise<RetryPolicyResponse> | Observable<RetryPolicyResponse> | RetryPolicyResponse;

  listRetryPolicies(
    request: ListRetryPoliciesRequest,
    metadata?: Metadata,
  ): Promise<ListRetryPoliciesResponse> | Observable<ListRetryPoliciesResponse> | ListRetryPoliciesResponse;

  createRetryPolicy(
    request: CreateRetryPolicyRequest,
    metadata?: Metadata,
  ): Promise<RetryPolicyResponse> | Observable<RetryPolicyResponse> | RetryPolicyResponse;

  updateRetryPolicy(
    request: UpdateRetryPolicyRequest,
    metadata?: Metadata,
  ): Promise<RetryPolicyResponse> | Observable<RetryPolicyResponse> | RetryPolicyResponse;

  deleteRetryPolicy(
    request: DeleteRetryPolicyRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  getRetrySchedule(
    request: GetRetryScheduleRequest,
    metadata?: Metadata,
  ): Promise<RetryScheduleResponse> | Observable<RetryScheduleResponse> | RetryScheduleResponse;

  listRetrySchedules(
    request: ListRetrySchedulesRequest,
    metadata?: Metadata,
  ): Promise<ListRetrySchedulesResponse> | Observable<ListRetrySchedulesResponse> | ListRetrySchedulesResponse;

  cancelRetrySchedule(
    request: CancelRetryScheduleRequest,
    metadata?: Metadata,
  ): Promise<RetryScheduleResponse> | Observable<RetryScheduleResponse> | RetryScheduleResponse;

  replanRetrySchedule(
    request: ReplanRetryScheduleRequest,
    metadata?: Metadata,
  ): Promise<RetryScheduleResponse> | Observable<RetryScheduleResponse> | RetryScheduleResponse;

  getRetryAttempt(
    request: GetRetryAttemptRequest,
    metadata?: Metadata,
  ): Promise<RetryAttemptResponse> | Observable<RetryAttemptResponse> | RetryAttemptResponse;

  listRetryAttempts(
    request: ListRetryAttemptsRequest,
    metadata?: Metadata,
  ): Promise<ListRetryAttemptsResponse> | Observable<ListRetryAttemptsResponse> | ListRetryAttemptsResponse;

  runNow(
    request: RunNowRequest,
    metadata?: Metadata,
  ): Promise<RunNowResponse> | Observable<RunNowResponse> | RunNowResponse;

  getRetryJobStatus(
    request: GetRetryJobStatusRequest,
    metadata?: Metadata,
  ): Promise<RetryJobResponse> | Observable<RetryJobResponse> | RetryJobResponse;

  listRetryJobs(
    request: ListRetryJobsRequest,
    metadata?: Metadata,
  ): Promise<ListRetryJobsResponse> | Observable<ListRetryJobsResponse> | ListRetryJobsResponse;

  getRetryMetrics(
    request: GetRetryMetricsRequest,
    metadata?: Metadata,
  ): Promise<RetryMetricsResponse> | Observable<RetryMetricsResponse> | RetryMetricsResponse;

  getAuditLogs(
    request: GetAuditLogsRequest,
    metadata?: Metadata,
  ): Promise<AuditLogsResponse> | Observable<AuditLogsResponse> | AuditLogsResponse;
}

export function RetryAdminServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getRetryPolicy",
      "listRetryPolicies",
      "createRetryPolicy",
      "updateRetryPolicy",
      "deleteRetryPolicy",
      "getRetrySchedule",
      "listRetrySchedules",
      "cancelRetrySchedule",
      "replanRetrySchedule",
      "getRetryAttempt",
      "listRetryAttempts",
      "runNow",
      "getRetryJobStatus",
      "listRetryJobs",
      "getRetryMetrics",
      "getAuditLogs",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("RetryAdminService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("RetryAdminService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const RETRY_ADMIN_SERVICE_NAME = "RetryAdminService";

export type RetryAdminServiceService = typeof RetryAdminServiceService;
export const RetryAdminServiceService = {
  getRetryPolicy: {
    path: "/retry.RetryAdminService/GetRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryPolicyRequest): Buffer =>
      Buffer.from(GetRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryPolicyRequest => GetRetryPolicyRequest.decode(value),
    responseSerialize: (value: RetryPolicyResponse): Buffer => Buffer.from(RetryPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryPolicyResponse => RetryPolicyResponse.decode(value),
  },
  listRetryPolicies: {
    path: "/retry.RetryAdminService/ListRetryPolicies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetryPoliciesRequest): Buffer =>
      Buffer.from(ListRetryPoliciesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetryPoliciesRequest => ListRetryPoliciesRequest.decode(value),
    responseSerialize: (value: ListRetryPoliciesResponse): Buffer =>
      Buffer.from(ListRetryPoliciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetryPoliciesResponse => ListRetryPoliciesResponse.decode(value),
  },
  createRetryPolicy: {
    path: "/retry.RetryAdminService/CreateRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRetryPolicyRequest): Buffer =>
      Buffer.from(CreateRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateRetryPolicyRequest => CreateRetryPolicyRequest.decode(value),
    responseSerialize: (value: RetryPolicyResponse): Buffer => Buffer.from(RetryPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryPolicyResponse => RetryPolicyResponse.decode(value),
  },
  updateRetryPolicy: {
    path: "/retry.RetryAdminService/UpdateRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateRetryPolicyRequest): Buffer =>
      Buffer.from(UpdateRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateRetryPolicyRequest => UpdateRetryPolicyRequest.decode(value),
    responseSerialize: (value: RetryPolicyResponse): Buffer => Buffer.from(RetryPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryPolicyResponse => RetryPolicyResponse.decode(value),
  },
  deleteRetryPolicy: {
    path: "/retry.RetryAdminService/DeleteRetryPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRetryPolicyRequest): Buffer =>
      Buffer.from(DeleteRetryPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRetryPolicyRequest => DeleteRetryPolicyRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getRetrySchedule: {
    path: "/retry.RetryAdminService/GetRetrySchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryScheduleRequest): Buffer =>
      Buffer.from(GetRetryScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryScheduleRequest => GetRetryScheduleRequest.decode(value),
    responseSerialize: (value: RetryScheduleResponse): Buffer =>
      Buffer.from(RetryScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryScheduleResponse => RetryScheduleResponse.decode(value),
  },
  listRetrySchedules: {
    path: "/retry.RetryAdminService/ListRetrySchedules",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetrySchedulesRequest): Buffer =>
      Buffer.from(ListRetrySchedulesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetrySchedulesRequest => ListRetrySchedulesRequest.decode(value),
    responseSerialize: (value: ListRetrySchedulesResponse): Buffer =>
      Buffer.from(ListRetrySchedulesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetrySchedulesResponse => ListRetrySchedulesResponse.decode(value),
  },
  cancelRetrySchedule: {
    path: "/retry.RetryAdminService/CancelRetrySchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelRetryScheduleRequest): Buffer =>
      Buffer.from(CancelRetryScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelRetryScheduleRequest => CancelRetryScheduleRequest.decode(value),
    responseSerialize: (value: RetryScheduleResponse): Buffer =>
      Buffer.from(RetryScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryScheduleResponse => RetryScheduleResponse.decode(value),
  },
  replanRetrySchedule: {
    path: "/retry.RetryAdminService/ReplanRetrySchedule",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReplanRetryScheduleRequest): Buffer =>
      Buffer.from(ReplanRetryScheduleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReplanRetryScheduleRequest => ReplanRetryScheduleRequest.decode(value),
    responseSerialize: (value: RetryScheduleResponse): Buffer =>
      Buffer.from(RetryScheduleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryScheduleResponse => RetryScheduleResponse.decode(value),
  },
  getRetryAttempt: {
    path: "/retry.RetryAdminService/GetRetryAttempt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryAttemptRequest): Buffer =>
      Buffer.from(GetRetryAttemptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryAttemptRequest => GetRetryAttemptRequest.decode(value),
    responseSerialize: (value: RetryAttemptResponse): Buffer =>
      Buffer.from(RetryAttemptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryAttemptResponse => RetryAttemptResponse.decode(value),
  },
  listRetryAttempts: {
    path: "/retry.RetryAdminService/ListRetryAttempts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetryAttemptsRequest): Buffer =>
      Buffer.from(ListRetryAttemptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetryAttemptsRequest => ListRetryAttemptsRequest.decode(value),
    responseSerialize: (value: ListRetryAttemptsResponse): Buffer =>
      Buffer.from(ListRetryAttemptsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetryAttemptsResponse => ListRetryAttemptsResponse.decode(value),
  },
  runNow: {
    path: "/retry.RetryAdminService/RunNow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RunNowRequest): Buffer => Buffer.from(RunNowRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunNowRequest => RunNowRequest.decode(value),
    responseSerialize: (value: RunNowResponse): Buffer => Buffer.from(RunNowResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunNowResponse => RunNowResponse.decode(value),
  },
  getRetryJobStatus: {
    path: "/retry.RetryAdminService/GetRetryJobStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryJobStatusRequest): Buffer =>
      Buffer.from(GetRetryJobStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryJobStatusRequest => GetRetryJobStatusRequest.decode(value),
    responseSerialize: (value: RetryJobResponse): Buffer => Buffer.from(RetryJobResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryJobResponse => RetryJobResponse.decode(value),
  },
  listRetryJobs: {
    path: "/retry.RetryAdminService/ListRetryJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetryJobsRequest): Buffer => Buffer.from(ListRetryJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetryJobsRequest => ListRetryJobsRequest.decode(value),
    responseSerialize: (value: ListRetryJobsResponse): Buffer =>
      Buffer.from(ListRetryJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetryJobsResponse => ListRetryJobsResponse.decode(value),
  },
  getRetryMetrics: {
    path: "/retry.RetryAdminService/GetRetryMetrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetryMetricsRequest): Buffer =>
      Buffer.from(GetRetryMetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetryMetricsRequest => GetRetryMetricsRequest.decode(value),
    responseSerialize: (value: RetryMetricsResponse): Buffer =>
      Buffer.from(RetryMetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RetryMetricsResponse => RetryMetricsResponse.decode(value),
  },
  getAuditLogs: {
    path: "/retry.RetryAdminService/GetAuditLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditLogsRequest): Buffer => Buffer.from(GetAuditLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuditLogsRequest => GetAuditLogsRequest.decode(value),
    responseSerialize: (value: AuditLogsResponse): Buffer => Buffer.from(AuditLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuditLogsResponse => AuditLogsResponse.decode(value),
  },
} as const;

export interface RetryAdminServiceServer extends UntypedServiceImplementation {
  getRetryPolicy: handleUnaryCall<GetRetryPolicyRequest, RetryPolicyResponse>;
  listRetryPolicies: handleUnaryCall<ListRetryPoliciesRequest, ListRetryPoliciesResponse>;
  createRetryPolicy: handleUnaryCall<CreateRetryPolicyRequest, RetryPolicyResponse>;
  updateRetryPolicy: handleUnaryCall<UpdateRetryPolicyRequest, RetryPolicyResponse>;
  deleteRetryPolicy: handleUnaryCall<DeleteRetryPolicyRequest, DeleteResponse>;
  getRetrySchedule: handleUnaryCall<GetRetryScheduleRequest, RetryScheduleResponse>;
  listRetrySchedules: handleUnaryCall<ListRetrySchedulesRequest, ListRetrySchedulesResponse>;
  cancelRetrySchedule: handleUnaryCall<CancelRetryScheduleRequest, RetryScheduleResponse>;
  replanRetrySchedule: handleUnaryCall<ReplanRetryScheduleRequest, RetryScheduleResponse>;
  getRetryAttempt: handleUnaryCall<GetRetryAttemptRequest, RetryAttemptResponse>;
  listRetryAttempts: handleUnaryCall<ListRetryAttemptsRequest, ListRetryAttemptsResponse>;
  runNow: handleUnaryCall<RunNowRequest, RunNowResponse>;
  getRetryJobStatus: handleUnaryCall<GetRetryJobStatusRequest, RetryJobResponse>;
  listRetryJobs: handleUnaryCall<ListRetryJobsRequest, ListRetryJobsResponse>;
  getRetryMetrics: handleUnaryCall<GetRetryMetricsRequest, RetryMetricsResponse>;
  getAuditLogs: handleUnaryCall<GetAuditLogsRequest, AuditLogsResponse>;
}

export interface RetrySchedulerServiceClient {
  processDueRetries(request: ProcessDueRetriesRequest, metadata?: Metadata): Observable<ProcessDueRetriesResponse>;

  checkEligibility(request: CheckEligibilityRequest, metadata?: Metadata): Observable<CheckEligibilityResponse>;

  handlePaymentRejected(request: PaymentRejectedEvent, metadata?: Metadata): Observable<HandleRejectionResponse>;
}

export interface RetrySchedulerServiceController {
  processDueRetries(
    request: ProcessDueRetriesRequest,
    metadata?: Metadata,
  ): Promise<ProcessDueRetriesResponse> | Observable<ProcessDueRetriesResponse> | ProcessDueRetriesResponse;

  checkEligibility(
    request: CheckEligibilityRequest,
    metadata?: Metadata,
  ): Promise<CheckEligibilityResponse> | Observable<CheckEligibilityResponse> | CheckEligibilityResponse;

  handlePaymentRejected(
    request: PaymentRejectedEvent,
    metadata?: Metadata,
  ): Promise<HandleRejectionResponse> | Observable<HandleRejectionResponse> | HandleRejectionResponse;
}

export function RetrySchedulerServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["processDueRetries", "checkEligibility", "handlePaymentRejected"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("RetrySchedulerService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("RetrySchedulerService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const RETRY_SCHEDULER_SERVICE_NAME = "RetrySchedulerService";

export type RetrySchedulerServiceService = typeof RetrySchedulerServiceService;
export const RetrySchedulerServiceService = {
  processDueRetries: {
    path: "/retry.RetrySchedulerService/ProcessDueRetries",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDueRetriesRequest): Buffer =>
      Buffer.from(ProcessDueRetriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessDueRetriesRequest => ProcessDueRetriesRequest.decode(value),
    responseSerialize: (value: ProcessDueRetriesResponse): Buffer =>
      Buffer.from(ProcessDueRetriesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessDueRetriesResponse => ProcessDueRetriesResponse.decode(value),
  },
  checkEligibility: {
    path: "/retry.RetrySchedulerService/CheckEligibility",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckEligibilityRequest): Buffer =>
      Buffer.from(CheckEligibilityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckEligibilityRequest => CheckEligibilityRequest.decode(value),
    responseSerialize: (value: CheckEligibilityResponse): Buffer =>
      Buffer.from(CheckEligibilityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckEligibilityResponse => CheckEligibilityResponse.decode(value),
  },
  handlePaymentRejected: {
    path: "/retry.RetrySchedulerService/HandlePaymentRejected",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentRejectedEvent): Buffer => Buffer.from(PaymentRejectedEvent.encode(value).finish()),
    requestDeserialize: (value: Buffer): PaymentRejectedEvent => PaymentRejectedEvent.decode(value),
    responseSerialize: (value: HandleRejectionResponse): Buffer =>
      Buffer.from(HandleRejectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HandleRejectionResponse => HandleRejectionResponse.decode(value),
  },
} as const;

export interface RetrySchedulerServiceServer extends UntypedServiceImplementation {
  processDueRetries: handleUnaryCall<ProcessDueRetriesRequest, ProcessDueRetriesResponse>;
  checkEligibility: handleUnaryCall<CheckEligibilityRequest, CheckEligibilityResponse>;
  handlePaymentRejected: handleUnaryCall<PaymentRejectedEvent, HandleRejectionResponse>;
}

export interface ReminderServiceClient {
  getReminderPolicy(request: GetReminderPolicyRequest, metadata?: Metadata): Observable<ReminderPolicyResponse>;

  listReminderPolicies(
    request: ListReminderPoliciesRequest,
    metadata?: Metadata,
  ): Observable<ListReminderPoliciesResponse>;

  createReminderPolicy(request: CreateReminderPolicyRequest, metadata?: Metadata): Observable<ReminderPolicyResponse>;

  updateReminderPolicy(request: UpdateReminderPolicyRequest, metadata?: Metadata): Observable<ReminderPolicyResponse>;

  deleteReminderPolicy(request: DeleteReminderPolicyRequest, metadata?: Metadata): Observable<DeleteResponse>;

  getReminder(request: GetReminderRequest, metadata?: Metadata): Observable<ReminderResponse>;

  listReminders(request: ListRemindersRequest, metadata?: Metadata): Observable<ListRemindersResponse>;

  cancelReminder(request: CancelReminderRequest, metadata?: Metadata): Observable<ReminderResponse>;

  sendReminder(request: SendReminderRequest, metadata?: Metadata): Observable<SendReminderResponse>;

  processDueReminders(
    request: ProcessDueRemindersRequest,
    metadata?: Metadata,
  ): Observable<ProcessDueRemindersResponse>;

  updateDeliveryStatus(request: UpdateDeliveryStatusRequest, metadata?: Metadata): Observable<ReminderResponse>;
}

export interface ReminderServiceController {
  getReminderPolicy(
    request: GetReminderPolicyRequest,
    metadata?: Metadata,
  ): Promise<ReminderPolicyResponse> | Observable<ReminderPolicyResponse> | ReminderPolicyResponse;

  listReminderPolicies(
    request: ListReminderPoliciesRequest,
    metadata?: Metadata,
  ): Promise<ListReminderPoliciesResponse> | Observable<ListReminderPoliciesResponse> | ListReminderPoliciesResponse;

  createReminderPolicy(
    request: CreateReminderPolicyRequest,
    metadata?: Metadata,
  ): Promise<ReminderPolicyResponse> | Observable<ReminderPolicyResponse> | ReminderPolicyResponse;

  updateReminderPolicy(
    request: UpdateReminderPolicyRequest,
    metadata?: Metadata,
  ): Promise<ReminderPolicyResponse> | Observable<ReminderPolicyResponse> | ReminderPolicyResponse;

  deleteReminderPolicy(
    request: DeleteReminderPolicyRequest,
    metadata?: Metadata,
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;

  getReminder(
    request: GetReminderRequest,
    metadata?: Metadata,
  ): Promise<ReminderResponse> | Observable<ReminderResponse> | ReminderResponse;

  listReminders(
    request: ListRemindersRequest,
    metadata?: Metadata,
  ): Promise<ListRemindersResponse> | Observable<ListRemindersResponse> | ListRemindersResponse;

  cancelReminder(
    request: CancelReminderRequest,
    metadata?: Metadata,
  ): Promise<ReminderResponse> | Observable<ReminderResponse> | ReminderResponse;

  sendReminder(
    request: SendReminderRequest,
    metadata?: Metadata,
  ): Promise<SendReminderResponse> | Observable<SendReminderResponse> | SendReminderResponse;

  processDueReminders(
    request: ProcessDueRemindersRequest,
    metadata?: Metadata,
  ): Promise<ProcessDueRemindersResponse> | Observable<ProcessDueRemindersResponse> | ProcessDueRemindersResponse;

  updateDeliveryStatus(
    request: UpdateDeliveryStatusRequest,
    metadata?: Metadata,
  ): Promise<ReminderResponse> | Observable<ReminderResponse> | ReminderResponse;
}

export function ReminderServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "getReminderPolicy",
      "listReminderPolicies",
      "createReminderPolicy",
      "updateReminderPolicy",
      "deleteReminderPolicy",
      "getReminder",
      "listReminders",
      "cancelReminder",
      "sendReminder",
      "processDueReminders",
      "updateDeliveryStatus",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ReminderService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ReminderService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const REMINDER_SERVICE_NAME = "ReminderService";

export type ReminderServiceService = typeof ReminderServiceService;
export const ReminderServiceService = {
  getReminderPolicy: {
    path: "/retry.ReminderService/GetReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReminderPolicyRequest): Buffer =>
      Buffer.from(GetReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReminderPolicyRequest => GetReminderPolicyRequest.decode(value),
    responseSerialize: (value: ReminderPolicyResponse): Buffer =>
      Buffer.from(ReminderPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderPolicyResponse => ReminderPolicyResponse.decode(value),
  },
  listReminderPolicies: {
    path: "/retry.ReminderService/ListReminderPolicies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListReminderPoliciesRequest): Buffer =>
      Buffer.from(ListReminderPoliciesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListReminderPoliciesRequest => ListReminderPoliciesRequest.decode(value),
    responseSerialize: (value: ListReminderPoliciesResponse): Buffer =>
      Buffer.from(ListReminderPoliciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListReminderPoliciesResponse => ListReminderPoliciesResponse.decode(value),
  },
  createReminderPolicy: {
    path: "/retry.ReminderService/CreateReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateReminderPolicyRequest): Buffer =>
      Buffer.from(CreateReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateReminderPolicyRequest => CreateReminderPolicyRequest.decode(value),
    responseSerialize: (value: ReminderPolicyResponse): Buffer =>
      Buffer.from(ReminderPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderPolicyResponse => ReminderPolicyResponse.decode(value),
  },
  updateReminderPolicy: {
    path: "/retry.ReminderService/UpdateReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateReminderPolicyRequest): Buffer =>
      Buffer.from(UpdateReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateReminderPolicyRequest => UpdateReminderPolicyRequest.decode(value),
    responseSerialize: (value: ReminderPolicyResponse): Buffer =>
      Buffer.from(ReminderPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderPolicyResponse => ReminderPolicyResponse.decode(value),
  },
  deleteReminderPolicy: {
    path: "/retry.ReminderService/DeleteReminderPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteReminderPolicyRequest): Buffer =>
      Buffer.from(DeleteReminderPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteReminderPolicyRequest => DeleteReminderPolicyRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
  getReminder: {
    path: "/retry.ReminderService/GetReminder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetReminderRequest): Buffer => Buffer.from(GetReminderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetReminderRequest => GetReminderRequest.decode(value),
    responseSerialize: (value: ReminderResponse): Buffer => Buffer.from(ReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderResponse => ReminderResponse.decode(value),
  },
  listReminders: {
    path: "/retry.ReminderService/ListReminders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRemindersRequest): Buffer => Buffer.from(ListRemindersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRemindersRequest => ListRemindersRequest.decode(value),
    responseSerialize: (value: ListRemindersResponse): Buffer =>
      Buffer.from(ListRemindersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRemindersResponse => ListRemindersResponse.decode(value),
  },
  cancelReminder: {
    path: "/retry.ReminderService/CancelReminder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelReminderRequest): Buffer =>
      Buffer.from(CancelReminderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelReminderRequest => CancelReminderRequest.decode(value),
    responseSerialize: (value: ReminderResponse): Buffer => Buffer.from(ReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderResponse => ReminderResponse.decode(value),
  },
  sendReminder: {
    path: "/retry.ReminderService/SendReminder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendReminderRequest): Buffer => Buffer.from(SendReminderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendReminderRequest => SendReminderRequest.decode(value),
    responseSerialize: (value: SendReminderResponse): Buffer =>
      Buffer.from(SendReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SendReminderResponse => SendReminderResponse.decode(value),
  },
  processDueReminders: {
    path: "/retry.ReminderService/ProcessDueReminders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessDueRemindersRequest): Buffer =>
      Buffer.from(ProcessDueRemindersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessDueRemindersRequest => ProcessDueRemindersRequest.decode(value),
    responseSerialize: (value: ProcessDueRemindersResponse): Buffer =>
      Buffer.from(ProcessDueRemindersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ProcessDueRemindersResponse => ProcessDueRemindersResponse.decode(value),
  },
  updateDeliveryStatus: {
    path: "/retry.ReminderService/UpdateDeliveryStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateDeliveryStatusRequest): Buffer =>
      Buffer.from(UpdateDeliveryStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateDeliveryStatusRequest => UpdateDeliveryStatusRequest.decode(value),
    responseSerialize: (value: ReminderResponse): Buffer => Buffer.from(ReminderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReminderResponse => ReminderResponse.decode(value),
  },
} as const;

export interface ReminderServiceServer extends UntypedServiceImplementation {
  getReminderPolicy: handleUnaryCall<GetReminderPolicyRequest, ReminderPolicyResponse>;
  listReminderPolicies: handleUnaryCall<ListReminderPoliciesRequest, ListReminderPoliciesResponse>;
  createReminderPolicy: handleUnaryCall<CreateReminderPolicyRequest, ReminderPolicyResponse>;
  updateReminderPolicy: handleUnaryCall<UpdateReminderPolicyRequest, ReminderPolicyResponse>;
  deleteReminderPolicy: handleUnaryCall<DeleteReminderPolicyRequest, DeleteResponse>;
  getReminder: handleUnaryCall<GetReminderRequest, ReminderResponse>;
  listReminders: handleUnaryCall<ListRemindersRequest, ListRemindersResponse>;
  cancelReminder: handleUnaryCall<CancelReminderRequest, ReminderResponse>;
  sendReminder: handleUnaryCall<SendReminderRequest, SendReminderResponse>;
  processDueReminders: handleUnaryCall<ProcessDueRemindersRequest, ProcessDueRemindersResponse>;
  updateDeliveryStatus: handleUnaryCall<UpdateDeliveryStatusRequest, ReminderResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
