// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: security/audit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleServerStreamingCall, handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "../google/protobuf/timestamp";

/** Audit result for logged actions */
export enum AuditResult {
  AUDIT_RESULT_UNSPECIFIED = 0,
  /** AUDIT_RESULT_ALLOWED - Action was allowed and executed */
  AUDIT_RESULT_ALLOWED = 1,
  /** AUDIT_RESULT_DENIED - Action was denied (authorization failed) */
  AUDIT_RESULT_DENIED = 2,
  /** AUDIT_RESULT_FAILED - Action failed (execution error) */
  AUDIT_RESULT_FAILED = 3,
}

/** Type of actor performing the action */
export enum ActorType {
  ACTOR_TYPE_UNSPECIFIED = 0,
  /** ACTOR_TYPE_USER - Human user */
  ACTOR_TYPE_USER = 1,
  /** ACTOR_TYPE_SERVICE - Service account or microservice */
  ACTOR_TYPE_SERVICE = 2,
  /** ACTOR_TYPE_SYSTEM - System/automated process */
  ACTOR_TYPE_SYSTEM = 3,
  /** ACTOR_TYPE_WEBHOOK - External webhook */
  ACTOR_TYPE_WEBHOOK = 4,
}

export enum ExportFormat {
  EXPORT_FORMAT_UNSPECIFIED = 0,
  EXPORT_FORMAT_JSON = 1,
  EXPORT_FORMAT_CSV = 2,
  EXPORT_FORMAT_PARQUET = 3,
}

/** Information about who performed the action */
export interface AuditActor {
  /** Type of actor */
  actorType: ActorType;
  /** User ID (if actor_type = USER) */
  userId: string;
  /** Keycloak subject ID (for correlation with IdP) */
  keycloakSub: string;
  /** Service name (if actor_type = SERVICE) */
  serviceName: string;
  /** Organisation/tenant context */
  organisationId: string;
  /** Break-glass session ID (if action performed under break-glass) */
  breakglassSessionId: string;
  /** User email (for display, may be redacted) */
  userEmail: string;
  /** IP address hash (SHA256 for privacy) */
  ipHash: string;
  /** User agent hash (SHA256 for privacy) */
  userAgentHash: string;
}

/** Information about the target of the action */
export interface AuditTarget {
  /** Type of target resource (e.g., "payment_intent", "user", "mandate") */
  targetType: string;
  /** ID of the target resource */
  targetId: string;
  /** Additional non-sensitive metadata about the target */
  targetMeta: { [key: string]: string };
}

export interface AuditTarget_TargetMetaEntry {
  key: string;
  value: string;
}

/** A single audit log entry */
export interface AuditLogEntry {
  /** Unique identifier (UUID) */
  id: string;
  /** When the action occurred */
  occurredAt?:
    | Timestamp
    | undefined;
  /** Trace ID for distributed tracing */
  requestId: string;
  /** Business correlation ID (e.g., payment flow ID) */
  correlationId: string;
  /** Who performed the action */
  actor?:
    | AuditActor
    | undefined;
  /** Action label (e.g., "payment.refund.create") */
  action: string;
  /** Permission that was evaluated */
  permission: string;
  /** Result of the action */
  result: AuditResult;
  /** Error message (if result = FAILED or DENIED) */
  errorMessage: string;
  /** What was the action performed on */
  target?:
    | AuditTarget
    | undefined;
  /** State before the action (JSON, encrypted if sensitive) */
  beforeJson: string;
  /** State after the action (JSON, encrypted if sensitive) */
  afterJson: string;
  /** Hash of the previous entry in the chain */
  prevHash: string;
  /** Hash of this entry (SHA256 of prev_hash + canonical entry) */
  entryHash: string;
  /** Additional non-sensitive metadata */
  meta: { [key: string]: string };
}

export interface AuditLogEntry_MetaEntry {
  key: string;
  value: string;
}

export interface WriteAuditRequest {
  /** The audit entry to write (id, prev_hash, entry_hash computed server-side) */
  entry?: AuditLogEntry | undefined;
}

export interface WriteAuditResponse {
  /** Whether the write succeeded */
  success: boolean;
  /** The computed entry hash (for verification) */
  persistedEntryHash: string;
  /** The assigned entry ID */
  entryId: string;
}

/** Batch write for high-throughput scenarios */
export interface BatchWriteAuditRequest {
  /** Entries to write (ordered, hashes computed server-side) */
  entries: AuditLogEntry[];
}

export interface BatchWriteAuditResponse {
  /** Number of entries successfully written */
  successCount: number;
  /** Number of entries that failed */
  failureCount: number;
  /** IDs of failed entries */
  failedEntryIds: string[];
  /** Hash of the last successfully written entry */
  lastEntryHash: string;
}

export interface ListAuditRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range */
  from?: Timestamp | undefined;
  to?:
    | Timestamp
    | undefined;
  /** Filters */
  actions: string[];
  actorUserIds: string[];
  results: AuditResult[];
  targetType: string;
  targetId: string;
  correlationId: string;
  requestId: string;
  /** Pagination */
  page: number;
  limit: number;
  /** Sort order (default: occurred_at DESC) */
  sortBy: string;
  sortOrder: string;
}

export interface ListAuditResponse {
  /** Audit entries matching the query */
  entries: AuditLogEntry[];
  /** Pagination info */
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface GetAuditEntryRequest {
  id: string;
  organisationId: string;
}

export interface GetAuditEntryResponse {
  entry?: AuditLogEntry | undefined;
}

export interface ExportAuditRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range (required for export) */
  from?: Timestamp | undefined;
  to?:
    | Timestamp
    | undefined;
  /** Output format */
  format: ExportFormat;
  /** Include hash chain proof data */
  includeChainProof: boolean;
  /** Filters (same as ListAuditRequest) */
  actions: string[];
  actorUserIds: string[];
}

export interface ExportAuditChunk {
  /** Chunk of export data */
  data: Uint8Array;
  /** Watermark ID (tracks who exported this data) */
  watermarkId: string;
  /** Chunk index (for reassembly) */
  chunkIndex: number;
  /** Total chunks */
  totalChunks: number;
  /** Is this the last chunk? */
  isLast: boolean;
}

export interface VerifyChainRequest {
  /** Required: tenant scope */
  organisationId: string;
  /** Time range to verify */
  from?: Timestamp | undefined;
  to?:
    | Timestamp
    | undefined;
  /** Optional: specific stream (default: "default") */
  stream: string;
}

export interface VerifyChainResponse {
  /** Whether the chain is valid */
  valid: boolean;
  /** First hash in the verified range */
  firstHash: string;
  /** Last hash in the verified range */
  lastHash: string;
  /** Number of entries verified */
  entriesChecked: number;
  /** If invalid: ID of first corrupted entry */
  corruptedEntryId: string;
  /** If invalid: description of the issue */
  corruptionDetails: string;
}

export interface GetChainHeadRequest {
  organisationId: string;
  stream: string;
}

export interface GetChainHeadResponse {
  organisationId: string;
  stream: string;
  lastEntryHash: string;
  entryCount: number;
  lastUpdatedAt?: Timestamp | undefined;
}

export interface CreateCheckpointRequest {
  organisationId: string;
  stream: string;
  /** If true, checkpoint is signed with KMS key */
  signCheckpoint: boolean;
}

export interface CreateCheckpointResponse {
  checkpointId: string;
  checkpointHash: string;
  signature: string;
  createdAt?: Timestamp | undefined;
  entryCount: number;
}

export interface VerifyCheckpointRequest {
  checkpointId: string;
}

export interface VerifyCheckpointResponse {
  valid: boolean;
  checkpointHash: string;
  signatureValid: boolean;
  checkpointCreatedAt?: Timestamp | undefined;
}

function createBaseAuditActor(): AuditActor {
  return {
    actorType: 0,
    userId: "",
    keycloakSub: "",
    serviceName: "",
    organisationId: "",
    breakglassSessionId: "",
    userEmail: "",
    ipHash: "",
    userAgentHash: "",
  };
}

export const AuditActor: MessageFns<AuditActor> = {
  encode(message: AuditActor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actorType !== 0) {
      writer.uint32(8).int32(message.actorType);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(26).string(message.keycloakSub);
    }
    if (message.serviceName !== "") {
      writer.uint32(34).string(message.serviceName);
    }
    if (message.organisationId !== "") {
      writer.uint32(42).string(message.organisationId);
    }
    if (message.breakglassSessionId !== "") {
      writer.uint32(50).string(message.breakglassSessionId);
    }
    if (message.userEmail !== "") {
      writer.uint32(58).string(message.userEmail);
    }
    if (message.ipHash !== "") {
      writer.uint32(66).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(74).string(message.userAgentHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditActor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditActor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actorType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.breakglassSessionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuditTarget(): AuditTarget {
  return { targetType: "", targetId: "", targetMeta: {} };
}

export const AuditTarget: MessageFns<AuditTarget> = {
  encode(message: AuditTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetType !== "") {
      writer.uint32(10).string(message.targetType);
    }
    if (message.targetId !== "") {
      writer.uint32(18).string(message.targetId);
    }
    globalThis.Object.entries(message.targetMeta).forEach(([key, value]: [string, string]) => {
      AuditTarget_TargetMetaEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = AuditTarget_TargetMetaEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.targetMeta[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuditTarget_TargetMetaEntry(): AuditTarget_TargetMetaEntry {
  return { key: "", value: "" };
}

export const AuditTarget_TargetMetaEntry: MessageFns<AuditTarget_TargetMetaEntry> = {
  encode(message: AuditTarget_TargetMetaEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditTarget_TargetMetaEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditTarget_TargetMetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuditLogEntry(): AuditLogEntry {
  return {
    id: "",
    requestId: "",
    correlationId: "",
    action: "",
    permission: "",
    result: 0,
    errorMessage: "",
    beforeJson: "",
    afterJson: "",
    prevHash: "",
    entryHash: "",
    meta: {},
  };
}

export const AuditLogEntry: MessageFns<AuditLogEntry> = {
  encode(message: AuditLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.occurredAt !== undefined) {
      Timestamp.encode(message.occurredAt, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.correlationId !== "") {
      writer.uint32(34).string(message.correlationId);
    }
    if (message.actor !== undefined) {
      AuditActor.encode(message.actor, writer.uint32(42).fork()).join();
    }
    if (message.action !== "") {
      writer.uint32(50).string(message.action);
    }
    if (message.permission !== "") {
      writer.uint32(58).string(message.permission);
    }
    if (message.result !== 0) {
      writer.uint32(64).int32(message.result);
    }
    if (message.errorMessage !== "") {
      writer.uint32(74).string(message.errorMessage);
    }
    if (message.target !== undefined) {
      AuditTarget.encode(message.target, writer.uint32(82).fork()).join();
    }
    if (message.beforeJson !== "") {
      writer.uint32(90).string(message.beforeJson);
    }
    if (message.afterJson !== "") {
      writer.uint32(98).string(message.afterJson);
    }
    if (message.prevHash !== "") {
      writer.uint32(106).string(message.prevHash);
    }
    if (message.entryHash !== "") {
      writer.uint32(114).string(message.entryHash);
    }
    globalThis.Object.entries(message.meta).forEach(([key, value]: [string, string]) => {
      AuditLogEntry_MetaEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.occurredAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.actor = AuditActor.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.permission = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.target = AuditTarget.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.beforeJson = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.afterJson = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.prevHash = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.entryHash = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = AuditLogEntry_MetaEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.meta[entry15.key] = entry15.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuditLogEntry_MetaEntry(): AuditLogEntry_MetaEntry {
  return { key: "", value: "" };
}

export const AuditLogEntry_MetaEntry: MessageFns<AuditLogEntry_MetaEntry> = {
  encode(message: AuditLogEntry_MetaEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLogEntry_MetaEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLogEntry_MetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWriteAuditRequest(): WriteAuditRequest {
  return {};
}

export const WriteAuditRequest: MessageFns<WriteAuditRequest> = {
  encode(message: WriteAuditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      AuditLogEntry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteAuditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry = AuditLogEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseWriteAuditResponse(): WriteAuditResponse {
  return { success: false, persistedEntryHash: "", entryId: "" };
}

export const WriteAuditResponse: MessageFns<WriteAuditResponse> = {
  encode(message: WriteAuditResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.persistedEntryHash !== "") {
      writer.uint32(18).string(message.persistedEntryHash);
    }
    if (message.entryId !== "") {
      writer.uint32(26).string(message.entryId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteAuditResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.persistedEntryHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entryId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchWriteAuditRequest(): BatchWriteAuditRequest {
  return { entries: [] };
}

export const BatchWriteAuditRequest: MessageFns<BatchWriteAuditRequest> = {
  encode(message: BatchWriteAuditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      AuditLogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchWriteAuditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchWriteAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchWriteAuditResponse(): BatchWriteAuditResponse {
  return { successCount: 0, failureCount: 0, failedEntryIds: [], lastEntryHash: "" };
}

export const BatchWriteAuditResponse: MessageFns<BatchWriteAuditResponse> = {
  encode(message: BatchWriteAuditResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.successCount !== 0) {
      writer.uint32(8).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(16).int32(message.failureCount);
    }
    for (const v of message.failedEntryIds) {
      writer.uint32(26).string(v!);
    }
    if (message.lastEntryHash !== "") {
      writer.uint32(34).string(message.lastEntryHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchWriteAuditResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchWriteAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.failedEntryIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastEntryHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListAuditRequest(): ListAuditRequest {
  return {
    organisationId: "",
    actions: [],
    actorUserIds: [],
    results: [],
    targetType: "",
    targetId: "",
    correlationId: "",
    requestId: "",
    page: 0,
    limit: 0,
    sortBy: "",
    sortOrder: "",
  };
}

export const ListAuditRequest: MessageFns<ListAuditRequest> = {
  encode(message: ListAuditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(message.from, writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(message.to, writer.uint32(26).fork()).join();
    }
    for (const v of message.actions) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.actorUserIds) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.results) {
      writer.int32(v);
    }
    writer.join();
    if (message.targetType !== "") {
      writer.uint32(58).string(message.targetType);
    }
    if (message.targetId !== "") {
      writer.uint32(66).string(message.targetId);
    }
    if (message.correlationId !== "") {
      writer.uint32(74).string(message.correlationId);
    }
    if (message.requestId !== "") {
      writer.uint32(82).string(message.requestId);
    }
    if (message.page !== 0) {
      writer.uint32(88).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(96).int32(message.limit);
    }
    if (message.sortBy !== "") {
      writer.uint32(106).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(114).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.actorUserIds.push(reader.string());
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.results.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.results.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.targetType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListAuditResponse(): ListAuditResponse {
  return { entries: [], total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const ListAuditResponse: MessageFns<ListAuditResponse> = {
  encode(message: ListAuditResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      AuditLogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(40).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuditResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(AuditLogEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuditEntryRequest(): GetAuditEntryRequest {
  return { id: "", organisationId: "" };
}

export const GetAuditEntryRequest: MessageFns<GetAuditEntryRequest> = {
  encode(message: GetAuditEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetAuditEntryResponse(): GetAuditEntryResponse {
  return {};
}

export const GetAuditEntryResponse: MessageFns<GetAuditEntryResponse> = {
  encode(message: GetAuditEntryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      AuditLogEntry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAuditEntryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditEntryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entry = AuditLogEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExportAuditRequest(): ExportAuditRequest {
  return { organisationId: "", format: 0, includeChainProof: false, actions: [], actorUserIds: [] };
}

export const ExportAuditRequest: MessageFns<ExportAuditRequest> = {
  encode(message: ExportAuditRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(message.from, writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(message.to, writer.uint32(26).fork()).join();
    }
    if (message.format !== 0) {
      writer.uint32(32).int32(message.format);
    }
    if (message.includeChainProof !== false) {
      writer.uint32(40).bool(message.includeChainProof);
    }
    for (const v of message.actions) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.actorUserIds) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportAuditRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAuditRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.includeChainProof = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.actorUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExportAuditChunk(): ExportAuditChunk {
  return { data: new Uint8Array(0), watermarkId: "", chunkIndex: 0, totalChunks: 0, isLast: false };
}

export const ExportAuditChunk: MessageFns<ExportAuditChunk> = {
  encode(message: ExportAuditChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.watermarkId !== "") {
      writer.uint32(18).string(message.watermarkId);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(24).int32(message.chunkIndex);
    }
    if (message.totalChunks !== 0) {
      writer.uint32(32).int32(message.totalChunks);
    }
    if (message.isLast !== false) {
      writer.uint32(40).bool(message.isLast);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportAuditChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAuditChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.watermarkId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalChunks = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isLast = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVerifyChainRequest(): VerifyChainRequest {
  return { organisationId: "", stream: "" };
}

export const VerifyChainRequest: MessageFns<VerifyChainRequest> = {
  encode(message: VerifyChainRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(message.from, writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(message.to, writer.uint32(26).fork()).join();
    }
    if (message.stream !== "") {
      writer.uint32(34).string(message.stream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyChainRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyChainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVerifyChainResponse(): VerifyChainResponse {
  return { valid: false, firstHash: "", lastHash: "", entriesChecked: 0, corruptedEntryId: "", corruptionDetails: "" };
}

export const VerifyChainResponse: MessageFns<VerifyChainResponse> = {
  encode(message: VerifyChainResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.firstHash !== "") {
      writer.uint32(18).string(message.firstHash);
    }
    if (message.lastHash !== "") {
      writer.uint32(26).string(message.lastHash);
    }
    if (message.entriesChecked !== 0) {
      writer.uint32(32).int64(message.entriesChecked);
    }
    if (message.corruptedEntryId !== "") {
      writer.uint32(42).string(message.corruptedEntryId);
    }
    if (message.corruptionDetails !== "") {
      writer.uint32(50).string(message.corruptionDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyChainResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyChainResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.entriesChecked = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.corruptedEntryId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.corruptionDetails = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetChainHeadRequest(): GetChainHeadRequest {
  return { organisationId: "", stream: "" };
}

export const GetChainHeadRequest: MessageFns<GetChainHeadRequest> = {
  encode(message: GetChainHeadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainHeadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainHeadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetChainHeadResponse(): GetChainHeadResponse {
  return { organisationId: "", stream: "", lastEntryHash: "", entryCount: 0 };
}

export const GetChainHeadResponse: MessageFns<GetChainHeadResponse> = {
  encode(message: GetChainHeadResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    if (message.lastEntryHash !== "") {
      writer.uint32(26).string(message.lastEntryHash);
    }
    if (message.entryCount !== 0) {
      writer.uint32(32).int64(message.entryCount);
    }
    if (message.lastUpdatedAt !== undefined) {
      Timestamp.encode(message.lastUpdatedAt, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainHeadResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainHeadResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastEntryHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.entryCount = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastUpdatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCheckpointRequest(): CreateCheckpointRequest {
  return { organisationId: "", stream: "", signCheckpoint: false };
}

export const CreateCheckpointRequest: MessageFns<CreateCheckpointRequest> = {
  encode(message: CreateCheckpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.stream !== "") {
      writer.uint32(18).string(message.stream);
    }
    if (message.signCheckpoint !== false) {
      writer.uint32(24).bool(message.signCheckpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signCheckpoint = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCheckpointResponse(): CreateCheckpointResponse {
  return { checkpointId: "", checkpointHash: "", signature: "", entryCount: 0 };
}

export const CreateCheckpointResponse: MessageFns<CreateCheckpointResponse> = {
  encode(message: CreateCheckpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkpointId !== "") {
      writer.uint32(10).string(message.checkpointId);
    }
    if (message.checkpointHash !== "") {
      writer.uint32(18).string(message.checkpointHash);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(34).fork()).join();
    }
    if (message.entryCount !== 0) {
      writer.uint32(40).int64(message.entryCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.checkpointId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkpointHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.entryCount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVerifyCheckpointRequest(): VerifyCheckpointRequest {
  return { checkpointId: "" };
}

export const VerifyCheckpointRequest: MessageFns<VerifyCheckpointRequest> = {
  encode(message: VerifyCheckpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkpointId !== "") {
      writer.uint32(10).string(message.checkpointId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyCheckpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.checkpointId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVerifyCheckpointResponse(): VerifyCheckpointResponse {
  return { valid: false, checkpointHash: "", signatureValid: false };
}

export const VerifyCheckpointResponse: MessageFns<VerifyCheckpointResponse> = {
  encode(message: VerifyCheckpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.checkpointHash !== "") {
      writer.uint32(18).string(message.checkpointHash);
    }
    if (message.signatureValid !== false) {
      writer.uint32(24).bool(message.signatureValid);
    }
    if (message.checkpointCreatedAt !== undefined) {
      Timestamp.encode(message.checkpointCreatedAt, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyCheckpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkpointHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signatureValid = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.checkpointCreatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface AuditServiceClient {
  /** Write a single audit entry */

  write(request: WriteAuditRequest, metadata?: Metadata): Observable<WriteAuditResponse>;

  /** Batch write audit entries */

  batchWrite(request: BatchWriteAuditRequest, metadata?: Metadata): Observable<BatchWriteAuditResponse>;

  /** Query audit entries */

  list(request: ListAuditRequest, metadata?: Metadata): Observable<ListAuditResponse>;

  /** Get a single audit entry */

  get(request: GetAuditEntryRequest, metadata?: Metadata): Observable<GetAuditEntryResponse>;

  /** Export audit entries (controlled, watermarked) */

  export(request: ExportAuditRequest, metadata?: Metadata): Observable<ExportAuditChunk>;

  /** Verify hash chain integrity */

  verifyChain(request: VerifyChainRequest, metadata?: Metadata): Observable<VerifyChainResponse>;

  /** Get current chain head */

  getChainHead(request: GetChainHeadRequest, metadata?: Metadata): Observable<GetChainHeadResponse>;

  /** Create a checkpoint (signed snapshot of chain state) */

  createCheckpoint(request: CreateCheckpointRequest, metadata?: Metadata): Observable<CreateCheckpointResponse>;

  /** Verify a checkpoint */

  verifyCheckpoint(request: VerifyCheckpointRequest, metadata?: Metadata): Observable<VerifyCheckpointResponse>;
}

export interface AuditServiceController {
  /** Write a single audit entry */

  write(
    request: WriteAuditRequest,
    metadata?: Metadata,
  ): Promise<WriteAuditResponse> | Observable<WriteAuditResponse> | WriteAuditResponse;

  /** Batch write audit entries */

  batchWrite(
    request: BatchWriteAuditRequest,
    metadata?: Metadata,
  ): Promise<BatchWriteAuditResponse> | Observable<BatchWriteAuditResponse> | BatchWriteAuditResponse;

  /** Query audit entries */

  list(
    request: ListAuditRequest,
    metadata?: Metadata,
  ): Promise<ListAuditResponse> | Observable<ListAuditResponse> | ListAuditResponse;

  /** Get a single audit entry */

  get(
    request: GetAuditEntryRequest,
    metadata?: Metadata,
  ): Promise<GetAuditEntryResponse> | Observable<GetAuditEntryResponse> | GetAuditEntryResponse;

  /** Export audit entries (controlled, watermarked) */

  export(request: ExportAuditRequest, metadata?: Metadata): Observable<ExportAuditChunk>;

  /** Verify hash chain integrity */

  verifyChain(
    request: VerifyChainRequest,
    metadata?: Metadata,
  ): Promise<VerifyChainResponse> | Observable<VerifyChainResponse> | VerifyChainResponse;

  /** Get current chain head */

  getChainHead(
    request: GetChainHeadRequest,
    metadata?: Metadata,
  ): Promise<GetChainHeadResponse> | Observable<GetChainHeadResponse> | GetChainHeadResponse;

  /** Create a checkpoint (signed snapshot of chain state) */

  createCheckpoint(
    request: CreateCheckpointRequest,
    metadata?: Metadata,
  ): Promise<CreateCheckpointResponse> | Observable<CreateCheckpointResponse> | CreateCheckpointResponse;

  /** Verify a checkpoint */

  verifyCheckpoint(
    request: VerifyCheckpointRequest,
    metadata?: Metadata,
  ): Promise<VerifyCheckpointResponse> | Observable<VerifyCheckpointResponse> | VerifyCheckpointResponse;
}

export function AuditServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "write",
      "batchWrite",
      "list",
      "get",
      "export",
      "verifyChain",
      "getChainHead",
      "createCheckpoint",
      "verifyCheckpoint",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AuditService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AuditService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const AUDIT_SERVICE_NAME = "AuditService";

export type AuditServiceService = typeof AuditServiceService;
export const AuditServiceService = {
  /** Write a single audit entry */
  write: {
    path: "/security.AuditService/Write",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WriteAuditRequest): Buffer => Buffer.from(WriteAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): WriteAuditRequest => WriteAuditRequest.decode(value),
    responseSerialize: (value: WriteAuditResponse): Buffer => Buffer.from(WriteAuditResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): WriteAuditResponse => WriteAuditResponse.decode(value),
  },
  /** Batch write audit entries */
  batchWrite: {
    path: "/security.AuditService/BatchWrite",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchWriteAuditRequest): Buffer =>
      Buffer.from(BatchWriteAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchWriteAuditRequest => BatchWriteAuditRequest.decode(value),
    responseSerialize: (value: BatchWriteAuditResponse): Buffer =>
      Buffer.from(BatchWriteAuditResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchWriteAuditResponse => BatchWriteAuditResponse.decode(value),
  },
  /** Query audit entries */
  list: {
    path: "/security.AuditService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAuditRequest): Buffer => Buffer.from(ListAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListAuditRequest => ListAuditRequest.decode(value),
    responseSerialize: (value: ListAuditResponse): Buffer => Buffer.from(ListAuditResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListAuditResponse => ListAuditResponse.decode(value),
  },
  /** Get a single audit entry */
  get: {
    path: "/security.AuditService/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAuditEntryRequest): Buffer => Buffer.from(GetAuditEntryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAuditEntryRequest => GetAuditEntryRequest.decode(value),
    responseSerialize: (value: GetAuditEntryResponse): Buffer =>
      Buffer.from(GetAuditEntryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAuditEntryResponse => GetAuditEntryResponse.decode(value),
  },
  /** Export audit entries (controlled, watermarked) */
  export: {
    path: "/security.AuditService/Export",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ExportAuditRequest): Buffer => Buffer.from(ExportAuditRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExportAuditRequest => ExportAuditRequest.decode(value),
    responseSerialize: (value: ExportAuditChunk): Buffer => Buffer.from(ExportAuditChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExportAuditChunk => ExportAuditChunk.decode(value),
  },
  /** Verify hash chain integrity */
  verifyChain: {
    path: "/security.AuditService/VerifyChain",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyChainRequest): Buffer => Buffer.from(VerifyChainRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyChainRequest => VerifyChainRequest.decode(value),
    responseSerialize: (value: VerifyChainResponse): Buffer => Buffer.from(VerifyChainResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyChainResponse => VerifyChainResponse.decode(value),
  },
  /** Get current chain head */
  getChainHead: {
    path: "/security.AuditService/GetChainHead",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetChainHeadRequest): Buffer => Buffer.from(GetChainHeadRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetChainHeadRequest => GetChainHeadRequest.decode(value),
    responseSerialize: (value: GetChainHeadResponse): Buffer =>
      Buffer.from(GetChainHeadResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetChainHeadResponse => GetChainHeadResponse.decode(value),
  },
  /** Create a checkpoint (signed snapshot of chain state) */
  createCheckpoint: {
    path: "/security.AuditService/CreateCheckpoint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCheckpointRequest): Buffer =>
      Buffer.from(CreateCheckpointRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCheckpointRequest => CreateCheckpointRequest.decode(value),
    responseSerialize: (value: CreateCheckpointResponse): Buffer =>
      Buffer.from(CreateCheckpointResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateCheckpointResponse => CreateCheckpointResponse.decode(value),
  },
  /** Verify a checkpoint */
  verifyCheckpoint: {
    path: "/security.AuditService/VerifyCheckpoint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyCheckpointRequest): Buffer =>
      Buffer.from(VerifyCheckpointRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyCheckpointRequest => VerifyCheckpointRequest.decode(value),
    responseSerialize: (value: VerifyCheckpointResponse): Buffer =>
      Buffer.from(VerifyCheckpointResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyCheckpointResponse => VerifyCheckpointResponse.decode(value),
  },
} as const;

export interface AuditServiceServer extends UntypedServiceImplementation {
  /** Write a single audit entry */
  write: handleUnaryCall<WriteAuditRequest, WriteAuditResponse>;
  /** Batch write audit entries */
  batchWrite: handleUnaryCall<BatchWriteAuditRequest, BatchWriteAuditResponse>;
  /** Query audit entries */
  list: handleUnaryCall<ListAuditRequest, ListAuditResponse>;
  /** Get a single audit entry */
  get: handleUnaryCall<GetAuditEntryRequest, GetAuditEntryResponse>;
  /** Export audit entries (controlled, watermarked) */
  export: handleServerStreamingCall<ExportAuditRequest, ExportAuditChunk>;
  /** Verify hash chain integrity */
  verifyChain: handleUnaryCall<VerifyChainRequest, VerifyChainResponse>;
  /** Get current chain head */
  getChainHead: handleUnaryCall<GetChainHeadRequest, GetChainHeadResponse>;
  /** Create a checkpoint (signed snapshot of chain state) */
  createCheckpoint: handleUnaryCall<CreateCheckpointRequest, CreateCheckpointResponse>;
  /** Verify a checkpoint */
  verifyCheckpoint: handleUnaryCall<VerifyCheckpointRequest, VerifyCheckpointResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
