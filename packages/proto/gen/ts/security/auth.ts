// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: security/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "../google/protobuf/timestamp";

/** Session status */
export enum SessionStatus {
  SESSION_STATUS_UNSPECIFIED = 0,
  SESSION_STATUS_ACTIVE = 1,
  SESSION_STATUS_REVOKED = 2,
  SESSION_STATUS_EXPIRED = 3,
  SESSION_STATUS_SUSPICIOUS = 4,
}

/** MFA method types */
export enum MfaMethod {
  MFA_METHOD_UNSPECIFIED = 0,
  MFA_METHOD_TOTP = 1,
  MFA_METHOD_WEBAUTHN = 2,
  MFA_METHOD_SMS = 3,
  MFA_METHOD_EMAIL = 4,
}

/** Break-glass session status */
export enum BreakglassStatus {
  BREAKGLASS_STATUS_UNSPECIFIED = 0,
  BREAKGLASS_STATUS_ACTIVE = 1,
  BREAKGLASS_STATUS_EXPIRED = 2,
  BREAKGLASS_STATUS_ENDED = 3,
  BREAKGLASS_STATUS_REVOKED = 4,
}

/** Auth session tracking */
export interface AuthSession {
  /** Session ID (from Keycloak sid claim) */
  sessionId: string;
  /** User ID in our system */
  userId: string;
  /** Keycloak subject ID */
  keycloakSub: string;
  /** Organisation context (if single-org session) */
  organisationId: string;
  /** Security metadata (hashed for privacy) */
  ipHash: string;
  userAgentHash: string;
  /** Timestamps */
  createdAt?: Timestamp | undefined;
  lastActivityAt?: Timestamp | undefined;
  expiresAt?:
    | Timestamp
    | undefined;
  /** MFA state */
  mfaVerifiedAt?: Timestamp | undefined;
  mfaMethod: MfaMethod;
  /** Session status */
  status: SessionStatus;
  /** Revocation info (if revoked) */
  revokedBy: string;
  revocationReason: string;
  revokedAt?: Timestamp | undefined;
}

/** Request to track a new session */
export interface TrackSessionRequest {
  sessionId: string;
  userId: string;
  keycloakSub: string;
  organisationId: string;
  ipHash: string;
  userAgentHash: string;
  expiresAt?: Timestamp | undefined;
  mfaVerifiedAt?: Timestamp | undefined;
  mfaMethod: MfaMethod;
}

export interface TrackSessionResponse {
  session?: AuthSession | undefined;
}

/** Request to update session activity */
export interface UpdateSessionActivityRequest {
  sessionId: string;
  ipHash: string;
  userAgentHash: string;
}

export interface UpdateSessionActivityResponse {
  session?:
    | AuthSession
    | undefined;
  /** True if session context changed significantly (IP/UA) */
  contextChanged: boolean;
}

/** Request to revoke a session */
export interface RevokeSessionRequest {
  sessionId: string;
  revokedBy: string;
  reason: string;
}

export interface RevokeSessionResponse {
  success: boolean;
}

/** Request to check session validity */
export interface CheckSessionRequest {
  sessionId: string;
}

export interface CheckSessionResponse {
  valid: boolean;
  session?:
    | AuthSession
    | undefined;
  /** If invalid, reason why */
  invalidReason: string;
}

/** List active sessions for a user */
export interface ListUserSessionsRequest {
  userId: string;
  includeRevoked: boolean;
}

export interface ListUserSessionsResponse {
  sessions: AuthSession[];
}

/** MFA device registration */
export interface MfaDevice {
  id: string;
  userId: string;
  method: MfaMethod;
  deviceName: string;
  registeredAt?: Timestamp | undefined;
  lastUsedAt?: Timestamp | undefined;
  isPrimary: boolean;
}

/** Record MFA verification */
export interface RecordMfaVerificationRequest {
  sessionId: string;
  userId: string;
  method: MfaMethod;
  success: boolean;
}

export interface RecordMfaVerificationResponse {
  recorded: boolean;
  mfaVerifiedAt?: Timestamp | undefined;
}

/** Check if MFA step-up is required */
export interface CheckStepUpRequest {
  sessionId: string;
  permission: string;
  requiredFreshnessSeconds: number;
}

export interface CheckStepUpResponse {
  stepUpRequired: boolean;
  mfaVerifiedAt?: Timestamp | undefined;
  secondsSinceMfa: number;
  stepUpUrl: string;
}

/** Break-glass session */
export interface BreakglassSession {
  id: string;
  organisationId: string;
  utilisateurId: string;
  /** Reason is encrypted at rest */
  reasonCiphertext: string;
  /** Ticket reference (e.g., JIRA ticket, incident ID) */
  ticketRef: string;
  /** Timestamps */
  startedAt?: Timestamp | undefined;
  expiresAt?: Timestamp | undefined;
  endedAt?:
    | Timestamp
    | undefined;
  /** Who ended the session (if manually ended) */
  endedByUserId: string;
  endReason: string;
  /** Status */
  status: BreakglassStatus;
  /** Permissions granted during break-glass */
  grantedPermissions: string[];
}

/** Activate break-glass session */
export interface ActivateBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
  reason: string;
  ticketRef: string;
  /** Duration in seconds (max 3600 = 1 hour) */
  ttlSeconds: number;
  /** Optional: specific permissions (default: SuperAdmin set) */
  requestedPermissions: string[];
}

export interface ActivateBreakglassResponse {
  session?: BreakglassSession | undefined;
}

/** Deactivate break-glass session */
export interface DeactivateBreakglassRequest {
  sessionId: string;
  endedByUserId: string;
  reason: string;
}

export interface DeactivateBreakglassResponse {
  session?: BreakglassSession | undefined;
}

/** Get active break-glass session for user */
export interface GetActiveBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
}

export interface GetActiveBreakglassResponse {
  /** Null if no active session */
  session?: BreakglassSession | undefined;
  hasActiveSession: boolean;
}

/** Check if break-glass is active for context */
export interface CheckBreakglassRequest {
  organisationId: string;
  utilisateurId: string;
}

export interface CheckBreakglassResponse {
  isActive: boolean;
  sessionId: string;
  expiresAt?: Timestamp | undefined;
  grantedPermissions: string[];
}

/** List break-glass sessions (for audit) */
export interface ListBreakglassSessionsRequest {
  organisationId: string;
  from?: Timestamp | undefined;
  to?: Timestamp | undefined;
  statuses: BreakglassStatus[];
  page: number;
  limit: number;
}

export interface ListBreakglassSessionsResponse {
  sessions: BreakglassSession[];
  total: number;
  page: number;
  limit: number;
}

/** Full access context for authorization decisions */
export interface AccessContext {
  /** User identity */
  userId: string;
  keycloakSub: string;
  /** Tenant context */
  organisationId: string;
  /** Roles and permissions */
  roles: string[];
  permissions: string[];
  /** Break-glass context (if active) */
  breakglassSessionId: string;
  breakglassPermissions: string[];
  /** MFA state */
  mfaVerifiedAt?: Timestamp | undefined;
  mfaMethod: MfaMethod;
  /** Session metadata */
  sessionId: string;
  ipHash: string;
  userAgentHash: string;
  /** Request context */
  requestId: string;
  correlationId: string;
}

/** Build access context from session */
export interface BuildAccessContextRequest {
  sessionId: string;
  organisationId: string;
}

export interface BuildAccessContextResponse {
  context?: AccessContext | undefined;
}

function createBaseAuthSession(): AuthSession {
  return {
    sessionId: "",
    userId: "",
    keycloakSub: "",
    organisationId: "",
    ipHash: "",
    userAgentHash: "",
    mfaMethod: 0,
    status: 0,
    revokedBy: "",
    revocationReason: "",
  };
}

export const AuthSession: MessageFns<AuthSession> = {
  encode(message: AuthSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(26).string(message.keycloakSub);
    }
    if (message.organisationId !== "") {
      writer.uint32(34).string(message.organisationId);
    }
    if (message.ipHash !== "") {
      writer.uint32(42).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(50).string(message.userAgentHash);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    if (message.lastActivityAt !== undefined) {
      Timestamp.encode(message.lastActivityAt, writer.uint32(66).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(message.expiresAt, writer.uint32(74).fork()).join();
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(message.mfaVerifiedAt, writer.uint32(82).fork()).join();
    }
    if (message.mfaMethod !== 0) {
      writer.uint32(88).int32(message.mfaMethod);
    }
    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    if (message.revokedBy !== "") {
      writer.uint32(106).string(message.revokedBy);
    }
    if (message.revocationReason !== "") {
      writer.uint32(114).string(message.revocationReason);
    }
    if (message.revokedAt !== undefined) {
      Timestamp.encode(message.revokedAt, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastActivityAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.expiresAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mfaVerifiedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.mfaMethod = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.revokedBy = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.revocationReason = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.revokedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTrackSessionRequest(): TrackSessionRequest {
  return {
    sessionId: "",
    userId: "",
    keycloakSub: "",
    organisationId: "",
    ipHash: "",
    userAgentHash: "",
    mfaMethod: 0,
  };
}

export const TrackSessionRequest: MessageFns<TrackSessionRequest> = {
  encode(message: TrackSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(26).string(message.keycloakSub);
    }
    if (message.organisationId !== "") {
      writer.uint32(34).string(message.organisationId);
    }
    if (message.ipHash !== "") {
      writer.uint32(42).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(50).string(message.userAgentHash);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(message.expiresAt, writer.uint32(58).fork()).join();
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(message.mfaVerifiedAt, writer.uint32(66).fork()).join();
    }
    if (message.mfaMethod !== 0) {
      writer.uint32(72).int32(message.mfaMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expiresAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mfaVerifiedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.mfaMethod = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTrackSessionResponse(): TrackSessionResponse {
  return {};
}

export const TrackSessionResponse: MessageFns<TrackSessionResponse> = {
  encode(message: TrackSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      AuthSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = AuthSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateSessionActivityRequest(): UpdateSessionActivityRequest {
  return { sessionId: "", ipHash: "", userAgentHash: "" };
}

export const UpdateSessionActivityRequest: MessageFns<UpdateSessionActivityRequest> = {
  encode(message: UpdateSessionActivityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.ipHash !== "") {
      writer.uint32(18).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(26).string(message.userAgentHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSessionActivityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionActivityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateSessionActivityResponse(): UpdateSessionActivityResponse {
  return { contextChanged: false };
}

export const UpdateSessionActivityResponse: MessageFns<UpdateSessionActivityResponse> = {
  encode(message: UpdateSessionActivityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      AuthSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.contextChanged !== false) {
      writer.uint32(16).bool(message.contextChanged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSessionActivityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionActivityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = AuthSession.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contextChanged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRevokeSessionRequest(): RevokeSessionRequest {
  return { sessionId: "", revokedBy: "", reason: "" };
}

export const RevokeSessionRequest: MessageFns<RevokeSessionRequest> = {
  encode(message: RevokeSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.revokedBy !== "") {
      writer.uint32(18).string(message.revokedBy);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.revokedBy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRevokeSessionResponse(): RevokeSessionResponse {
  return { success: false };
}

export const RevokeSessionResponse: MessageFns<RevokeSessionResponse> = {
  encode(message: RevokeSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckSessionRequest(): CheckSessionRequest {
  return { sessionId: "" };
}

export const CheckSessionRequest: MessageFns<CheckSessionRequest> = {
  encode(message: CheckSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckSessionResponse(): CheckSessionResponse {
  return { valid: false, invalidReason: "" };
}

export const CheckSessionResponse: MessageFns<CheckSessionResponse> = {
  encode(message: CheckSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.session !== undefined) {
      AuthSession.encode(message.session, writer.uint32(18).fork()).join();
    }
    if (message.invalidReason !== "") {
      writer.uint32(26).string(message.invalidReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.session = AuthSession.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invalidReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListUserSessionsRequest(): ListUserSessionsRequest {
  return { userId: "", includeRevoked: false };
}

export const ListUserSessionsRequest: MessageFns<ListUserSessionsRequest> = {
  encode(message: ListUserSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.includeRevoked !== false) {
      writer.uint32(16).bool(message.includeRevoked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeRevoked = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListUserSessionsResponse(): ListUserSessionsResponse {
  return { sessions: [] };
}

export const ListUserSessionsResponse: MessageFns<ListUserSessionsResponse> = {
  encode(message: ListUserSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      AuthSession.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(AuthSession.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMfaDevice(): MfaDevice {
  return { id: "", userId: "", method: 0, deviceName: "", isPrimary: false };
}

export const MfaDevice: MessageFns<MfaDevice> = {
  encode(message: MfaDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.method !== 0) {
      writer.uint32(24).int32(message.method);
    }
    if (message.deviceName !== "") {
      writer.uint32(34).string(message.deviceName);
    }
    if (message.registeredAt !== undefined) {
      Timestamp.encode(message.registeredAt, writer.uint32(42).fork()).join();
    }
    if (message.lastUsedAt !== undefined) {
      Timestamp.encode(message.lastUsedAt, writer.uint32(50).fork()).join();
    }
    if (message.isPrimary !== false) {
      writer.uint32(56).bool(message.isPrimary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MfaDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMfaDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.registeredAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastUsedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isPrimary = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRecordMfaVerificationRequest(): RecordMfaVerificationRequest {
  return { sessionId: "", userId: "", method: 0, success: false };
}

export const RecordMfaVerificationRequest: MessageFns<RecordMfaVerificationRequest> = {
  encode(message: RecordMfaVerificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.method !== 0) {
      writer.uint32(24).int32(message.method);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordMfaVerificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordMfaVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRecordMfaVerificationResponse(): RecordMfaVerificationResponse {
  return { recorded: false };
}

export const RecordMfaVerificationResponse: MessageFns<RecordMfaVerificationResponse> = {
  encode(message: RecordMfaVerificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recorded !== false) {
      writer.uint32(8).bool(message.recorded);
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(message.mfaVerifiedAt, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordMfaVerificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordMfaVerificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.recorded = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mfaVerifiedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckStepUpRequest(): CheckStepUpRequest {
  return { sessionId: "", permission: "", requiredFreshnessSeconds: 0 };
}

export const CheckStepUpRequest: MessageFns<CheckStepUpRequest> = {
  encode(message: CheckStepUpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.permission !== "") {
      writer.uint32(18).string(message.permission);
    }
    if (message.requiredFreshnessSeconds !== 0) {
      writer.uint32(24).int32(message.requiredFreshnessSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckStepUpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStepUpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permission = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.requiredFreshnessSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckStepUpResponse(): CheckStepUpResponse {
  return { stepUpRequired: false, secondsSinceMfa: 0, stepUpUrl: "" };
}

export const CheckStepUpResponse: MessageFns<CheckStepUpResponse> = {
  encode(message: CheckStepUpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stepUpRequired !== false) {
      writer.uint32(8).bool(message.stepUpRequired);
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(message.mfaVerifiedAt, writer.uint32(18).fork()).join();
    }
    if (message.secondsSinceMfa !== 0) {
      writer.uint32(24).int32(message.secondsSinceMfa);
    }
    if (message.stepUpUrl !== "") {
      writer.uint32(34).string(message.stepUpUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckStepUpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStepUpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stepUpRequired = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mfaVerifiedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.secondsSinceMfa = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stepUpUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBreakglassSession(): BreakglassSession {
  return {
    id: "",
    organisationId: "",
    utilisateurId: "",
    reasonCiphertext: "",
    ticketRef: "",
    endedByUserId: "",
    endReason: "",
    status: 0,
    grantedPermissions: [],
  };
}

export const BreakglassSession: MessageFns<BreakglassSession> = {
  encode(message: BreakglassSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(26).string(message.utilisateurId);
    }
    if (message.reasonCiphertext !== "") {
      writer.uint32(34).string(message.reasonCiphertext);
    }
    if (message.ticketRef !== "") {
      writer.uint32(42).string(message.ticketRef);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(message.startedAt, writer.uint32(50).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(message.expiresAt, writer.uint32(58).fork()).join();
    }
    if (message.endedAt !== undefined) {
      Timestamp.encode(message.endedAt, writer.uint32(66).fork()).join();
    }
    if (message.endedByUserId !== "") {
      writer.uint32(74).string(message.endedByUserId);
    }
    if (message.endReason !== "") {
      writer.uint32(82).string(message.endReason);
    }
    if (message.status !== 0) {
      writer.uint32(88).int32(message.status);
    }
    for (const v of message.grantedPermissions) {
      writer.uint32(98).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BreakglassSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakglassSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reasonCiphertext = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ticketRef = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.startedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expiresAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.endedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.endedByUserId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.endReason = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.grantedPermissions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseActivateBreakglassRequest(): ActivateBreakglassRequest {
  return { organisationId: "", utilisateurId: "", reason: "", ticketRef: "", ttlSeconds: 0, requestedPermissions: [] };
}

export const ActivateBreakglassRequest: MessageFns<ActivateBreakglassRequest> = {
  encode(message: ActivateBreakglassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.ticketRef !== "") {
      writer.uint32(34).string(message.ticketRef);
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(40).int32(message.ttlSeconds);
    }
    for (const v of message.requestedPermissions) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateBreakglassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ticketRef = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ttlSeconds = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requestedPermissions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseActivateBreakglassResponse(): ActivateBreakglassResponse {
  return {};
}

export const ActivateBreakglassResponse: MessageFns<ActivateBreakglassResponse> = {
  encode(message: ActivateBreakglassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      BreakglassSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateBreakglassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = BreakglassSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeactivateBreakglassRequest(): DeactivateBreakglassRequest {
  return { sessionId: "", endedByUserId: "", reason: "" };
}

export const DeactivateBreakglassRequest: MessageFns<DeactivateBreakglassRequest> = {
  encode(message: DeactivateBreakglassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.endedByUserId !== "") {
      writer.uint32(18).string(message.endedByUserId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeactivateBreakglassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeactivateBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endedByUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeactivateBreakglassResponse(): DeactivateBreakglassResponse {
  return {};
}

export const DeactivateBreakglassResponse: MessageFns<DeactivateBreakglassResponse> = {
  encode(message: DeactivateBreakglassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      BreakglassSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeactivateBreakglassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeactivateBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = BreakglassSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetActiveBreakglassRequest(): GetActiveBreakglassRequest {
  return { organisationId: "", utilisateurId: "" };
}

export const GetActiveBreakglassRequest: MessageFns<GetActiveBreakglassRequest> = {
  encode(message: GetActiveBreakglassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveBreakglassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetActiveBreakglassResponse(): GetActiveBreakglassResponse {
  return { hasActiveSession: false };
}

export const GetActiveBreakglassResponse: MessageFns<GetActiveBreakglassResponse> = {
  encode(message: GetActiveBreakglassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      BreakglassSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    if (message.hasActiveSession !== false) {
      writer.uint32(16).bool(message.hasActiveSession);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActiveBreakglassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActiveBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = BreakglassSession.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasActiveSession = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckBreakglassRequest(): CheckBreakglassRequest {
  return { organisationId: "", utilisateurId: "" };
}

export const CheckBreakglassRequest: MessageFns<CheckBreakglassRequest> = {
  encode(message: CheckBreakglassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.utilisateurId !== "") {
      writer.uint32(18).string(message.utilisateurId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckBreakglassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBreakglassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utilisateurId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckBreakglassResponse(): CheckBreakglassResponse {
  return { isActive: false, sessionId: "", grantedPermissions: [] };
}

export const CheckBreakglassResponse: MessageFns<CheckBreakglassResponse> = {
  encode(message: CheckBreakglassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(message.expiresAt, writer.uint32(26).fork()).join();
    }
    for (const v of message.grantedPermissions) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckBreakglassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckBreakglassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.expiresAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.grantedPermissions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListBreakglassSessionsRequest(): ListBreakglassSessionsRequest {
  return { organisationId: "", statuses: [], page: 0, limit: 0 };
}

export const ListBreakglassSessionsRequest: MessageFns<ListBreakglassSessionsRequest> = {
  encode(message: ListBreakglassSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(message.from, writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(message.to, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.page !== 0) {
      writer.uint32(40).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(48).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBreakglassSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBreakglassSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListBreakglassSessionsResponse(): ListBreakglassSessionsResponse {
  return { sessions: [], total: 0, page: 0, limit: 0 };
}

export const ListBreakglassSessionsResponse: MessageFns<ListBreakglassSessionsResponse> = {
  encode(message: ListBreakglassSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      BreakglassSession.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBreakglassSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBreakglassSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(BreakglassSession.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAccessContext(): AccessContext {
  return {
    userId: "",
    keycloakSub: "",
    organisationId: "",
    roles: [],
    permissions: [],
    breakglassSessionId: "",
    breakglassPermissions: [],
    mfaMethod: 0,
    sessionId: "",
    ipHash: "",
    userAgentHash: "",
    requestId: "",
    correlationId: "",
  };
}

export const AccessContext: MessageFns<AccessContext> = {
  encode(message: AccessContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.keycloakSub !== "") {
      writer.uint32(18).string(message.keycloakSub);
    }
    if (message.organisationId !== "") {
      writer.uint32(26).string(message.organisationId);
    }
    for (const v of message.roles) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.permissions) {
      writer.uint32(42).string(v!);
    }
    if (message.breakglassSessionId !== "") {
      writer.uint32(50).string(message.breakglassSessionId);
    }
    for (const v of message.breakglassPermissions) {
      writer.uint32(58).string(v!);
    }
    if (message.mfaVerifiedAt !== undefined) {
      Timestamp.encode(message.mfaVerifiedAt, writer.uint32(66).fork()).join();
    }
    if (message.mfaMethod !== 0) {
      writer.uint32(72).int32(message.mfaMethod);
    }
    if (message.sessionId !== "") {
      writer.uint32(82).string(message.sessionId);
    }
    if (message.ipHash !== "") {
      writer.uint32(90).string(message.ipHash);
    }
    if (message.userAgentHash !== "") {
      writer.uint32(98).string(message.userAgentHash);
    }
    if (message.requestId !== "") {
      writer.uint32(106).string(message.requestId);
    }
    if (message.correlationId !== "") {
      writer.uint32(114).string(message.correlationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keycloakSub = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.breakglassSessionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.breakglassPermissions.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mfaVerifiedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.mfaMethod = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userAgentHash = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBuildAccessContextRequest(): BuildAccessContextRequest {
  return { sessionId: "", organisationId: "" };
}

export const BuildAccessContextRequest: MessageFns<BuildAccessContextRequest> = {
  encode(message: BuildAccessContextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildAccessContextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildAccessContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBuildAccessContextResponse(): BuildAccessContextResponse {
  return {};
}

export const BuildAccessContextResponse: MessageFns<BuildAccessContextResponse> = {
  encode(message: BuildAccessContextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      AccessContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildAccessContextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildAccessContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = AccessContext.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ========== SESSION MANAGEMENT ========== */

export interface AuthServiceClient {
  trackSession(request: TrackSessionRequest, metadata?: Metadata): Observable<TrackSessionResponse>;

  updateSessionActivity(
    request: UpdateSessionActivityRequest,
    metadata?: Metadata,
  ): Observable<UpdateSessionActivityResponse>;

  revokeSession(request: RevokeSessionRequest, metadata?: Metadata): Observable<RevokeSessionResponse>;

  checkSession(request: CheckSessionRequest, metadata?: Metadata): Observable<CheckSessionResponse>;

  listUserSessions(request: ListUserSessionsRequest, metadata?: Metadata): Observable<ListUserSessionsResponse>;

  recordMfaVerification(
    request: RecordMfaVerificationRequest,
    metadata?: Metadata,
  ): Observable<RecordMfaVerificationResponse>;

  checkStepUp(request: CheckStepUpRequest, metadata?: Metadata): Observable<CheckStepUpResponse>;

  activateBreakglass(request: ActivateBreakglassRequest, metadata?: Metadata): Observable<ActivateBreakglassResponse>;

  deactivateBreakglass(
    request: DeactivateBreakglassRequest,
    metadata?: Metadata,
  ): Observable<DeactivateBreakglassResponse>;

  getActiveBreakglass(
    request: GetActiveBreakglassRequest,
    metadata?: Metadata,
  ): Observable<GetActiveBreakglassResponse>;

  checkBreakglass(request: CheckBreakglassRequest, metadata?: Metadata): Observable<CheckBreakglassResponse>;

  listBreakglassSessions(
    request: ListBreakglassSessionsRequest,
    metadata?: Metadata,
  ): Observable<ListBreakglassSessionsResponse>;

  buildAccessContext(request: BuildAccessContextRequest, metadata?: Metadata): Observable<BuildAccessContextResponse>;
}

/** ========== SESSION MANAGEMENT ========== */

export interface AuthServiceController {
  trackSession(
    request: TrackSessionRequest,
    metadata?: Metadata,
  ): Promise<TrackSessionResponse> | Observable<TrackSessionResponse> | TrackSessionResponse;

  updateSessionActivity(
    request: UpdateSessionActivityRequest,
    metadata?: Metadata,
  ): Promise<UpdateSessionActivityResponse> | Observable<UpdateSessionActivityResponse> | UpdateSessionActivityResponse;

  revokeSession(
    request: RevokeSessionRequest,
    metadata?: Metadata,
  ): Promise<RevokeSessionResponse> | Observable<RevokeSessionResponse> | RevokeSessionResponse;

  checkSession(
    request: CheckSessionRequest,
    metadata?: Metadata,
  ): Promise<CheckSessionResponse> | Observable<CheckSessionResponse> | CheckSessionResponse;

  listUserSessions(
    request: ListUserSessionsRequest,
    metadata?: Metadata,
  ): Promise<ListUserSessionsResponse> | Observable<ListUserSessionsResponse> | ListUserSessionsResponse;

  recordMfaVerification(
    request: RecordMfaVerificationRequest,
    metadata?: Metadata,
  ): Promise<RecordMfaVerificationResponse> | Observable<RecordMfaVerificationResponse> | RecordMfaVerificationResponse;

  checkStepUp(
    request: CheckStepUpRequest,
    metadata?: Metadata,
  ): Promise<CheckStepUpResponse> | Observable<CheckStepUpResponse> | CheckStepUpResponse;

  activateBreakglass(
    request: ActivateBreakglassRequest,
    metadata?: Metadata,
  ): Promise<ActivateBreakglassResponse> | Observable<ActivateBreakglassResponse> | ActivateBreakglassResponse;

  deactivateBreakglass(
    request: DeactivateBreakglassRequest,
    metadata?: Metadata,
  ): Promise<DeactivateBreakglassResponse> | Observable<DeactivateBreakglassResponse> | DeactivateBreakglassResponse;

  getActiveBreakglass(
    request: GetActiveBreakglassRequest,
    metadata?: Metadata,
  ): Promise<GetActiveBreakglassResponse> | Observable<GetActiveBreakglassResponse> | GetActiveBreakglassResponse;

  checkBreakglass(
    request: CheckBreakglassRequest,
    metadata?: Metadata,
  ): Promise<CheckBreakglassResponse> | Observable<CheckBreakglassResponse> | CheckBreakglassResponse;

  listBreakglassSessions(
    request: ListBreakglassSessionsRequest,
    metadata?: Metadata,
  ):
    | Promise<ListBreakglassSessionsResponse>
    | Observable<ListBreakglassSessionsResponse>
    | ListBreakglassSessionsResponse;

  buildAccessContext(
    request: BuildAccessContextRequest,
    metadata?: Metadata,
  ): Promise<BuildAccessContextResponse> | Observable<BuildAccessContextResponse> | BuildAccessContextResponse;
}

export function AuthServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "trackSession",
      "updateSessionActivity",
      "revokeSession",
      "checkSession",
      "listUserSessions",
      "recordMfaVerification",
      "checkStepUp",
      "activateBreakglass",
      "deactivateBreakglass",
      "getActiveBreakglass",
      "checkBreakglass",
      "listBreakglassSessions",
      "buildAccessContext",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const AUTH_SERVICE_NAME = "AuthService";

/** ========== SESSION MANAGEMENT ========== */
export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  trackSession: {
    path: "/security.AuthService/TrackSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TrackSessionRequest): Buffer => Buffer.from(TrackSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TrackSessionRequest => TrackSessionRequest.decode(value),
    responseSerialize: (value: TrackSessionResponse): Buffer =>
      Buffer.from(TrackSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TrackSessionResponse => TrackSessionResponse.decode(value),
  },
  updateSessionActivity: {
    path: "/security.AuthService/UpdateSessionActivity",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSessionActivityRequest): Buffer =>
      Buffer.from(UpdateSessionActivityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSessionActivityRequest => UpdateSessionActivityRequest.decode(value),
    responseSerialize: (value: UpdateSessionActivityResponse): Buffer =>
      Buffer.from(UpdateSessionActivityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateSessionActivityResponse => UpdateSessionActivityResponse.decode(value),
  },
  revokeSession: {
    path: "/security.AuthService/RevokeSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RevokeSessionRequest): Buffer => Buffer.from(RevokeSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RevokeSessionRequest => RevokeSessionRequest.decode(value),
    responseSerialize: (value: RevokeSessionResponse): Buffer =>
      Buffer.from(RevokeSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RevokeSessionResponse => RevokeSessionResponse.decode(value),
  },
  checkSession: {
    path: "/security.AuthService/CheckSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckSessionRequest): Buffer => Buffer.from(CheckSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckSessionRequest => CheckSessionRequest.decode(value),
    responseSerialize: (value: CheckSessionResponse): Buffer =>
      Buffer.from(CheckSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckSessionResponse => CheckSessionResponse.decode(value),
  },
  listUserSessions: {
    path: "/security.AuthService/ListUserSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListUserSessionsRequest): Buffer =>
      Buffer.from(ListUserSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListUserSessionsRequest => ListUserSessionsRequest.decode(value),
    responseSerialize: (value: ListUserSessionsResponse): Buffer =>
      Buffer.from(ListUserSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListUserSessionsResponse => ListUserSessionsResponse.decode(value),
  },
  recordMfaVerification: {
    path: "/security.AuthService/RecordMfaVerification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RecordMfaVerificationRequest): Buffer =>
      Buffer.from(RecordMfaVerificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RecordMfaVerificationRequest => RecordMfaVerificationRequest.decode(value),
    responseSerialize: (value: RecordMfaVerificationResponse): Buffer =>
      Buffer.from(RecordMfaVerificationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RecordMfaVerificationResponse => RecordMfaVerificationResponse.decode(value),
  },
  checkStepUp: {
    path: "/security.AuthService/CheckStepUp",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckStepUpRequest): Buffer => Buffer.from(CheckStepUpRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckStepUpRequest => CheckStepUpRequest.decode(value),
    responseSerialize: (value: CheckStepUpResponse): Buffer => Buffer.from(CheckStepUpResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckStepUpResponse => CheckStepUpResponse.decode(value),
  },
  activateBreakglass: {
    path: "/security.AuthService/ActivateBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ActivateBreakglassRequest): Buffer =>
      Buffer.from(ActivateBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ActivateBreakglassRequest => ActivateBreakglassRequest.decode(value),
    responseSerialize: (value: ActivateBreakglassResponse): Buffer =>
      Buffer.from(ActivateBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ActivateBreakglassResponse => ActivateBreakglassResponse.decode(value),
  },
  deactivateBreakglass: {
    path: "/security.AuthService/DeactivateBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeactivateBreakglassRequest): Buffer =>
      Buffer.from(DeactivateBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeactivateBreakglassRequest => DeactivateBreakglassRequest.decode(value),
    responseSerialize: (value: DeactivateBreakglassResponse): Buffer =>
      Buffer.from(DeactivateBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeactivateBreakglassResponse => DeactivateBreakglassResponse.decode(value),
  },
  getActiveBreakglass: {
    path: "/security.AuthService/GetActiveBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetActiveBreakglassRequest): Buffer =>
      Buffer.from(GetActiveBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetActiveBreakglassRequest => GetActiveBreakglassRequest.decode(value),
    responseSerialize: (value: GetActiveBreakglassResponse): Buffer =>
      Buffer.from(GetActiveBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetActiveBreakglassResponse => GetActiveBreakglassResponse.decode(value),
  },
  checkBreakglass: {
    path: "/security.AuthService/CheckBreakglass",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckBreakglassRequest): Buffer =>
      Buffer.from(CheckBreakglassRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckBreakglassRequest => CheckBreakglassRequest.decode(value),
    responseSerialize: (value: CheckBreakglassResponse): Buffer =>
      Buffer.from(CheckBreakglassResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckBreakglassResponse => CheckBreakglassResponse.decode(value),
  },
  listBreakglassSessions: {
    path: "/security.AuthService/ListBreakglassSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListBreakglassSessionsRequest): Buffer =>
      Buffer.from(ListBreakglassSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListBreakglassSessionsRequest => ListBreakglassSessionsRequest.decode(value),
    responseSerialize: (value: ListBreakglassSessionsResponse): Buffer =>
      Buffer.from(ListBreakglassSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListBreakglassSessionsResponse =>
      ListBreakglassSessionsResponse.decode(value),
  },
  buildAccessContext: {
    path: "/security.AuthService/BuildAccessContext",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BuildAccessContextRequest): Buffer =>
      Buffer.from(BuildAccessContextRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BuildAccessContextRequest => BuildAccessContextRequest.decode(value),
    responseSerialize: (value: BuildAccessContextResponse): Buffer =>
      Buffer.from(BuildAccessContextResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BuildAccessContextResponse => BuildAccessContextResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  trackSession: handleUnaryCall<TrackSessionRequest, TrackSessionResponse>;
  updateSessionActivity: handleUnaryCall<UpdateSessionActivityRequest, UpdateSessionActivityResponse>;
  revokeSession: handleUnaryCall<RevokeSessionRequest, RevokeSessionResponse>;
  checkSession: handleUnaryCall<CheckSessionRequest, CheckSessionResponse>;
  listUserSessions: handleUnaryCall<ListUserSessionsRequest, ListUserSessionsResponse>;
  recordMfaVerification: handleUnaryCall<RecordMfaVerificationRequest, RecordMfaVerificationResponse>;
  checkStepUp: handleUnaryCall<CheckStepUpRequest, CheckStepUpResponse>;
  activateBreakglass: handleUnaryCall<ActivateBreakglassRequest, ActivateBreakglassResponse>;
  deactivateBreakglass: handleUnaryCall<DeactivateBreakglassRequest, DeactivateBreakglassResponse>;
  getActiveBreakglass: handleUnaryCall<GetActiveBreakglassRequest, GetActiveBreakglassResponse>;
  checkBreakglass: handleUnaryCall<CheckBreakglassRequest, CheckBreakglassResponse>;
  listBreakglassSessions: handleUnaryCall<ListBreakglassSessionsRequest, ListBreakglassSessionsResponse>;
  buildAccessContext: handleUnaryCall<BuildAccessContextRequest, BuildAccessContextResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
