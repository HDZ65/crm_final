// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: security/crypto.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "../google/protobuf/timestamp";

/** Key domain for segmentation */
export enum KeyDomain {
  KEY_DOMAIN_UNSPECIFIED = 0,
  /** KEY_DOMAIN_PII - Personal Identifiable Information */
  KEY_DOMAIN_PII = 1,
  /** KEY_DOMAIN_PAYMENT - Payment-related data */
  KEY_DOMAIN_PAYMENT = 2,
  /** KEY_DOMAIN_AUDIT_SIGNING - Audit log signing */
  KEY_DOMAIN_AUDIT_SIGNING = 3,
  /** KEY_DOMAIN_SECRETS - General secrets */
  KEY_DOMAIN_SECRETS = 4,
}

/** Key status */
export enum KeyStatus {
  KEY_STATUS_UNSPECIFIED = 0,
  /** KEY_STATUS_ACTIVE - Key is active for encryption and decryption */
  KEY_STATUS_ACTIVE = 1,
  /** KEY_STATUS_DECRYPT_ONLY - Key is only valid for decryption (deprecated) */
  KEY_STATUS_DECRYPT_ONLY = 2,
  /** KEY_STATUS_PENDING_DELETION - Key is scheduled for deletion */
  KEY_STATUS_PENDING_DELETION = 3,
  /** KEY_STATUS_DESTROYED - Key has been deleted/destroyed */
  KEY_STATUS_DESTROYED = 4,
}

export enum BlindIndexType {
  BLIND_INDEX_TYPE_UNSPECIFIED = 0,
  /** BLIND_INDEX_TYPE_EMAIL - Email: lowercase, trim */
  BLIND_INDEX_TYPE_EMAIL = 1,
  /** BLIND_INDEX_TYPE_PHONE - Phone: digits only, normalized */
  BLIND_INDEX_TYPE_PHONE = 2,
  /** BLIND_INDEX_TYPE_IBAN - IBAN: uppercase, no spaces */
  BLIND_INDEX_TYPE_IBAN = 3,
  /** BLIND_INDEX_TYPE_GENERIC - Generic: as-is */
  BLIND_INDEX_TYPE_GENERIC = 4,
}

/** Data Encryption Key (DEK) metadata */
export interface DataKey {
  id: string;
  /** Which domain this key belongs to */
  domain: KeyDomain;
  /** Key version (incrementing) */
  version: number;
  /** Environment (dev, staging, prod) */
  environment: string;
  /** Status */
  status: KeyStatus;
  /** Algorithm (e.g., AES-256-GCM) */
  algorithm: string;
  /** Timestamps */
  createdAt?: Timestamp | undefined;
  activatedAt?: Timestamp | undefined;
  deprecatedAt?: Timestamp | undefined;
  scheduledDeletionAt?:
    | Timestamp
    | undefined;
  /** Created by */
  createdBy: string;
  /** Is this the current active key for encryption? */
  isCurrent: boolean;
}

/** Encrypted field metadata (stored alongside ciphertext) */
export interface EncryptedFieldMeta {
  /** Key version used for encryption */
  keyVersion: number;
  /** Key domain */
  domain: KeyDomain;
  /** Algorithm (e.g., AES-256-GCM) */
  algorithm: string;
  /** Nonce/IV (base64 encoded) */
  nonce: Uint8Array;
  /** Additional authenticated data (optional) */
  aad: Uint8Array;
  /** Timestamp of encryption */
  encryptedAt?: Timestamp | undefined;
}

/** Encrypt a value */
export interface EncryptRequest {
  /** Plaintext to encrypt (bytes) */
  plaintext: Uint8Array;
  /** Key domain to use */
  domain: KeyDomain;
  /** Optional: additional authenticated data */
  aad: Uint8Array;
  /** Context (for audit/logging) */
  context: string;
}

export interface EncryptResponse {
  /** Ciphertext (bytes) */
  ciphertext: Uint8Array;
  /** Metadata about the encryption */
  meta?: EncryptedFieldMeta | undefined;
}

/** Decrypt a value */
export interface DecryptRequest {
  /** Ciphertext to decrypt */
  ciphertext: Uint8Array;
  /** Encryption metadata */
  meta?:
    | EncryptedFieldMeta
    | undefined;
  /** Context (for audit/logging) */
  context: string;
}

export interface DecryptResponse {
  /** Decrypted plaintext */
  plaintext: Uint8Array;
}

/** Batch encrypt multiple values */
export interface BatchEncryptRequest {
  items: BatchEncryptRequest_Item[];
  domain: KeyDomain;
  context: string;
}

export interface BatchEncryptRequest_Item {
  id: string;
  plaintext: Uint8Array;
  aad: Uint8Array;
}

export interface BatchEncryptResponse {
  items: BatchEncryptResponse_EncryptedItem[];
  successCount: number;
  failureCount: number;
}

export interface BatchEncryptResponse_EncryptedItem {
  id: string;
  ciphertext: Uint8Array;
  meta?: EncryptedFieldMeta | undefined;
  error: string;
}

/** Batch decrypt multiple values */
export interface BatchDecryptRequest {
  items: BatchDecryptRequest_Item[];
  context: string;
}

export interface BatchDecryptRequest_Item {
  id: string;
  ciphertext: Uint8Array;
  meta?: EncryptedFieldMeta | undefined;
}

export interface BatchDecryptResponse {
  items: BatchDecryptResponse_DecryptedItem[];
  successCount: number;
  failureCount: number;
}

export interface BatchDecryptResponse_DecryptedItem {
  id: string;
  plaintext: Uint8Array;
  error: string;
}

/** Re-encrypt with new key version (for key rotation) */
export interface ReencryptRequest {
  ciphertext: Uint8Array;
  currentMeta?: EncryptedFieldMeta | undefined;
  context: string;
}

export interface ReencryptResponse {
  ciphertext: Uint8Array;
  newMeta?: EncryptedFieldMeta | undefined;
  keyVersionChanged: boolean;
}

/** Generate blind index for searchable encryption */
export interface GenerateBlindIndexRequest {
  /** Value to index (will be normalized) */
  value: string;
  /** Index type (affects normalization) */
  indexType: BlindIndexType;
  /** Key domain for HMAC key */
  domain: KeyDomain;
}

export interface GenerateBlindIndexResponse {
  /** Blind index (HMAC-SHA256, hex encoded) */
  blindIndex: Uint8Array;
  /** Key version used */
  keyVersion: number;
}

/** Batch generate blind indexes */
export interface BatchGenerateBlindIndexRequest {
  items: BatchGenerateBlindIndexRequest_Item[];
  indexType: BlindIndexType;
  domain: KeyDomain;
}

export interface BatchGenerateBlindIndexRequest_Item {
  id: string;
  value: string;
}

export interface BatchGenerateBlindIndexResponse {
  items: BatchGenerateBlindIndexResponse_IndexedItem[];
  keyVersion: number;
}

export interface BatchGenerateBlindIndexResponse_IndexedItem {
  id: string;
  blindIndex: Uint8Array;
  error: string;
}

/** List available keys */
export interface ListKeysRequest {
  domain: KeyDomain;
  environment: string;
  includeDeprecated: boolean;
}

export interface ListKeysResponse {
  keys: DataKey[];
}

/** Get current active key for a domain */
export interface GetCurrentKeyRequest {
  domain: KeyDomain;
  environment: string;
}

export interface GetCurrentKeyResponse {
  key?: DataKey | undefined;
}

/** Rotate key (create new version) */
export interface RotateKeyRequest {
  domain: KeyDomain;
  environment: string;
  reason: string;
}

export interface RotateKeyResponse {
  newKey?: DataKey | undefined;
  oldKey?: DataKey | undefined;
}

/** Schedule key deletion */
export interface ScheduleKeyDeletionRequest {
  keyId: string;
  pendingDays: number;
  reason: string;
}

export interface ScheduleKeyDeletionResponse {
  key?: DataKey | undefined;
}

/** Cancel scheduled deletion */
export interface CancelKeyDeletionRequest {
  keyId: string;
  reason: string;
}

export interface CancelKeyDeletionResponse {
  key?: DataKey | undefined;
}

/** Sign data */
export interface SignRequest {
  data: Uint8Array;
  domain: KeyDomain;
  context: string;
}

export interface SignResponse {
  signature: Uint8Array;
  keyVersion: number;
  algorithm: string;
}

/** Verify signature */
export interface VerifyRequest {
  data: Uint8Array;
  signature: Uint8Array;
  keyVersion: number;
  domain: KeyDomain;
}

export interface VerifyResponse {
  valid: boolean;
}

function createBaseDataKey(): DataKey {
  return { id: "", domain: 0, version: 0, environment: "", status: 0, algorithm: "", createdBy: "", isCurrent: false };
}

export const DataKey: MessageFns<DataKey> = {
  encode(message: DataKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.version !== 0) {
      writer.uint32(24).int32(message.version);
    }
    if (message.environment !== "") {
      writer.uint32(34).string(message.environment);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.algorithm !== "") {
      writer.uint32(50).string(message.algorithm);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(58).fork()).join();
    }
    if (message.activatedAt !== undefined) {
      Timestamp.encode(message.activatedAt, writer.uint32(66).fork()).join();
    }
    if (message.deprecatedAt !== undefined) {
      Timestamp.encode(message.deprecatedAt, writer.uint32(74).fork()).join();
    }
    if (message.scheduledDeletionAt !== undefined) {
      Timestamp.encode(message.scheduledDeletionAt, writer.uint32(82).fork()).join();
    }
    if (message.createdBy !== "") {
      writer.uint32(90).string(message.createdBy);
    }
    if (message.isCurrent !== false) {
      writer.uint32(96).bool(message.isCurrent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.activatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.deprecatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.scheduledDeletionAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isCurrent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEncryptedFieldMeta(): EncryptedFieldMeta {
  return { keyVersion: 0, domain: 0, algorithm: "", nonce: new Uint8Array(0), aad: new Uint8Array(0) };
}

export const EncryptedFieldMeta: MessageFns<EncryptedFieldMeta> = {
  encode(message: EncryptedFieldMeta, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyVersion !== 0) {
      writer.uint32(8).int32(message.keyVersion);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(34).bytes(message.nonce);
    }
    if (message.aad.length !== 0) {
      writer.uint32(42).bytes(message.aad);
    }
    if (message.encryptedAt !== undefined) {
      Timestamp.encode(message.encryptedAt, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedFieldMeta {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedFieldMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aad = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encryptedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEncryptRequest(): EncryptRequest {
  return { plaintext: new Uint8Array(0), domain: 0, aad: new Uint8Array(0), context: "" };
}

export const EncryptRequest: MessageFns<EncryptRequest> = {
  encode(message: EncryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.aad.length !== 0) {
      writer.uint32(26).bytes(message.aad);
    }
    if (message.context !== "") {
      writer.uint32(34).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aad = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEncryptResponse(): EncryptResponse {
  return { ciphertext: new Uint8Array(0) };
}

export const EncryptResponse: MessageFns<EncryptResponse> = {
  encode(message: EncryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDecryptRequest(): DecryptRequest {
  return { ciphertext: new Uint8Array(0), context: "" };
}

export const DecryptRequest: MessageFns<DecryptRequest> = {
  encode(message: DecryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(18).fork()).join();
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDecryptResponse(): DecryptResponse {
  return { plaintext: new Uint8Array(0) };
}

export const DecryptResponse: MessageFns<DecryptResponse> = {
  encode(message: DecryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DecryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchEncryptRequest(): BatchEncryptRequest {
  return { items: [], domain: 0, context: "" };
}

export const BatchEncryptRequest: MessageFns<BatchEncryptRequest> = {
  encode(message: BatchEncryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchEncryptRequest_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchEncryptRequest_Item.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchEncryptRequest_Item(): BatchEncryptRequest_Item {
  return { id: "", plaintext: new Uint8Array(0), aad: new Uint8Array(0) };
}

export const BatchEncryptRequest_Item: MessageFns<BatchEncryptRequest_Item> = {
  encode(message: BatchEncryptRequest_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.plaintext.length !== 0) {
      writer.uint32(18).bytes(message.plaintext);
    }
    if (message.aad.length !== 0) {
      writer.uint32(26).bytes(message.aad);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptRequest_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptRequest_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aad = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchEncryptResponse(): BatchEncryptResponse {
  return { items: [], successCount: 0, failureCount: 0 };
}

export const BatchEncryptResponse: MessageFns<BatchEncryptResponse> = {
  encode(message: BatchEncryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchEncryptResponse_EncryptedItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(24).int32(message.failureCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchEncryptResponse_EncryptedItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchEncryptResponse_EncryptedItem(): BatchEncryptResponse_EncryptedItem {
  return { id: "", ciphertext: new Uint8Array(0), error: "" };
}

export const BatchEncryptResponse_EncryptedItem: MessageFns<BatchEncryptResponse_EncryptedItem> = {
  encode(message: BatchEncryptResponse_EncryptedItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(26).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchEncryptResponse_EncryptedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchEncryptResponse_EncryptedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchDecryptRequest(): BatchDecryptRequest {
  return { items: [], context: "" };
}

export const BatchDecryptRequest: MessageFns<BatchDecryptRequest> = {
  encode(message: BatchDecryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchDecryptRequest_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchDecryptRequest_Item.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchDecryptRequest_Item(): BatchDecryptRequest_Item {
  return { id: "", ciphertext: new Uint8Array(0) };
}

export const BatchDecryptRequest_Item: MessageFns<BatchDecryptRequest_Item> = {
  encode(message: BatchDecryptRequest_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.meta !== undefined) {
      EncryptedFieldMeta.encode(message.meta, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptRequest_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptRequest_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.meta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchDecryptResponse(): BatchDecryptResponse {
  return { items: [], successCount: 0, failureCount: 0 };
}

export const BatchDecryptResponse: MessageFns<BatchDecryptResponse> = {
  encode(message: BatchDecryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchDecryptResponse_DecryptedItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.successCount !== 0) {
      writer.uint32(16).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(24).int32(message.failureCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchDecryptResponse_DecryptedItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchDecryptResponse_DecryptedItem(): BatchDecryptResponse_DecryptedItem {
  return { id: "", plaintext: new Uint8Array(0), error: "" };
}

export const BatchDecryptResponse_DecryptedItem: MessageFns<BatchDecryptResponse_DecryptedItem> = {
  encode(message: BatchDecryptResponse_DecryptedItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.plaintext.length !== 0) {
      writer.uint32(18).bytes(message.plaintext);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDecryptResponse_DecryptedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDecryptResponse_DecryptedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReencryptRequest(): ReencryptRequest {
  return { ciphertext: new Uint8Array(0), context: "" };
}

export const ReencryptRequest: MessageFns<ReencryptRequest> = {
  encode(message: ReencryptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.currentMeta !== undefined) {
      EncryptedFieldMeta.encode(message.currentMeta, writer.uint32(18).fork()).join();
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReencryptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReencryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currentMeta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReencryptResponse(): ReencryptResponse {
  return { ciphertext: new Uint8Array(0), keyVersionChanged: false };
}

export const ReencryptResponse: MessageFns<ReencryptResponse> = {
  encode(message: ReencryptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.newMeta !== undefined) {
      EncryptedFieldMeta.encode(message.newMeta, writer.uint32(18).fork()).join();
    }
    if (message.keyVersionChanged !== false) {
      writer.uint32(24).bool(message.keyVersionChanged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReencryptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReencryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newMeta = EncryptedFieldMeta.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyVersionChanged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGenerateBlindIndexRequest(): GenerateBlindIndexRequest {
  return { value: "", indexType: 0, domain: 0 };
}

export const GenerateBlindIndexRequest: MessageFns<GenerateBlindIndexRequest> = {
  encode(message: GenerateBlindIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.indexType !== 0) {
      writer.uint32(16).int32(message.indexType);
    }
    if (message.domain !== 0) {
      writer.uint32(24).int32(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateBlindIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateBlindIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indexType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGenerateBlindIndexResponse(): GenerateBlindIndexResponse {
  return { blindIndex: new Uint8Array(0), keyVersion: 0 };
}

export const GenerateBlindIndexResponse: MessageFns<GenerateBlindIndexResponse> = {
  encode(message: GenerateBlindIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blindIndex.length !== 0) {
      writer.uint32(10).bytes(message.blindIndex);
    }
    if (message.keyVersion !== 0) {
      writer.uint32(16).int32(message.keyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateBlindIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateBlindIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blindIndex = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchGenerateBlindIndexRequest(): BatchGenerateBlindIndexRequest {
  return { items: [], indexType: 0, domain: 0 };
}

export const BatchGenerateBlindIndexRequest: MessageFns<BatchGenerateBlindIndexRequest> = {
  encode(message: BatchGenerateBlindIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchGenerateBlindIndexRequest_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.indexType !== 0) {
      writer.uint32(16).int32(message.indexType);
    }
    if (message.domain !== 0) {
      writer.uint32(24).int32(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchGenerateBlindIndexRequest_Item.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indexType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchGenerateBlindIndexRequest_Item(): BatchGenerateBlindIndexRequest_Item {
  return { id: "", value: "" };
}

export const BatchGenerateBlindIndexRequest_Item: MessageFns<BatchGenerateBlindIndexRequest_Item> = {
  encode(message: BatchGenerateBlindIndexRequest_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexRequest_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexRequest_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchGenerateBlindIndexResponse(): BatchGenerateBlindIndexResponse {
  return { items: [], keyVersion: 0 };
}

export const BatchGenerateBlindIndexResponse: MessageFns<BatchGenerateBlindIndexResponse> = {
  encode(message: BatchGenerateBlindIndexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BatchGenerateBlindIndexResponse_IndexedItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.keyVersion !== 0) {
      writer.uint32(16).int32(message.keyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(BatchGenerateBlindIndexResponse_IndexedItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseBatchGenerateBlindIndexResponse_IndexedItem(): BatchGenerateBlindIndexResponse_IndexedItem {
  return { id: "", blindIndex: new Uint8Array(0), error: "" };
}

export const BatchGenerateBlindIndexResponse_IndexedItem: MessageFns<BatchGenerateBlindIndexResponse_IndexedItem> = {
  encode(
    message: BatchGenerateBlindIndexResponse_IndexedItem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blindIndex.length !== 0) {
      writer.uint32(18).bytes(message.blindIndex);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGenerateBlindIndexResponse_IndexedItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGenerateBlindIndexResponse_IndexedItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blindIndex = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListKeysRequest(): ListKeysRequest {
  return { domain: 0, environment: "", includeDeprecated: false };
}

export const ListKeysRequest: MessageFns<ListKeysRequest> = {
  encode(message: ListKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== 0) {
      writer.uint32(8).int32(message.domain);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    if (message.includeDeprecated !== false) {
      writer.uint32(24).bool(message.includeDeprecated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeDeprecated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListKeysResponse(): ListKeysResponse {
  return { keys: [] };
}

export const ListKeysResponse: MessageFns<ListKeysResponse> = {
  encode(message: ListKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      DataKey.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keys.push(DataKey.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCurrentKeyRequest(): GetCurrentKeyRequest {
  return { domain: 0, environment: "" };
}

export const GetCurrentKeyRequest: MessageFns<GetCurrentKeyRequest> = {
  encode(message: GetCurrentKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== 0) {
      writer.uint32(8).int32(message.domain);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetCurrentKeyResponse(): GetCurrentKeyResponse {
  return {};
}

export const GetCurrentKeyResponse: MessageFns<GetCurrentKeyResponse> = {
  encode(message: GetCurrentKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      DataKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCurrentKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrentKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRotateKeyRequest(): RotateKeyRequest {
  return { domain: 0, environment: "", reason: "" };
}

export const RotateKeyRequest: MessageFns<RotateKeyRequest> = {
  encode(message: RotateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== 0) {
      writer.uint32(8).int32(message.domain);
    }
    if (message.environment !== "") {
      writer.uint32(18).string(message.environment);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RotateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRotateKeyResponse(): RotateKeyResponse {
  return {};
}

export const RotateKeyResponse: MessageFns<RotateKeyResponse> = {
  encode(message: RotateKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newKey !== undefined) {
      DataKey.encode(message.newKey, writer.uint32(10).fork()).join();
    }
    if (message.oldKey !== undefined) {
      DataKey.encode(message.oldKey, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RotateKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newKey = DataKey.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldKey = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseScheduleKeyDeletionRequest(): ScheduleKeyDeletionRequest {
  return { keyId: "", pendingDays: 0, reason: "" };
}

export const ScheduleKeyDeletionRequest: MessageFns<ScheduleKeyDeletionRequest> = {
  encode(message: ScheduleKeyDeletionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    if (message.pendingDays !== 0) {
      writer.uint32(16).int32(message.pendingDays);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleKeyDeletionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleKeyDeletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pendingDays = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseScheduleKeyDeletionResponse(): ScheduleKeyDeletionResponse {
  return {};
}

export const ScheduleKeyDeletionResponse: MessageFns<ScheduleKeyDeletionResponse> = {
  encode(message: ScheduleKeyDeletionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      DataKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScheduleKeyDeletionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduleKeyDeletionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelKeyDeletionRequest(): CancelKeyDeletionRequest {
  return { keyId: "", reason: "" };
}

export const CancelKeyDeletionRequest: MessageFns<CancelKeyDeletionRequest> = {
  encode(message: CancelKeyDeletionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelKeyDeletionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelKeyDeletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelKeyDeletionResponse(): CancelKeyDeletionResponse {
  return {};
}

export const CancelKeyDeletionResponse: MessageFns<CancelKeyDeletionResponse> = {
  encode(message: CancelKeyDeletionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      DataKey.encode(message.key, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelKeyDeletionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelKeyDeletionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = DataKey.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSignRequest(): SignRequest {
  return { data: new Uint8Array(0), domain: 0, context: "" };
}

export const SignRequest: MessageFns<SignRequest> = {
  encode(message: SignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.domain !== 0) {
      writer.uint32(16).int32(message.domain);
    }
    if (message.context !== "") {
      writer.uint32(26).string(message.context);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.context = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSignResponse(): SignResponse {
  return { signature: new Uint8Array(0), keyVersion: 0, algorithm: "" };
}

export const SignResponse: MessageFns<SignResponse> = {
  encode(message: SignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.keyVersion !== 0) {
      writer.uint32(16).int32(message.keyVersion);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVerifyRequest(): VerifyRequest {
  return { data: new Uint8Array(0), signature: new Uint8Array(0), keyVersion: 0, domain: 0 };
}

export const VerifyRequest: MessageFns<VerifyRequest> = {
  encode(message: VerifyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.keyVersion !== 0) {
      writer.uint32(24).int32(message.keyVersion);
    }
    if (message.domain !== 0) {
      writer.uint32(32).int32(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyVersion = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseVerifyResponse(): VerifyResponse {
  return { valid: false };
}

export const VerifyResponse: MessageFns<VerifyResponse> = {
  encode(message: VerifyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ========== ENCRYPTION ========== */

export interface CryptoServiceClient {
  encrypt(request: EncryptRequest, metadata?: Metadata): Observable<EncryptResponse>;

  decrypt(request: DecryptRequest, metadata?: Metadata): Observable<DecryptResponse>;

  batchEncrypt(request: BatchEncryptRequest, metadata?: Metadata): Observable<BatchEncryptResponse>;

  batchDecrypt(request: BatchDecryptRequest, metadata?: Metadata): Observable<BatchDecryptResponse>;

  reencrypt(request: ReencryptRequest, metadata?: Metadata): Observable<ReencryptResponse>;

  generateBlindIndex(request: GenerateBlindIndexRequest, metadata?: Metadata): Observable<GenerateBlindIndexResponse>;

  batchGenerateBlindIndex(
    request: BatchGenerateBlindIndexRequest,
    metadata?: Metadata,
  ): Observable<BatchGenerateBlindIndexResponse>;

  listKeys(request: ListKeysRequest, metadata?: Metadata): Observable<ListKeysResponse>;

  getCurrentKey(request: GetCurrentKeyRequest, metadata?: Metadata): Observable<GetCurrentKeyResponse>;

  rotateKey(request: RotateKeyRequest, metadata?: Metadata): Observable<RotateKeyResponse>;

  scheduleKeyDeletion(
    request: ScheduleKeyDeletionRequest,
    metadata?: Metadata,
  ): Observable<ScheduleKeyDeletionResponse>;

  cancelKeyDeletion(request: CancelKeyDeletionRequest, metadata?: Metadata): Observable<CancelKeyDeletionResponse>;

  sign(request: SignRequest, metadata?: Metadata): Observable<SignResponse>;

  verify(request: VerifyRequest, metadata?: Metadata): Observable<VerifyResponse>;
}

/** ========== ENCRYPTION ========== */

export interface CryptoServiceController {
  encrypt(
    request: EncryptRequest,
    metadata?: Metadata,
  ): Promise<EncryptResponse> | Observable<EncryptResponse> | EncryptResponse;

  decrypt(
    request: DecryptRequest,
    metadata?: Metadata,
  ): Promise<DecryptResponse> | Observable<DecryptResponse> | DecryptResponse;

  batchEncrypt(
    request: BatchEncryptRequest,
    metadata?: Metadata,
  ): Promise<BatchEncryptResponse> | Observable<BatchEncryptResponse> | BatchEncryptResponse;

  batchDecrypt(
    request: BatchDecryptRequest,
    metadata?: Metadata,
  ): Promise<BatchDecryptResponse> | Observable<BatchDecryptResponse> | BatchDecryptResponse;

  reencrypt(
    request: ReencryptRequest,
    metadata?: Metadata,
  ): Promise<ReencryptResponse> | Observable<ReencryptResponse> | ReencryptResponse;

  generateBlindIndex(
    request: GenerateBlindIndexRequest,
    metadata?: Metadata,
  ): Promise<GenerateBlindIndexResponse> | Observable<GenerateBlindIndexResponse> | GenerateBlindIndexResponse;

  batchGenerateBlindIndex(
    request: BatchGenerateBlindIndexRequest,
    metadata?: Metadata,
  ):
    | Promise<BatchGenerateBlindIndexResponse>
    | Observable<BatchGenerateBlindIndexResponse>
    | BatchGenerateBlindIndexResponse;

  listKeys(
    request: ListKeysRequest,
    metadata?: Metadata,
  ): Promise<ListKeysResponse> | Observable<ListKeysResponse> | ListKeysResponse;

  getCurrentKey(
    request: GetCurrentKeyRequest,
    metadata?: Metadata,
  ): Promise<GetCurrentKeyResponse> | Observable<GetCurrentKeyResponse> | GetCurrentKeyResponse;

  rotateKey(
    request: RotateKeyRequest,
    metadata?: Metadata,
  ): Promise<RotateKeyResponse> | Observable<RotateKeyResponse> | RotateKeyResponse;

  scheduleKeyDeletion(
    request: ScheduleKeyDeletionRequest,
    metadata?: Metadata,
  ): Promise<ScheduleKeyDeletionResponse> | Observable<ScheduleKeyDeletionResponse> | ScheduleKeyDeletionResponse;

  cancelKeyDeletion(
    request: CancelKeyDeletionRequest,
    metadata?: Metadata,
  ): Promise<CancelKeyDeletionResponse> | Observable<CancelKeyDeletionResponse> | CancelKeyDeletionResponse;

  sign(request: SignRequest, metadata?: Metadata): Promise<SignResponse> | Observable<SignResponse> | SignResponse;

  verify(
    request: VerifyRequest,
    metadata?: Metadata,
  ): Promise<VerifyResponse> | Observable<VerifyResponse> | VerifyResponse;
}

export function CryptoServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "encrypt",
      "decrypt",
      "batchEncrypt",
      "batchDecrypt",
      "reencrypt",
      "generateBlindIndex",
      "batchGenerateBlindIndex",
      "listKeys",
      "getCurrentKey",
      "rotateKey",
      "scheduleKeyDeletion",
      "cancelKeyDeletion",
      "sign",
      "verify",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("CryptoService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("CryptoService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CRYPTO_SERVICE_NAME = "CryptoService";

/** ========== ENCRYPTION ========== */
export type CryptoServiceService = typeof CryptoServiceService;
export const CryptoServiceService = {
  encrypt: {
    path: "/security.CryptoService/Encrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EncryptRequest): Buffer => Buffer.from(EncryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): EncryptRequest => EncryptRequest.decode(value),
    responseSerialize: (value: EncryptResponse): Buffer => Buffer.from(EncryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EncryptResponse => EncryptResponse.decode(value),
  },
  decrypt: {
    path: "/security.CryptoService/Decrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DecryptRequest): Buffer => Buffer.from(DecryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DecryptRequest => DecryptRequest.decode(value),
    responseSerialize: (value: DecryptResponse): Buffer => Buffer.from(DecryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DecryptResponse => DecryptResponse.decode(value),
  },
  batchEncrypt: {
    path: "/security.CryptoService/BatchEncrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchEncryptRequest): Buffer => Buffer.from(BatchEncryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchEncryptRequest => BatchEncryptRequest.decode(value),
    responseSerialize: (value: BatchEncryptResponse): Buffer =>
      Buffer.from(BatchEncryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchEncryptResponse => BatchEncryptResponse.decode(value),
  },
  batchDecrypt: {
    path: "/security.CryptoService/BatchDecrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchDecryptRequest): Buffer => Buffer.from(BatchDecryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchDecryptRequest => BatchDecryptRequest.decode(value),
    responseSerialize: (value: BatchDecryptResponse): Buffer =>
      Buffer.from(BatchDecryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchDecryptResponse => BatchDecryptResponse.decode(value),
  },
  reencrypt: {
    path: "/security.CryptoService/Reencrypt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReencryptRequest): Buffer => Buffer.from(ReencryptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReencryptRequest => ReencryptRequest.decode(value),
    responseSerialize: (value: ReencryptResponse): Buffer => Buffer.from(ReencryptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReencryptResponse => ReencryptResponse.decode(value),
  },
  generateBlindIndex: {
    path: "/security.CryptoService/GenerateBlindIndex",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GenerateBlindIndexRequest): Buffer =>
      Buffer.from(GenerateBlindIndexRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GenerateBlindIndexRequest => GenerateBlindIndexRequest.decode(value),
    responseSerialize: (value: GenerateBlindIndexResponse): Buffer =>
      Buffer.from(GenerateBlindIndexResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GenerateBlindIndexResponse => GenerateBlindIndexResponse.decode(value),
  },
  batchGenerateBlindIndex: {
    path: "/security.CryptoService/BatchGenerateBlindIndex",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BatchGenerateBlindIndexRequest): Buffer =>
      Buffer.from(BatchGenerateBlindIndexRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): BatchGenerateBlindIndexRequest => BatchGenerateBlindIndexRequest.decode(value),
    responseSerialize: (value: BatchGenerateBlindIndexResponse): Buffer =>
      Buffer.from(BatchGenerateBlindIndexResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): BatchGenerateBlindIndexResponse =>
      BatchGenerateBlindIndexResponse.decode(value),
  },
  listKeys: {
    path: "/security.CryptoService/ListKeys",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListKeysRequest): Buffer => Buffer.from(ListKeysRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListKeysRequest => ListKeysRequest.decode(value),
    responseSerialize: (value: ListKeysResponse): Buffer => Buffer.from(ListKeysResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListKeysResponse => ListKeysResponse.decode(value),
  },
  getCurrentKey: {
    path: "/security.CryptoService/GetCurrentKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCurrentKeyRequest): Buffer => Buffer.from(GetCurrentKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetCurrentKeyRequest => GetCurrentKeyRequest.decode(value),
    responseSerialize: (value: GetCurrentKeyResponse): Buffer =>
      Buffer.from(GetCurrentKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetCurrentKeyResponse => GetCurrentKeyResponse.decode(value),
  },
  rotateKey: {
    path: "/security.CryptoService/RotateKey",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RotateKeyRequest): Buffer => Buffer.from(RotateKeyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RotateKeyRequest => RotateKeyRequest.decode(value),
    responseSerialize: (value: RotateKeyResponse): Buffer => Buffer.from(RotateKeyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RotateKeyResponse => RotateKeyResponse.decode(value),
  },
  scheduleKeyDeletion: {
    path: "/security.CryptoService/ScheduleKeyDeletion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ScheduleKeyDeletionRequest): Buffer =>
      Buffer.from(ScheduleKeyDeletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ScheduleKeyDeletionRequest => ScheduleKeyDeletionRequest.decode(value),
    responseSerialize: (value: ScheduleKeyDeletionResponse): Buffer =>
      Buffer.from(ScheduleKeyDeletionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ScheduleKeyDeletionResponse => ScheduleKeyDeletionResponse.decode(value),
  },
  cancelKeyDeletion: {
    path: "/security.CryptoService/CancelKeyDeletion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelKeyDeletionRequest): Buffer =>
      Buffer.from(CancelKeyDeletionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelKeyDeletionRequest => CancelKeyDeletionRequest.decode(value),
    responseSerialize: (value: CancelKeyDeletionResponse): Buffer =>
      Buffer.from(CancelKeyDeletionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CancelKeyDeletionResponse => CancelKeyDeletionResponse.decode(value),
  },
  sign: {
    path: "/security.CryptoService/Sign",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignRequest): Buffer => Buffer.from(SignRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignRequest => SignRequest.decode(value),
    responseSerialize: (value: SignResponse): Buffer => Buffer.from(SignResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignResponse => SignResponse.decode(value),
  },
  verify: {
    path: "/security.CryptoService/Verify",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyRequest): Buffer => Buffer.from(VerifyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyRequest => VerifyRequest.decode(value),
    responseSerialize: (value: VerifyResponse): Buffer => Buffer.from(VerifyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VerifyResponse => VerifyResponse.decode(value),
  },
} as const;

export interface CryptoServiceServer extends UntypedServiceImplementation {
  encrypt: handleUnaryCall<EncryptRequest, EncryptResponse>;
  decrypt: handleUnaryCall<DecryptRequest, DecryptResponse>;
  batchEncrypt: handleUnaryCall<BatchEncryptRequest, BatchEncryptResponse>;
  batchDecrypt: handleUnaryCall<BatchDecryptRequest, BatchDecryptResponse>;
  reencrypt: handleUnaryCall<ReencryptRequest, ReencryptResponse>;
  generateBlindIndex: handleUnaryCall<GenerateBlindIndexRequest, GenerateBlindIndexResponse>;
  batchGenerateBlindIndex: handleUnaryCall<BatchGenerateBlindIndexRequest, BatchGenerateBlindIndexResponse>;
  listKeys: handleUnaryCall<ListKeysRequest, ListKeysResponse>;
  getCurrentKey: handleUnaryCall<GetCurrentKeyRequest, GetCurrentKeyResponse>;
  rotateKey: handleUnaryCall<RotateKeyRequest, RotateKeyResponse>;
  scheduleKeyDeletion: handleUnaryCall<ScheduleKeyDeletionRequest, ScheduleKeyDeletionResponse>;
  cancelKeyDeletion: handleUnaryCall<CancelKeyDeletionRequest, CancelKeyDeletionResponse>;
  sign: handleUnaryCall<SignRequest, SignResponse>;
  verify: handleUnaryCall<VerifyRequest, VerifyResponse>;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
