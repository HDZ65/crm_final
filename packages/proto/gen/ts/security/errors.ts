// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: security/errors.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

/**
 * Security error codes grouped by category
 * 100-199: Authentication
 * 200-299: Authorization
 * 300-399: MFA / Step-up
 * 400-499: Audit
 * 500-599: Retention / Purge
 * 600-699: Encryption
 * 700-799: Break-glass
 */
export enum SecurityErrorCode {
  SECURITY_ERROR_CODE_UNSPECIFIED = 0,
  /** UNAUTHORIZED - No valid credentials provided */
  UNAUTHORIZED = 100,
  /** SESSION_EXPIRED - Token has expired (access or refresh) */
  SESSION_EXPIRED = 101,
  /** SESSION_REVOKED - Session has been explicitly revoked (logout or admin action) */
  SESSION_REVOKED = 102,
  /** SSO_ASSERTION_INVALID - OIDC/SAML assertion is invalid or malformed */
  SSO_ASSERTION_INVALID = 103,
  /** TOKEN_REFRESH_FAILED - Refresh token is invalid, expired, or has been reused */
  TOKEN_REFRESH_FAILED = 104,
  /** INVALID_CREDENTIALS - Invalid credentials during authentication */
  INVALID_CREDENTIALS = 105,
  /** ACCOUNT_LOCKED - Account is locked due to too many failed attempts */
  ACCOUNT_LOCKED = 106,
  /** ACCOUNT_DISABLED - Account has been disabled by administrator */
  ACCOUNT_DISABLED = 107,
  /** FORBIDDEN - Generic forbidden - user authenticated but not allowed */
  FORBIDDEN = 200,
  /** PERMISSION_MISSING - Specific permission not granted to user's role(s) */
  PERMISSION_MISSING = 201,
  /** TENANT_SCOPE_VIOLATION - Request's organisation_id doesn't match user's membership */
  TENANT_SCOPE_VIOLATION = 202,
  /** ROLE_INSUFFICIENT - User's role is insufficient for this operation */
  ROLE_INSUFFICIENT = 203,
  /** MEMBERSHIP_INACTIVE - User's membership in organisation is not active */
  MEMBERSHIP_INACTIVE = 204,
  /** RESOURCE_NOT_ACCESSIBLE - Resource belongs to different tenant */
  RESOURCE_NOT_ACCESSIBLE = 205,
  /** MFA_REQUIRED - MFA is not configured for user but is required */
  MFA_REQUIRED = 300,
  /** MFA_STEP_UP_REQUIRED - MFA verification is stale, need to re-verify */
  MFA_STEP_UP_REQUIRED = 301,
  /** MFA_CHALLENGE_FAILED - MFA challenge failed (wrong OTP, WebAuthn failed, etc.) */
  MFA_CHALLENGE_FAILED = 302,
  /** MFA_DEVICE_NOT_FOUND - MFA device not registered */
  MFA_DEVICE_NOT_FOUND = 303,
  /** MFA_CHALLENGE_EXPIRED - MFA challenge has expired */
  MFA_CHALLENGE_EXPIRED = 304,
  /** MFA_ATTEMPTS_EXCEEDED - Too many MFA attempts, temporarily locked */
  MFA_ATTEMPTS_EXCEEDED = 305,
  /**
   * AUDIT_WRITE_FAILED - Audit write failed - BLOCKING for sensitive operations
   * If this error is returned, the sensitive action was NOT executed
   */
  AUDIT_WRITE_FAILED = 400,
  /** AUDIT_SERVICE_UNAVAILABLE - Audit service is unavailable */
  AUDIT_SERVICE_UNAVAILABLE = 401,
  /** AUDIT_CHAIN_INVALID - Audit chain verification failed (tampering detected) */
  AUDIT_CHAIN_INVALID = 402,
  /** AUDIT_EXPORT_DENIED - Audit export is not allowed for this query */
  AUDIT_EXPORT_DENIED = 403,
  /** RETENTION_POLICY_INVALID - Retention policy configuration is invalid */
  RETENTION_POLICY_INVALID = 500,
  /** PURGE_NOT_ALLOWED - Purge is not allowed (legal hold, etc.) */
  PURGE_NOT_ALLOWED = 501,
  /** PURGE_IN_PROGRESS - Purge request is already in progress */
  PURGE_IN_PROGRESS = 502,
  /** PURGE_REQUEST_NOT_FOUND - Purge request not found */
  PURGE_REQUEST_NOT_FOUND = 503,
  /** PURGE_PARTIAL_FAILURE - Purge failed for one or more services */
  PURGE_PARTIAL_FAILURE = 504,
  /** PURGE_SUBJECT_NOT_FOUND - Subject for purge not found */
  PURGE_SUBJECT_NOT_FOUND = 505,
  /** DECRYPTION_FAILED - Decryption failed - key version mismatch or data corrupted */
  DECRYPTION_FAILED = 600,
  /** KEY_NOT_FOUND - KMS key not found or inaccessible */
  KEY_NOT_FOUND = 601,
  /** ENCRYPTION_FAILED - Encryption operation failed */
  ENCRYPTION_FAILED = 602,
  /** KEY_ROTATION_IN_PROGRESS - Key rotation is in progress, retry later */
  KEY_ROTATION_IN_PROGRESS = 603,
  /** BREAKGLASS_REQUIRED - This action requires an active break-glass session */
  BREAKGLASS_REQUIRED = 700,
  /** BREAKGLASS_EXPIRED - Break-glass session has expired */
  BREAKGLASS_EXPIRED = 701,
  /** BREAKGLASS_NOT_ACTIVE - No active break-glass session found */
  BREAKGLASS_NOT_ACTIVE = 702,
  /** BREAKGLASS_ACTIVATION_FAILED - Break-glass activation failed */
  BREAKGLASS_ACTIVATION_FAILED = 703,
  /** BREAKGLASS_ALREADY_ACTIVE - Break-glass session already active */
  BREAKGLASS_ALREADY_ACTIVE = 704,
  /** BREAKGLASS_DURATION_EXCEEDED - Break-glass duration exceeds maximum allowed */
  BREAKGLASS_DURATION_EXCEEDED = 705,
}

/** Structured security error response */
export interface SecurityError {
  /** Error code for programmatic handling */
  code: SecurityErrorCode;
  /** Human-readable message (safe for UI display) */
  message: string;
  /** Request ID for log correlation and support */
  requestId: string;
  /** Additional non-sensitive context */
  details: { [key: string]: string };
  /** For step-up flows: URL to redirect for MFA */
  stepUpUrl: string;
  /** For step-up flows: how long the step-up is valid (seconds) */
  stepUpTtlSeconds: number;
  /** For permission errors: the permission that was required */
  requiredPermission: string;
  /** For tenant errors: the expected organisation_id */
  expectedOrganisationId: string;
  /** Timestamp when error occurred (ISO 8601) */
  occurredAt: string;
}

export interface SecurityError_DetailsEntry {
  key: string;
  value: string;
}

/** Validation error for input validation failures */
export interface ValidationError {
  /** Field that failed validation */
  field: string;
  /** Validation rule that failed */
  rule: string;
  /** Human-readable error message */
  message: string;
  /** The invalid value (redacted if sensitive) */
  value: string;
}

/** Collection of validation errors */
export interface ValidationErrors {
  /** List of individual field validation errors */
  errors: ValidationError[];
  /** Request ID for log correlation */
  requestId: string;
}

/** Rate limit error response */
export interface RateLimitError {
  /** When the client can retry (Unix timestamp) */
  retryAfter: number;
  /** Current limit that was exceeded */
  limit: number;
  /** Time window for the limit (seconds) */
  windowSeconds: number;
  /** Request ID for log correlation */
  requestId: string;
}

function createBaseSecurityError(): SecurityError {
  return {
    code: 0,
    message: "",
    requestId: "",
    details: {},
    stepUpUrl: "",
    stepUpTtlSeconds: 0,
    requiredPermission: "",
    expectedOrganisationId: "",
    occurredAt: "",
  };
}

export const SecurityError: MessageFns<SecurityError> = {
  encode(message: SecurityError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    globalThis.Object.entries(message.details).forEach(([key, value]: [string, string]) => {
      SecurityError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.stepUpUrl !== "") {
      writer.uint32(42).string(message.stepUpUrl);
    }
    if (message.stepUpTtlSeconds !== 0) {
      writer.uint32(48).int32(message.stepUpTtlSeconds);
    }
    if (message.requiredPermission !== "") {
      writer.uint32(58).string(message.requiredPermission);
    }
    if (message.expectedOrganisationId !== "") {
      writer.uint32(66).string(message.expectedOrganisationId);
    }
    if (message.occurredAt !== "") {
      writer.uint32(74).string(message.occurredAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SecurityError_DetailsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.details[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stepUpUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.stepUpTtlSeconds = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.requiredPermission = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expectedOrganisationId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.occurredAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSecurityError_DetailsEntry(): SecurityError_DetailsEntry {
  return { key: "", value: "" };
}

export const SecurityError_DetailsEntry: MessageFns<SecurityError_DetailsEntry> = {
  encode(message: SecurityError_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityError_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidationError(): ValidationError {
  return { field: "", rule: "", message: "", value: "" };
}

export const ValidationError: MessageFns<ValidationError> = {
  encode(message: ValidationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.rule !== "") {
      writer.uint32(18).string(message.rule);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidationErrors(): ValidationErrors {
  return { errors: [], requestId: "" };
}

export const ValidationErrors: MessageFns<ValidationErrors> = {
  encode(message: ValidationErrors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      ValidationError.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationErrors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationErrors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(ValidationError.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRateLimitError(): RateLimitError {
  return { retryAfter: 0, limit: 0, windowSeconds: 0, requestId: "" };
}

export const RateLimitError: MessageFns<RateLimitError> = {
  encode(message: RateLimitError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryAfter !== 0) {
      writer.uint32(8).int64(message.retryAfter);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.windowSeconds !== 0) {
      writer.uint32(24).int32(message.windowSeconds);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RateLimitError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRateLimitError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.retryAfter = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.windowSeconds = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
