// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: security/retention.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, Metadata, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Timestamp } from "../google/protobuf/timestamp";

/** Purge mode for data removal */
export enum PurgeMode {
  PURGE_MODE_UNSPECIFIED = 0,
  /** PURGE_MODE_DELETE - Hard delete - completely remove data */
  PURGE_MODE_DELETE = 1,
  /** PURGE_MODE_ANONYMIZE - Anonymize - remove PII but keep structure for analytics */
  PURGE_MODE_ANONYMIZE = 2,
  /** PURGE_MODE_ARCHIVE - Archive - move to cold storage */
  PURGE_MODE_ARCHIVE = 3,
}

/** Status of a purge request */
export enum PurgeRequestStatus {
  PURGE_REQUEST_STATUS_UNSPECIFIED = 0,
  /** PURGE_REQUEST_STATUS_PENDING - Request created, not yet processed */
  PURGE_REQUEST_STATUS_PENDING = 1,
  /** PURGE_REQUEST_STATUS_RUNNING - Purge is currently running */
  PURGE_REQUEST_STATUS_RUNNING = 2,
  /** PURGE_REQUEST_STATUS_COMPLETED - Purge completed successfully */
  PURGE_REQUEST_STATUS_COMPLETED = 3,
  /** PURGE_REQUEST_STATUS_PARTIAL - Partial purge (some data retained due to legal hold) */
  PURGE_REQUEST_STATUS_PARTIAL = 4,
  /** PURGE_REQUEST_STATUS_REJECTED - Request rejected (e.g., not authorized) */
  PURGE_REQUEST_STATUS_REJECTED = 5,
  /** PURGE_REQUEST_STATUS_FAILED - Purge failed with error */
  PURGE_REQUEST_STATUS_FAILED = 6,
}

/** Status of individual purge execution per service */
export enum PurgeExecutionStatus {
  PURGE_EXECUTION_STATUS_UNSPECIFIED = 0,
  PURGE_EXECUTION_STATUS_SUCCESS = 1,
  PURGE_EXECUTION_STATUS_PARTIAL = 2,
  PURGE_EXECUTION_STATUS_FAILED = 3,
  PURGE_EXECUTION_STATUS_SKIPPED = 4,
}

/** Subject type for purge requests */
export enum SubjectType {
  SUBJECT_TYPE_UNSPECIFIED = 0,
  /** SUBJECT_TYPE_USER - Internal user (employee, admin) */
  SUBJECT_TYPE_USER = 1,
  /** SUBJECT_TYPE_CUSTOMER - External customer */
  SUBJECT_TYPE_CUSTOMER = 2,
  /** SUBJECT_TYPE_PARTNER - Partner/vendor */
  SUBJECT_TYPE_PARTNER = 3,
}

/** Retention policy for a data category */
export interface RetentionPolicy {
  id: string;
  /** Category identifier (e.g., PAYMENT_10Y, AUDIT_7Y, TECH_90D) */
  category: string;
  /** Service that owns this data */
  serviceName: string;
  /** Entity/table name */
  entityName: string;
  /** Retention period in days */
  retentionDays: number;
  /** How to handle data after retention period */
  purgeMode: PurgeMode;
  /** Legal basis for retention (for compliance documentation) */
  legalBasis: string;
  /** Description for documentation */
  description: string;
  /** Timestamps */
  createdAt?: Timestamp | undefined;
  updatedAt?: Timestamp | undefined;
  updatedByUserId: string;
  /** Whether this policy is active */
  isActive: boolean;
}

/** Create or update retention policy */
export interface UpsertRetentionPolicyRequest {
  category: string;
  serviceName: string;
  entityName: string;
  retentionDays: number;
  purgeMode: PurgeMode;
  legalBasis: string;
  description: string;
}

export interface UpsertRetentionPolicyResponse {
  policy?: RetentionPolicy | undefined;
  created: boolean;
}

/** List retention policies */
export interface ListRetentionPoliciesRequest {
  serviceName: string;
  category: string;
  includeInactive: boolean;
}

export interface ListRetentionPoliciesResponse {
  policies: RetentionPolicy[];
}

/** Get specific policy */
export interface GetRetentionPolicyRequest {
  id: string;
}

export interface GetRetentionPolicyResponse {
  policy?: RetentionPolicy | undefined;
}

/** Purge job for scheduled retention enforcement */
export interface PurgeJob {
  id: string;
  /** Which policy triggered this job */
  retentionPolicyId: string;
  /** Service being purged */
  serviceName: string;
  /** Entity being purged */
  entityName: string;
  /** Cutoff date (records before this date are purged) */
  cutoffDate?:
    | Timestamp
    | undefined;
  /** Job status */
  status: PurgeExecutionStatus;
  /** Counts */
  recordsScanned: number;
  recordsDeleted: number;
  recordsAnonymized: number;
  recordsArchived: number;
  recordsRetained: number;
  /** Reason for retention (if any records retained) */
  retentionReason: string;
  /** Timestamps */
  startedAt?: Timestamp | undefined;
  completedAt?:
    | Timestamp
    | undefined;
  /** Error info (if failed) */
  errorMessage: string;
  /** Is this a dry run? */
  dryRun: boolean;
}

/** Run scheduled purge (daily job) */
export interface RunScheduledPurgeRequest {
  /** Optional: limit to specific service */
  serviceName: string;
  /** Optional: limit to specific category */
  category: string;
  /** If true, only report what would be purged */
  dryRun: boolean;
}

export interface RunScheduledPurgeResponse {
  jobs: PurgeJob[];
  totalJobs: number;
  successfulJobs: number;
  failedJobs: number;
  totalRecordsPurged: number;
}

/** List purge job history */
export interface ListPurgeJobsRequest {
  serviceName: string;
  from?: Timestamp | undefined;
  to?: Timestamp | undefined;
  statuses: PurgeExecutionStatus[];
  page: number;
  limit: number;
}

export interface ListPurgeJobsResponse {
  jobs: PurgeJob[];
  total: number;
  page: number;
  limit: number;
}

/** GDPR purge request for a specific subject */
export interface PurgeRequest {
  id: string;
  /** Tenant context */
  organisationId: string;
  /** Who requested the purge */
  requestedByUserId: string;
  /** Subject of the purge */
  subjectType: SubjectType;
  subjectId: string;
  /** Optional: subject email (for cross-service lookup) */
  subjectEmail: string;
  /** Reason for purge (GDPR article, etc.) */
  reason: string;
  /** Legal basis for purge */
  legalBasis: string;
  /** If true, some data may be retained for legal reasons */
  legalHold: boolean;
  /** Legal hold details (if applicable) */
  legalHoldReason: string;
  legalHoldUntil?:
    | Timestamp
    | undefined;
  /** Status */
  status: PurgeRequestStatus;
  /** Timestamps */
  createdAt?: Timestamp | undefined;
  startedAt?: Timestamp | undefined;
  completedAt?:
    | Timestamp
    | undefined;
  /** External reference (e.g., support ticket) */
  externalReference: string;
}

/** Per-service execution result for a purge request */
export interface PurgeExecution {
  id: string;
  purgeRequestId: string;
  /** Service that executed the purge */
  serviceName: string;
  /** Entity purged */
  entityName: string;
  /** Status */
  status: PurgeExecutionStatus;
  /** Counts */
  deletedCount: number;
  anonymizedCount: number;
  retainedCount: number;
  /** If any retained, why */
  retainedReason: string;
  /** Verification */
  verificationQuery: string;
  verificationPassed: boolean;
  /** Timestamps */
  executedAt?:
    | Timestamp
    | undefined;
  /** Error info (if failed) */
  errorMessage: string;
}

/** Create GDPR purge request */
export interface CreatePurgeRequestRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  subjectEmail: string;
  reason: string;
  legalBasis: string;
  externalReference: string;
}

export interface CreatePurgeRequestResponse {
  request?: PurgeRequest | undefined;
}

/** Execute purge request */
export interface ExecutePurgeRequest {
  purgeRequestId: string;
  /** If true, only report what would be purged */
  dryRun: boolean;
}

export interface ExecutePurgeResponse {
  request?: PurgeRequest | undefined;
  executions: PurgeExecution[];
}

/** Get purge request with executions */
export interface GetPurgeRequestRequest {
  purgeRequestId: string;
}

export interface GetPurgeRequestResponse {
  request?: PurgeRequest | undefined;
  executions: PurgeExecution[];
}

/** List purge requests */
export interface ListPurgeRequestsRequest {
  organisationId: string;
  statuses: PurgeRequestStatus[];
  subjectType: SubjectType;
  from?: Timestamp | undefined;
  to?: Timestamp | undefined;
  page: number;
  limit: number;
}

export interface ListPurgeRequestsResponse {
  requests: PurgeRequest[];
  total: number;
  page: number;
  limit: number;
}

/** Cancel pending purge request */
export interface CancelPurgeRequestRequest {
  purgeRequestId: string;
  reason: string;
}

export interface CancelPurgeRequestResponse {
  request?: PurgeRequest | undefined;
}

/** Legal hold on a subject's data */
export interface LegalHold {
  id: string;
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  /** Legal hold details */
  reason: string;
  caseReference: string;
  /** Who placed the hold */
  placedByUserId: string;
  placedAt?:
    | Timestamp
    | undefined;
  /** Optional expiration */
  expiresAt?:
    | Timestamp
    | undefined;
  /** Is hold active? */
  isActive: boolean;
  /** If lifted, details */
  liftedByUserId: string;
  liftedAt?: Timestamp | undefined;
  liftReason: string;
}

/** Place legal hold */
export interface PlaceLegalHoldRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
  reason: string;
  caseReference: string;
  expiresAt?: Timestamp | undefined;
}

export interface PlaceLegalHoldResponse {
  hold?: LegalHold | undefined;
}

/** Lift legal hold */
export interface LiftLegalHoldRequest {
  holdId: string;
  reason: string;
}

export interface LiftLegalHoldResponse {
  hold?: LegalHold | undefined;
}

/** Check for legal hold */
export interface CheckLegalHoldRequest {
  organisationId: string;
  subjectType: SubjectType;
  subjectId: string;
}

export interface CheckLegalHoldResponse {
  hasHold: boolean;
  activeHolds: LegalHold[];
}

/** Proof of purge for compliance documentation */
export interface PurgeProof {
  purgeRequestId: string;
  /** Summary */
  purgeCompletedAt?: Timestamp | undefined;
  finalStatus: PurgeRequestStatus;
  /** Per-service summary */
  executions: PurgeExecution[];
  /** Totals */
  totalDeleted: number;
  totalAnonymized: number;
  totalRetained: number;
  /** Verification results */
  allVerificationsPassed: boolean;
  failedVerifications: string[];
  /** Digital signature for proof integrity */
  proofSignature: string;
  proofGeneratedAt?: Timestamp | undefined;
}

/** Generate proof of purge */
export interface GeneratePurgeProofRequest {
  purgeRequestId: string;
}

export interface GeneratePurgeProofResponse {
  proof?: PurgeProof | undefined;
}

function createBaseRetentionPolicy(): RetentionPolicy {
  return {
    id: "",
    category: "",
    serviceName: "",
    entityName: "",
    retentionDays: 0,
    purgeMode: 0,
    legalBasis: "",
    description: "",
    updatedByUserId: "",
    isActive: false,
  };
}

export const RetentionPolicy: MessageFns<RetentionPolicy> = {
  encode(message: RetentionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.serviceName !== "") {
      writer.uint32(26).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(34).string(message.entityName);
    }
    if (message.retentionDays !== 0) {
      writer.uint32(40).int32(message.retentionDays);
    }
    if (message.purgeMode !== 0) {
      writer.uint32(48).int32(message.purgeMode);
    }
    if (message.legalBasis !== "") {
      writer.uint32(58).string(message.legalBasis);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(74).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(message.updatedAt, writer.uint32(82).fork()).join();
    }
    if (message.updatedByUserId !== "") {
      writer.uint32(90).string(message.updatedByUserId);
    }
    if (message.isActive !== false) {
      writer.uint32(96).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetentionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.retentionDays = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.purgeMode = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedByUserId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpsertRetentionPolicyRequest(): UpsertRetentionPolicyRequest {
  return {
    category: "",
    serviceName: "",
    entityName: "",
    retentionDays: 0,
    purgeMode: 0,
    legalBasis: "",
    description: "",
  };
}

export const UpsertRetentionPolicyRequest: MessageFns<UpsertRetentionPolicyRequest> = {
  encode(message: UpsertRetentionPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.category !== "") {
      writer.uint32(10).string(message.category);
    }
    if (message.serviceName !== "") {
      writer.uint32(18).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(26).string(message.entityName);
    }
    if (message.retentionDays !== 0) {
      writer.uint32(32).int32(message.retentionDays);
    }
    if (message.purgeMode !== 0) {
      writer.uint32(40).int32(message.purgeMode);
    }
    if (message.legalBasis !== "") {
      writer.uint32(50).string(message.legalBasis);
    }
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRetentionPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRetentionPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.retentionDays = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.purgeMode = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpsertRetentionPolicyResponse(): UpsertRetentionPolicyResponse {
  return { created: false };
}

export const UpsertRetentionPolicyResponse: MessageFns<UpsertRetentionPolicyResponse> = {
  encode(message: UpsertRetentionPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      RetentionPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    if (message.created !== false) {
      writer.uint32(16).bool(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertRetentionPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertRetentionPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = RetentionPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.created = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetentionPoliciesRequest(): ListRetentionPoliciesRequest {
  return { serviceName: "", category: "", includeInactive: false };
}

export const ListRetentionPoliciesRequest: MessageFns<ListRetentionPoliciesRequest> = {
  encode(message: ListRetentionPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.includeInactive !== false) {
      writer.uint32(24).bool(message.includeInactive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetentionPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetentionPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeInactive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListRetentionPoliciesResponse(): ListRetentionPoliciesResponse {
  return { policies: [] };
}

export const ListRetentionPoliciesResponse: MessageFns<ListRetentionPoliciesResponse> = {
  encode(message: ListRetentionPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policies) {
      RetentionPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRetentionPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRetentionPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policies.push(RetentionPolicy.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRetentionPolicyRequest(): GetRetentionPolicyRequest {
  return { id: "" };
}

export const GetRetentionPolicyRequest: MessageFns<GetRetentionPolicyRequest> = {
  encode(message: GetRetentionPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetentionPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetentionPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetRetentionPolicyResponse(): GetRetentionPolicyResponse {
  return {};
}

export const GetRetentionPolicyResponse: MessageFns<GetRetentionPolicyResponse> = {
  encode(message: GetRetentionPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== undefined) {
      RetentionPolicy.encode(message.policy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRetentionPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRetentionPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policy = RetentionPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePurgeJob(): PurgeJob {
  return {
    id: "",
    retentionPolicyId: "",
    serviceName: "",
    entityName: "",
    status: 0,
    recordsScanned: 0,
    recordsDeleted: 0,
    recordsAnonymized: 0,
    recordsArchived: 0,
    recordsRetained: 0,
    retentionReason: "",
    errorMessage: "",
    dryRun: false,
  };
}

export const PurgeJob: MessageFns<PurgeJob> = {
  encode(message: PurgeJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.retentionPolicyId !== "") {
      writer.uint32(18).string(message.retentionPolicyId);
    }
    if (message.serviceName !== "") {
      writer.uint32(26).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(34).string(message.entityName);
    }
    if (message.cutoffDate !== undefined) {
      Timestamp.encode(message.cutoffDate, writer.uint32(42).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.recordsScanned !== 0) {
      writer.uint32(56).int64(message.recordsScanned);
    }
    if (message.recordsDeleted !== 0) {
      writer.uint32(64).int64(message.recordsDeleted);
    }
    if (message.recordsAnonymized !== 0) {
      writer.uint32(72).int64(message.recordsAnonymized);
    }
    if (message.recordsArchived !== 0) {
      writer.uint32(80).int64(message.recordsArchived);
    }
    if (message.recordsRetained !== 0) {
      writer.uint32(88).int64(message.recordsRetained);
    }
    if (message.retentionReason !== "") {
      writer.uint32(98).string(message.retentionReason);
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(message.startedAt, writer.uint32(106).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(message.completedAt, writer.uint32(114).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(122).string(message.errorMessage);
    }
    if (message.dryRun !== false) {
      writer.uint32(128).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.retentionPolicyId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cutoffDate = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recordsScanned = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.recordsDeleted = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.recordsAnonymized = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.recordsArchived = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.recordsRetained = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.retentionReason = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.startedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.completedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRunScheduledPurgeRequest(): RunScheduledPurgeRequest {
  return { serviceName: "", category: "", dryRun: false };
}

export const RunScheduledPurgeRequest: MessageFns<RunScheduledPurgeRequest> = {
  encode(message: RunScheduledPurgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.category !== "") {
      writer.uint32(18).string(message.category);
    }
    if (message.dryRun !== false) {
      writer.uint32(24).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunScheduledPurgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunScheduledPurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRunScheduledPurgeResponse(): RunScheduledPurgeResponse {
  return { jobs: [], totalJobs: 0, successfulJobs: 0, failedJobs: 0, totalRecordsPurged: 0 };
}

export const RunScheduledPurgeResponse: MessageFns<RunScheduledPurgeResponse> = {
  encode(message: RunScheduledPurgeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      PurgeJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalJobs !== 0) {
      writer.uint32(16).int32(message.totalJobs);
    }
    if (message.successfulJobs !== 0) {
      writer.uint32(24).int32(message.successfulJobs);
    }
    if (message.failedJobs !== 0) {
      writer.uint32(32).int32(message.failedJobs);
    }
    if (message.totalRecordsPurged !== 0) {
      writer.uint32(40).int64(message.totalRecordsPurged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunScheduledPurgeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunScheduledPurgeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(PurgeJob.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalJobs = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.successfulJobs = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.failedJobs = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalRecordsPurged = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPurgeJobsRequest(): ListPurgeJobsRequest {
  return { serviceName: "", statuses: [], page: 0, limit: 0 };
}

export const ListPurgeJobsRequest: MessageFns<ListPurgeJobsRequest> = {
  encode(message: ListPurgeJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.from !== undefined) {
      Timestamp.encode(message.from, writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(message.to, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.page !== 0) {
      writer.uint32(40).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(48).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPurgeJobsResponse(): ListPurgeJobsResponse {
  return { jobs: [], total: 0, page: 0, limit: 0 };
}

export const ListPurgeJobsResponse: MessageFns<ListPurgeJobsResponse> = {
  encode(message: ListPurgeJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      PurgeJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(PurgeJob.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePurgeRequest(): PurgeRequest {
  return {
    id: "",
    organisationId: "",
    requestedByUserId: "",
    subjectType: 0,
    subjectId: "",
    subjectEmail: "",
    reason: "",
    legalBasis: "",
    legalHold: false,
    legalHoldReason: "",
    status: 0,
    externalReference: "",
  };
}

export const PurgeRequest: MessageFns<PurgeRequest> = {
  encode(message: PurgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.requestedByUserId !== "") {
      writer.uint32(26).string(message.requestedByUserId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(32).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(42).string(message.subjectId);
    }
    if (message.subjectEmail !== "") {
      writer.uint32(50).string(message.subjectEmail);
    }
    if (message.reason !== "") {
      writer.uint32(58).string(message.reason);
    }
    if (message.legalBasis !== "") {
      writer.uint32(66).string(message.legalBasis);
    }
    if (message.legalHold !== false) {
      writer.uint32(72).bool(message.legalHold);
    }
    if (message.legalHoldReason !== "") {
      writer.uint32(82).string(message.legalHoldReason);
    }
    if (message.legalHoldUntil !== undefined) {
      Timestamp.encode(message.legalHoldUntil, writer.uint32(90).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(message.createdAt, writer.uint32(106).fork()).join();
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(message.startedAt, writer.uint32(114).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(message.completedAt, writer.uint32(122).fork()).join();
    }
    if (message.externalReference !== "") {
      writer.uint32(130).string(message.externalReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestedByUserId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subjectEmail = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.legalHold = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.legalHoldReason = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.legalHoldUntil = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.startedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.completedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.externalReference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePurgeExecution(): PurgeExecution {
  return {
    id: "",
    purgeRequestId: "",
    serviceName: "",
    entityName: "",
    status: 0,
    deletedCount: 0,
    anonymizedCount: 0,
    retainedCount: 0,
    retainedReason: "",
    verificationQuery: "",
    verificationPassed: false,
    errorMessage: "",
  };
}

export const PurgeExecution: MessageFns<PurgeExecution> = {
  encode(message: PurgeExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.purgeRequestId !== "") {
      writer.uint32(18).string(message.purgeRequestId);
    }
    if (message.serviceName !== "") {
      writer.uint32(26).string(message.serviceName);
    }
    if (message.entityName !== "") {
      writer.uint32(34).string(message.entityName);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.deletedCount !== 0) {
      writer.uint32(48).int64(message.deletedCount);
    }
    if (message.anonymizedCount !== 0) {
      writer.uint32(56).int64(message.anonymizedCount);
    }
    if (message.retainedCount !== 0) {
      writer.uint32(64).int64(message.retainedCount);
    }
    if (message.retainedReason !== "") {
      writer.uint32(74).string(message.retainedReason);
    }
    if (message.verificationQuery !== "") {
      writer.uint32(82).string(message.verificationQuery);
    }
    if (message.verificationPassed !== false) {
      writer.uint32(88).bool(message.verificationPassed);
    }
    if (message.executedAt !== undefined) {
      Timestamp.encode(message.executedAt, writer.uint32(98).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(106).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entityName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.deletedCount = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.anonymizedCount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.retainedCount = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.retainedReason = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.verificationQuery = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.verificationPassed = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.executedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePurgeRequestRequest(): CreatePurgeRequestRequest {
  return {
    organisationId: "",
    subjectType: 0,
    subjectId: "",
    subjectEmail: "",
    reason: "",
    legalBasis: "",
    externalReference: "",
  };
}

export const CreatePurgeRequestRequest: MessageFns<CreatePurgeRequestRequest> = {
  encode(message: CreatePurgeRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(16).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(26).string(message.subjectId);
    }
    if (message.subjectEmail !== "") {
      writer.uint32(34).string(message.subjectEmail);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    if (message.legalBasis !== "") {
      writer.uint32(50).string(message.legalBasis);
    }
    if (message.externalReference !== "") {
      writer.uint32(58).string(message.externalReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePurgeRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePurgeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subjectEmail = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.legalBasis = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.externalReference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePurgeRequestResponse(): CreatePurgeRequestResponse {
  return {};
}

export const CreatePurgeRequestResponse: MessageFns<CreatePurgeRequestResponse> = {
  encode(message: CreatePurgeRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePurgeRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePurgeRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExecutePurgeRequest(): ExecutePurgeRequest {
  return { purgeRequestId: "", dryRun: false };
}

export const ExecutePurgeRequest: MessageFns<ExecutePurgeRequest> = {
  encode(message: ExecutePurgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    if (message.dryRun !== false) {
      writer.uint32(16).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutePurgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutePurgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseExecutePurgeResponse(): ExecutePurgeResponse {
  return { executions: [] };
}

export const ExecutePurgeResponse: MessageFns<ExecutePurgeResponse> = {
  encode(message: ExecutePurgeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    for (const v of message.executions) {
      PurgeExecution.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutePurgeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutePurgeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executions.push(PurgeExecution.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPurgeRequestRequest(): GetPurgeRequestRequest {
  return { purgeRequestId: "" };
}

export const GetPurgeRequestRequest: MessageFns<GetPurgeRequestRequest> = {
  encode(message: GetPurgeRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPurgeRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPurgeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPurgeRequestResponse(): GetPurgeRequestResponse {
  return { executions: [] };
}

export const GetPurgeRequestResponse: MessageFns<GetPurgeRequestResponse> = {
  encode(message: GetPurgeRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    for (const v of message.executions) {
      PurgeExecution.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPurgeRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPurgeRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.executions.push(PurgeExecution.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPurgeRequestsRequest(): ListPurgeRequestsRequest {
  return { organisationId: "", statuses: [], subjectType: 0, page: 0, limit: 0 };
}

export const ListPurgeRequestsRequest: MessageFns<ListPurgeRequestsRequest> = {
  encode(message: ListPurgeRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    writer.uint32(18).fork();
    for (const v of message.statuses) {
      writer.int32(v);
    }
    writer.join();
    if (message.subjectType !== 0) {
      writer.uint32(24).int32(message.subjectType);
    }
    if (message.from !== undefined) {
      Timestamp.encode(message.from, writer.uint32(34).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(message.to, writer.uint32(42).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(48).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(56).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.statuses.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.statuses.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.from = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.to = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPurgeRequestsResponse(): ListPurgeRequestsResponse {
  return { requests: [], total: 0, page: 0, limit: 0 };
}

export const ListPurgeRequestsResponse: MessageFns<ListPurgeRequestsResponse> = {
  encode(message: ListPurgeRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      PurgeRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPurgeRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPurgeRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(PurgeRequest.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelPurgeRequestRequest(): CancelPurgeRequestRequest {
  return { purgeRequestId: "", reason: "" };
}

export const CancelPurgeRequestRequest: MessageFns<CancelPurgeRequestRequest> = {
  encode(message: CancelPurgeRequestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPurgeRequestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPurgeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCancelPurgeRequestResponse(): CancelPurgeRequestResponse {
  return {};
}

export const CancelPurgeRequestResponse: MessageFns<CancelPurgeRequestResponse> = {
  encode(message: CancelPurgeRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      PurgeRequest.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPurgeRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPurgeRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = PurgeRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLegalHold(): LegalHold {
  return {
    id: "",
    organisationId: "",
    subjectType: 0,
    subjectId: "",
    reason: "",
    caseReference: "",
    placedByUserId: "",
    isActive: false,
    liftedByUserId: "",
    liftReason: "",
  };
}

export const LegalHold: MessageFns<LegalHold> = {
  encode(message: LegalHold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.organisationId !== "") {
      writer.uint32(18).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(24).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(34).string(message.subjectId);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    if (message.caseReference !== "") {
      writer.uint32(50).string(message.caseReference);
    }
    if (message.placedByUserId !== "") {
      writer.uint32(58).string(message.placedByUserId);
    }
    if (message.placedAt !== undefined) {
      Timestamp.encode(message.placedAt, writer.uint32(66).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(message.expiresAt, writer.uint32(74).fork()).join();
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.liftedByUserId !== "") {
      writer.uint32(90).string(message.liftedByUserId);
    }
    if (message.liftedAt !== undefined) {
      Timestamp.encode(message.liftedAt, writer.uint32(98).fork()).join();
    }
    if (message.liftReason !== "") {
      writer.uint32(106).string(message.liftReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LegalHold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLegalHold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.caseReference = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.placedByUserId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.placedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.expiresAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.liftedByUserId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.liftedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.liftReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlaceLegalHoldRequest(): PlaceLegalHoldRequest {
  return { organisationId: "", subjectType: 0, subjectId: "", reason: "", caseReference: "" };
}

export const PlaceLegalHoldRequest: MessageFns<PlaceLegalHoldRequest> = {
  encode(message: PlaceLegalHoldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(16).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(26).string(message.subjectId);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.caseReference !== "") {
      writer.uint32(42).string(message.caseReference);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(message.expiresAt, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceLegalHoldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceLegalHoldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.caseReference = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiresAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlaceLegalHoldResponse(): PlaceLegalHoldResponse {
  return {};
}

export const PlaceLegalHoldResponse: MessageFns<PlaceLegalHoldResponse> = {
  encode(message: PlaceLegalHoldResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hold !== undefined) {
      LegalHold.encode(message.hold, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceLegalHoldResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceLegalHoldResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hold = LegalHold.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiftLegalHoldRequest(): LiftLegalHoldRequest {
  return { holdId: "", reason: "" };
}

export const LiftLegalHoldRequest: MessageFns<LiftLegalHoldRequest> = {
  encode(message: LiftLegalHoldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.holdId !== "") {
      writer.uint32(10).string(message.holdId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiftLegalHoldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiftLegalHoldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.holdId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseLiftLegalHoldResponse(): LiftLegalHoldResponse {
  return {};
}

export const LiftLegalHoldResponse: MessageFns<LiftLegalHoldResponse> = {
  encode(message: LiftLegalHoldResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hold !== undefined) {
      LegalHold.encode(message.hold, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiftLegalHoldResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiftLegalHoldResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hold = LegalHold.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckLegalHoldRequest(): CheckLegalHoldRequest {
  return { organisationId: "", subjectType: 0, subjectId: "" };
}

export const CheckLegalHoldRequest: MessageFns<CheckLegalHoldRequest> = {
  encode(message: CheckLegalHoldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organisationId !== "") {
      writer.uint32(10).string(message.organisationId);
    }
    if (message.subjectType !== 0) {
      writer.uint32(16).int32(message.subjectType);
    }
    if (message.subjectId !== "") {
      writer.uint32(26).string(message.subjectId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckLegalHoldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckLegalHoldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organisationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subjectType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckLegalHoldResponse(): CheckLegalHoldResponse {
  return { hasHold: false, activeHolds: [] };
}

export const CheckLegalHoldResponse: MessageFns<CheckLegalHoldResponse> = {
  encode(message: CheckLegalHoldResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasHold !== false) {
      writer.uint32(8).bool(message.hasHold);
    }
    for (const v of message.activeHolds) {
      LegalHold.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckLegalHoldResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckLegalHoldResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasHold = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activeHolds.push(LegalHold.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePurgeProof(): PurgeProof {
  return {
    purgeRequestId: "",
    finalStatus: 0,
    executions: [],
    totalDeleted: 0,
    totalAnonymized: 0,
    totalRetained: 0,
    allVerificationsPassed: false,
    failedVerifications: [],
    proofSignature: "",
  };
}

export const PurgeProof: MessageFns<PurgeProof> = {
  encode(message: PurgeProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    if (message.purgeCompletedAt !== undefined) {
      Timestamp.encode(message.purgeCompletedAt, writer.uint32(18).fork()).join();
    }
    if (message.finalStatus !== 0) {
      writer.uint32(24).int32(message.finalStatus);
    }
    for (const v of message.executions) {
      PurgeExecution.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.totalDeleted !== 0) {
      writer.uint32(40).int64(message.totalDeleted);
    }
    if (message.totalAnonymized !== 0) {
      writer.uint32(48).int64(message.totalAnonymized);
    }
    if (message.totalRetained !== 0) {
      writer.uint32(56).int64(message.totalRetained);
    }
    if (message.allVerificationsPassed !== false) {
      writer.uint32(64).bool(message.allVerificationsPassed);
    }
    for (const v of message.failedVerifications) {
      writer.uint32(74).string(v!);
    }
    if (message.proofSignature !== "") {
      writer.uint32(82).string(message.proofSignature);
    }
    if (message.proofGeneratedAt !== undefined) {
      Timestamp.encode(message.proofGeneratedAt, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurgeProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.purgeCompletedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.finalStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.executions.push(PurgeExecution.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalDeleted = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalAnonymized = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalRetained = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.allVerificationsPassed = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.failedVerifications.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.proofSignature = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.proofGeneratedAt = Timestamp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGeneratePurgeProofRequest(): GeneratePurgeProofRequest {
  return { purgeRequestId: "" };
}

export const GeneratePurgeProofRequest: MessageFns<GeneratePurgeProofRequest> = {
  encode(message: GeneratePurgeProofRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.purgeRequestId !== "") {
      writer.uint32(10).string(message.purgeRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratePurgeProofRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratePurgeProofRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.purgeRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGeneratePurgeProofResponse(): GeneratePurgeProofResponse {
  return {};
}

export const GeneratePurgeProofResponse: MessageFns<GeneratePurgeProofResponse> = {
  encode(message: GeneratePurgeProofResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proof !== undefined) {
      PurgeProof.encode(message.proof, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratePurgeProofResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratePurgeProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proof = PurgeProof.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ========== RETENTION POLICIES ========== */

export interface ComplianceServiceClient {
  upsertRetentionPolicy(
    request: UpsertRetentionPolicyRequest,
    metadata?: Metadata,
  ): Observable<UpsertRetentionPolicyResponse>;

  listRetentionPolicies(
    request: ListRetentionPoliciesRequest,
    metadata?: Metadata,
  ): Observable<ListRetentionPoliciesResponse>;

  getRetentionPolicy(request: GetRetentionPolicyRequest, metadata?: Metadata): Observable<GetRetentionPolicyResponse>;

  runScheduledPurge(request: RunScheduledPurgeRequest, metadata?: Metadata): Observable<RunScheduledPurgeResponse>;

  listPurgeJobs(request: ListPurgeJobsRequest, metadata?: Metadata): Observable<ListPurgeJobsResponse>;

  createPurgeRequest(request: CreatePurgeRequestRequest, metadata?: Metadata): Observable<CreatePurgeRequestResponse>;

  executePurge(request: ExecutePurgeRequest, metadata?: Metadata): Observable<ExecutePurgeResponse>;

  getPurgeRequest(request: GetPurgeRequestRequest, metadata?: Metadata): Observable<GetPurgeRequestResponse>;

  listPurgeRequests(request: ListPurgeRequestsRequest, metadata?: Metadata): Observable<ListPurgeRequestsResponse>;

  cancelPurgeRequest(request: CancelPurgeRequestRequest, metadata?: Metadata): Observable<CancelPurgeRequestResponse>;

  placeLegalHold(request: PlaceLegalHoldRequest, metadata?: Metadata): Observable<PlaceLegalHoldResponse>;

  liftLegalHold(request: LiftLegalHoldRequest, metadata?: Metadata): Observable<LiftLegalHoldResponse>;

  checkLegalHold(request: CheckLegalHoldRequest, metadata?: Metadata): Observable<CheckLegalHoldResponse>;

  generatePurgeProof(request: GeneratePurgeProofRequest, metadata?: Metadata): Observable<GeneratePurgeProofResponse>;
}

/** ========== RETENTION POLICIES ========== */

export interface ComplianceServiceController {
  upsertRetentionPolicy(
    request: UpsertRetentionPolicyRequest,
    metadata?: Metadata,
  ): Promise<UpsertRetentionPolicyResponse> | Observable<UpsertRetentionPolicyResponse> | UpsertRetentionPolicyResponse;

  listRetentionPolicies(
    request: ListRetentionPoliciesRequest,
    metadata?: Metadata,
  ): Promise<ListRetentionPoliciesResponse> | Observable<ListRetentionPoliciesResponse> | ListRetentionPoliciesResponse;

  getRetentionPolicy(
    request: GetRetentionPolicyRequest,
    metadata?: Metadata,
  ): Promise<GetRetentionPolicyResponse> | Observable<GetRetentionPolicyResponse> | GetRetentionPolicyResponse;

  runScheduledPurge(
    request: RunScheduledPurgeRequest,
    metadata?: Metadata,
  ): Promise<RunScheduledPurgeResponse> | Observable<RunScheduledPurgeResponse> | RunScheduledPurgeResponse;

  listPurgeJobs(
    request: ListPurgeJobsRequest,
    metadata?: Metadata,
  ): Promise<ListPurgeJobsResponse> | Observable<ListPurgeJobsResponse> | ListPurgeJobsResponse;

  createPurgeRequest(
    request: CreatePurgeRequestRequest,
    metadata?: Metadata,
  ): Promise<CreatePurgeRequestResponse> | Observable<CreatePurgeRequestResponse> | CreatePurgeRequestResponse;

  executePurge(
    request: ExecutePurgeRequest,
    metadata?: Metadata,
  ): Promise<ExecutePurgeResponse> | Observable<ExecutePurgeResponse> | ExecutePurgeResponse;

  getPurgeRequest(
    request: GetPurgeRequestRequest,
    metadata?: Metadata,
  ): Promise<GetPurgeRequestResponse> | Observable<GetPurgeRequestResponse> | GetPurgeRequestResponse;

  listPurgeRequests(
    request: ListPurgeRequestsRequest,
    metadata?: Metadata,
  ): Promise<ListPurgeRequestsResponse> | Observable<ListPurgeRequestsResponse> | ListPurgeRequestsResponse;

  cancelPurgeRequest(
    request: CancelPurgeRequestRequest,
    metadata?: Metadata,
  ): Promise<CancelPurgeRequestResponse> | Observable<CancelPurgeRequestResponse> | CancelPurgeRequestResponse;

  placeLegalHold(
    request: PlaceLegalHoldRequest,
    metadata?: Metadata,
  ): Promise<PlaceLegalHoldResponse> | Observable<PlaceLegalHoldResponse> | PlaceLegalHoldResponse;

  liftLegalHold(
    request: LiftLegalHoldRequest,
    metadata?: Metadata,
  ): Promise<LiftLegalHoldResponse> | Observable<LiftLegalHoldResponse> | LiftLegalHoldResponse;

  checkLegalHold(
    request: CheckLegalHoldRequest,
    metadata?: Metadata,
  ): Promise<CheckLegalHoldResponse> | Observable<CheckLegalHoldResponse> | CheckLegalHoldResponse;

  generatePurgeProof(
    request: GeneratePurgeProofRequest,
    metadata?: Metadata,
  ): Promise<GeneratePurgeProofResponse> | Observable<GeneratePurgeProofResponse> | GeneratePurgeProofResponse;
}

export function ComplianceServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "upsertRetentionPolicy",
      "listRetentionPolicies",
      "getRetentionPolicy",
      "runScheduledPurge",
      "listPurgeJobs",
      "createPurgeRequest",
      "executePurge",
      "getPurgeRequest",
      "listPurgeRequests",
      "cancelPurgeRequest",
      "placeLegalHold",
      "liftLegalHold",
      "checkLegalHold",
      "generatePurgeProof",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ComplianceService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ComplianceService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const COMPLIANCE_SERVICE_NAME = "ComplianceService";

/** ========== RETENTION POLICIES ========== */
export type ComplianceServiceService = typeof ComplianceServiceService;
export const ComplianceServiceService = {
  upsertRetentionPolicy: {
    path: "/security.ComplianceService/UpsertRetentionPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpsertRetentionPolicyRequest): Buffer =>
      Buffer.from(UpsertRetentionPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpsertRetentionPolicyRequest => UpsertRetentionPolicyRequest.decode(value),
    responseSerialize: (value: UpsertRetentionPolicyResponse): Buffer =>
      Buffer.from(UpsertRetentionPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpsertRetentionPolicyResponse => UpsertRetentionPolicyResponse.decode(value),
  },
  listRetentionPolicies: {
    path: "/security.ComplianceService/ListRetentionPolicies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRetentionPoliciesRequest): Buffer =>
      Buffer.from(ListRetentionPoliciesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRetentionPoliciesRequest => ListRetentionPoliciesRequest.decode(value),
    responseSerialize: (value: ListRetentionPoliciesResponse): Buffer =>
      Buffer.from(ListRetentionPoliciesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRetentionPoliciesResponse => ListRetentionPoliciesResponse.decode(value),
  },
  getRetentionPolicy: {
    path: "/security.ComplianceService/GetRetentionPolicy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRetentionPolicyRequest): Buffer =>
      Buffer.from(GetRetentionPolicyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRetentionPolicyRequest => GetRetentionPolicyRequest.decode(value),
    responseSerialize: (value: GetRetentionPolicyResponse): Buffer =>
      Buffer.from(GetRetentionPolicyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetRetentionPolicyResponse => GetRetentionPolicyResponse.decode(value),
  },
  runScheduledPurge: {
    path: "/security.ComplianceService/RunScheduledPurge",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RunScheduledPurgeRequest): Buffer =>
      Buffer.from(RunScheduledPurgeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunScheduledPurgeRequest => RunScheduledPurgeRequest.decode(value),
    responseSerialize: (value: RunScheduledPurgeResponse): Buffer =>
      Buffer.from(RunScheduledPurgeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunScheduledPurgeResponse => RunScheduledPurgeResponse.decode(value),
  },
  listPurgeJobs: {
    path: "/security.ComplianceService/ListPurgeJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPurgeJobsRequest): Buffer => Buffer.from(ListPurgeJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPurgeJobsRequest => ListPurgeJobsRequest.decode(value),
    responseSerialize: (value: ListPurgeJobsResponse): Buffer =>
      Buffer.from(ListPurgeJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPurgeJobsResponse => ListPurgeJobsResponse.decode(value),
  },
  createPurgeRequest: {
    path: "/security.ComplianceService/CreatePurgeRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePurgeRequestRequest): Buffer =>
      Buffer.from(CreatePurgeRequestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePurgeRequestRequest => CreatePurgeRequestRequest.decode(value),
    responseSerialize: (value: CreatePurgeRequestResponse): Buffer =>
      Buffer.from(CreatePurgeRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreatePurgeRequestResponse => CreatePurgeRequestResponse.decode(value),
  },
  executePurge: {
    path: "/security.ComplianceService/ExecutePurge",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecutePurgeRequest): Buffer => Buffer.from(ExecutePurgeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecutePurgeRequest => ExecutePurgeRequest.decode(value),
    responseSerialize: (value: ExecutePurgeResponse): Buffer =>
      Buffer.from(ExecutePurgeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecutePurgeResponse => ExecutePurgeResponse.decode(value),
  },
  getPurgeRequest: {
    path: "/security.ComplianceService/GetPurgeRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPurgeRequestRequest): Buffer =>
      Buffer.from(GetPurgeRequestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPurgeRequestRequest => GetPurgeRequestRequest.decode(value),
    responseSerialize: (value: GetPurgeRequestResponse): Buffer =>
      Buffer.from(GetPurgeRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetPurgeRequestResponse => GetPurgeRequestResponse.decode(value),
  },
  listPurgeRequests: {
    path: "/security.ComplianceService/ListPurgeRequests",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListPurgeRequestsRequest): Buffer =>
      Buffer.from(ListPurgeRequestsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListPurgeRequestsRequest => ListPurgeRequestsRequest.decode(value),
    responseSerialize: (value: ListPurgeRequestsResponse): Buffer =>
      Buffer.from(ListPurgeRequestsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPurgeRequestsResponse => ListPurgeRequestsResponse.decode(value),
  },
  cancelPurgeRequest: {
    path: "/security.ComplianceService/CancelPurgeRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelPurgeRequestRequest): Buffer =>
      Buffer.from(CancelPurgeRequestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CancelPurgeRequestRequest => CancelPurgeRequestRequest.decode(value),
    responseSerialize: (value: CancelPurgeRequestResponse): Buffer =>
      Buffer.from(CancelPurgeRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CancelPurgeRequestResponse => CancelPurgeRequestResponse.decode(value),
  },
  placeLegalHold: {
    path: "/security.ComplianceService/PlaceLegalHold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PlaceLegalHoldRequest): Buffer =>
      Buffer.from(PlaceLegalHoldRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PlaceLegalHoldRequest => PlaceLegalHoldRequest.decode(value),
    responseSerialize: (value: PlaceLegalHoldResponse): Buffer =>
      Buffer.from(PlaceLegalHoldResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PlaceLegalHoldResponse => PlaceLegalHoldResponse.decode(value),
  },
  liftLegalHold: {
    path: "/security.ComplianceService/LiftLegalHold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LiftLegalHoldRequest): Buffer => Buffer.from(LiftLegalHoldRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LiftLegalHoldRequest => LiftLegalHoldRequest.decode(value),
    responseSerialize: (value: LiftLegalHoldResponse): Buffer =>
      Buffer.from(LiftLegalHoldResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LiftLegalHoldResponse => LiftLegalHoldResponse.decode(value),
  },
  checkLegalHold: {
    path: "/security.ComplianceService/CheckLegalHold",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckLegalHoldRequest): Buffer =>
      Buffer.from(CheckLegalHoldRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CheckLegalHoldRequest => CheckLegalHoldRequest.decode(value),
    responseSerialize: (value: CheckLegalHoldResponse): Buffer =>
      Buffer.from(CheckLegalHoldResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CheckLegalHoldResponse => CheckLegalHoldResponse.decode(value),
  },
  generatePurgeProof: {
    path: "/security.ComplianceService/GeneratePurgeProof",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GeneratePurgeProofRequest): Buffer =>
      Buffer.from(GeneratePurgeProofRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GeneratePurgeProofRequest => GeneratePurgeProofRequest.decode(value),
    responseSerialize: (value: GeneratePurgeProofResponse): Buffer =>
      Buffer.from(GeneratePurgeProofResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GeneratePurgeProofResponse => GeneratePurgeProofResponse.decode(value),
  },
} as const;

export interface ComplianceServiceServer extends UntypedServiceImplementation {
  upsertRetentionPolicy: handleUnaryCall<UpsertRetentionPolicyRequest, UpsertRetentionPolicyResponse>;
  listRetentionPolicies: handleUnaryCall<ListRetentionPoliciesRequest, ListRetentionPoliciesResponse>;
  getRetentionPolicy: handleUnaryCall<GetRetentionPolicyRequest, GetRetentionPolicyResponse>;
  runScheduledPurge: handleUnaryCall<RunScheduledPurgeRequest, RunScheduledPurgeResponse>;
  listPurgeJobs: handleUnaryCall<ListPurgeJobsRequest, ListPurgeJobsResponse>;
  createPurgeRequest: handleUnaryCall<CreatePurgeRequestRequest, CreatePurgeRequestResponse>;
  executePurge: handleUnaryCall<ExecutePurgeRequest, ExecutePurgeResponse>;
  getPurgeRequest: handleUnaryCall<GetPurgeRequestRequest, GetPurgeRequestResponse>;
  listPurgeRequests: handleUnaryCall<ListPurgeRequestsRequest, ListPurgeRequestsResponse>;
  cancelPurgeRequest: handleUnaryCall<CancelPurgeRequestRequest, CancelPurgeRequestResponse>;
  placeLegalHold: handleUnaryCall<PlaceLegalHoldRequest, PlaceLegalHoldResponse>;
  liftLegalHold: handleUnaryCall<LiftLegalHoldRequest, LiftLegalHoldResponse>;
  checkLegalHold: handleUnaryCall<CheckLegalHoldRequest, CheckLegalHoldResponse>;
  generatePurgeProof: handleUnaryCall<GeneratePurgeProofRequest, GeneratePurgeProofResponse>;
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
